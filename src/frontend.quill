
mod frontend

use js::*

pub val AriaNotifyInterrupt::None: String = "none"
pub val AriaNotifyInterrupt::All: String = "all"
pub val AriaNotifyInterrupt::Pending: String = "pending"

pub val AriaNotifyPriority::Normal: String = "normal"
pub val AriaNotifyPriority::High: String = "high"

pub struct AriaNotificationOptions(
    priority: Option[String],
    interrupt: Option[String],
    type: Option[String]
)

pub fun AriaNotificationOptions::default() -> mut AriaNotificationOptions
    = AriaNotificationOptions(Option::Some("normal"), Option::Some("none"), Option::Some(""))

pub ext fun AriaNotificationOptions::from_js(value: JsValue) -> mut AriaNotificationOptions = "
    const r = {};
    r.m_priority = #fun(Option::from_js[String])(#var(value).priority);
    r.m_interrupt = #fun(Option::from_js[String])(#var(value).interrupt);
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    return r;
"

pub ext fun AriaNotificationOptions::as_js(self: AriaNotificationOptions) -> JsValue = "
    const r = {};
    r.priority = #fun(Option::as_js_undef[String])(#var(self).m_priority);
    r.interrupt = #fun(Option::as_js_undef[String])(#var(self).m_interrupt);
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    return r;
"

pub val AnimationPlayState::Idle: String = "idle"
pub val AnimationPlayState::Pending: String = "pending"
pub val AnimationPlayState::Running: String = "running"
pub val AnimationPlayState::Paused: String = "paused"
pub val AnimationPlayState::Finished: String = "finished"

pub val ReplaceState::Active: String = "active"
pub val ReplaceState::Removed: String = "removed"
pub val ReplaceState::Persisted: String = "persisted"

struct Animation()

/// Converts a reference to 'Animation' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Animation::as_event_target(self: Animation) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Animation' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Animation::as_mevent_target(self: mut Animation) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Animation'.
/// The conversion may fail and panic if 'base' is not a reference to 'Animation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Animation::from_event_target(base: EventTarget) -> Animation = "
    if(#var(base) instanceof Animation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Animation'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Animation'.
/// The conversion may fail and panic if 'base' is not a reference to 'Animation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Animation::from_mevent_target(base: mut EventTarget) -> mut Animation = "
    if(#var(base) instanceof Animation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Animation'!\");
"

pub ext fun Animation::from_omanimation_effect_omanimation_timeline(effect: Option[mut AnimationEffect], timeline: Option[mut AnimationTimeline]) -> mut Animation
    = "return new Animation(#fun(Option::as_js[mut AnimationEffect])(#var(effect)), #fun(Option::as_js[mut AnimationTimeline])(#var(timeline)));"

pub ext fun Animation::effect(self: Animation) -> Option[mut AnimationEffect]
    = "return #fun(Option::from_js[mut AnimationEffect])(#var(self).effect);"

pub ext fun Animation::set_effect(self: mut Animation, value: Option[mut AnimationEffect])
    = "#var(self).effect = #fun(Option::as_js[mut AnimationEffect])(#var(value));"

pub ext fun Animation::timeline(self: Animation) -> Option[mut AnimationTimeline]
    = "return #fun(Option::from_js[mut AnimationTimeline])(#var(self).timeline);"

pub ext fun Animation::set_timeline(self: mut Animation, value: Option[mut AnimationTimeline])
    = "#var(self).timeline = #fun(Option::as_js[mut AnimationTimeline])(#var(value));"

pub ext fun Animation::start_time(self: Animation) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).startTime);"

pub ext fun Animation::set_start_time(self: mut Animation, value: Option[JsValue])
    = "#var(self).startTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Animation::current_time(self: Animation) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun Animation::set_current_time(self: mut Animation, value: Option[JsValue])
    = "#var(self).currentTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Animation::overall_progress(self: Animation) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).overallProgress);"

pub ext fun Animation::playback_rate(self: Animation) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun Animation::set_playback_rate(self: mut Animation, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun Animation::range_start(self: Animation) -> JsValue
    = "return #var(self).rangeStart;"

pub ext fun Animation::set_range_start(self: mut Animation, value: JsValue)
    = "#var(self).rangeStart = #var(value);"

pub ext fun Animation::range_end(self: Animation) -> JsValue
    = "return #var(self).rangeEnd;"

pub ext fun Animation::set_range_end(self: mut Animation, value: JsValue)
    = "#var(self).rangeEnd = #var(value);"

pub ext fun Animation::play_state(self: Animation) -> String
    = "return #fun(String::from_js)(#var(self).playState);"

pub ext fun Animation::replace_state(self: Animation) -> String
    = "return #fun(String::from_js)(#var(self).replaceState);"

pub ext fun Animation::pending(self: Animation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pending);"

pub ext fun Animation::id(self: Animation) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun Animation::set_id(self: mut Animation, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun Animation::onfinish(self: Animation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfinish);"

pub ext fun Animation::set_onfinish(self: mut Animation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfinish = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Animation::oncancel(self: Animation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun Animation::set_oncancel(self: mut Animation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Animation::onremove(self: Animation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremove);"

pub ext fun Animation::set_onremove(self: mut Animation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Animation::finished(self: Animation) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).finished);"

pub ext fun Animation::ready(self: Animation) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).ready);"

pub ext fun Animation::commit_styles(__self: mut Animation) -> Unit = "
    const r = #var(__self).commitStyles();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::finish(__self: mut Animation) -> Unit = "
    const r = #var(__self).finish();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::play(__self: mut Animation) -> Unit = "
    const r = #var(__self).play();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::pause(__self: mut Animation) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::reverse(__self: mut Animation) -> Unit = "
    const r = #var(__self).reverse();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::update_playback_rate(__self: mut Animation, playback__rate: Float) -> Unit = "
    const r = #var(__self).updatePlaybackRate(#fun(Float::as_js)(#var(playback__rate)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::persist(__self: mut Animation) -> Unit = "
    const r = #var(__self).persist();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::cancel(__self: mut Animation) -> Unit = "
    const r = #var(__self).cancel();
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::add_event_listener(__self: mut Animation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::remove_event_listener(__self: mut Animation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Animation::dispatch_event(__self: mut Animation, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Animation::when(__self: mut Animation, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Animation::as_js(self: Animation) -> JsValue = JsValue::unsafe_from[Animation](self)

pub fun Animation::from_js(v: JsValue) -> mut Animation = JsValue::unsafe_as[mut Animation](v)

struct AnimationEffect()

pub ext fun AnimationEffect::get_timing(__self: mut AnimationEffect) -> mut EffectTiming = "
    const r = #var(__self).getTiming();
    return #fun(EffectTiming::from_js)(r);
"

pub ext fun AnimationEffect::get_computed_timing(__self: mut AnimationEffect) -> mut ComputedEffectTiming = "
    const r = #var(__self).getComputedTiming();
    return #fun(ComputedEffectTiming::from_js)(r);
"

pub ext fun AnimationEffect::update_timing(__self: mut AnimationEffect, timing: mut OptionalEffectTiming) -> Unit = "
    const r = #var(__self).updateTiming(#fun(OptionalEffectTiming::as_js)(#var(timing)));
    return #fun(Unit::from_js)(r);
"

pub fun AnimationEffect::as_js(self: AnimationEffect) -> JsValue = JsValue::unsafe_from[AnimationEffect](self)

pub fun AnimationEffect::from_js(v: JsValue) -> mut AnimationEffect = JsValue::unsafe_as[mut AnimationEffect](v)

pub val TimelinePhase::Inactive: String = "inactive"
pub val TimelinePhase::Before: String = "before"
pub val TimelinePhase::Active: String = "active"
pub val TimelinePhase::After: String = "after"

struct AnimationTimeline()

pub ext fun AnimationTimeline::current_time(self: AnimationTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun AnimationTimeline::duration(self: AnimationTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).duration);"

pub ext fun AnimationTimeline::get_current_time(__self: mut AnimationTimeline, range_name: String) -> Option[mut CSSNumericValue] = "
    const r = #var(__self).getCurrentTime(#fun(String::as_js)(#var(range_name)));
    return #fun(Option::from_js[mut CSSNumericValue])(r);
"

pub fun AnimationTimeline::as_js(self: AnimationTimeline) -> JsValue = JsValue::unsafe_from[AnimationTimeline](self)

pub fun AnimationTimeline::from_js(v: JsValue) -> mut AnimationTimeline = JsValue::unsafe_as[mut AnimationTimeline](v)

pub val AnimationTriggerBehavior::Once: String = "once"
pub val AnimationTriggerBehavior::Repeat: String = "repeat"
pub val AnimationTriggerBehavior::Alternate: String = "alternate"
pub val AnimationTriggerBehavior::State: String = "state"

struct AnimationTrigger()

pub ext fun AnimationTrigger::from_manimation_trigger_options(options: mut AnimationTriggerOptions) -> mut AnimationTrigger
    = "return new AnimationTrigger(#fun(AnimationTriggerOptions::as_js)(#var(options)));"

pub ext fun AnimationTrigger::timeline(self: AnimationTrigger) -> Option[mut AnimationTimeline]
    = "return #fun(Option::from_js[mut AnimationTimeline])(#var(self).timeline);"

pub ext fun AnimationTrigger::behavior(self: AnimationTrigger) -> String
    = "return #fun(String::from_js)(#var(self).behavior);"

pub ext fun AnimationTrigger::range_start(self: AnimationTrigger) -> JsValue
    = "return #var(self).rangeStart;"

pub ext fun AnimationTrigger::range_end(self: AnimationTrigger) -> JsValue
    = "return #var(self).rangeEnd;"

pub ext fun AnimationTrigger::exit_range_start(self: AnimationTrigger) -> JsValue
    = "return #var(self).exitRangeStart;"

pub ext fun AnimationTrigger::exit_range_end(self: AnimationTrigger) -> JsValue
    = "return #var(self).exitRangeEnd;"

pub ext fun AnimationTrigger::add_animation(__self: mut AnimationTrigger, animation: mut Animation) -> Unit = "
    const r = #var(__self).addAnimation(#fun(Animation::as_js)(#var(animation)));
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationTrigger::remove_animation(__self: mut AnimationTrigger, animation: mut Animation) -> Unit = "
    const r = #var(__self).removeAnimation(#fun(Animation::as_js)(#var(animation)));
    return #fun(Unit::from_js)(r);
"

pub fun AnimationTrigger::as_js(self: AnimationTrigger) -> JsValue = JsValue::unsafe_from[AnimationTrigger](self)

pub fun AnimationTrigger::from_js(v: JsValue) -> mut AnimationTrigger = JsValue::unsafe_as[mut AnimationTrigger](v)

pub struct AnimationTriggerOptions(
    behavior: Option[String],
    timeline: Option[mut AnimationTimeline],
    range_start: Option[JsValue],
    range_end: Option[JsValue],
    exit_range_start: Option[JsValue],
    exit_range_end: Option[JsValue]
)

pub fun AnimationTriggerOptions::default() -> mut AnimationTriggerOptions
    = AnimationTriggerOptions(Option::Some("once"), Option::None, Option::Some("normal" |> as_js()), Option::Some("normal" |> as_js()), Option::Some("auto" |> as_js()), Option::Some("auto" |> as_js()))

pub ext fun AnimationTriggerOptions::from_js(value: JsValue) -> mut AnimationTriggerOptions = "
    const r = {};
    r.m_behavior = #fun(Option::from_js[String])(#var(value).behavior);
    r.m_timeline = #fun(Option::from_js[mut AnimationTimeline])(#var(value).timeline);
    r.m_range_start = #fun(Option::from_js[JsValue])(#var(value).rangeStart);
    r.m_range_end = #fun(Option::from_js[JsValue])(#var(value).rangeEnd);
    r.m_exit_range_start = #fun(Option::from_js[JsValue])(#var(value).exitRangeStart);
    r.m_exit_range_end = #fun(Option::from_js[JsValue])(#var(value).exitRangeEnd);
    return r;
"

pub ext fun AnimationTriggerOptions::as_js(self: AnimationTriggerOptions) -> JsValue = "
    const r = {};
    r.behavior = #fun(Option::as_js_undef[String])(#var(self).m_behavior);
    r.timeline = #fun(Option::as_js_undef[mut AnimationTimeline])(#var(self).m_timeline);
    r.rangeStart = #fun(Option::as_js_undef[JsValue])(#var(self).m_range_start);
    r.rangeEnd = #fun(Option::as_js_undef[JsValue])(#var(self).m_range_end);
    r.exitRangeStart = #fun(Option::as_js_undef[JsValue])(#var(self).m_exit_range_start);
    r.exitRangeEnd = #fun(Option::as_js_undef[JsValue])(#var(self).m_exit_range_end);
    return r;
"

pub val CompositeOperationOrAuto::Replace: String = "replace"
pub val CompositeOperationOrAuto::Add: String = "add"
pub val CompositeOperationOrAuto::Accumulate: String = "accumulate"
pub val CompositeOperationOrAuto::Auto: String = "auto"

pub struct BaseKeyframe(
    offset: Option[JsValue],
    easing: Option[String],
    composite: Option[String]
)

pub fun BaseKeyframe::default() -> mut BaseKeyframe
    = BaseKeyframe(Option::None, Option::Some("linear"), Option::Some("auto"))

pub ext fun BaseKeyframe::from_js(value: JsValue) -> mut BaseKeyframe = "
    const r = {};
    r.m_offset = #fun(Option::from_js[JsValue])(#var(value).offset);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    r.m_composite = #fun(Option::from_js[String])(#var(value).composite);
    return r;
"

pub ext fun BaseKeyframe::as_js(self: BaseKeyframe) -> JsValue = "
    const r = {};
    r.offset = #fun(Option::as_js_undef[JsValue])(#var(self).m_offset);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    r.composite = #fun(Option::as_js_undef[String])(#var(self).m_composite);
    return r;
"

pub struct BasePropertyIndexedKeyframe(
    offset: Option[JsValue],
    easing: Option[JsValue],
    composite: Option[JsValue]
)

pub fun BasePropertyIndexedKeyframe::default() -> mut BasePropertyIndexedKeyframe
    = BasePropertyIndexedKeyframe(Option::Some(EMPTY_LIST |> as_js()), Option::Some(EMPTY_LIST |> as_js()), Option::Some(EMPTY_LIST |> as_js()))

pub ext fun BasePropertyIndexedKeyframe::from_js(value: JsValue) -> mut BasePropertyIndexedKeyframe = "
    const r = {};
    r.m_offset = #fun(Option::from_js[JsValue])(#var(value).offset);
    r.m_easing = #fun(Option::from_js[JsValue])(#var(value).easing);
    r.m_composite = #fun(Option::from_js[JsValue])(#var(value).composite);
    return r;
"

pub ext fun BasePropertyIndexedKeyframe::as_js(self: BasePropertyIndexedKeyframe) -> JsValue = "
    const r = {};
    r.offset = #fun(Option::as_js_undef[JsValue])(#var(self).m_offset);
    r.easing = #fun(Option::as_js_undef[JsValue])(#var(self).m_easing);
    r.composite = #fun(Option::as_js_undef[JsValue])(#var(self).m_composite);
    return r;
"

pub struct ComputedEffectTiming(
    end_time: Option[JsValue],
    active_duration: Option[JsValue],
    local_time: Option[JsValue],
    progress: Option[Float],
    current_iteration: Option[Float],
    delay: Option[JsValue],
    end_delay: Option[JsValue],
    fill: Option[String],
    iteration_start: Option[Float],
    iterations: Option[Float],
    duration: Option[JsValue],
    direction: Option[String],
    easing: Option[String]
)

pub fun ComputedEffectTiming::default() -> mut ComputedEffectTiming
    = ComputedEffectTiming(Option::None, Option::None, Option::None, Option::None, Option::None, Option::Some(0.0 |> as_js()), Option::Some(0.0 |> as_js()), Option::Some("auto"), Option::Some(0.0), Option::Some(1.0), Option::Some("auto" |> as_js()), Option::Some("normal"), Option::Some("linear"))

/// Converts a reference to 'ComputedEffectTiming' to a reference to 'EffectTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun ComputedEffectTiming::as_effect_timing(self: ComputedEffectTiming) -> EffectTiming = "return #var(self);"

/// Converts a mutable reference to 'ComputedEffectTiming' to a mutable reference to 'EffectTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun ComputedEffectTiming::as_meffect_timing(self: mut ComputedEffectTiming) -> mut EffectTiming = "return #var(self);"

/// Attempts to convert a reference to 'EffectTiming' to a reference to 'ComputedEffectTiming'.
/// A 'base' that is not a reference to 'ComputedEffectTiming' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ComputedEffectTiming::from_effect_timing_unchecked(base: EffectTiming) -> ComputedEffectTiming = "return #var(base);"

/// Attempts to convert a mutable reference to 'EffectTiming' to a mutable reference to 'ComputedEffectTiming'.
/// A 'base' that is not a reference to 'ComputedEffectTiming' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ComputedEffectTiming::from_meffect_timing_unchecked(base: mut EffectTiming) -> mut ComputedEffectTiming = "return #var(base);"

pub ext fun ComputedEffectTiming::from_js(value: JsValue) -> mut ComputedEffectTiming = "
    const r = {};
    r.m_end_time = #fun(Option::from_js[JsValue])(#var(value).endTime);
    r.m_active_duration = #fun(Option::from_js[JsValue])(#var(value).activeDuration);
    r.m_local_time = #fun(Option::from_js[JsValue])(#var(value).localTime);
    r.m_progress = #fun(Option::from_js[Float])(#var(value).progress);
    r.m_current_iteration = #fun(Option::from_js[Float])(#var(value).currentIteration);
    r.m_delay = #fun(Option::from_js[JsValue])(#var(value).delay);
    r.m_end_delay = #fun(Option::from_js[JsValue])(#var(value).endDelay);
    r.m_fill = #fun(Option::from_js[String])(#var(value).fill);
    r.m_iteration_start = #fun(Option::from_js[Float])(#var(value).iterationStart);
    r.m_iterations = #fun(Option::from_js[Float])(#var(value).iterations);
    r.m_duration = #fun(Option::from_js[JsValue])(#var(value).duration);
    r.m_direction = #fun(Option::from_js[String])(#var(value).direction);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    return r;
"

pub ext fun ComputedEffectTiming::as_js(self: ComputedEffectTiming) -> JsValue = "
    const r = {};
    r.endTime = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_time);
    r.activeDuration = #fun(Option::as_js_undef[JsValue])(#var(self).m_active_duration);
    r.localTime = #fun(Option::as_js_undef[JsValue])(#var(self).m_local_time);
    r.progress = #fun(Option::as_js_undef[Float])(#var(self).m_progress);
    r.currentIteration = #fun(Option::as_js_undef[Float])(#var(self).m_current_iteration);
    r.delay = #fun(Option::as_js_undef[JsValue])(#var(self).m_delay);
    r.endDelay = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_delay);
    r.fill = #fun(Option::as_js_undef[String])(#var(self).m_fill);
    r.iterationStart = #fun(Option::as_js_undef[Float])(#var(self).m_iteration_start);
    r.iterations = #fun(Option::as_js_undef[Float])(#var(self).m_iterations);
    r.duration = #fun(Option::as_js_undef[JsValue])(#var(self).m_duration);
    r.direction = #fun(Option::as_js_undef[String])(#var(self).m_direction);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    return r;
"

struct CSSAnimation()

/// Converts a reference to 'CSSAnimation' to a reference to 'Animation'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::as_animation(self: CSSAnimation) -> Animation = "return #var(self);"

/// Converts a mutable reference to 'CSSAnimation' to a mutable reference to 'Animation'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::as_manimation(self: mut CSSAnimation) -> mut Animation = "return #var(self);"

/// Attempts to convert a reference to 'Animation' to a reference to 'CSSAnimation'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSAnimation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::from_animation(base: Animation) -> CSSAnimation = "
    if(#var(base) instanceof CSSAnimation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Animation' to 'CSSAnimation'!\");
"

/// Attempts to convert a mutable reference to 'Animation' to a mutable reference to 'CSSAnimation'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSAnimation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::from_manimation(base: mut Animation) -> mut CSSAnimation = "
    if(#var(base) instanceof CSSAnimation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Animation' to 'CSSAnimation'!\");
"

/// Converts a reference to 'CSSAnimation' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::as_event_target(self: CSSAnimation) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CSSAnimation' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::as_mevent_target(self: mut CSSAnimation) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CSSAnimation'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSAnimation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::from_event_target(base: EventTarget) -> CSSAnimation = "
    if(#var(base) instanceof CSSAnimation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CSSAnimation'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CSSAnimation'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSAnimation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSAnimation::from_mevent_target(base: mut EventTarget) -> mut CSSAnimation = "
    if(#var(base) instanceof CSSAnimation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CSSAnimation'!\");
"

pub ext fun CSSAnimation::animation_name(self: CSSAnimation) -> String
    = "return #fun(String::from_js)(#var(self).animationName);"

pub ext fun CSSAnimation::effect(self: CSSAnimation) -> Option[mut AnimationEffect]
    = "return #fun(Option::from_js[mut AnimationEffect])(#var(self).effect);"

pub ext fun CSSAnimation::set_effect(self: mut CSSAnimation, value: Option[mut AnimationEffect])
    = "#var(self).effect = #fun(Option::as_js[mut AnimationEffect])(#var(value));"

pub ext fun CSSAnimation::timeline(self: CSSAnimation) -> Option[mut AnimationTimeline]
    = "return #fun(Option::from_js[mut AnimationTimeline])(#var(self).timeline);"

pub ext fun CSSAnimation::set_timeline(self: mut CSSAnimation, value: Option[mut AnimationTimeline])
    = "#var(self).timeline = #fun(Option::as_js[mut AnimationTimeline])(#var(value));"

pub ext fun CSSAnimation::start_time(self: CSSAnimation) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).startTime);"

pub ext fun CSSAnimation::set_start_time(self: mut CSSAnimation, value: Option[JsValue])
    = "#var(self).startTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CSSAnimation::current_time(self: CSSAnimation) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun CSSAnimation::set_current_time(self: mut CSSAnimation, value: Option[JsValue])
    = "#var(self).currentTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CSSAnimation::overall_progress(self: CSSAnimation) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).overallProgress);"

pub ext fun CSSAnimation::playback_rate(self: CSSAnimation) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun CSSAnimation::set_playback_rate(self: mut CSSAnimation, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun CSSAnimation::range_start(self: CSSAnimation) -> JsValue
    = "return #var(self).rangeStart;"

pub ext fun CSSAnimation::set_range_start(self: mut CSSAnimation, value: JsValue)
    = "#var(self).rangeStart = #var(value);"

pub ext fun CSSAnimation::range_end(self: CSSAnimation) -> JsValue
    = "return #var(self).rangeEnd;"

pub ext fun CSSAnimation::set_range_end(self: mut CSSAnimation, value: JsValue)
    = "#var(self).rangeEnd = #var(value);"

pub ext fun CSSAnimation::play_state(self: CSSAnimation) -> String
    = "return #fun(String::from_js)(#var(self).playState);"

pub ext fun CSSAnimation::replace_state(self: CSSAnimation) -> String
    = "return #fun(String::from_js)(#var(self).replaceState);"

pub ext fun CSSAnimation::pending(self: CSSAnimation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pending);"

pub ext fun CSSAnimation::id(self: CSSAnimation) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun CSSAnimation::set_id(self: mut CSSAnimation, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun CSSAnimation::onfinish(self: CSSAnimation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfinish);"

pub ext fun CSSAnimation::set_onfinish(self: mut CSSAnimation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfinish = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSAnimation::oncancel(self: CSSAnimation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun CSSAnimation::set_oncancel(self: mut CSSAnimation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSAnimation::onremove(self: CSSAnimation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremove);"

pub ext fun CSSAnimation::set_onremove(self: mut CSSAnimation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSAnimation::finished(self: CSSAnimation) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).finished);"

pub ext fun CSSAnimation::ready(self: CSSAnimation) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).ready);"

pub ext fun CSSAnimation::commit_styles(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).commitStyles();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::finish(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).finish();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::play(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).play();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::pause(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::reverse(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).reverse();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::update_playback_rate(__self: mut CSSAnimation, playback__rate: Float) -> Unit = "
    const r = #var(__self).updatePlaybackRate(#fun(Float::as_js)(#var(playback__rate)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::persist(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).persist();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::cancel(__self: mut CSSAnimation) -> Unit = "
    const r = #var(__self).cancel();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::add_event_listener(__self: mut CSSAnimation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::remove_event_listener(__self: mut CSSAnimation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSAnimation::dispatch_event(__self: mut CSSAnimation, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSAnimation::when(__self: mut CSSAnimation, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun CSSAnimation::as_js(self: CSSAnimation) -> JsValue = JsValue::unsafe_from[CSSAnimation](self)

pub fun CSSAnimation::from_js(v: JsValue) -> mut CSSAnimation = JsValue::unsafe_as[mut CSSAnimation](v)

struct CSSTransition()

/// Converts a reference to 'CSSTransition' to a reference to 'Animation'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::as_animation(self: CSSTransition) -> Animation = "return #var(self);"

/// Converts a mutable reference to 'CSSTransition' to a mutable reference to 'Animation'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::as_manimation(self: mut CSSTransition) -> mut Animation = "return #var(self);"

/// Attempts to convert a reference to 'Animation' to a reference to 'CSSTransition'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransition' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::from_animation(base: Animation) -> CSSTransition = "
    if(#var(base) instanceof CSSTransition) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Animation' to 'CSSTransition'!\");
"

/// Attempts to convert a mutable reference to 'Animation' to a mutable reference to 'CSSTransition'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransition' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::from_manimation(base: mut Animation) -> mut CSSTransition = "
    if(#var(base) instanceof CSSTransition) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Animation' to 'CSSTransition'!\");
"

/// Converts a reference to 'CSSTransition' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::as_event_target(self: CSSTransition) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CSSTransition' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::as_mevent_target(self: mut CSSTransition) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CSSTransition'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransition' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::from_event_target(base: EventTarget) -> CSSTransition = "
    if(#var(base) instanceof CSSTransition) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CSSTransition'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CSSTransition'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransition' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransition::from_mevent_target(base: mut EventTarget) -> mut CSSTransition = "
    if(#var(base) instanceof CSSTransition) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CSSTransition'!\");
"

pub ext fun CSSTransition::transition_property(self: CSSTransition) -> String
    = "return #fun(String::from_js)(#var(self).transitionProperty);"

pub ext fun CSSTransition::effect(self: CSSTransition) -> Option[mut AnimationEffect]
    = "return #fun(Option::from_js[mut AnimationEffect])(#var(self).effect);"

pub ext fun CSSTransition::set_effect(self: mut CSSTransition, value: Option[mut AnimationEffect])
    = "#var(self).effect = #fun(Option::as_js[mut AnimationEffect])(#var(value));"

pub ext fun CSSTransition::timeline(self: CSSTransition) -> Option[mut AnimationTimeline]
    = "return #fun(Option::from_js[mut AnimationTimeline])(#var(self).timeline);"

pub ext fun CSSTransition::set_timeline(self: mut CSSTransition, value: Option[mut AnimationTimeline])
    = "#var(self).timeline = #fun(Option::as_js[mut AnimationTimeline])(#var(value));"

pub ext fun CSSTransition::start_time(self: CSSTransition) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).startTime);"

pub ext fun CSSTransition::set_start_time(self: mut CSSTransition, value: Option[JsValue])
    = "#var(self).startTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CSSTransition::current_time(self: CSSTransition) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun CSSTransition::set_current_time(self: mut CSSTransition, value: Option[JsValue])
    = "#var(self).currentTime = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CSSTransition::overall_progress(self: CSSTransition) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).overallProgress);"

pub ext fun CSSTransition::playback_rate(self: CSSTransition) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun CSSTransition::set_playback_rate(self: mut CSSTransition, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun CSSTransition::range_start(self: CSSTransition) -> JsValue
    = "return #var(self).rangeStart;"

pub ext fun CSSTransition::set_range_start(self: mut CSSTransition, value: JsValue)
    = "#var(self).rangeStart = #var(value);"

pub ext fun CSSTransition::range_end(self: CSSTransition) -> JsValue
    = "return #var(self).rangeEnd;"

pub ext fun CSSTransition::set_range_end(self: mut CSSTransition, value: JsValue)
    = "#var(self).rangeEnd = #var(value);"

pub ext fun CSSTransition::play_state(self: CSSTransition) -> String
    = "return #fun(String::from_js)(#var(self).playState);"

pub ext fun CSSTransition::replace_state(self: CSSTransition) -> String
    = "return #fun(String::from_js)(#var(self).replaceState);"

pub ext fun CSSTransition::pending(self: CSSTransition) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pending);"

pub ext fun CSSTransition::id(self: CSSTransition) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun CSSTransition::set_id(self: mut CSSTransition, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun CSSTransition::onfinish(self: CSSTransition) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfinish);"

pub ext fun CSSTransition::set_onfinish(self: mut CSSTransition, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfinish = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSTransition::oncancel(self: CSSTransition) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun CSSTransition::set_oncancel(self: mut CSSTransition, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSTransition::onremove(self: CSSTransition) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremove);"

pub ext fun CSSTransition::set_onremove(self: mut CSSTransition, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CSSTransition::finished(self: CSSTransition) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).finished);"

pub ext fun CSSTransition::ready(self: CSSTransition) -> Promise[mut Animation]
    = "return #fun(Promise::from_js[mut Animation])(#var(self).ready);"

pub ext fun CSSTransition::commit_styles(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).commitStyles();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::finish(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).finish();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::play(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).play();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::pause(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::reverse(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).reverse();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::update_playback_rate(__self: mut CSSTransition, playback__rate: Float) -> Unit = "
    const r = #var(__self).updatePlaybackRate(#fun(Float::as_js)(#var(playback__rate)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::persist(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).persist();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::cancel(__self: mut CSSTransition) -> Unit = "
    const r = #var(__self).cancel();
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::add_event_listener(__self: mut CSSTransition, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::remove_event_listener(__self: mut CSSTransition, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSTransition::dispatch_event(__self: mut CSSTransition, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSTransition::when(__self: mut CSSTransition, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun CSSTransition::as_js(self: CSSTransition) -> JsValue = JsValue::unsafe_from[CSSTransition](self)

pub fun CSSTransition::from_js(v: JsValue) -> mut CSSTransition = JsValue::unsafe_as[mut CSSTransition](v)

struct Document()

pub ext fun Document::timeline(self: Document) -> mut DocumentTimeline
    = "return #fun(DocumentTimeline::from_js)(#var(self).timeline);"

pub ext fun Document::onabort(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun Document::set_onabort(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onbeforeinput(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeinput);"

pub ext fun Document::set_onbeforeinput(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeinput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onbeforematch(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforematch);"

pub ext fun Document::set_onbeforematch(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforematch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onbeforetoggle(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforetoggle);"

pub ext fun Document::set_onbeforetoggle(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforetoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onblur(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun Document::set_onblur(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncancel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun Document::set_oncancel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncanplay(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplay);"

pub ext fun Document::set_oncanplay(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncanplaythrough(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplaythrough);"

pub ext fun Document::set_oncanplaythrough(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplaythrough = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun Document::set_onchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onclick(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclick);"

pub ext fun Document::set_onclick(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onclose(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun Document::set_onclose(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncommand(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncommand);"

pub ext fun Document::set_oncommand(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncommand = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncontentvisibilityautostatechange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontentvisibilityautostatechange);"

pub ext fun Document::set_oncontentvisibilityautostatechange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontentvisibilityautostatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncontextlost(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun Document::set_oncontextlost(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncontextmenu(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextmenu);"

pub ext fun Document::set_oncontextmenu(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextmenu = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncontextrestored(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun Document::set_oncontextrestored(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncuechange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun Document::set_oncuechange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondblclick(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondblclick);"

pub ext fun Document::set_ondblclick(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondblclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondrag(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrag);"

pub ext fun Document::set_ondrag(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrag = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondragend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragend);"

pub ext fun Document::set_ondragend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondragenter(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragenter);"

pub ext fun Document::set_ondragenter(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondragleave(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragleave);"

pub ext fun Document::set_ondragleave(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondragover(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragover);"

pub ext fun Document::set_ondragover(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondragstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragstart);"

pub ext fun Document::set_ondragstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondrop(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrop);"

pub ext fun Document::set_ondrop(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrop = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ondurationchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondurationchange);"

pub ext fun Document::set_ondurationchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondurationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onemptied(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onemptied);"

pub ext fun Document::set_onemptied(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onemptied = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onended(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onended);"

pub ext fun Document::set_onended(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onended = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onerror(self: Document) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun Document::set_onerror(self: mut Document, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onfencedtreeclick(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfencedtreeclick);"

pub ext fun Document::set_onfencedtreeclick(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfencedtreeclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onfocus(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun Document::set_onfocus(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onformdata(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onformdata);"

pub ext fun Document::set_onformdata(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onformdata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oninput(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninput);"

pub ext fun Document::set_oninput(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oninvalid(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninvalid);"

pub ext fun Document::set_oninvalid(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninvalid = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onkeydown(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeydown);"

pub ext fun Document::set_onkeydown(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeydown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onkeypress(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeypress);"

pub ext fun Document::set_onkeypress(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeypress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onkeyup(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeyup);"

pub ext fun Document::set_onkeyup(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeyup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onload(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun Document::set_onload(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onloadeddata(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadeddata);"

pub ext fun Document::set_onloadeddata(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadeddata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onloadedmetadata(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadedmetadata);"

pub ext fun Document::set_onloadedmetadata(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadedmetadata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onloadstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun Document::set_onloadstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmousedown(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousedown);"

pub ext fun Document::set_onmousedown(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousedown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmouseenter(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseenter);"

pub ext fun Document::set_onmouseenter(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmouseleave(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseleave);"

pub ext fun Document::set_onmouseleave(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmousemove(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousemove);"

pub ext fun Document::set_onmousemove(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousemove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmouseout(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseout);"

pub ext fun Document::set_onmouseout(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmouseover(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseover);"

pub ext fun Document::set_onmouseover(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmouseup(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseup);"

pub ext fun Document::set_onmouseup(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onmousewheel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousewheel);"

pub ext fun Document::set_onmousewheel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousewheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onoverscroll(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoverscroll);"

pub ext fun Document::set_onoverscroll(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoverscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpause(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpause);"

pub ext fun Document::set_onpause(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpause = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onplay(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplay);"

pub ext fun Document::set_onplay(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onplaying(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplaying);"

pub ext fun Document::set_onplaying(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplaying = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onprogress(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun Document::set_onprogress(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onratechange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onratechange);"

pub ext fun Document::set_onratechange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onratechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onreset(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreset);"

pub ext fun Document::set_onreset(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreset = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onresize(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun Document::set_onresize(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onscroll(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun Document::set_onscroll(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onscrollend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun Document::set_onscrollend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onsecuritypolicyviolation(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsecuritypolicyviolation);"

pub ext fun Document::set_onsecuritypolicyviolation(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsecuritypolicyviolation = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onseeked(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeked);"

pub ext fun Document::set_onseeked(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeked = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onseeking(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeking);"

pub ext fun Document::set_onseeking(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeking = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onselect(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselect);"

pub ext fun Document::set_onselect(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onslotchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun Document::set_onslotchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onscrollsnapchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchange);"

pub ext fun Document::set_onscrollsnapchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onscrollsnapchanging(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchanging);"

pub ext fun Document::set_onscrollsnapchanging(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchanging = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onstalled(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstalled);"

pub ext fun Document::set_onstalled(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstalled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onsubmit(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsubmit);"

pub ext fun Document::set_onsubmit(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsubmit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onsuspend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsuspend);"

pub ext fun Document::set_onsuspend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsuspend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontimeupdate(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeupdate);"

pub ext fun Document::set_ontimeupdate(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontoggle(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontoggle);"

pub ext fun Document::set_ontoggle(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onvolumechange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvolumechange);"

pub ext fun Document::set_onvolumechange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvolumechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwaiting(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwaiting);"

pub ext fun Document::set_onwaiting(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwaiting = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwebkitanimationend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationend);"

pub ext fun Document::set_onwebkitanimationend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwebkitanimationiteration(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationiteration);"

pub ext fun Document::set_onwebkitanimationiteration(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwebkitanimationstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationstart);"

pub ext fun Document::set_onwebkitanimationstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwebkittransitionend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkittransitionend);"

pub ext fun Document::set_onwebkittransitionend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkittransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwheel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwheel);"

pub ext fun Document::set_onwheel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onauxclick(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onauxclick);"

pub ext fun Document::set_onauxclick(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onauxclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ongotpointercapture(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ongotpointercapture);"

pub ext fun Document::set_ongotpointercapture(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ongotpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onlostpointercapture(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlostpointercapture);"

pub ext fun Document::set_onlostpointercapture(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlostpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerdown(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerdown);"

pub ext fun Document::set_onpointerdown(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerdown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointermove(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointermove);"

pub ext fun Document::set_onpointermove(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointermove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerrawupdate(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerrawupdate);"

pub ext fun Document::set_onpointerrawupdate(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerrawupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerup(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerup);"

pub ext fun Document::set_onpointerup(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointercancel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointercancel);"

pub ext fun Document::set_onpointercancel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointercancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerover(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerover);"

pub ext fun Document::set_onpointerover(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerout(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerout);"

pub ext fun Document::set_onpointerout(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerenter(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerenter);"

pub ext fun Document::set_onpointerenter(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerleave(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerleave);"

pub ext fun Document::set_onpointerleave(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontouchcancel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchcancel);"

pub ext fun Document::set_ontouchcancel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchcancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontouchend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchend);"

pub ext fun Document::set_ontouchend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontouchmove(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchmove);"

pub ext fun Document::set_ontouchmove(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontouchstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchstart);"

pub ext fun Document::set_ontouchstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onselectstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectstart);"

pub ext fun Document::set_onselectstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onselectionchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectionchange);"

pub ext fun Document::set_onselectionchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectionchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onanimationend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationend);"

pub ext fun Document::set_onanimationend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onanimationiteration(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationiteration);"

pub ext fun Document::set_onanimationiteration(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onanimationstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationstart);"

pub ext fun Document::set_onanimationstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontransitionrun(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionrun);"

pub ext fun Document::set_ontransitionrun(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionrun = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontransitionstart(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionstart);"

pub ext fun Document::set_ontransitionstart(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontransitionend(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionend);"

pub ext fun Document::set_ontransitionend(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::ontransitioncancel(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitioncancel);"

pub ext fun Document::set_ontransitioncancel(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitioncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncopy(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncopy);"

pub ext fun Document::set_oncopy(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::oncut(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncut);"

pub ext fun Document::set_oncut(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpaste(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpaste);"

pub ext fun Document::set_onpaste(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::children(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun Document::first_element_child(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun Document::last_element_child(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun Document::child_element_count(self: Document) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun Document::active_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).activeElement);"

pub ext fun Document::style_sheets(self: Document) -> mut StyleSheetList
    = "return #fun(StyleSheetList::from_js)(#var(self).styleSheets);"

pub ext fun Document::pointer_lock_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).pointerLockElement);"

pub ext fun Document::fullscreen_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).fullscreenElement);"

pub ext fun Document::adopted_style_sheets(self: Document) -> JsValue
    = "return #var(self).adoptedStyleSheets;"

pub ext fun Document::set_adopted_style_sheets(self: mut Document, value: JsValue)
    = "#var(self).adoptedStyleSheets = #var(value);"

pub ext fun Document::picture_in_picture_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).pictureInPictureElement);"

pub ext fun Document::custom_element_registry(self: Document) -> Option[mut CustomElementRegistry]
    = "return #fun(Option::from_js[mut CustomElementRegistry])(#var(self).customElementRegistry);"

pub ext fun Document::fonts(self: Document) -> mut FontFaceSet
    = "return #fun(FontFaceSet::from_js)(#var(self).fonts);"

pub ext fun Document::prepend(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::append(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::replace_children(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::move_before(__self: mut Document, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::query_selector(__self: mut Document, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Document::query_selector_all(__self: mut Document, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Document::get_element_by_id(__self: mut Document, element_id: String) -> Option[mut Element] = "
    const r = #var(__self).getElementById(#fun(String::as_js)(#var(element_id)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Document::get_selection(__self: mut Document) -> Option[mut Selection] = "
    const r = #var(__self).getSelection();
    return #fun(Option::from_js[mut Selection])(r);
"

pub ext fun Document::get_animations(__self: mut Document) -> List[mut Animation] = "
    const r = #var(__self).getAnimations();
    return #fun(List::from_js[mut Animation])(r);
"

pub ext fun Document::element_from_point(__self: mut Document, x: Float, y: Float) -> Option[mut Element] = "
    const r = #var(__self).elementFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Document::elements_from_point(__self: mut Document, x: Float, y: Float) -> List[mut Element] = "
    const r = #var(__self).elementsFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(List::from_js[mut Element])(r);
"

pub fun Document::as_js(self: Document) -> JsValue = JsValue::unsafe_from[Document](self)

pub fun Document::from_js(v: JsValue) -> mut Document = JsValue::unsafe_as[mut Document](v)

struct DocumentTimeline()

/// Converts a reference to 'DocumentTimeline' to a reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentTimeline::as_animation_timeline(self: DocumentTimeline) -> AnimationTimeline = "return #var(self);"

/// Converts a mutable reference to 'DocumentTimeline' to a mutable reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentTimeline::as_manimation_timeline(self: mut DocumentTimeline) -> mut AnimationTimeline = "return #var(self);"

/// Attempts to convert a reference to 'AnimationTimeline' to a reference to 'DocumentTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentTimeline::from_animation_timeline(base: AnimationTimeline) -> DocumentTimeline = "
    if(#var(base) instanceof DocumentTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'DocumentTimeline'!\");
"

/// Attempts to convert a mutable reference to 'AnimationTimeline' to a mutable reference to 'DocumentTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentTimeline::from_manimation_timeline(base: mut AnimationTimeline) -> mut DocumentTimeline = "
    if(#var(base) instanceof DocumentTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'DocumentTimeline'!\");
"

pub ext fun DocumentTimeline::from_mdocument_timeline_options(options: mut DocumentTimelineOptions) -> mut DocumentTimeline
    = "return new DocumentTimeline(#fun(DocumentTimelineOptions::as_js)(#var(options)));"

pub ext fun DocumentTimeline::current_time(self: DocumentTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun DocumentTimeline::duration(self: DocumentTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).duration);"

pub ext fun DocumentTimeline::get_current_time(__self: mut DocumentTimeline, range_name: String) -> Option[mut CSSNumericValue] = "
    const r = #var(__self).getCurrentTime(#fun(String::as_js)(#var(range_name)));
    return #fun(Option::from_js[mut CSSNumericValue])(r);
"

pub fun DocumentTimeline::as_js(self: DocumentTimeline) -> JsValue = JsValue::unsafe_from[DocumentTimeline](self)

pub fun DocumentTimeline::from_js(v: JsValue) -> mut DocumentTimeline = JsValue::unsafe_as[mut DocumentTimeline](v)

pub struct DocumentTimelineOptions(
    origin_time: Option[Float]
)

pub fun DocumentTimelineOptions::default() -> mut DocumentTimelineOptions
    = DocumentTimelineOptions(Option::Some(0.0))

pub ext fun DocumentTimelineOptions::from_js(value: JsValue) -> mut DocumentTimelineOptions = "
    const r = {};
    r.m_origin_time = #fun(Option::from_js[Float])(#var(value).originTime);
    return r;
"

pub ext fun DocumentTimelineOptions::as_js(self: DocumentTimelineOptions) -> JsValue = "
    const r = {};
    r.originTime = #fun(Option::as_js_undef[Float])(#var(self).m_origin_time);
    return r;
"

pub val FillMode::None: String = "none"
pub val FillMode::Forwards: String = "forwards"
pub val FillMode::Backwards: String = "backwards"
pub val FillMode::Both: String = "both"
pub val FillMode::Auto: String = "auto"

pub val PlaybackDirection::Normal: String = "normal"
pub val PlaybackDirection::Reverse: String = "reverse"
pub val PlaybackDirection::Alternate: String = "alternate"
pub val PlaybackDirection::AlternateReverse: String = "alternate-reverse"

pub struct EffectTiming(
    delay: Option[JsValue],
    end_delay: Option[JsValue],
    fill: Option[String],
    iteration_start: Option[Float],
    iterations: Option[Float],
    duration: Option[JsValue],
    direction: Option[String],
    easing: Option[String]
)

pub fun EffectTiming::default() -> mut EffectTiming
    = EffectTiming(Option::Some(0.0 |> as_js()), Option::Some(0.0 |> as_js()), Option::Some("auto"), Option::Some(0.0), Option::Some(1.0), Option::Some("auto" |> as_js()), Option::Some("normal"), Option::Some("linear"))

pub ext fun EffectTiming::from_js(value: JsValue) -> mut EffectTiming = "
    const r = {};
    r.m_delay = #fun(Option::from_js[JsValue])(#var(value).delay);
    r.m_end_delay = #fun(Option::from_js[JsValue])(#var(value).endDelay);
    r.m_fill = #fun(Option::from_js[String])(#var(value).fill);
    r.m_iteration_start = #fun(Option::from_js[Float])(#var(value).iterationStart);
    r.m_iterations = #fun(Option::from_js[Float])(#var(value).iterations);
    r.m_duration = #fun(Option::from_js[JsValue])(#var(value).duration);
    r.m_direction = #fun(Option::from_js[String])(#var(value).direction);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    return r;
"

pub ext fun EffectTiming::as_js(self: EffectTiming) -> JsValue = "
    const r = {};
    r.delay = #fun(Option::as_js_undef[JsValue])(#var(self).m_delay);
    r.endDelay = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_delay);
    r.fill = #fun(Option::as_js_undef[String])(#var(self).m_fill);
    r.iterationStart = #fun(Option::as_js_undef[Float])(#var(self).m_iteration_start);
    r.iterations = #fun(Option::as_js_undef[Float])(#var(self).m_iterations);
    r.duration = #fun(Option::as_js_undef[JsValue])(#var(self).m_duration);
    r.direction = #fun(Option::as_js_undef[String])(#var(self).m_direction);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    return r;
"

pub struct GetAnimationsOptions(
    subtree: Option[Bool]
)

pub fun GetAnimationsOptions::default() -> mut GetAnimationsOptions
    = GetAnimationsOptions(Option::Some(false))

pub ext fun GetAnimationsOptions::from_js(value: JsValue) -> mut GetAnimationsOptions = "
    const r = {};
    r.m_subtree = #fun(Option::from_js[Bool])(#var(value).subtree);
    return r;
"

pub ext fun GetAnimationsOptions::as_js(self: GetAnimationsOptions) -> JsValue = "
    const r = {};
    r.subtree = #fun(Option::as_js_undef[Bool])(#var(self).m_subtree);
    return r;
"

pub val TimelineRange::None: String = "none"
pub val TimelineRange::Cover: String = "cover"
pub val TimelineRange::Contain: String = "contain"
pub val TimelineRange::Entry: String = "entry"
pub val TimelineRange::EntryCrossing: String = "entry-crossing"
pub val TimelineRange::Exit: String = "exit"
pub val TimelineRange::ExitCrossing: String = "exit-crossing"
pub val TimelineRange::Scroll: String = "scroll"

pub struct TimelineRangeOffset(
    range_name: Option[String],
    offset: Option[mut CSSNumericValue]
)

pub fun TimelineRangeOffset::default() -> mut TimelineRangeOffset
    = TimelineRangeOffset(Option::None, Option::None)

pub ext fun TimelineRangeOffset::from_js(value: JsValue) -> mut TimelineRangeOffset = "
    const r = {};
    r.m_range_name = #fun(Option::from_js[String])(#var(value).rangeName);
    r.m_offset = #fun(Option::from_js[mut CSSNumericValue])(#var(value).offset);
    return r;
"

pub ext fun TimelineRangeOffset::as_js(self: TimelineRangeOffset) -> JsValue = "
    const r = {};
    r.rangeName = #fun(Option::as_js_undef[String])(#var(self).m_range_name);
    r.offset = #fun(Option::as_js_undef[mut CSSNumericValue])(#var(self).m_offset);
    return r;
"

pub struct KeyframeAnimationOptions(
    id: Option[String],
    timeline: Option[mut AnimationTimeline],
    range_start: Option[JsValue],
    range_end: Option[JsValue],
    composite: Option[String],
    pseudo_element: Option[String],
    delay: Option[JsValue],
    end_delay: Option[JsValue],
    fill: Option[String],
    iteration_start: Option[Float],
    iterations: Option[Float],
    duration: Option[JsValue],
    direction: Option[String],
    easing: Option[String]
)

pub fun KeyframeAnimationOptions::default() -> mut KeyframeAnimationOptions
    = KeyframeAnimationOptions(Option::Some(""), Option::None, Option::Some("normal" |> as_js()), Option::Some("normal" |> as_js()), Option::Some("replace"), Option::None, Option::Some(0.0 |> as_js()), Option::Some(0.0 |> as_js()), Option::Some("auto"), Option::Some(0.0), Option::Some(1.0), Option::Some("auto" |> as_js()), Option::Some("normal"), Option::Some("linear"))

/// Converts a reference to 'KeyframeAnimationOptions' to a reference to 'KeyframeEffectOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeAnimationOptions::as_keyframe_effect_options(self: KeyframeAnimationOptions) -> KeyframeEffectOptions = "return #var(self);"

/// Converts a mutable reference to 'KeyframeAnimationOptions' to a mutable reference to 'KeyframeEffectOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeAnimationOptions::as_mkeyframe_effect_options(self: mut KeyframeAnimationOptions) -> mut KeyframeEffectOptions = "return #var(self);"

/// Attempts to convert a reference to 'KeyframeEffectOptions' to a reference to 'KeyframeAnimationOptions'.
/// A 'base' that is not a reference to 'KeyframeAnimationOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeAnimationOptions::from_keyframe_effect_options_unchecked(base: KeyframeEffectOptions) -> KeyframeAnimationOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'KeyframeEffectOptions' to a mutable reference to 'KeyframeAnimationOptions'.
/// A 'base' that is not a reference to 'KeyframeAnimationOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeAnimationOptions::from_mkeyframe_effect_options_unchecked(base: mut KeyframeEffectOptions) -> mut KeyframeAnimationOptions = "return #var(base);"

pub ext fun KeyframeAnimationOptions::from_js(value: JsValue) -> mut KeyframeAnimationOptions = "
    const r = {};
    r.m_id = #fun(Option::from_js[String])(#var(value).id);
    r.m_timeline = #fun(Option::from_js[mut AnimationTimeline])(#var(value).timeline);
    r.m_range_start = #fun(Option::from_js[JsValue])(#var(value).rangeStart);
    r.m_range_end = #fun(Option::from_js[JsValue])(#var(value).rangeEnd);
    r.m_composite = #fun(Option::from_js[String])(#var(value).composite);
    r.m_pseudo_element = #fun(Option::from_js[String])(#var(value).pseudoElement);
    r.m_delay = #fun(Option::from_js[JsValue])(#var(value).delay);
    r.m_end_delay = #fun(Option::from_js[JsValue])(#var(value).endDelay);
    r.m_fill = #fun(Option::from_js[String])(#var(value).fill);
    r.m_iteration_start = #fun(Option::from_js[Float])(#var(value).iterationStart);
    r.m_iterations = #fun(Option::from_js[Float])(#var(value).iterations);
    r.m_duration = #fun(Option::from_js[JsValue])(#var(value).duration);
    r.m_direction = #fun(Option::from_js[String])(#var(value).direction);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    return r;
"

pub ext fun KeyframeAnimationOptions::as_js(self: KeyframeAnimationOptions) -> JsValue = "
    const r = {};
    r.id = #fun(Option::as_js_undef[String])(#var(self).m_id);
    r.timeline = #fun(Option::as_js_undef[mut AnimationTimeline])(#var(self).m_timeline);
    r.rangeStart = #fun(Option::as_js_undef[JsValue])(#var(self).m_range_start);
    r.rangeEnd = #fun(Option::as_js_undef[JsValue])(#var(self).m_range_end);
    r.composite = #fun(Option::as_js_undef[String])(#var(self).m_composite);
    r.pseudoElement = #fun(Option::as_js_undef[String])(#var(self).m_pseudo_element);
    r.delay = #fun(Option::as_js_undef[JsValue])(#var(self).m_delay);
    r.endDelay = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_delay);
    r.fill = #fun(Option::as_js_undef[String])(#var(self).m_fill);
    r.iterationStart = #fun(Option::as_js_undef[Float])(#var(self).m_iteration_start);
    r.iterations = #fun(Option::as_js_undef[Float])(#var(self).m_iterations);
    r.duration = #fun(Option::as_js_undef[JsValue])(#var(self).m_duration);
    r.direction = #fun(Option::as_js_undef[String])(#var(self).m_direction);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    return r;
"

pub val CompositeOperation::Replace: String = "replace"
pub val CompositeOperation::Add: String = "add"
pub val CompositeOperation::Accumulate: String = "accumulate"

struct KeyframeEffect()

/// Converts a reference to 'KeyframeEffect' to a reference to 'AnimationEffect'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffect::as_animation_effect(self: KeyframeEffect) -> AnimationEffect = "return #var(self);"

/// Converts a mutable reference to 'KeyframeEffect' to a mutable reference to 'AnimationEffect'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffect::as_manimation_effect(self: mut KeyframeEffect) -> mut AnimationEffect = "return #var(self);"

/// Attempts to convert a reference to 'AnimationEffect' to a reference to 'KeyframeEffect'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyframeEffect' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffect::from_animation_effect(base: AnimationEffect) -> KeyframeEffect = "
    if(#var(base) instanceof KeyframeEffect) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationEffect' to 'KeyframeEffect'!\");
"

/// Attempts to convert a mutable reference to 'AnimationEffect' to a mutable reference to 'KeyframeEffect'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyframeEffect' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffect::from_manimation_effect(base: mut AnimationEffect) -> mut KeyframeEffect = "
    if(#var(base) instanceof KeyframeEffect) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationEffect' to 'KeyframeEffect'!\");
"

pub ext fun KeyframeEffect::from_omelement_oobj_any(target: Option[mut Element], keyframes: Option[JsObject], options: JsValue) -> mut KeyframeEffect
    = "return new KeyframeEffect(#fun(Option::as_js[mut Element])(#var(target)), #fun(Option::as_js[JsObject])(#var(keyframes)), #var(options));"

pub ext fun KeyframeEffect::from_mkeyframe_effect(source: mut KeyframeEffect) -> mut KeyframeEffect
    = "return new KeyframeEffect(#fun(KeyframeEffect::as_js)(#var(source)));"

pub ext fun KeyframeEffect::target(self: KeyframeEffect) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).target);"

pub ext fun KeyframeEffect::set_target(self: mut KeyframeEffect, value: Option[mut Element])
    = "#var(self).target = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun KeyframeEffect::pseudo_element(self: KeyframeEffect) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).pseudoElement);"

pub ext fun KeyframeEffect::set_pseudo_element(self: mut KeyframeEffect, value: Option[String])
    = "#var(self).pseudoElement = #fun(Option::as_js[String])(#var(value));"

pub ext fun KeyframeEffect::composite(self: KeyframeEffect) -> String
    = "return #fun(String::from_js)(#var(self).composite);"

pub ext fun KeyframeEffect::set_composite(self: mut KeyframeEffect, value: String)
    = "#var(self).composite = #var(value);"

pub ext fun KeyframeEffect::get_keyframes(__self: mut KeyframeEffect) -> List[JsObject] = "
    const r = #var(__self).getKeyframes();
    return #fun(List::from_js[JsObject])(r);
"

pub ext fun KeyframeEffect::set_keyframes(__self: mut KeyframeEffect, keyframes: Option[JsObject]) -> Unit = "
    const r = #var(__self).setKeyframes(#fun(Option::as_js[JsObject])(#var(keyframes)));
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyframeEffect::get_timing(__self: mut KeyframeEffect) -> mut EffectTiming = "
    const r = #var(__self).getTiming();
    return #fun(EffectTiming::from_js)(r);
"

pub ext fun KeyframeEffect::get_computed_timing(__self: mut KeyframeEffect) -> mut ComputedEffectTiming = "
    const r = #var(__self).getComputedTiming();
    return #fun(ComputedEffectTiming::from_js)(r);
"

pub ext fun KeyframeEffect::update_timing(__self: mut KeyframeEffect, timing: mut OptionalEffectTiming) -> Unit = "
    const r = #var(__self).updateTiming(#fun(OptionalEffectTiming::as_js)(#var(timing)));
    return #fun(Unit::from_js)(r);
"

pub fun KeyframeEffect::as_js(self: KeyframeEffect) -> JsValue = JsValue::unsafe_from[KeyframeEffect](self)

pub fun KeyframeEffect::from_js(v: JsValue) -> mut KeyframeEffect = JsValue::unsafe_as[mut KeyframeEffect](v)

pub struct KeyframeEffectOptions(
    composite: Option[String],
    pseudo_element: Option[String],
    delay: Option[JsValue],
    end_delay: Option[JsValue],
    fill: Option[String],
    iteration_start: Option[Float],
    iterations: Option[Float],
    duration: Option[JsValue],
    direction: Option[String],
    easing: Option[String]
)

pub fun KeyframeEffectOptions::default() -> mut KeyframeEffectOptions
    = KeyframeEffectOptions(Option::Some("replace"), Option::None, Option::Some(0.0 |> as_js()), Option::Some(0.0 |> as_js()), Option::Some("auto"), Option::Some(0.0), Option::Some(1.0), Option::Some("auto" |> as_js()), Option::Some("normal"), Option::Some("linear"))

/// Converts a reference to 'KeyframeEffectOptions' to a reference to 'EffectTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffectOptions::as_effect_timing(self: KeyframeEffectOptions) -> EffectTiming = "return #var(self);"

/// Converts a mutable reference to 'KeyframeEffectOptions' to a mutable reference to 'EffectTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffectOptions::as_meffect_timing(self: mut KeyframeEffectOptions) -> mut EffectTiming = "return #var(self);"

/// Attempts to convert a reference to 'EffectTiming' to a reference to 'KeyframeEffectOptions'.
/// A 'base' that is not a reference to 'KeyframeEffectOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffectOptions::from_effect_timing_unchecked(base: EffectTiming) -> KeyframeEffectOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'EffectTiming' to a mutable reference to 'KeyframeEffectOptions'.
/// A 'base' that is not a reference to 'KeyframeEffectOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyframeEffectOptions::from_meffect_timing_unchecked(base: mut EffectTiming) -> mut KeyframeEffectOptions = "return #var(base);"

pub ext fun KeyframeEffectOptions::from_js(value: JsValue) -> mut KeyframeEffectOptions = "
    const r = {};
    r.m_composite = #fun(Option::from_js[String])(#var(value).composite);
    r.m_pseudo_element = #fun(Option::from_js[String])(#var(value).pseudoElement);
    r.m_delay = #fun(Option::from_js[JsValue])(#var(value).delay);
    r.m_end_delay = #fun(Option::from_js[JsValue])(#var(value).endDelay);
    r.m_fill = #fun(Option::from_js[String])(#var(value).fill);
    r.m_iteration_start = #fun(Option::from_js[Float])(#var(value).iterationStart);
    r.m_iterations = #fun(Option::from_js[Float])(#var(value).iterations);
    r.m_duration = #fun(Option::from_js[JsValue])(#var(value).duration);
    r.m_direction = #fun(Option::from_js[String])(#var(value).direction);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    return r;
"

pub ext fun KeyframeEffectOptions::as_js(self: KeyframeEffectOptions) -> JsValue = "
    const r = {};
    r.composite = #fun(Option::as_js_undef[String])(#var(self).m_composite);
    r.pseudoElement = #fun(Option::as_js_undef[String])(#var(self).m_pseudo_element);
    r.delay = #fun(Option::as_js_undef[JsValue])(#var(self).m_delay);
    r.endDelay = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_delay);
    r.fill = #fun(Option::as_js_undef[String])(#var(self).m_fill);
    r.iterationStart = #fun(Option::as_js_undef[Float])(#var(self).m_iteration_start);
    r.iterations = #fun(Option::as_js_undef[Float])(#var(self).m_iterations);
    r.duration = #fun(Option::as_js_undef[JsValue])(#var(self).m_duration);
    r.direction = #fun(Option::as_js_undef[String])(#var(self).m_direction);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    return r;
"

pub struct OptionalEffectTiming(
    delay: Option[JsValue],
    end_delay: Option[JsValue],
    fill: Option[String],
    iteration_start: Option[Float],
    iterations: Option[Float],
    duration: Option[JsValue],
    direction: Option[String],
    easing: Option[String]
)

pub fun OptionalEffectTiming::default() -> mut OptionalEffectTiming
    = OptionalEffectTiming(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun OptionalEffectTiming::from_js(value: JsValue) -> mut OptionalEffectTiming = "
    const r = {};
    r.m_delay = #fun(Option::from_js[JsValue])(#var(value).delay);
    r.m_end_delay = #fun(Option::from_js[JsValue])(#var(value).endDelay);
    r.m_fill = #fun(Option::from_js[String])(#var(value).fill);
    r.m_iteration_start = #fun(Option::from_js[Float])(#var(value).iterationStart);
    r.m_iterations = #fun(Option::from_js[Float])(#var(value).iterations);
    r.m_duration = #fun(Option::from_js[JsValue])(#var(value).duration);
    r.m_direction = #fun(Option::from_js[String])(#var(value).direction);
    r.m_easing = #fun(Option::from_js[String])(#var(value).easing);
    return r;
"

pub ext fun OptionalEffectTiming::as_js(self: OptionalEffectTiming) -> JsValue = "
    const r = {};
    r.delay = #fun(Option::as_js_undef[JsValue])(#var(self).m_delay);
    r.endDelay = #fun(Option::as_js_undef[JsValue])(#var(self).m_end_delay);
    r.fill = #fun(Option::as_js_undef[String])(#var(self).m_fill);
    r.iterationStart = #fun(Option::as_js_undef[Float])(#var(self).m_iteration_start);
    r.iterations = #fun(Option::as_js_undef[Float])(#var(self).m_iterations);
    r.duration = #fun(Option::as_js_undef[JsValue])(#var(self).m_duration);
    r.direction = #fun(Option::as_js_undef[String])(#var(self).m_direction);
    r.easing = #fun(Option::as_js_undef[String])(#var(self).m_easing);
    return r;
"

pub val ScrollAxis::Block: String = "block"
pub val ScrollAxis::Inline: String = "inline"
pub val ScrollAxis::X: String = "x"
pub val ScrollAxis::Y: String = "y"

struct ScrollTimeline()

/// Converts a reference to 'ScrollTimeline' to a reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollTimeline::as_animation_timeline(self: ScrollTimeline) -> AnimationTimeline = "return #var(self);"

/// Converts a mutable reference to 'ScrollTimeline' to a mutable reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollTimeline::as_manimation_timeline(self: mut ScrollTimeline) -> mut AnimationTimeline = "return #var(self);"

/// Attempts to convert a reference to 'AnimationTimeline' to a reference to 'ScrollTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ScrollTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollTimeline::from_animation_timeline(base: AnimationTimeline) -> ScrollTimeline = "
    if(#var(base) instanceof ScrollTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'ScrollTimeline'!\");
"

/// Attempts to convert a mutable reference to 'AnimationTimeline' to a mutable reference to 'ScrollTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ScrollTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollTimeline::from_manimation_timeline(base: mut AnimationTimeline) -> mut ScrollTimeline = "
    if(#var(base) instanceof ScrollTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'ScrollTimeline'!\");
"

pub ext fun ScrollTimeline::from_mscroll_timeline_options(options: mut ScrollTimelineOptions) -> mut ScrollTimeline
    = "return new ScrollTimeline(#fun(ScrollTimelineOptions::as_js)(#var(options)));"

pub ext fun ScrollTimeline::source(self: ScrollTimeline) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).source);"

pub ext fun ScrollTimeline::axis(self: ScrollTimeline) -> String
    = "return #fun(String::from_js)(#var(self).axis);"

pub ext fun ScrollTimeline::current_time(self: ScrollTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun ScrollTimeline::duration(self: ScrollTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).duration);"

pub ext fun ScrollTimeline::get_current_time(__self: mut ScrollTimeline, range_name: String) -> Option[mut CSSNumericValue] = "
    const r = #var(__self).getCurrentTime(#fun(String::as_js)(#var(range_name)));
    return #fun(Option::from_js[mut CSSNumericValue])(r);
"

pub fun ScrollTimeline::as_js(self: ScrollTimeline) -> JsValue = JsValue::unsafe_from[ScrollTimeline](self)

pub fun ScrollTimeline::from_js(v: JsValue) -> mut ScrollTimeline = JsValue::unsafe_as[mut ScrollTimeline](v)

pub struct ScrollTimelineOptions(
    source: Option[mut Element],
    axis: Option[String]
)

pub fun ScrollTimelineOptions::default() -> mut ScrollTimelineOptions
    = ScrollTimelineOptions(Option::None, Option::Some("block"))

pub ext fun ScrollTimelineOptions::from_js(value: JsValue) -> mut ScrollTimelineOptions = "
    const r = {};
    r.m_source = #fun(Option::from_js[mut Element])(#var(value).source);
    r.m_axis = #fun(Option::from_js[String])(#var(value).axis);
    return r;
"

pub ext fun ScrollTimelineOptions::as_js(self: ScrollTimelineOptions) -> JsValue = "
    const r = {};
    r.source = #fun(Option::as_js_undef[mut Element])(#var(self).m_source);
    r.axis = #fun(Option::as_js_undef[String])(#var(self).m_axis);
    return r;
"

struct ViewTimeline()

/// Converts a reference to 'ViewTimeline' to a reference to 'ScrollTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::as_scroll_timeline(self: ViewTimeline) -> ScrollTimeline = "return #var(self);"

/// Converts a mutable reference to 'ViewTimeline' to a mutable reference to 'ScrollTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::as_mscroll_timeline(self: mut ViewTimeline) -> mut ScrollTimeline = "return #var(self);"

/// Attempts to convert a reference to 'ScrollTimeline' to a reference to 'ViewTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ViewTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::from_scroll_timeline(base: ScrollTimeline) -> ViewTimeline = "
    if(#var(base) instanceof ViewTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ScrollTimeline' to 'ViewTimeline'!\");
"

/// Attempts to convert a mutable reference to 'ScrollTimeline' to a mutable reference to 'ViewTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ViewTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::from_mscroll_timeline(base: mut ScrollTimeline) -> mut ViewTimeline = "
    if(#var(base) instanceof ViewTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ScrollTimeline' to 'ViewTimeline'!\");
"

/// Converts a reference to 'ViewTimeline' to a reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::as_animation_timeline(self: ViewTimeline) -> AnimationTimeline = "return #var(self);"

/// Converts a mutable reference to 'ViewTimeline' to a mutable reference to 'AnimationTimeline'.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::as_manimation_timeline(self: mut ViewTimeline) -> mut AnimationTimeline = "return #var(self);"

/// Attempts to convert a reference to 'AnimationTimeline' to a reference to 'ViewTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ViewTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::from_animation_timeline(base: AnimationTimeline) -> ViewTimeline = "
    if(#var(base) instanceof ViewTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'ViewTimeline'!\");
"

/// Attempts to convert a mutable reference to 'AnimationTimeline' to a mutable reference to 'ViewTimeline'.
/// The conversion may fail and panic if 'base' is not a reference to 'ViewTimeline' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ViewTimeline::from_manimation_timeline(base: mut AnimationTimeline) -> mut ViewTimeline = "
    if(#var(base) instanceof ViewTimeline) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AnimationTimeline' to 'ViewTimeline'!\");
"

pub ext fun ViewTimeline::from_mview_timeline_options(options: mut ViewTimelineOptions) -> mut ViewTimeline
    = "return new ViewTimeline(#fun(ViewTimelineOptions::as_js)(#var(options)));"

pub ext fun ViewTimeline::subject(self: ViewTimeline) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).subject);"

pub ext fun ViewTimeline::start_offset(self: ViewTimeline) -> Option[mut CSSNumericValue]
    = "return #fun(Option::from_js[mut CSSNumericValue])(#var(self).startOffset);"

pub ext fun ViewTimeline::end_offset(self: ViewTimeline) -> Option[mut CSSNumericValue]
    = "return #fun(Option::from_js[mut CSSNumericValue])(#var(self).endOffset);"

pub ext fun ViewTimeline::source(self: ViewTimeline) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).source);"

pub ext fun ViewTimeline::axis(self: ViewTimeline) -> String
    = "return #fun(String::from_js)(#var(self).axis);"

pub ext fun ViewTimeline::current_time(self: ViewTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun ViewTimeline::duration(self: ViewTimeline) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).duration);"

pub ext fun ViewTimeline::get_current_time(__self: mut ViewTimeline, range_name: String) -> Option[mut CSSNumericValue] = "
    const r = #var(__self).getCurrentTime(#fun(String::as_js)(#var(range_name)));
    return #fun(Option::from_js[mut CSSNumericValue])(r);
"

pub fun ViewTimeline::as_js(self: ViewTimeline) -> JsValue = JsValue::unsafe_from[ViewTimeline](self)

pub fun ViewTimeline::from_js(v: JsValue) -> mut ViewTimeline = JsValue::unsafe_as[mut ViewTimeline](v)

pub struct ViewTimelineOptions(
    subject: Option[mut Element],
    axis: Option[String],
    inset: Option[JsValue]
)

pub fun ViewTimelineOptions::default() -> mut ViewTimelineOptions
    = ViewTimelineOptions(Option::None, Option::Some("block"), Option::Some(EMPTY_LIST |> as_js()))

pub ext fun ViewTimelineOptions::from_js(value: JsValue) -> mut ViewTimelineOptions = "
    const r = {};
    r.m_subject = #fun(Option::from_js[mut Element])(#var(value).subject);
    r.m_axis = #fun(Option::from_js[String])(#var(value).axis);
    r.m_inset = #fun(Option::from_js[JsValue])(#var(value).inset);
    return r;
"

pub ext fun ViewTimelineOptions::as_js(self: ViewTimelineOptions) -> JsValue = "
    const r = {};
    r.subject = #fun(Option::as_js_undef[mut Element])(#var(self).m_subject);
    r.axis = #fun(Option::as_js_undef[String])(#var(self).m_axis);
    r.inset = #fun(Option::as_js_undef[JsValue])(#var(self).m_inset);
    return r;
"

struct DataTransfer()

pub ext fun DataTransfer::new() -> mut DataTransfer
    = "return new DataTransfer();"

pub ext fun DataTransfer::drop_effect(self: DataTransfer) -> String
    = "return #fun(String::from_js)(#var(self).dropEffect);"

pub ext fun DataTransfer::set_drop_effect(self: mut DataTransfer, value: String)
    = "#var(self).dropEffect = #fun(String::as_js)(#var(value));"

pub ext fun DataTransfer::effect_allowed(self: DataTransfer) -> String
    = "return #fun(String::from_js)(#var(self).effectAllowed);"

pub ext fun DataTransfer::set_effect_allowed(self: mut DataTransfer, value: String)
    = "#var(self).effectAllowed = #fun(String::as_js)(#var(value));"

pub ext fun DataTransfer::items(self: DataTransfer) -> mut DataTransferItemList
    = "return #fun(DataTransferItemList::from_js)(#var(self).items);"

pub ext fun DataTransfer::types(self: DataTransfer) -> JsValue
    = "return #var(self).types;"

pub ext fun DataTransfer::files(self: DataTransfer) -> mut FileList
    = "return #fun(FileList::from_js)(#var(self).files);"

pub ext fun DataTransfer::set_drag_image(__self: mut DataTransfer, image: mut Element, x: Int, y: Int) -> Unit = "
    const r = #var(__self).setDragImage(#fun(Element::as_js)(#var(image)), #fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DataTransfer::get_data(__self: mut DataTransfer, format: String) -> String = "
    const r = #var(__self).getData(#fun(String::as_js)(#var(format)));
    return #fun(String::from_js)(r);
"

pub ext fun DataTransfer::set_data(__self: mut DataTransfer, format: String, data: String) -> Unit = "
    const r = #var(__self).setData(#fun(String::as_js)(#var(format)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DataTransfer::clear_data(__self: mut DataTransfer, format: String) -> Unit = "
    const r = #var(__self).clearData(#fun(String::as_js)(#var(format)));
    return #fun(Unit::from_js)(r);
"

pub fun DataTransfer::as_js(self: DataTransfer) -> JsValue = JsValue::unsafe_from[DataTransfer](self)

pub fun DataTransfer::from_js(v: JsValue) -> mut DataTransfer = JsValue::unsafe_as[mut DataTransfer](v)

struct DataTransferItem()

pub ext fun DataTransferItem::kind(self: DataTransferItem) -> String
    = "return #fun(String::from_js)(#var(self).kind);"

pub ext fun DataTransferItem::type(self: DataTransferItem) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun DataTransferItem::get_as_string(__self: mut DataTransferItem, callback: Option[Fun(String) -> Unit]) -> Unit = "
    const r = #var(__self).getAsString(#fun(Option::as_js[Fun(String) -> Unit])(#var(callback)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DataTransferItem::get_as_file(__self: mut DataTransferItem) -> Option[mut File] = "
    const r = #var(__self).getAsFile();
    return #fun(Option::from_js[mut File])(r);
"

pub fun DataTransferItem::as_js(self: DataTransferItem) -> JsValue = JsValue::unsafe_from[DataTransferItem](self)

pub fun DataTransferItem::from_js(v: JsValue) -> mut DataTransferItem = JsValue::unsafe_as[mut DataTransferItem](v)

struct DataTransferItemList()

pub ext fun DataTransferItemList::length(self: DataTransferItemList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun DataTransferItemList::get(__self: DataTransferItemList, index: Int) -> mut DataTransferItem = "
    const r = DataTransferItemList[#fun(Int::as_js)(#var(index))];
    return #fun(DataTransferItem::from_js)(r);
"

pub ext fun DataTransferItemList::add_str_str(__self: mut DataTransferItemList, data: String, type: String) -> Option[mut DataTransferItem] = "
    const r = #var(__self).add(#fun(String::as_js)(#var(data)), #fun(String::as_js)(#var(type)));
    return #fun(Option::from_js[mut DataTransferItem])(r);
"

pub ext fun DataTransferItemList::add_mfile(__self: mut DataTransferItemList, file: mut File) -> Option[mut DataTransferItem] = "
    const r = #var(__self).add(#fun(File::as_js)(#var(file)));
    return #fun(Option::from_js[mut DataTransferItem])(r);
"

pub ext fun DataTransferItemList::remove(__self: mut DataTransferItemList, index: Int) -> Unit = "
    const r = #var(__self).remove(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DataTransferItemList::clear(__self: mut DataTransferItemList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub fun DataTransferItemList::as_js(self: DataTransferItemList) -> JsValue = JsValue::unsafe_from[DataTransferItemList](self)

pub fun DataTransferItemList::from_js(v: JsValue) -> mut DataTransferItemList = JsValue::unsafe_as[mut DataTransferItemList](v)

// TODO: Definitions of type 'namespace'

struct CSSConditionRule()

/// Converts a reference to 'CSSConditionRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::as_css_grouping_rule(self: CSSConditionRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSConditionRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::as_mcss_grouping_rule(self: mut CSSConditionRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSConditionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSConditionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSConditionRule = "
    if(#var(base) instanceof CSSConditionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSConditionRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSConditionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSConditionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSConditionRule = "
    if(#var(base) instanceof CSSConditionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSConditionRule'!\");
"

/// Converts a reference to 'CSSConditionRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::as_css_rule(self: CSSConditionRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSConditionRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::as_mcss_rule(self: mut CSSConditionRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSConditionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSConditionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::from_css_rule(base: CSSRule) -> CSSConditionRule = "
    if(#var(base) instanceof CSSConditionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSConditionRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSConditionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSConditionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSConditionRule::from_mcss_rule(base: mut CSSRule) -> mut CSSConditionRule = "
    if(#var(base) instanceof CSSConditionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSConditionRule'!\");
"

pub ext fun CSSConditionRule::condition_text(self: CSSConditionRule) -> String
    = "return #fun(String::from_js)(#var(self).conditionText);"

pub ext fun CSSConditionRule::css_rules(self: CSSConditionRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSConditionRule::type(self: CSSConditionRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSConditionRule::css_text(self: CSSConditionRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSConditionRule::set_css_text(self: mut CSSConditionRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSConditionRule::parent_rule(self: CSSConditionRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSConditionRule::parent_style_sheet(self: CSSConditionRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSConditionRule::insert_rule(__self: mut CSSConditionRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSConditionRule::delete_rule(__self: mut CSSConditionRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSConditionRule::as_js(self: CSSConditionRule) -> JsValue = JsValue::unsafe_from[CSSConditionRule](self)

pub fun CSSConditionRule::from_js(v: JsValue) -> mut CSSConditionRule = JsValue::unsafe_as[mut CSSConditionRule](v)

pub val CSSConditionRule::style_rule: Int = 1
pub val CSSConditionRule::charset_rule: Int = 2
pub val CSSConditionRule::import_rule: Int = 3
pub val CSSConditionRule::media_rule: Int = 4
pub val CSSConditionRule::font_face_rule: Int = 5
pub val CSSConditionRule::page_rule: Int = 6
pub val CSSConditionRule::margin_rule: Int = 9
pub val CSSConditionRule::namespace_rule: Int = 10
pub val CSSConditionRule::keyframes_rule: Int = 7
pub val CSSConditionRule::keyframe_rule: Int = 8
pub val CSSConditionRule::counter_style_rule: Int = 11
pub val CSSConditionRule::font_feature_values_rule: Int = 14
pub val CSSConditionRule::supports_rule: Int = 12

struct CSSContainerRule()

/// Converts a reference to 'CSSContainerRule' to a reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_css_condition_rule(self: CSSContainerRule) -> CSSConditionRule = "return #var(self);"

/// Converts a mutable reference to 'CSSContainerRule' to a mutable reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_mcss_condition_rule(self: mut CSSContainerRule) -> mut CSSConditionRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSConditionRule' to a reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_css_condition_rule(base: CSSConditionRule) -> CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSContainerRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSConditionRule' to a mutable reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_mcss_condition_rule(base: mut CSSConditionRule) -> mut CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSContainerRule'!\");
"

/// Converts a reference to 'CSSContainerRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_css_grouping_rule(self: CSSContainerRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSContainerRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_mcss_grouping_rule(self: mut CSSContainerRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSContainerRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSContainerRule'!\");
"

/// Converts a reference to 'CSSContainerRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_css_rule(self: CSSContainerRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSContainerRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::as_mcss_rule(self: mut CSSContainerRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_css_rule(base: CSSRule) -> CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSContainerRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSContainerRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSContainerRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSContainerRule::from_mcss_rule(base: mut CSSRule) -> mut CSSContainerRule = "
    if(#var(base) instanceof CSSContainerRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSContainerRule'!\");
"

pub ext fun CSSContainerRule::container_name(self: CSSContainerRule) -> String
    = "return #fun(String::from_js)(#var(self).containerName);"

pub ext fun CSSContainerRule::container_query(self: CSSContainerRule) -> String
    = "return #fun(String::from_js)(#var(self).containerQuery);"

pub ext fun CSSContainerRule::condition_text(self: CSSContainerRule) -> String
    = "return #fun(String::from_js)(#var(self).conditionText);"

pub ext fun CSSContainerRule::css_rules(self: CSSContainerRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSContainerRule::type(self: CSSContainerRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSContainerRule::css_text(self: CSSContainerRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSContainerRule::set_css_text(self: mut CSSContainerRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSContainerRule::parent_rule(self: CSSContainerRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSContainerRule::parent_style_sheet(self: CSSContainerRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSContainerRule::insert_rule(__self: mut CSSContainerRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSContainerRule::delete_rule(__self: mut CSSContainerRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSContainerRule::as_js(self: CSSContainerRule) -> JsValue = JsValue::unsafe_from[CSSContainerRule](self)

pub fun CSSContainerRule::from_js(v: JsValue) -> mut CSSContainerRule = JsValue::unsafe_as[mut CSSContainerRule](v)

pub val CSSContainerRule::style_rule: Int = 1
pub val CSSContainerRule::charset_rule: Int = 2
pub val CSSContainerRule::import_rule: Int = 3
pub val CSSContainerRule::media_rule: Int = 4
pub val CSSContainerRule::font_face_rule: Int = 5
pub val CSSContainerRule::page_rule: Int = 6
pub val CSSContainerRule::margin_rule: Int = 9
pub val CSSContainerRule::namespace_rule: Int = 10
pub val CSSContainerRule::keyframes_rule: Int = 7
pub val CSSContainerRule::keyframe_rule: Int = 8
pub val CSSContainerRule::counter_style_rule: Int = 11
pub val CSSContainerRule::font_feature_values_rule: Int = 14
pub val CSSContainerRule::supports_rule: Int = 12

struct CSSCounterStyleRule()

/// Converts a reference to 'CSSCounterStyleRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSCounterStyleRule::as_css_rule(self: CSSCounterStyleRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSCounterStyleRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSCounterStyleRule::as_mcss_rule(self: mut CSSCounterStyleRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSCounterStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSCounterStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSCounterStyleRule::from_css_rule(base: CSSRule) -> CSSCounterStyleRule = "
    if(#var(base) instanceof CSSCounterStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSCounterStyleRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSCounterStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSCounterStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSCounterStyleRule::from_mcss_rule(base: mut CSSRule) -> mut CSSCounterStyleRule = "
    if(#var(base) instanceof CSSCounterStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSCounterStyleRule'!\");
"

pub ext fun CSSCounterStyleRule::name(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSCounterStyleRule::set_name(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::system(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).system);"

pub ext fun CSSCounterStyleRule::set_system(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).system = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::symbols(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).symbols);"

pub ext fun CSSCounterStyleRule::set_symbols(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).symbols = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::additive_symbols(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).additiveSymbols);"

pub ext fun CSSCounterStyleRule::set_additive_symbols(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).additiveSymbols = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::negative(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).negative);"

pub ext fun CSSCounterStyleRule::set_negative(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).negative = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::prefix(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).prefix);"

pub ext fun CSSCounterStyleRule::set_prefix(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).prefix = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::suffix(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).suffix);"

pub ext fun CSSCounterStyleRule::set_suffix(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).suffix = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::range(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).range);"

pub ext fun CSSCounterStyleRule::set_range(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).range = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::pad(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).pad);"

pub ext fun CSSCounterStyleRule::set_pad(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).pad = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::speak_as(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).speakAs);"

pub ext fun CSSCounterStyleRule::set_speak_as(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).speakAs = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::fallback(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).fallback);"

pub ext fun CSSCounterStyleRule::set_fallback(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).fallback = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::type(self: CSSCounterStyleRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSCounterStyleRule::css_text(self: CSSCounterStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSCounterStyleRule::set_css_text(self: mut CSSCounterStyleRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSCounterStyleRule::parent_rule(self: CSSCounterStyleRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSCounterStyleRule::parent_style_sheet(self: CSSCounterStyleRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSCounterStyleRule::as_js(self: CSSCounterStyleRule) -> JsValue = JsValue::unsafe_from[CSSCounterStyleRule](self)

pub fun CSSCounterStyleRule::from_js(v: JsValue) -> mut CSSCounterStyleRule = JsValue::unsafe_as[mut CSSCounterStyleRule](v)

pub val CSSCounterStyleRule::style_rule: Int = 1
pub val CSSCounterStyleRule::charset_rule: Int = 2
pub val CSSCounterStyleRule::import_rule: Int = 3
pub val CSSCounterStyleRule::media_rule: Int = 4
pub val CSSCounterStyleRule::font_face_rule: Int = 5
pub val CSSCounterStyleRule::page_rule: Int = 6
pub val CSSCounterStyleRule::margin_rule: Int = 9
pub val CSSCounterStyleRule::namespace_rule: Int = 10
pub val CSSCounterStyleRule::keyframes_rule: Int = 7
pub val CSSCounterStyleRule::keyframe_rule: Int = 8
pub val CSSCounterStyleRule::counter_style_rule: Int = 11
pub val CSSCounterStyleRule::font_feature_values_rule: Int = 14
pub val CSSCounterStyleRule::supports_rule: Int = 12

struct CSSFontFaceRule()

/// Converts a reference to 'CSSFontFaceRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFaceRule::as_css_rule(self: CSSFontFaceRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFontFaceRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFaceRule::as_mcss_rule(self: mut CSSFontFaceRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSFontFaceRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontFaceRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFaceRule::from_css_rule(base: CSSRule) -> CSSFontFaceRule = "
    if(#var(base) instanceof CSSFontFaceRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontFaceRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSFontFaceRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontFaceRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFaceRule::from_mcss_rule(base: mut CSSRule) -> mut CSSFontFaceRule = "
    if(#var(base) instanceof CSSFontFaceRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontFaceRule'!\");
"

pub ext fun CSSFontFaceRule::style(self: CSSFontFaceRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSFontFaceRule::type(self: CSSFontFaceRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSFontFaceRule::css_text(self: CSSFontFaceRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFontFaceRule::set_css_text(self: mut CSSFontFaceRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFontFaceRule::parent_rule(self: CSSFontFaceRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFontFaceRule::parent_style_sheet(self: CSSFontFaceRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSFontFaceRule::as_js(self: CSSFontFaceRule) -> JsValue = JsValue::unsafe_from[CSSFontFaceRule](self)

pub fun CSSFontFaceRule::from_js(v: JsValue) -> mut CSSFontFaceRule = JsValue::unsafe_as[mut CSSFontFaceRule](v)

pub val CSSFontFaceRule::style_rule: Int = 1
pub val CSSFontFaceRule::charset_rule: Int = 2
pub val CSSFontFaceRule::import_rule: Int = 3
pub val CSSFontFaceRule::media_rule: Int = 4
pub val CSSFontFaceRule::font_face_rule: Int = 5
pub val CSSFontFaceRule::page_rule: Int = 6
pub val CSSFontFaceRule::margin_rule: Int = 9
pub val CSSFontFaceRule::namespace_rule: Int = 10
pub val CSSFontFaceRule::keyframes_rule: Int = 7
pub val CSSFontFaceRule::keyframe_rule: Int = 8
pub val CSSFontFaceRule::counter_style_rule: Int = 11
pub val CSSFontFaceRule::font_feature_values_rule: Int = 14
pub val CSSFontFaceRule::supports_rule: Int = 12

struct CSSFontFeatureValuesRule()

/// Converts a reference to 'CSSFontFeatureValuesRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFeatureValuesRule::as_css_rule(self: CSSFontFeatureValuesRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFontFeatureValuesRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFeatureValuesRule::as_mcss_rule(self: mut CSSFontFeatureValuesRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSFontFeatureValuesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontFeatureValuesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFeatureValuesRule::from_css_rule(base: CSSRule) -> CSSFontFeatureValuesRule = "
    if(#var(base) instanceof CSSFontFeatureValuesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontFeatureValuesRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSFontFeatureValuesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontFeatureValuesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontFeatureValuesRule::from_mcss_rule(base: mut CSSRule) -> mut CSSFontFeatureValuesRule = "
    if(#var(base) instanceof CSSFontFeatureValuesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontFeatureValuesRule'!\");
"

pub ext fun CSSFontFeatureValuesRule::font_family(self: CSSFontFeatureValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).fontFamily);"

pub ext fun CSSFontFeatureValuesRule::set_font_family(self: mut CSSFontFeatureValuesRule, value: String)
    = "#var(self).fontFamily = #fun(String::as_js)(#var(value));"

pub ext fun CSSFontFeatureValuesRule::annotation(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).annotation);"

pub ext fun CSSFontFeatureValuesRule::ornaments(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).ornaments);"

pub ext fun CSSFontFeatureValuesRule::stylistic(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).stylistic);"

pub ext fun CSSFontFeatureValuesRule::swash(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).swash);"

pub ext fun CSSFontFeatureValuesRule::character_variant(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).characterVariant);"

pub ext fun CSSFontFeatureValuesRule::styleset(self: CSSFontFeatureValuesRule) -> mut CSSFontFeatureValuesMap
    = "return #fun(CSSFontFeatureValuesMap::from_js)(#var(self).styleset);"

pub ext fun CSSFontFeatureValuesRule::type(self: CSSFontFeatureValuesRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSFontFeatureValuesRule::css_text(self: CSSFontFeatureValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFontFeatureValuesRule::set_css_text(self: mut CSSFontFeatureValuesRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFontFeatureValuesRule::parent_rule(self: CSSFontFeatureValuesRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFontFeatureValuesRule::parent_style_sheet(self: CSSFontFeatureValuesRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSFontFeatureValuesRule::as_js(self: CSSFontFeatureValuesRule) -> JsValue = JsValue::unsafe_from[CSSFontFeatureValuesRule](self)

pub fun CSSFontFeatureValuesRule::from_js(v: JsValue) -> mut CSSFontFeatureValuesRule = JsValue::unsafe_as[mut CSSFontFeatureValuesRule](v)

pub val CSSFontFeatureValuesRule::style_rule: Int = 1
pub val CSSFontFeatureValuesRule::charset_rule: Int = 2
pub val CSSFontFeatureValuesRule::import_rule: Int = 3
pub val CSSFontFeatureValuesRule::media_rule: Int = 4
pub val CSSFontFeatureValuesRule::font_face_rule: Int = 5
pub val CSSFontFeatureValuesRule::page_rule: Int = 6
pub val CSSFontFeatureValuesRule::margin_rule: Int = 9
pub val CSSFontFeatureValuesRule::namespace_rule: Int = 10
pub val CSSFontFeatureValuesRule::keyframes_rule: Int = 7
pub val CSSFontFeatureValuesRule::keyframe_rule: Int = 8
pub val CSSFontFeatureValuesRule::counter_style_rule: Int = 11
pub val CSSFontFeatureValuesRule::font_feature_values_rule: Int = 14
pub val CSSFontFeatureValuesRule::supports_rule: Int = 12

struct CSSFontFeatureValuesMap()

pub ext fun CSSFontFeatureValuesMap::set(__self: mut CSSFontFeatureValuesMap, feature_value_name: String, values: JsValue) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(feature_value_name)), #var(values));
    return #fun(Unit::from_js)(r);
"

pub fun CSSFontFeatureValuesMap::as_js(self: CSSFontFeatureValuesMap) -> JsValue = JsValue::unsafe_from[CSSFontFeatureValuesMap](self)

pub fun CSSFontFeatureValuesMap::from_js(v: JsValue) -> mut CSSFontFeatureValuesMap = JsValue::unsafe_as[mut CSSFontFeatureValuesMap](v)

struct CSSFontPaletteValuesRule()

/// Converts a reference to 'CSSFontPaletteValuesRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontPaletteValuesRule::as_css_rule(self: CSSFontPaletteValuesRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFontPaletteValuesRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontPaletteValuesRule::as_mcss_rule(self: mut CSSFontPaletteValuesRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSFontPaletteValuesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontPaletteValuesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontPaletteValuesRule::from_css_rule(base: CSSRule) -> CSSFontPaletteValuesRule = "
    if(#var(base) instanceof CSSFontPaletteValuesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontPaletteValuesRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSFontPaletteValuesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFontPaletteValuesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFontPaletteValuesRule::from_mcss_rule(base: mut CSSRule) -> mut CSSFontPaletteValuesRule = "
    if(#var(base) instanceof CSSFontPaletteValuesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFontPaletteValuesRule'!\");
"

pub ext fun CSSFontPaletteValuesRule::name(self: CSSFontPaletteValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSFontPaletteValuesRule::font_family(self: CSSFontPaletteValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).fontFamily);"

pub ext fun CSSFontPaletteValuesRule::base_palette(self: CSSFontPaletteValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).basePalette);"

pub ext fun CSSFontPaletteValuesRule::override_colors(self: CSSFontPaletteValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).overrideColors);"

pub ext fun CSSFontPaletteValuesRule::type(self: CSSFontPaletteValuesRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSFontPaletteValuesRule::css_text(self: CSSFontPaletteValuesRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFontPaletteValuesRule::set_css_text(self: mut CSSFontPaletteValuesRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFontPaletteValuesRule::parent_rule(self: CSSFontPaletteValuesRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFontPaletteValuesRule::parent_style_sheet(self: CSSFontPaletteValuesRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSFontPaletteValuesRule::as_js(self: CSSFontPaletteValuesRule) -> JsValue = JsValue::unsafe_from[CSSFontPaletteValuesRule](self)

pub fun CSSFontPaletteValuesRule::from_js(v: JsValue) -> mut CSSFontPaletteValuesRule = JsValue::unsafe_as[mut CSSFontPaletteValuesRule](v)

pub val CSSFontPaletteValuesRule::style_rule: Int = 1
pub val CSSFontPaletteValuesRule::charset_rule: Int = 2
pub val CSSFontPaletteValuesRule::import_rule: Int = 3
pub val CSSFontPaletteValuesRule::media_rule: Int = 4
pub val CSSFontPaletteValuesRule::font_face_rule: Int = 5
pub val CSSFontPaletteValuesRule::page_rule: Int = 6
pub val CSSFontPaletteValuesRule::margin_rule: Int = 9
pub val CSSFontPaletteValuesRule::namespace_rule: Int = 10
pub val CSSFontPaletteValuesRule::keyframes_rule: Int = 7
pub val CSSFontPaletteValuesRule::keyframe_rule: Int = 8
pub val CSSFontPaletteValuesRule::counter_style_rule: Int = 11
pub val CSSFontPaletteValuesRule::font_feature_values_rule: Int = 14
pub val CSSFontPaletteValuesRule::supports_rule: Int = 12

struct CSSFunctionDeclarations()

/// Converts a reference to 'CSSFunctionDeclarations' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDeclarations::as_css_rule(self: CSSFunctionDeclarations) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFunctionDeclarations' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDeclarations::as_mcss_rule(self: mut CSSFunctionDeclarations) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSFunctionDeclarations'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionDeclarations' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDeclarations::from_css_rule(base: CSSRule) -> CSSFunctionDeclarations = "
    if(#var(base) instanceof CSSFunctionDeclarations) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFunctionDeclarations'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSFunctionDeclarations'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionDeclarations' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDeclarations::from_mcss_rule(base: mut CSSRule) -> mut CSSFunctionDeclarations = "
    if(#var(base) instanceof CSSFunctionDeclarations) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFunctionDeclarations'!\");
"

pub ext fun CSSFunctionDeclarations::style(self: CSSFunctionDeclarations) -> mut CSSFunctionDescriptors
    = "return #fun(CSSFunctionDescriptors::from_js)(#var(self).style);"

pub ext fun CSSFunctionDeclarations::type(self: CSSFunctionDeclarations) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSFunctionDeclarations::css_text(self: CSSFunctionDeclarations) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFunctionDeclarations::set_css_text(self: mut CSSFunctionDeclarations, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFunctionDeclarations::parent_rule(self: CSSFunctionDeclarations) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFunctionDeclarations::parent_style_sheet(self: CSSFunctionDeclarations) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSFunctionDeclarations::as_js(self: CSSFunctionDeclarations) -> JsValue = JsValue::unsafe_from[CSSFunctionDeclarations](self)

pub fun CSSFunctionDeclarations::from_js(v: JsValue) -> mut CSSFunctionDeclarations = JsValue::unsafe_as[mut CSSFunctionDeclarations](v)

pub val CSSFunctionDeclarations::style_rule: Int = 1
pub val CSSFunctionDeclarations::charset_rule: Int = 2
pub val CSSFunctionDeclarations::import_rule: Int = 3
pub val CSSFunctionDeclarations::media_rule: Int = 4
pub val CSSFunctionDeclarations::font_face_rule: Int = 5
pub val CSSFunctionDeclarations::page_rule: Int = 6
pub val CSSFunctionDeclarations::margin_rule: Int = 9
pub val CSSFunctionDeclarations::namespace_rule: Int = 10
pub val CSSFunctionDeclarations::keyframes_rule: Int = 7
pub val CSSFunctionDeclarations::keyframe_rule: Int = 8
pub val CSSFunctionDeclarations::counter_style_rule: Int = 11
pub val CSSFunctionDeclarations::font_feature_values_rule: Int = 14
pub val CSSFunctionDeclarations::supports_rule: Int = 12

struct CSSFunctionDescriptors()

/// Converts a reference to 'CSSFunctionDescriptors' to a reference to 'CSSStyleDeclaration'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDescriptors::as_css_style_declaration(self: CSSFunctionDescriptors) -> CSSStyleDeclaration = "return #var(self);"

/// Converts a mutable reference to 'CSSFunctionDescriptors' to a mutable reference to 'CSSStyleDeclaration'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDescriptors::as_mcss_style_declaration(self: mut CSSFunctionDescriptors) -> mut CSSStyleDeclaration = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleDeclaration' to a reference to 'CSSFunctionDescriptors'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionDescriptors' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDescriptors::from_css_style_declaration(base: CSSStyleDeclaration) -> CSSFunctionDescriptors = "
    if(#var(base) instanceof CSSFunctionDescriptors) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleDeclaration' to 'CSSFunctionDescriptors'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleDeclaration' to a mutable reference to 'CSSFunctionDescriptors'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionDescriptors' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionDescriptors::from_mcss_style_declaration(base: mut CSSStyleDeclaration) -> mut CSSFunctionDescriptors = "
    if(#var(base) instanceof CSSFunctionDescriptors) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleDeclaration' to 'CSSFunctionDescriptors'!\");
"

pub ext fun CSSFunctionDescriptors::result(self: CSSFunctionDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).result);"

pub ext fun CSSFunctionDescriptors::set_result(self: mut CSSFunctionDescriptors, value: String)
    = "#var(self).result = #fun(String::as_js)(#var(value));"

pub ext fun CSSFunctionDescriptors::css_text(self: CSSFunctionDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFunctionDescriptors::set_css_text(self: mut CSSFunctionDescriptors, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFunctionDescriptors::length(self: CSSFunctionDescriptors) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSFunctionDescriptors::parent_rule(self: CSSFunctionDescriptors) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFunctionDescriptors::css_float(self: CSSFunctionDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).cssFloat);"

pub ext fun CSSFunctionDescriptors::set_css_float(self: mut CSSFunctionDescriptors, value: String)
    = "#var(self).cssFloat = #fun(String::as_js)(#var(value));"

pub ext fun CSSFunctionDescriptors::item(__self: mut CSSFunctionDescriptors, index: Int) -> String = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::get_property_value(__self: mut CSSFunctionDescriptors, property: String) -> String = "
    const r = #var(__self).getPropertyValue(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::get_property_priority(__self: mut CSSFunctionDescriptors, property: String) -> String = "
    const r = #var(__self).getPropertyPriority(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::set_property(__self: mut CSSFunctionDescriptors, property: String, value: String, priority: String) -> Unit = "
    const r = #var(__self).setProperty(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(value)), #fun(String::as_js)(#var(priority)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::remove_property(__self: mut CSSFunctionDescriptors, property: String) -> String = "
    const r = #var(__self).removeProperty(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::get(__self: CSSFunctionDescriptors, name: String) -> String = "
    const r = CSSFunctionDescriptors[#fun(String::as_js)(#var(name))];
    return #fun(String::from_js)(r);
"

pub ext fun CSSFunctionDescriptors::set(__self: mut CSSFunctionDescriptors, property: String, property_value: JsValue) = "
    CSSFunctionDescriptors[#fun(String::as_js)(#var(property))] = #var(property_value);
"

pub ext fun CSSFunctionDescriptors::remove(__self: mut CSSFunctionDescriptors, property: String) = "
    delete CSSFunctionDescriptors[#fun(String::as_js)(#var(property))];
"

pub fun CSSFunctionDescriptors::as_js(self: CSSFunctionDescriptors) -> JsValue = JsValue::unsafe_from[CSSFunctionDescriptors](self)

pub fun CSSFunctionDescriptors::from_js(v: JsValue) -> mut CSSFunctionDescriptors = JsValue::unsafe_as[mut CSSFunctionDescriptors](v)

pub struct FunctionParameter(
    name: String,
    type: String,
    default_value: Option[String]
)

pub fun FunctionParameter::default(name: String, type: String) -> mut FunctionParameter
    = FunctionParameter(name, type, Option::None)

pub ext fun FunctionParameter::from_js(value: JsValue) -> mut FunctionParameter = "
    const r = {};
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_type = #fun(String::from_js)(#var(value).type);
    r.m_default_value = #fun(Option::from_js[String])(#var(value).defaultValue);
    return r;
"

pub ext fun FunctionParameter::as_js(self: FunctionParameter) -> JsValue = "
    const r = {};
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.type = #fun(String::as_js)(#var(self).m_type);
    r.defaultValue = #fun(Option::as_js_undef[String])(#var(self).m_default_value);
    return r;
"

struct CSSFunctionRule()

/// Converts a reference to 'CSSFunctionRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::as_css_grouping_rule(self: CSSFunctionRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFunctionRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::as_mcss_grouping_rule(self: mut CSSFunctionRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSFunctionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSFunctionRule = "
    if(#var(base) instanceof CSSFunctionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSFunctionRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSFunctionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSFunctionRule = "
    if(#var(base) instanceof CSSFunctionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSFunctionRule'!\");
"

/// Converts a reference to 'CSSFunctionRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::as_css_rule(self: CSSFunctionRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSFunctionRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::as_mcss_rule(self: mut CSSFunctionRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSFunctionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::from_css_rule(base: CSSRule) -> CSSFunctionRule = "
    if(#var(base) instanceof CSSFunctionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFunctionRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSFunctionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSFunctionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSFunctionRule::from_mcss_rule(base: mut CSSRule) -> mut CSSFunctionRule = "
    if(#var(base) instanceof CSSFunctionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSFunctionRule'!\");
"

pub ext fun CSSFunctionRule::name(self: CSSFunctionRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSFunctionRule::return_type(self: CSSFunctionRule) -> String
    = "return #fun(String::from_js)(#var(self).returnType);"

pub ext fun CSSFunctionRule::css_rules(self: CSSFunctionRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSFunctionRule::type(self: CSSFunctionRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSFunctionRule::css_text(self: CSSFunctionRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSFunctionRule::set_css_text(self: mut CSSFunctionRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSFunctionRule::parent_rule(self: CSSFunctionRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSFunctionRule::parent_style_sheet(self: CSSFunctionRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSFunctionRule::get_parameters(__self: mut CSSFunctionRule) -> List[mut FunctionParameter] = "
    const r = #var(__self).getParameters();
    return #fun(List::from_js[mut FunctionParameter])(r);
"

pub ext fun CSSFunctionRule::insert_rule(__self: mut CSSFunctionRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSFunctionRule::delete_rule(__self: mut CSSFunctionRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSFunctionRule::as_js(self: CSSFunctionRule) -> JsValue = JsValue::unsafe_from[CSSFunctionRule](self)

pub fun CSSFunctionRule::from_js(v: JsValue) -> mut CSSFunctionRule = JsValue::unsafe_as[mut CSSFunctionRule](v)

pub val CSSFunctionRule::style_rule: Int = 1
pub val CSSFunctionRule::charset_rule: Int = 2
pub val CSSFunctionRule::import_rule: Int = 3
pub val CSSFunctionRule::media_rule: Int = 4
pub val CSSFunctionRule::font_face_rule: Int = 5
pub val CSSFunctionRule::page_rule: Int = 6
pub val CSSFunctionRule::margin_rule: Int = 9
pub val CSSFunctionRule::namespace_rule: Int = 10
pub val CSSFunctionRule::keyframes_rule: Int = 7
pub val CSSFunctionRule::keyframe_rule: Int = 8
pub val CSSFunctionRule::counter_style_rule: Int = 11
pub val CSSFunctionRule::font_feature_values_rule: Int = 14
pub val CSSFunctionRule::supports_rule: Int = 12

struct CSSGroupingRule()

/// Converts a reference to 'CSSGroupingRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSGroupingRule::as_css_rule(self: CSSGroupingRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSGroupingRule::as_mcss_rule(self: mut CSSGroupingRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSGroupingRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSGroupingRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSGroupingRule::from_css_rule(base: CSSRule) -> CSSGroupingRule = "
    if(#var(base) instanceof CSSGroupingRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSGroupingRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSGroupingRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSGroupingRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSGroupingRule::from_mcss_rule(base: mut CSSRule) -> mut CSSGroupingRule = "
    if(#var(base) instanceof CSSGroupingRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSGroupingRule'!\");
"

pub ext fun CSSGroupingRule::css_rules(self: CSSGroupingRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSGroupingRule::type(self: CSSGroupingRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSGroupingRule::css_text(self: CSSGroupingRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSGroupingRule::set_css_text(self: mut CSSGroupingRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSGroupingRule::parent_rule(self: CSSGroupingRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSGroupingRule::parent_style_sheet(self: CSSGroupingRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSGroupingRule::insert_rule(__self: mut CSSGroupingRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSGroupingRule::delete_rule(__self: mut CSSGroupingRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSGroupingRule::as_js(self: CSSGroupingRule) -> JsValue = JsValue::unsafe_from[CSSGroupingRule](self)

pub fun CSSGroupingRule::from_js(v: JsValue) -> mut CSSGroupingRule = JsValue::unsafe_as[mut CSSGroupingRule](v)

pub val CSSGroupingRule::style_rule: Int = 1
pub val CSSGroupingRule::charset_rule: Int = 2
pub val CSSGroupingRule::import_rule: Int = 3
pub val CSSGroupingRule::media_rule: Int = 4
pub val CSSGroupingRule::font_face_rule: Int = 5
pub val CSSGroupingRule::page_rule: Int = 6
pub val CSSGroupingRule::margin_rule: Int = 9
pub val CSSGroupingRule::namespace_rule: Int = 10
pub val CSSGroupingRule::keyframes_rule: Int = 7
pub val CSSGroupingRule::keyframe_rule: Int = 8
pub val CSSGroupingRule::counter_style_rule: Int = 11
pub val CSSGroupingRule::font_feature_values_rule: Int = 14
pub val CSSGroupingRule::supports_rule: Int = 12

struct CSSImportRule()

/// Converts a reference to 'CSSImportRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImportRule::as_css_rule(self: CSSImportRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSImportRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImportRule::as_mcss_rule(self: mut CSSImportRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSImportRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSImportRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImportRule::from_css_rule(base: CSSRule) -> CSSImportRule = "
    if(#var(base) instanceof CSSImportRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSImportRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSImportRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSImportRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImportRule::from_mcss_rule(base: mut CSSRule) -> mut CSSImportRule = "
    if(#var(base) instanceof CSSImportRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSImportRule'!\");
"

pub ext fun CSSImportRule::href(self: CSSImportRule) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun CSSImportRule::media(self: CSSImportRule) -> mut MediaList
    = "return #fun(MediaList::from_js)(#var(self).media);"

pub ext fun CSSImportRule::style_sheet(self: CSSImportRule) -> mut CSSStyleSheet
    = "return #fun(CSSStyleSheet::from_js)(#var(self).styleSheet);"

pub ext fun CSSImportRule::layer_name(self: CSSImportRule) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).layerName);"

pub ext fun CSSImportRule::supports_text(self: CSSImportRule) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).supportsText);"

pub ext fun CSSImportRule::type(self: CSSImportRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSImportRule::css_text(self: CSSImportRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSImportRule::set_css_text(self: mut CSSImportRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSImportRule::parent_rule(self: CSSImportRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSImportRule::parent_style_sheet(self: CSSImportRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSImportRule::as_js(self: CSSImportRule) -> JsValue = JsValue::unsafe_from[CSSImportRule](self)

pub fun CSSImportRule::from_js(v: JsValue) -> mut CSSImportRule = JsValue::unsafe_as[mut CSSImportRule](v)

pub val CSSImportRule::style_rule: Int = 1
pub val CSSImportRule::charset_rule: Int = 2
pub val CSSImportRule::import_rule: Int = 3
pub val CSSImportRule::media_rule: Int = 4
pub val CSSImportRule::font_face_rule: Int = 5
pub val CSSImportRule::page_rule: Int = 6
pub val CSSImportRule::margin_rule: Int = 9
pub val CSSImportRule::namespace_rule: Int = 10
pub val CSSImportRule::keyframes_rule: Int = 7
pub val CSSImportRule::keyframe_rule: Int = 8
pub val CSSImportRule::counter_style_rule: Int = 11
pub val CSSImportRule::font_feature_values_rule: Int = 14
pub val CSSImportRule::supports_rule: Int = 12

struct CSSKeyframeRule()

/// Converts a reference to 'CSSKeyframeRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframeRule::as_css_rule(self: CSSKeyframeRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSKeyframeRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframeRule::as_mcss_rule(self: mut CSSKeyframeRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSKeyframeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeyframeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframeRule::from_css_rule(base: CSSRule) -> CSSKeyframeRule = "
    if(#var(base) instanceof CSSKeyframeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSKeyframeRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSKeyframeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeyframeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframeRule::from_mcss_rule(base: mut CSSRule) -> mut CSSKeyframeRule = "
    if(#var(base) instanceof CSSKeyframeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSKeyframeRule'!\");
"

pub ext fun CSSKeyframeRule::key_text(self: CSSKeyframeRule) -> String
    = "return #fun(String::from_js)(#var(self).keyText);"

pub ext fun CSSKeyframeRule::set_key_text(self: mut CSSKeyframeRule, value: String)
    = "#var(self).keyText = #fun(String::as_js)(#var(value));"

pub ext fun CSSKeyframeRule::style(self: CSSKeyframeRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSKeyframeRule::type(self: CSSKeyframeRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSKeyframeRule::css_text(self: CSSKeyframeRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSKeyframeRule::set_css_text(self: mut CSSKeyframeRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSKeyframeRule::parent_rule(self: CSSKeyframeRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSKeyframeRule::parent_style_sheet(self: CSSKeyframeRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSKeyframeRule::as_js(self: CSSKeyframeRule) -> JsValue = JsValue::unsafe_from[CSSKeyframeRule](self)

pub fun CSSKeyframeRule::from_js(v: JsValue) -> mut CSSKeyframeRule = JsValue::unsafe_as[mut CSSKeyframeRule](v)

pub val CSSKeyframeRule::style_rule: Int = 1
pub val CSSKeyframeRule::charset_rule: Int = 2
pub val CSSKeyframeRule::import_rule: Int = 3
pub val CSSKeyframeRule::media_rule: Int = 4
pub val CSSKeyframeRule::font_face_rule: Int = 5
pub val CSSKeyframeRule::page_rule: Int = 6
pub val CSSKeyframeRule::margin_rule: Int = 9
pub val CSSKeyframeRule::namespace_rule: Int = 10
pub val CSSKeyframeRule::keyframes_rule: Int = 7
pub val CSSKeyframeRule::keyframe_rule: Int = 8
pub val CSSKeyframeRule::counter_style_rule: Int = 11
pub val CSSKeyframeRule::font_feature_values_rule: Int = 14
pub val CSSKeyframeRule::supports_rule: Int = 12

struct CSSKeyframesRule()

/// Converts a reference to 'CSSKeyframesRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframesRule::as_css_rule(self: CSSKeyframesRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSKeyframesRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframesRule::as_mcss_rule(self: mut CSSKeyframesRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSKeyframesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeyframesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframesRule::from_css_rule(base: CSSRule) -> CSSKeyframesRule = "
    if(#var(base) instanceof CSSKeyframesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSKeyframesRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSKeyframesRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeyframesRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeyframesRule::from_mcss_rule(base: mut CSSRule) -> mut CSSKeyframesRule = "
    if(#var(base) instanceof CSSKeyframesRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSKeyframesRule'!\");
"

pub ext fun CSSKeyframesRule::name(self: CSSKeyframesRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSKeyframesRule::set_name(self: mut CSSKeyframesRule, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun CSSKeyframesRule::css_rules(self: CSSKeyframesRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSKeyframesRule::length(self: CSSKeyframesRule) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSKeyframesRule::type(self: CSSKeyframesRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSKeyframesRule::css_text(self: CSSKeyframesRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSKeyframesRule::set_css_text(self: mut CSSKeyframesRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSKeyframesRule::parent_rule(self: CSSKeyframesRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSKeyframesRule::parent_style_sheet(self: CSSKeyframesRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSKeyframesRule::get(__self: CSSKeyframesRule, index: Int) -> mut CSSKeyframeRule = "
    const r = CSSKeyframesRule[#fun(Int::as_js)(#var(index))];
    return #fun(CSSKeyframeRule::from_js)(r);
"

pub ext fun CSSKeyframesRule::append_rule(__self: mut CSSKeyframesRule, rule: String) -> Unit = "
    const r = #var(__self).appendRule(#fun(String::as_js)(#var(rule)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSKeyframesRule::delete_rule(__self: mut CSSKeyframesRule, select: String) -> Unit = "
    const r = #var(__self).deleteRule(#fun(String::as_js)(#var(select)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSKeyframesRule::find_rule(__self: mut CSSKeyframesRule, select: String) -> Option[mut CSSKeyframeRule] = "
    const r = #var(__self).findRule(#fun(String::as_js)(#var(select)));
    return #fun(Option::from_js[mut CSSKeyframeRule])(r);
"

pub fun CSSKeyframesRule::as_js(self: CSSKeyframesRule) -> JsValue = JsValue::unsafe_from[CSSKeyframesRule](self)

pub fun CSSKeyframesRule::from_js(v: JsValue) -> mut CSSKeyframesRule = JsValue::unsafe_as[mut CSSKeyframesRule](v)

pub val CSSKeyframesRule::style_rule: Int = 1
pub val CSSKeyframesRule::charset_rule: Int = 2
pub val CSSKeyframesRule::import_rule: Int = 3
pub val CSSKeyframesRule::media_rule: Int = 4
pub val CSSKeyframesRule::font_face_rule: Int = 5
pub val CSSKeyframesRule::page_rule: Int = 6
pub val CSSKeyframesRule::margin_rule: Int = 9
pub val CSSKeyframesRule::namespace_rule: Int = 10
pub val CSSKeyframesRule::keyframes_rule: Int = 7
pub val CSSKeyframesRule::keyframe_rule: Int = 8
pub val CSSKeyframesRule::counter_style_rule: Int = 11
pub val CSSKeyframesRule::font_feature_values_rule: Int = 14
pub val CSSKeyframesRule::supports_rule: Int = 12

struct CSSLayerBlockRule()

/// Converts a reference to 'CSSLayerBlockRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::as_css_grouping_rule(self: CSSLayerBlockRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSLayerBlockRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::as_mcss_grouping_rule(self: mut CSSLayerBlockRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSLayerBlockRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerBlockRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSLayerBlockRule = "
    if(#var(base) instanceof CSSLayerBlockRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSLayerBlockRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSLayerBlockRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerBlockRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSLayerBlockRule = "
    if(#var(base) instanceof CSSLayerBlockRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSLayerBlockRule'!\");
"

/// Converts a reference to 'CSSLayerBlockRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::as_css_rule(self: CSSLayerBlockRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSLayerBlockRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::as_mcss_rule(self: mut CSSLayerBlockRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSLayerBlockRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerBlockRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::from_css_rule(base: CSSRule) -> CSSLayerBlockRule = "
    if(#var(base) instanceof CSSLayerBlockRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSLayerBlockRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSLayerBlockRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerBlockRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerBlockRule::from_mcss_rule(base: mut CSSRule) -> mut CSSLayerBlockRule = "
    if(#var(base) instanceof CSSLayerBlockRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSLayerBlockRule'!\");
"

pub ext fun CSSLayerBlockRule::name(self: CSSLayerBlockRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSLayerBlockRule::css_rules(self: CSSLayerBlockRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSLayerBlockRule::type(self: CSSLayerBlockRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSLayerBlockRule::css_text(self: CSSLayerBlockRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSLayerBlockRule::set_css_text(self: mut CSSLayerBlockRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSLayerBlockRule::parent_rule(self: CSSLayerBlockRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSLayerBlockRule::parent_style_sheet(self: CSSLayerBlockRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSLayerBlockRule::insert_rule(__self: mut CSSLayerBlockRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSLayerBlockRule::delete_rule(__self: mut CSSLayerBlockRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSLayerBlockRule::as_js(self: CSSLayerBlockRule) -> JsValue = JsValue::unsafe_from[CSSLayerBlockRule](self)

pub fun CSSLayerBlockRule::from_js(v: JsValue) -> mut CSSLayerBlockRule = JsValue::unsafe_as[mut CSSLayerBlockRule](v)

pub val CSSLayerBlockRule::style_rule: Int = 1
pub val CSSLayerBlockRule::charset_rule: Int = 2
pub val CSSLayerBlockRule::import_rule: Int = 3
pub val CSSLayerBlockRule::media_rule: Int = 4
pub val CSSLayerBlockRule::font_face_rule: Int = 5
pub val CSSLayerBlockRule::page_rule: Int = 6
pub val CSSLayerBlockRule::margin_rule: Int = 9
pub val CSSLayerBlockRule::namespace_rule: Int = 10
pub val CSSLayerBlockRule::keyframes_rule: Int = 7
pub val CSSLayerBlockRule::keyframe_rule: Int = 8
pub val CSSLayerBlockRule::counter_style_rule: Int = 11
pub val CSSLayerBlockRule::font_feature_values_rule: Int = 14
pub val CSSLayerBlockRule::supports_rule: Int = 12

struct CSSLayerStatementRule()

/// Converts a reference to 'CSSLayerStatementRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerStatementRule::as_css_rule(self: CSSLayerStatementRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSLayerStatementRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerStatementRule::as_mcss_rule(self: mut CSSLayerStatementRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSLayerStatementRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerStatementRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerStatementRule::from_css_rule(base: CSSRule) -> CSSLayerStatementRule = "
    if(#var(base) instanceof CSSLayerStatementRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSLayerStatementRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSLayerStatementRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSLayerStatementRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSLayerStatementRule::from_mcss_rule(base: mut CSSRule) -> mut CSSLayerStatementRule = "
    if(#var(base) instanceof CSSLayerStatementRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSLayerStatementRule'!\");
"

pub ext fun CSSLayerStatementRule::name_list(self: CSSLayerStatementRule) -> JsValue
    = "return #var(self).nameList;"

pub ext fun CSSLayerStatementRule::type(self: CSSLayerStatementRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSLayerStatementRule::css_text(self: CSSLayerStatementRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSLayerStatementRule::set_css_text(self: mut CSSLayerStatementRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSLayerStatementRule::parent_rule(self: CSSLayerStatementRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSLayerStatementRule::parent_style_sheet(self: CSSLayerStatementRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSLayerStatementRule::as_js(self: CSSLayerStatementRule) -> JsValue = JsValue::unsafe_from[CSSLayerStatementRule](self)

pub fun CSSLayerStatementRule::from_js(v: JsValue) -> mut CSSLayerStatementRule = JsValue::unsafe_as[mut CSSLayerStatementRule](v)

pub val CSSLayerStatementRule::style_rule: Int = 1
pub val CSSLayerStatementRule::charset_rule: Int = 2
pub val CSSLayerStatementRule::import_rule: Int = 3
pub val CSSLayerStatementRule::media_rule: Int = 4
pub val CSSLayerStatementRule::font_face_rule: Int = 5
pub val CSSLayerStatementRule::page_rule: Int = 6
pub val CSSLayerStatementRule::margin_rule: Int = 9
pub val CSSLayerStatementRule::namespace_rule: Int = 10
pub val CSSLayerStatementRule::keyframes_rule: Int = 7
pub val CSSLayerStatementRule::keyframe_rule: Int = 8
pub val CSSLayerStatementRule::counter_style_rule: Int = 11
pub val CSSLayerStatementRule::font_feature_values_rule: Int = 14
pub val CSSLayerStatementRule::supports_rule: Int = 12

struct CSSMarginRule()

/// Converts a reference to 'CSSMarginRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMarginRule::as_css_rule(self: CSSMarginRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSMarginRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMarginRule::as_mcss_rule(self: mut CSSMarginRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSMarginRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMarginRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMarginRule::from_css_rule(base: CSSRule) -> CSSMarginRule = "
    if(#var(base) instanceof CSSMarginRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSMarginRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSMarginRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMarginRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMarginRule::from_mcss_rule(base: mut CSSRule) -> mut CSSMarginRule = "
    if(#var(base) instanceof CSSMarginRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSMarginRule'!\");
"

pub ext fun CSSMarginRule::name(self: CSSMarginRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSMarginRule::style(self: CSSMarginRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSMarginRule::type(self: CSSMarginRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSMarginRule::css_text(self: CSSMarginRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSMarginRule::set_css_text(self: mut CSSMarginRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSMarginRule::parent_rule(self: CSSMarginRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSMarginRule::parent_style_sheet(self: CSSMarginRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSMarginRule::as_js(self: CSSMarginRule) -> JsValue = JsValue::unsafe_from[CSSMarginRule](self)

pub fun CSSMarginRule::from_js(v: JsValue) -> mut CSSMarginRule = JsValue::unsafe_as[mut CSSMarginRule](v)

pub val CSSMarginRule::style_rule: Int = 1
pub val CSSMarginRule::charset_rule: Int = 2
pub val CSSMarginRule::import_rule: Int = 3
pub val CSSMarginRule::media_rule: Int = 4
pub val CSSMarginRule::font_face_rule: Int = 5
pub val CSSMarginRule::page_rule: Int = 6
pub val CSSMarginRule::margin_rule: Int = 9
pub val CSSMarginRule::namespace_rule: Int = 10
pub val CSSMarginRule::keyframes_rule: Int = 7
pub val CSSMarginRule::keyframe_rule: Int = 8
pub val CSSMarginRule::counter_style_rule: Int = 11
pub val CSSMarginRule::font_feature_values_rule: Int = 14
pub val CSSMarginRule::supports_rule: Int = 12

struct CSSMediaRule()

/// Converts a reference to 'CSSMediaRule' to a reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_css_condition_rule(self: CSSMediaRule) -> CSSConditionRule = "return #var(self);"

/// Converts a mutable reference to 'CSSMediaRule' to a mutable reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_mcss_condition_rule(self: mut CSSMediaRule) -> mut CSSConditionRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSConditionRule' to a reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_css_condition_rule(base: CSSConditionRule) -> CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSMediaRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSConditionRule' to a mutable reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_mcss_condition_rule(base: mut CSSConditionRule) -> mut CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSMediaRule'!\");
"

/// Converts a reference to 'CSSMediaRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_css_grouping_rule(self: CSSMediaRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSMediaRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_mcss_grouping_rule(self: mut CSSMediaRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSMediaRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSMediaRule'!\");
"

/// Converts a reference to 'CSSMediaRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_css_rule(self: CSSMediaRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSMediaRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::as_mcss_rule(self: mut CSSMediaRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_css_rule(base: CSSRule) -> CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSMediaRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSMediaRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMediaRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMediaRule::from_mcss_rule(base: mut CSSRule) -> mut CSSMediaRule = "
    if(#var(base) instanceof CSSMediaRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSMediaRule'!\");
"

pub ext fun CSSMediaRule::media(self: CSSMediaRule) -> mut MediaList
    = "return #fun(MediaList::from_js)(#var(self).media);"

pub ext fun CSSMediaRule::condition_text(self: CSSMediaRule) -> String
    = "return #fun(String::from_js)(#var(self).conditionText);"

pub ext fun CSSMediaRule::css_rules(self: CSSMediaRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSMediaRule::type(self: CSSMediaRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSMediaRule::css_text(self: CSSMediaRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSMediaRule::set_css_text(self: mut CSSMediaRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSMediaRule::parent_rule(self: CSSMediaRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSMediaRule::parent_style_sheet(self: CSSMediaRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSMediaRule::insert_rule(__self: mut CSSMediaRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSMediaRule::delete_rule(__self: mut CSSMediaRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSMediaRule::as_js(self: CSSMediaRule) -> JsValue = JsValue::unsafe_from[CSSMediaRule](self)

pub fun CSSMediaRule::from_js(v: JsValue) -> mut CSSMediaRule = JsValue::unsafe_as[mut CSSMediaRule](v)

pub val CSSMediaRule::style_rule: Int = 1
pub val CSSMediaRule::charset_rule: Int = 2
pub val CSSMediaRule::import_rule: Int = 3
pub val CSSMediaRule::media_rule: Int = 4
pub val CSSMediaRule::font_face_rule: Int = 5
pub val CSSMediaRule::page_rule: Int = 6
pub val CSSMediaRule::margin_rule: Int = 9
pub val CSSMediaRule::namespace_rule: Int = 10
pub val CSSMediaRule::keyframes_rule: Int = 7
pub val CSSMediaRule::keyframe_rule: Int = 8
pub val CSSMediaRule::counter_style_rule: Int = 11
pub val CSSMediaRule::font_feature_values_rule: Int = 14
pub val CSSMediaRule::supports_rule: Int = 12

struct CSSNamespaceRule()

/// Converts a reference to 'CSSNamespaceRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNamespaceRule::as_css_rule(self: CSSNamespaceRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSNamespaceRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNamespaceRule::as_mcss_rule(self: mut CSSNamespaceRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSNamespaceRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNamespaceRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNamespaceRule::from_css_rule(base: CSSRule) -> CSSNamespaceRule = "
    if(#var(base) instanceof CSSNamespaceRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNamespaceRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSNamespaceRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNamespaceRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNamespaceRule::from_mcss_rule(base: mut CSSRule) -> mut CSSNamespaceRule = "
    if(#var(base) instanceof CSSNamespaceRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNamespaceRule'!\");
"

pub ext fun CSSNamespaceRule::namespace_uri(self: CSSNamespaceRule) -> String
    = "return #fun(String::from_js)(#var(self).namespaceURI);"

pub ext fun CSSNamespaceRule::prefix(self: CSSNamespaceRule) -> String
    = "return #fun(String::from_js)(#var(self).prefix);"

pub ext fun CSSNamespaceRule::type(self: CSSNamespaceRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSNamespaceRule::css_text(self: CSSNamespaceRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSNamespaceRule::set_css_text(self: mut CSSNamespaceRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSNamespaceRule::parent_rule(self: CSSNamespaceRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSNamespaceRule::parent_style_sheet(self: CSSNamespaceRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSNamespaceRule::as_js(self: CSSNamespaceRule) -> JsValue = JsValue::unsafe_from[CSSNamespaceRule](self)

pub fun CSSNamespaceRule::from_js(v: JsValue) -> mut CSSNamespaceRule = JsValue::unsafe_as[mut CSSNamespaceRule](v)

pub val CSSNamespaceRule::style_rule: Int = 1
pub val CSSNamespaceRule::charset_rule: Int = 2
pub val CSSNamespaceRule::import_rule: Int = 3
pub val CSSNamespaceRule::media_rule: Int = 4
pub val CSSNamespaceRule::font_face_rule: Int = 5
pub val CSSNamespaceRule::page_rule: Int = 6
pub val CSSNamespaceRule::margin_rule: Int = 9
pub val CSSNamespaceRule::namespace_rule: Int = 10
pub val CSSNamespaceRule::keyframes_rule: Int = 7
pub val CSSNamespaceRule::keyframe_rule: Int = 8
pub val CSSNamespaceRule::counter_style_rule: Int = 11
pub val CSSNamespaceRule::font_feature_values_rule: Int = 14
pub val CSSNamespaceRule::supports_rule: Int = 12

struct CSSNestedDeclarations()

/// Converts a reference to 'CSSNestedDeclarations' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarations::as_css_rule(self: CSSNestedDeclarations) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSNestedDeclarations' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarations::as_mcss_rule(self: mut CSSNestedDeclarations) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSNestedDeclarations'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNestedDeclarations' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarations::from_css_rule(base: CSSRule) -> CSSNestedDeclarations = "
    if(#var(base) instanceof CSSNestedDeclarations) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNestedDeclarations'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSNestedDeclarations'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNestedDeclarations' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarations::from_mcss_rule(base: mut CSSRule) -> mut CSSNestedDeclarations = "
    if(#var(base) instanceof CSSNestedDeclarations) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNestedDeclarations'!\");
"

pub ext fun CSSNestedDeclarations::style(self: CSSNestedDeclarations) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSNestedDeclarations::type(self: CSSNestedDeclarations) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSNestedDeclarations::css_text(self: CSSNestedDeclarations) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSNestedDeclarations::set_css_text(self: mut CSSNestedDeclarations, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSNestedDeclarations::parent_rule(self: CSSNestedDeclarations) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSNestedDeclarations::parent_style_sheet(self: CSSNestedDeclarations) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSNestedDeclarations::as_js(self: CSSNestedDeclarations) -> JsValue = JsValue::unsafe_from[CSSNestedDeclarations](self)

pub fun CSSNestedDeclarations::from_js(v: JsValue) -> mut CSSNestedDeclarations = JsValue::unsafe_as[mut CSSNestedDeclarations](v)

pub val CSSNestedDeclarations::style_rule: Int = 1
pub val CSSNestedDeclarations::charset_rule: Int = 2
pub val CSSNestedDeclarations::import_rule: Int = 3
pub val CSSNestedDeclarations::media_rule: Int = 4
pub val CSSNestedDeclarations::font_face_rule: Int = 5
pub val CSSNestedDeclarations::page_rule: Int = 6
pub val CSSNestedDeclarations::margin_rule: Int = 9
pub val CSSNestedDeclarations::namespace_rule: Int = 10
pub val CSSNestedDeclarations::keyframes_rule: Int = 7
pub val CSSNestedDeclarations::keyframe_rule: Int = 8
pub val CSSNestedDeclarations::counter_style_rule: Int = 11
pub val CSSNestedDeclarations::font_feature_values_rule: Int = 14
pub val CSSNestedDeclarations::supports_rule: Int = 12

struct CSSNestedDeclarationsRule()

/// Converts a reference to 'CSSNestedDeclarationsRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarationsRule::as_css_rule(self: CSSNestedDeclarationsRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSNestedDeclarationsRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarationsRule::as_mcss_rule(self: mut CSSNestedDeclarationsRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSNestedDeclarationsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNestedDeclarationsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarationsRule::from_css_rule(base: CSSRule) -> CSSNestedDeclarationsRule = "
    if(#var(base) instanceof CSSNestedDeclarationsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNestedDeclarationsRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSNestedDeclarationsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNestedDeclarationsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNestedDeclarationsRule::from_mcss_rule(base: mut CSSRule) -> mut CSSNestedDeclarationsRule = "
    if(#var(base) instanceof CSSNestedDeclarationsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSNestedDeclarationsRule'!\");
"

pub ext fun CSSNestedDeclarationsRule::selector_text(self: CSSNestedDeclarationsRule) -> String
    = "return #fun(String::from_js)(#var(self).selectorText);"

pub ext fun CSSNestedDeclarationsRule::set_selector_text(self: mut CSSNestedDeclarationsRule, value: String)
    = "#var(self).selectorText = #fun(String::as_js)(#var(value));"

pub ext fun CSSNestedDeclarationsRule::style(self: CSSNestedDeclarationsRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSNestedDeclarationsRule::style_map(self: CSSNestedDeclarationsRule) -> mut StylePropertyMap
    = "return #fun(StylePropertyMap::from_js)(#var(self).styleMap);"

pub ext fun CSSNestedDeclarationsRule::type(self: CSSNestedDeclarationsRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSNestedDeclarationsRule::css_text(self: CSSNestedDeclarationsRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSNestedDeclarationsRule::set_css_text(self: mut CSSNestedDeclarationsRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSNestedDeclarationsRule::parent_rule(self: CSSNestedDeclarationsRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSNestedDeclarationsRule::parent_style_sheet(self: CSSNestedDeclarationsRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSNestedDeclarationsRule::as_js(self: CSSNestedDeclarationsRule) -> JsValue = JsValue::unsafe_from[CSSNestedDeclarationsRule](self)

pub fun CSSNestedDeclarationsRule::from_js(v: JsValue) -> mut CSSNestedDeclarationsRule = JsValue::unsafe_as[mut CSSNestedDeclarationsRule](v)

pub val CSSNestedDeclarationsRule::style_rule: Int = 1
pub val CSSNestedDeclarationsRule::charset_rule: Int = 2
pub val CSSNestedDeclarationsRule::import_rule: Int = 3
pub val CSSNestedDeclarationsRule::media_rule: Int = 4
pub val CSSNestedDeclarationsRule::font_face_rule: Int = 5
pub val CSSNestedDeclarationsRule::page_rule: Int = 6
pub val CSSNestedDeclarationsRule::margin_rule: Int = 9
pub val CSSNestedDeclarationsRule::namespace_rule: Int = 10
pub val CSSNestedDeclarationsRule::keyframes_rule: Int = 7
pub val CSSNestedDeclarationsRule::keyframe_rule: Int = 8
pub val CSSNestedDeclarationsRule::counter_style_rule: Int = 11
pub val CSSNestedDeclarationsRule::font_feature_values_rule: Int = 14
pub val CSSNestedDeclarationsRule::supports_rule: Int = 12

struct CSSPageRule()

/// Converts a reference to 'CSSPageRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::as_css_grouping_rule(self: CSSPageRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSPageRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::as_mcss_grouping_rule(self: mut CSSPageRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSPageRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPageRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSPageRule = "
    if(#var(base) instanceof CSSPageRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSPageRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSPageRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPageRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSPageRule = "
    if(#var(base) instanceof CSSPageRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSPageRule'!\");
"

/// Converts a reference to 'CSSPageRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::as_css_rule(self: CSSPageRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSPageRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::as_mcss_rule(self: mut CSSPageRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSPageRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPageRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::from_css_rule(base: CSSRule) -> CSSPageRule = "
    if(#var(base) instanceof CSSPageRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPageRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSPageRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPageRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPageRule::from_mcss_rule(base: mut CSSRule) -> mut CSSPageRule = "
    if(#var(base) instanceof CSSPageRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPageRule'!\");
"

pub ext fun CSSPageRule::selector_text(self: CSSPageRule) -> String
    = "return #fun(String::from_js)(#var(self).selectorText);"

pub ext fun CSSPageRule::set_selector_text(self: mut CSSPageRule, value: String)
    = "#var(self).selectorText = #fun(String::as_js)(#var(value));"

pub ext fun CSSPageRule::style(self: CSSPageRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSPageRule::css_rules(self: CSSPageRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSPageRule::type(self: CSSPageRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSPageRule::css_text(self: CSSPageRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSPageRule::set_css_text(self: mut CSSPageRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSPageRule::parent_rule(self: CSSPageRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSPageRule::parent_style_sheet(self: CSSPageRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSPageRule::insert_rule(__self: mut CSSPageRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSPageRule::delete_rule(__self: mut CSSPageRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSPageRule::as_js(self: CSSPageRule) -> JsValue = JsValue::unsafe_from[CSSPageRule](self)

pub fun CSSPageRule::from_js(v: JsValue) -> mut CSSPageRule = JsValue::unsafe_as[mut CSSPageRule](v)

pub val CSSPageRule::style_rule: Int = 1
pub val CSSPageRule::charset_rule: Int = 2
pub val CSSPageRule::import_rule: Int = 3
pub val CSSPageRule::media_rule: Int = 4
pub val CSSPageRule::font_face_rule: Int = 5
pub val CSSPageRule::page_rule: Int = 6
pub val CSSPageRule::margin_rule: Int = 9
pub val CSSPageRule::namespace_rule: Int = 10
pub val CSSPageRule::keyframes_rule: Int = 7
pub val CSSPageRule::keyframe_rule: Int = 8
pub val CSSPageRule::counter_style_rule: Int = 11
pub val CSSPageRule::font_feature_values_rule: Int = 14
pub val CSSPageRule::supports_rule: Int = 12

struct CSSPositionTryDescriptors()

/// Converts a reference to 'CSSPositionTryDescriptors' to a reference to 'CSSStyleDeclaration'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryDescriptors::as_css_style_declaration(self: CSSPositionTryDescriptors) -> CSSStyleDeclaration = "return #var(self);"

/// Converts a mutable reference to 'CSSPositionTryDescriptors' to a mutable reference to 'CSSStyleDeclaration'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryDescriptors::as_mcss_style_declaration(self: mut CSSPositionTryDescriptors) -> mut CSSStyleDeclaration = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleDeclaration' to a reference to 'CSSPositionTryDescriptors'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionTryDescriptors' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryDescriptors::from_css_style_declaration(base: CSSStyleDeclaration) -> CSSPositionTryDescriptors = "
    if(#var(base) instanceof CSSPositionTryDescriptors) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleDeclaration' to 'CSSPositionTryDescriptors'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleDeclaration' to a mutable reference to 'CSSPositionTryDescriptors'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionTryDescriptors' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryDescriptors::from_mcss_style_declaration(base: mut CSSStyleDeclaration) -> mut CSSPositionTryDescriptors = "
    if(#var(base) instanceof CSSPositionTryDescriptors) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleDeclaration' to 'CSSPositionTryDescriptors'!\");
"

pub ext fun CSSPositionTryDescriptors::margin(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).margin);"

pub ext fun CSSPositionTryDescriptors::set_margin(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).margin = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_top(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginTop);"

pub ext fun CSSPositionTryDescriptors::set_margin_top(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginTop = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_right(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginRight);"

pub ext fun CSSPositionTryDescriptors::set_margin_right(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginRight = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_bottom(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginBottom);"

pub ext fun CSSPositionTryDescriptors::set_margin_bottom(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginBottom = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_left(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginLeft);"

pub ext fun CSSPositionTryDescriptors::set_margin_left(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginLeft = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_block(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginBlock);"

pub ext fun CSSPositionTryDescriptors::set_margin_block(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginBlock = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_block_start(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginBlockStart);"

pub ext fun CSSPositionTryDescriptors::set_margin_block_start(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginBlockStart = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_block_end(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginBlockEnd);"

pub ext fun CSSPositionTryDescriptors::set_margin_block_end(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginBlockEnd = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_inline(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginInline);"

pub ext fun CSSPositionTryDescriptors::set_margin_inline(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginInline = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_inline_start(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginInlineStart);"

pub ext fun CSSPositionTryDescriptors::set_margin_inline_start(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginInlineStart = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::margin_inline_end(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).marginInlineEnd);"

pub ext fun CSSPositionTryDescriptors::set_margin_inline_end(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).marginInlineEnd = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).inset);"

pub ext fun CSSPositionTryDescriptors::set_inset(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).inset = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_block(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetBlock);"

pub ext fun CSSPositionTryDescriptors::set_inset_block(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetBlock = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_block_start(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetBlockStart);"

pub ext fun CSSPositionTryDescriptors::set_inset_block_start(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetBlockStart = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_block_end(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetBlockEnd);"

pub ext fun CSSPositionTryDescriptors::set_inset_block_end(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetBlockEnd = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_inline(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetInline);"

pub ext fun CSSPositionTryDescriptors::set_inset_inline(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetInline = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_inline_start(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetInlineStart);"

pub ext fun CSSPositionTryDescriptors::set_inset_inline_start(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetInlineStart = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inset_inline_end(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).insetInlineEnd);"

pub ext fun CSSPositionTryDescriptors::set_inset_inline_end(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).insetInlineEnd = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::top(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).top);"

pub ext fun CSSPositionTryDescriptors::set_top(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).top = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::left(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).left);"

pub ext fun CSSPositionTryDescriptors::set_left(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).left = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::right(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).right);"

pub ext fun CSSPositionTryDescriptors::set_right(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).right = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::bottom(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).bottom);"

pub ext fun CSSPositionTryDescriptors::set_bottom(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).bottom = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::width(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun CSSPositionTryDescriptors::set_width(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::min_width(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).minWidth);"

pub ext fun CSSPositionTryDescriptors::set_min_width(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).minWidth = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::max_width(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).maxWidth);"

pub ext fun CSSPositionTryDescriptors::set_max_width(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).maxWidth = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::height(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun CSSPositionTryDescriptors::set_height(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::min_height(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).minHeight);"

pub ext fun CSSPositionTryDescriptors::set_min_height(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).minHeight = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::max_height(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).maxHeight);"

pub ext fun CSSPositionTryDescriptors::set_max_height(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).maxHeight = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::block_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).blockSize);"

pub ext fun CSSPositionTryDescriptors::set_block_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).blockSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::min_block_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).minBlockSize);"

pub ext fun CSSPositionTryDescriptors::set_min_block_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).minBlockSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::max_block_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).maxBlockSize);"

pub ext fun CSSPositionTryDescriptors::set_max_block_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).maxBlockSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::inline_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).inlineSize);"

pub ext fun CSSPositionTryDescriptors::set_inline_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).inlineSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::min_inline_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).minInlineSize);"

pub ext fun CSSPositionTryDescriptors::set_min_inline_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).minInlineSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::max_inline_size(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).maxInlineSize);"

pub ext fun CSSPositionTryDescriptors::set_max_inline_size(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).maxInlineSize = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::place_self(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).placeSelf);"

pub ext fun CSSPositionTryDescriptors::set_place_self(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).placeSelf = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::align_self(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).alignSelf);"

pub ext fun CSSPositionTryDescriptors::set_align_self(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).alignSelf = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::justify_self(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).justifySelf);"

pub ext fun CSSPositionTryDescriptors::set_justify_self(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).justifySelf = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::position_anchor(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).positionAnchor);"

pub ext fun CSSPositionTryDescriptors::set_position_anchor(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).positionAnchor = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::position_area(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).positionArea);"

pub ext fun CSSPositionTryDescriptors::set_position_area(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).positionArea = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::css_text(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSPositionTryDescriptors::set_css_text(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::length(self: CSSPositionTryDescriptors) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSPositionTryDescriptors::parent_rule(self: CSSPositionTryDescriptors) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSPositionTryDescriptors::css_float(self: CSSPositionTryDescriptors) -> String
    = "return #fun(String::from_js)(#var(self).cssFloat);"

pub ext fun CSSPositionTryDescriptors::set_css_float(self: mut CSSPositionTryDescriptors, value: String)
    = "#var(self).cssFloat = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryDescriptors::item(__self: mut CSSPositionTryDescriptors, index: Int) -> String = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::get_property_value(__self: mut CSSPositionTryDescriptors, property: String) -> String = "
    const r = #var(__self).getPropertyValue(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::get_property_priority(__self: mut CSSPositionTryDescriptors, property: String) -> String = "
    const r = #var(__self).getPropertyPriority(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::set_property(__self: mut CSSPositionTryDescriptors, property: String, value: String, priority: String) -> Unit = "
    const r = #var(__self).setProperty(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(value)), #fun(String::as_js)(#var(priority)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::remove_property(__self: mut CSSPositionTryDescriptors, property: String) -> String = "
    const r = #var(__self).removeProperty(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::get(__self: CSSPositionTryDescriptors, name: String) -> String = "
    const r = CSSPositionTryDescriptors[#fun(String::as_js)(#var(name))];
    return #fun(String::from_js)(r);
"

pub ext fun CSSPositionTryDescriptors::set(__self: mut CSSPositionTryDescriptors, property: String, property_value: JsValue) = "
    CSSPositionTryDescriptors[#fun(String::as_js)(#var(property))] = #var(property_value);
"

pub ext fun CSSPositionTryDescriptors::remove(__self: mut CSSPositionTryDescriptors, property: String) = "
    delete CSSPositionTryDescriptors[#fun(String::as_js)(#var(property))];
"

pub fun CSSPositionTryDescriptors::as_js(self: CSSPositionTryDescriptors) -> JsValue = JsValue::unsafe_from[CSSPositionTryDescriptors](self)

pub fun CSSPositionTryDescriptors::from_js(v: JsValue) -> mut CSSPositionTryDescriptors = JsValue::unsafe_as[mut CSSPositionTryDescriptors](v)

struct CSSPositionTryRule()

/// Converts a reference to 'CSSPositionTryRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryRule::as_css_rule(self: CSSPositionTryRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSPositionTryRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryRule::as_mcss_rule(self: mut CSSPositionTryRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSPositionTryRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionTryRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryRule::from_css_rule(base: CSSRule) -> CSSPositionTryRule = "
    if(#var(base) instanceof CSSPositionTryRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPositionTryRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSPositionTryRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionTryRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionTryRule::from_mcss_rule(base: mut CSSRule) -> mut CSSPositionTryRule = "
    if(#var(base) instanceof CSSPositionTryRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPositionTryRule'!\");
"

pub ext fun CSSPositionTryRule::name(self: CSSPositionTryRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSPositionTryRule::style(self: CSSPositionTryRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSPositionTryRule::type(self: CSSPositionTryRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSPositionTryRule::css_text(self: CSSPositionTryRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSPositionTryRule::set_css_text(self: mut CSSPositionTryRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSPositionTryRule::parent_rule(self: CSSPositionTryRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSPositionTryRule::parent_style_sheet(self: CSSPositionTryRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSPositionTryRule::as_js(self: CSSPositionTryRule) -> JsValue = JsValue::unsafe_from[CSSPositionTryRule](self)

pub fun CSSPositionTryRule::from_js(v: JsValue) -> mut CSSPositionTryRule = JsValue::unsafe_as[mut CSSPositionTryRule](v)

pub val CSSPositionTryRule::style_rule: Int = 1
pub val CSSPositionTryRule::charset_rule: Int = 2
pub val CSSPositionTryRule::import_rule: Int = 3
pub val CSSPositionTryRule::media_rule: Int = 4
pub val CSSPositionTryRule::font_face_rule: Int = 5
pub val CSSPositionTryRule::page_rule: Int = 6
pub val CSSPositionTryRule::margin_rule: Int = 9
pub val CSSPositionTryRule::namespace_rule: Int = 10
pub val CSSPositionTryRule::keyframes_rule: Int = 7
pub val CSSPositionTryRule::keyframe_rule: Int = 8
pub val CSSPositionTryRule::counter_style_rule: Int = 11
pub val CSSPositionTryRule::font_feature_values_rule: Int = 14
pub val CSSPositionTryRule::supports_rule: Int = 12

struct CSSPropertyRule()

/// Converts a reference to 'CSSPropertyRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPropertyRule::as_css_rule(self: CSSPropertyRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSPropertyRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPropertyRule::as_mcss_rule(self: mut CSSPropertyRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSPropertyRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPropertyRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPropertyRule::from_css_rule(base: CSSRule) -> CSSPropertyRule = "
    if(#var(base) instanceof CSSPropertyRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPropertyRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSPropertyRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPropertyRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPropertyRule::from_mcss_rule(base: mut CSSRule) -> mut CSSPropertyRule = "
    if(#var(base) instanceof CSSPropertyRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSPropertyRule'!\");
"

pub ext fun CSSPropertyRule::name(self: CSSPropertyRule) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun CSSPropertyRule::syntax(self: CSSPropertyRule) -> String
    = "return #fun(String::from_js)(#var(self).syntax);"

pub ext fun CSSPropertyRule::inherits(self: CSSPropertyRule) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inherits);"

pub ext fun CSSPropertyRule::initial_value(self: CSSPropertyRule) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).initialValue);"

pub ext fun CSSPropertyRule::type(self: CSSPropertyRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSPropertyRule::css_text(self: CSSPropertyRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSPropertyRule::set_css_text(self: mut CSSPropertyRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSPropertyRule::parent_rule(self: CSSPropertyRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSPropertyRule::parent_style_sheet(self: CSSPropertyRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSPropertyRule::as_js(self: CSSPropertyRule) -> JsValue = JsValue::unsafe_from[CSSPropertyRule](self)

pub fun CSSPropertyRule::from_js(v: JsValue) -> mut CSSPropertyRule = JsValue::unsafe_as[mut CSSPropertyRule](v)

pub val CSSPropertyRule::style_rule: Int = 1
pub val CSSPropertyRule::charset_rule: Int = 2
pub val CSSPropertyRule::import_rule: Int = 3
pub val CSSPropertyRule::media_rule: Int = 4
pub val CSSPropertyRule::font_face_rule: Int = 5
pub val CSSPropertyRule::page_rule: Int = 6
pub val CSSPropertyRule::margin_rule: Int = 9
pub val CSSPropertyRule::namespace_rule: Int = 10
pub val CSSPropertyRule::keyframes_rule: Int = 7
pub val CSSPropertyRule::keyframe_rule: Int = 8
pub val CSSPropertyRule::counter_style_rule: Int = 11
pub val CSSPropertyRule::font_feature_values_rule: Int = 14
pub val CSSPropertyRule::supports_rule: Int = 12

struct CSSRule()

pub ext fun CSSRule::type(self: CSSRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSRule::css_text(self: CSSRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSRule::set_css_text(self: mut CSSRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSRule::parent_rule(self: CSSRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSRule::parent_style_sheet(self: CSSRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSRule::as_js(self: CSSRule) -> JsValue = JsValue::unsafe_from[CSSRule](self)

pub fun CSSRule::from_js(v: JsValue) -> mut CSSRule = JsValue::unsafe_as[mut CSSRule](v)

pub val CSSRule::style_rule: Int = 1
pub val CSSRule::charset_rule: Int = 2
pub val CSSRule::import_rule: Int = 3
pub val CSSRule::media_rule: Int = 4
pub val CSSRule::font_face_rule: Int = 5
pub val CSSRule::page_rule: Int = 6
pub val CSSRule::margin_rule: Int = 9
pub val CSSRule::namespace_rule: Int = 10
pub val CSSRule::keyframes_rule: Int = 7
pub val CSSRule::keyframe_rule: Int = 8
pub val CSSRule::counter_style_rule: Int = 11
pub val CSSRule::font_feature_values_rule: Int = 14
pub val CSSRule::supports_rule: Int = 12

struct CSSRuleList()

pub ext fun CSSRuleList::length(self: CSSRuleList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSRuleList::item(__self: mut CSSRuleList, index: Int) -> Option[mut CSSRule] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut CSSRule])(r);
"

pub fun CSSRuleList::as_js(self: CSSRuleList) -> JsValue = JsValue::unsafe_from[CSSRuleList](self)

pub fun CSSRuleList::from_js(v: JsValue) -> mut CSSRuleList = JsValue::unsafe_as[mut CSSRuleList](v)

struct CSSScopeRule()

/// Converts a reference to 'CSSScopeRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::as_css_grouping_rule(self: CSSScopeRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSScopeRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::as_mcss_grouping_rule(self: mut CSSScopeRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSScopeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScopeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSScopeRule = "
    if(#var(base) instanceof CSSScopeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSScopeRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSScopeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScopeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSScopeRule = "
    if(#var(base) instanceof CSSScopeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSScopeRule'!\");
"

/// Converts a reference to 'CSSScopeRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::as_css_rule(self: CSSScopeRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSScopeRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::as_mcss_rule(self: mut CSSScopeRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSScopeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScopeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::from_css_rule(base: CSSRule) -> CSSScopeRule = "
    if(#var(base) instanceof CSSScopeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSScopeRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSScopeRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScopeRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScopeRule::from_mcss_rule(base: mut CSSRule) -> mut CSSScopeRule = "
    if(#var(base) instanceof CSSScopeRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSScopeRule'!\");
"

pub ext fun CSSScopeRule::start(self: CSSScopeRule) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).start);"

pub ext fun CSSScopeRule::end(self: CSSScopeRule) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).end);"

pub ext fun CSSScopeRule::css_rules(self: CSSScopeRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSScopeRule::type(self: CSSScopeRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSScopeRule::css_text(self: CSSScopeRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSScopeRule::set_css_text(self: mut CSSScopeRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSScopeRule::parent_rule(self: CSSScopeRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSScopeRule::parent_style_sheet(self: CSSScopeRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSScopeRule::insert_rule(__self: mut CSSScopeRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSScopeRule::delete_rule(__self: mut CSSScopeRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSScopeRule::as_js(self: CSSScopeRule) -> JsValue = JsValue::unsafe_from[CSSScopeRule](self)

pub fun CSSScopeRule::from_js(v: JsValue) -> mut CSSScopeRule = JsValue::unsafe_as[mut CSSScopeRule](v)

pub val CSSScopeRule::style_rule: Int = 1
pub val CSSScopeRule::charset_rule: Int = 2
pub val CSSScopeRule::import_rule: Int = 3
pub val CSSScopeRule::media_rule: Int = 4
pub val CSSScopeRule::font_face_rule: Int = 5
pub val CSSScopeRule::page_rule: Int = 6
pub val CSSScopeRule::margin_rule: Int = 9
pub val CSSScopeRule::namespace_rule: Int = 10
pub val CSSScopeRule::keyframes_rule: Int = 7
pub val CSSScopeRule::keyframe_rule: Int = 8
pub val CSSScopeRule::counter_style_rule: Int = 11
pub val CSSScopeRule::font_feature_values_rule: Int = 14
pub val CSSScopeRule::supports_rule: Int = 12

struct CSSStartingStyleRule()

/// Converts a reference to 'CSSStartingStyleRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::as_css_grouping_rule(self: CSSStartingStyleRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSStartingStyleRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::as_mcss_grouping_rule(self: mut CSSStartingStyleRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSStartingStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStartingStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSStartingStyleRule = "
    if(#var(base) instanceof CSSStartingStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSStartingStyleRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSStartingStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStartingStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSStartingStyleRule = "
    if(#var(base) instanceof CSSStartingStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSStartingStyleRule'!\");
"

/// Converts a reference to 'CSSStartingStyleRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::as_css_rule(self: CSSStartingStyleRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSStartingStyleRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::as_mcss_rule(self: mut CSSStartingStyleRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSStartingStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStartingStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::from_css_rule(base: CSSRule) -> CSSStartingStyleRule = "
    if(#var(base) instanceof CSSStartingStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSStartingStyleRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSStartingStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStartingStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStartingStyleRule::from_mcss_rule(base: mut CSSRule) -> mut CSSStartingStyleRule = "
    if(#var(base) instanceof CSSStartingStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSStartingStyleRule'!\");
"

pub ext fun CSSStartingStyleRule::css_rules(self: CSSStartingStyleRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSStartingStyleRule::type(self: CSSStartingStyleRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSStartingStyleRule::css_text(self: CSSStartingStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSStartingStyleRule::set_css_text(self: mut CSSStartingStyleRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSStartingStyleRule::parent_rule(self: CSSStartingStyleRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSStartingStyleRule::parent_style_sheet(self: CSSStartingStyleRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSStartingStyleRule::insert_rule(__self: mut CSSStartingStyleRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSStartingStyleRule::delete_rule(__self: mut CSSStartingStyleRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSStartingStyleRule::as_js(self: CSSStartingStyleRule) -> JsValue = JsValue::unsafe_from[CSSStartingStyleRule](self)

pub fun CSSStartingStyleRule::from_js(v: JsValue) -> mut CSSStartingStyleRule = JsValue::unsafe_as[mut CSSStartingStyleRule](v)

pub val CSSStartingStyleRule::style_rule: Int = 1
pub val CSSStartingStyleRule::charset_rule: Int = 2
pub val CSSStartingStyleRule::import_rule: Int = 3
pub val CSSStartingStyleRule::media_rule: Int = 4
pub val CSSStartingStyleRule::font_face_rule: Int = 5
pub val CSSStartingStyleRule::page_rule: Int = 6
pub val CSSStartingStyleRule::margin_rule: Int = 9
pub val CSSStartingStyleRule::namespace_rule: Int = 10
pub val CSSStartingStyleRule::keyframes_rule: Int = 7
pub val CSSStartingStyleRule::keyframe_rule: Int = 8
pub val CSSStartingStyleRule::counter_style_rule: Int = 11
pub val CSSStartingStyleRule::font_feature_values_rule: Int = 14
pub val CSSStartingStyleRule::supports_rule: Int = 12

struct CSSStyleDeclaration()

pub ext fun CSSStyleDeclaration::css_text(self: CSSStyleDeclaration) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSStyleDeclaration::set_css_text(self: mut CSSStyleDeclaration, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSStyleDeclaration::length(self: CSSStyleDeclaration) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSStyleDeclaration::parent_rule(self: CSSStyleDeclaration) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSStyleDeclaration::css_float(self: CSSStyleDeclaration) -> String
    = "return #fun(String::from_js)(#var(self).cssFloat);"

pub ext fun CSSStyleDeclaration::set_css_float(self: mut CSSStyleDeclaration, value: String)
    = "#var(self).cssFloat = #fun(String::as_js)(#var(value));"

pub ext fun CSSStyleDeclaration::item(__self: mut CSSStyleDeclaration, index: Int) -> String = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSStyleDeclaration::get_property_value(__self: mut CSSStyleDeclaration, property: String) -> String = "
    const r = #var(__self).getPropertyValue(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSStyleDeclaration::get_property_priority(__self: mut CSSStyleDeclaration, property: String) -> String = "
    const r = #var(__self).getPropertyPriority(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSStyleDeclaration::set_property(__self: mut CSSStyleDeclaration, property: String, value: String, priority: String) -> Unit = "
    const r = #var(__self).setProperty(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(value)), #fun(String::as_js)(#var(priority)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSStyleDeclaration::remove_property(__self: mut CSSStyleDeclaration, property: String) -> String = "
    const r = #var(__self).removeProperty(#fun(String::as_js)(#var(property)));
    return #fun(String::from_js)(r);
"

pub ext fun CSSStyleDeclaration::get(__self: CSSStyleDeclaration, name: String) -> String = "
    const r = CSSStyleDeclaration[#fun(String::as_js)(#var(name))];
    return #fun(String::from_js)(r);
"

pub ext fun CSSStyleDeclaration::set(__self: mut CSSStyleDeclaration, property: String, property_value: JsValue) = "
    CSSStyleDeclaration[#fun(String::as_js)(#var(property))] = #var(property_value);
"

pub ext fun CSSStyleDeclaration::remove(__self: mut CSSStyleDeclaration, property: String) = "
    delete CSSStyleDeclaration[#fun(String::as_js)(#var(property))];
"

pub fun CSSStyleDeclaration::as_js(self: CSSStyleDeclaration) -> JsValue = JsValue::unsafe_from[CSSStyleDeclaration](self)

pub fun CSSStyleDeclaration::from_js(v: JsValue) -> mut CSSStyleDeclaration = JsValue::unsafe_as[mut CSSStyleDeclaration](v)

struct CSSStyleRule()

/// Converts a reference to 'CSSStyleRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleRule::as_css_rule(self: CSSStyleRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSStyleRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleRule::as_mcss_rule(self: mut CSSStyleRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleRule::from_css_rule(base: CSSRule) -> CSSStyleRule = "
    if(#var(base) instanceof CSSStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSStyleRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSStyleRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStyleRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleRule::from_mcss_rule(base: mut CSSRule) -> mut CSSStyleRule = "
    if(#var(base) instanceof CSSStyleRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSStyleRule'!\");
"

pub ext fun CSSStyleRule::selector_text(self: CSSStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).selectorText);"

pub ext fun CSSStyleRule::set_selector_text(self: mut CSSStyleRule, value: String)
    = "#var(self).selectorText = #fun(String::as_js)(#var(value));"

pub ext fun CSSStyleRule::style(self: CSSStyleRule) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun CSSStyleRule::style_map(self: CSSStyleRule) -> mut StylePropertyMap
    = "return #fun(StylePropertyMap::from_js)(#var(self).styleMap);"

pub ext fun CSSStyleRule::css_rules(self: CSSStyleRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSStyleRule::type(self: CSSStyleRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSStyleRule::css_text(self: CSSStyleRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSStyleRule::set_css_text(self: mut CSSStyleRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSStyleRule::parent_rule(self: CSSStyleRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSStyleRule::parent_style_sheet(self: CSSStyleRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSStyleRule::insert_rule(__self: mut CSSStyleRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSStyleRule::delete_rule(__self: mut CSSStyleRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSStyleRule::as_js(self: CSSStyleRule) -> JsValue = JsValue::unsafe_from[CSSStyleRule](self)

pub fun CSSStyleRule::from_js(v: JsValue) -> mut CSSStyleRule = JsValue::unsafe_as[mut CSSStyleRule](v)

pub val CSSStyleRule::style_rule: Int = 1
pub val CSSStyleRule::charset_rule: Int = 2
pub val CSSStyleRule::import_rule: Int = 3
pub val CSSStyleRule::media_rule: Int = 4
pub val CSSStyleRule::font_face_rule: Int = 5
pub val CSSStyleRule::page_rule: Int = 6
pub val CSSStyleRule::margin_rule: Int = 9
pub val CSSStyleRule::namespace_rule: Int = 10
pub val CSSStyleRule::keyframes_rule: Int = 7
pub val CSSStyleRule::keyframe_rule: Int = 8
pub val CSSStyleRule::counter_style_rule: Int = 11
pub val CSSStyleRule::font_feature_values_rule: Int = 14
pub val CSSStyleRule::supports_rule: Int = 12

struct CSSStyleSheet()

/// Converts a reference to 'CSSStyleSheet' to a reference to 'StyleSheet'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleSheet::as_style_sheet(self: CSSStyleSheet) -> StyleSheet = "return #var(self);"

/// Converts a mutable reference to 'CSSStyleSheet' to a mutable reference to 'StyleSheet'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleSheet::as_mstyle_sheet(self: mut CSSStyleSheet) -> mut StyleSheet = "return #var(self);"

/// Attempts to convert a reference to 'StyleSheet' to a reference to 'CSSStyleSheet'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStyleSheet' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleSheet::from_style_sheet(base: StyleSheet) -> CSSStyleSheet = "
    if(#var(base) instanceof CSSStyleSheet) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'StyleSheet' to 'CSSStyleSheet'!\");
"

/// Attempts to convert a mutable reference to 'StyleSheet' to a mutable reference to 'CSSStyleSheet'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSStyleSheet' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSStyleSheet::from_mstyle_sheet(base: mut StyleSheet) -> mut CSSStyleSheet = "
    if(#var(base) instanceof CSSStyleSheet) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'StyleSheet' to 'CSSStyleSheet'!\");
"

pub ext fun CSSStyleSheet::from_mcss_style_sheet_init(options: mut CSSStyleSheetInit) -> mut CSSStyleSheet
    = "return new CSSStyleSheet(#fun(CSSStyleSheetInit::as_js)(#var(options)));"

pub ext fun CSSStyleSheet::owner_rule(self: CSSStyleSheet) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).ownerRule);"

pub ext fun CSSStyleSheet::css_rules(self: CSSStyleSheet) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSStyleSheet::rules(self: CSSStyleSheet) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).rules);"

pub ext fun CSSStyleSheet::type(self: CSSStyleSheet) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CSSStyleSheet::href(self: CSSStyleSheet) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).href);"

pub ext fun CSSStyleSheet::owner_node(self: CSSStyleSheet) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).ownerNode);"

pub ext fun CSSStyleSheet::parent_style_sheet(self: CSSStyleSheet) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSStyleSheet::title(self: CSSStyleSheet) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).title);"

pub ext fun CSSStyleSheet::media(self: CSSStyleSheet) -> mut MediaList
    = "return #fun(MediaList::from_js)(#var(self).media);"

pub ext fun CSSStyleSheet::disabled(self: CSSStyleSheet) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun CSSStyleSheet::set_disabled(self: mut CSSStyleSheet, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSStyleSheet::insert_rule(__self: mut CSSStyleSheet, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSStyleSheet::delete_rule(__self: mut CSSStyleSheet, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSStyleSheet::replace(__self: mut CSSStyleSheet, text: String) -> Promise[mut CSSStyleSheet] = "
    const r = #var(__self).replace(#fun(String::as_js)(#var(text)));
    return #fun(Promise::from_js[mut CSSStyleSheet])(r);
"

pub ext fun CSSStyleSheet::replace_sync(__self: mut CSSStyleSheet, text: String) -> Unit = "
    const r = #var(__self).replaceSync(#fun(String::as_js)(#var(text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CSSStyleSheet::add_rule(__self: mut CSSStyleSheet, selector: String, style: String, index: Int) -> Int = "
    const r = #var(__self).addRule(#fun(String::as_js)(#var(selector)), #fun(String::as_js)(#var(style)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSStyleSheet::remove_rule(__self: mut CSSStyleSheet, index: Int) -> Unit = "
    const r = #var(__self).removeRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSStyleSheet::as_js(self: CSSStyleSheet) -> JsValue = JsValue::unsafe_from[CSSStyleSheet](self)

pub fun CSSStyleSheet::from_js(v: JsValue) -> mut CSSStyleSheet = JsValue::unsafe_as[mut CSSStyleSheet](v)

pub struct CSSStyleSheetInit(
    media: Option[JsValue],
    alternate: Option[Bool],
    disabled: Option[Bool]
)

pub fun CSSStyleSheetInit::default() -> mut CSSStyleSheetInit
    = CSSStyleSheetInit(Option::Some("" |> as_js()), Option::Some(false), Option::Some(false))

pub ext fun CSSStyleSheetInit::from_js(value: JsValue) -> mut CSSStyleSheetInit = "
    const r = {};
    r.m_media = #fun(Option::from_js[JsValue])(#var(value).media);
    r.m_alternate = #fun(Option::from_js[Bool])(#var(value).alternate);
    r.m_disabled = #fun(Option::from_js[Bool])(#var(value).disabled);
    return r;
"

pub ext fun CSSStyleSheetInit::as_js(self: CSSStyleSheetInit) -> JsValue = "
    const r = {};
    r.media = #fun(Option::as_js_undef[JsValue])(#var(self).m_media);
    r.alternate = #fun(Option::as_js_undef[Bool])(#var(self).m_alternate);
    r.disabled = #fun(Option::as_js_undef[Bool])(#var(self).m_disabled);
    return r;
"

struct CSSSupportsRule()

/// Converts a reference to 'CSSSupportsRule' to a reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_css_condition_rule(self: CSSSupportsRule) -> CSSConditionRule = "return #var(self);"

/// Converts a mutable reference to 'CSSSupportsRule' to a mutable reference to 'CSSConditionRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_mcss_condition_rule(self: mut CSSSupportsRule) -> mut CSSConditionRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSConditionRule' to a reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_css_condition_rule(base: CSSConditionRule) -> CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSSupportsRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSConditionRule' to a mutable reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_mcss_condition_rule(base: mut CSSConditionRule) -> mut CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSConditionRule' to 'CSSSupportsRule'!\");
"

/// Converts a reference to 'CSSSupportsRule' to a reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_css_grouping_rule(self: CSSSupportsRule) -> CSSGroupingRule = "return #var(self);"

/// Converts a mutable reference to 'CSSSupportsRule' to a mutable reference to 'CSSGroupingRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_mcss_grouping_rule(self: mut CSSSupportsRule) -> mut CSSGroupingRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSGroupingRule' to a reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_css_grouping_rule(base: CSSGroupingRule) -> CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSSupportsRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSGroupingRule' to a mutable reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_mcss_grouping_rule(base: mut CSSGroupingRule) -> mut CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSGroupingRule' to 'CSSSupportsRule'!\");
"

/// Converts a reference to 'CSSSupportsRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_css_rule(self: CSSSupportsRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSSupportsRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::as_mcss_rule(self: mut CSSSupportsRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_css_rule(base: CSSRule) -> CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSSupportsRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSSupportsRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSupportsRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSupportsRule::from_mcss_rule(base: mut CSSRule) -> mut CSSSupportsRule = "
    if(#var(base) instanceof CSSSupportsRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSSupportsRule'!\");
"

pub ext fun CSSSupportsRule::condition_text(self: CSSSupportsRule) -> String
    = "return #fun(String::from_js)(#var(self).conditionText);"

pub ext fun CSSSupportsRule::css_rules(self: CSSSupportsRule) -> mut CSSRuleList
    = "return #fun(CSSRuleList::from_js)(#var(self).cssRules);"

pub ext fun CSSSupportsRule::type(self: CSSSupportsRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSSupportsRule::css_text(self: CSSSupportsRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSSupportsRule::set_css_text(self: mut CSSSupportsRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSSupportsRule::parent_rule(self: CSSSupportsRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSSupportsRule::parent_style_sheet(self: CSSSupportsRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub ext fun CSSSupportsRule::insert_rule(__self: mut CSSSupportsRule, rule: String, index: Int) -> Int = "
    const r = #var(__self).insertRule(#fun(String::as_js)(#var(rule)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun CSSSupportsRule::delete_rule(__self: mut CSSSupportsRule, index: Int) -> Unit = "
    const r = #var(__self).deleteRule(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub fun CSSSupportsRule::as_js(self: CSSSupportsRule) -> JsValue = JsValue::unsafe_from[CSSSupportsRule](self)

pub fun CSSSupportsRule::from_js(v: JsValue) -> mut CSSSupportsRule = JsValue::unsafe_as[mut CSSSupportsRule](v)

pub val CSSSupportsRule::style_rule: Int = 1
pub val CSSSupportsRule::charset_rule: Int = 2
pub val CSSSupportsRule::import_rule: Int = 3
pub val CSSSupportsRule::media_rule: Int = 4
pub val CSSSupportsRule::font_face_rule: Int = 5
pub val CSSSupportsRule::page_rule: Int = 6
pub val CSSSupportsRule::margin_rule: Int = 9
pub val CSSSupportsRule::namespace_rule: Int = 10
pub val CSSSupportsRule::keyframes_rule: Int = 7
pub val CSSSupportsRule::keyframe_rule: Int = 8
pub val CSSSupportsRule::counter_style_rule: Int = 11
pub val CSSSupportsRule::font_feature_values_rule: Int = 14
pub val CSSSupportsRule::supports_rule: Int = 12

struct CSSViewTransitionRule()

/// Converts a reference to 'CSSViewTransitionRule' to a reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSViewTransitionRule::as_css_rule(self: CSSViewTransitionRule) -> CSSRule = "return #var(self);"

/// Converts a mutable reference to 'CSSViewTransitionRule' to a mutable reference to 'CSSRule'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSViewTransitionRule::as_mcss_rule(self: mut CSSViewTransitionRule) -> mut CSSRule = "return #var(self);"

/// Attempts to convert a reference to 'CSSRule' to a reference to 'CSSViewTransitionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSViewTransitionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSViewTransitionRule::from_css_rule(base: CSSRule) -> CSSViewTransitionRule = "
    if(#var(base) instanceof CSSViewTransitionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSViewTransitionRule'!\");
"

/// Attempts to convert a mutable reference to 'CSSRule' to a mutable reference to 'CSSViewTransitionRule'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSViewTransitionRule' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSViewTransitionRule::from_mcss_rule(base: mut CSSRule) -> mut CSSViewTransitionRule = "
    if(#var(base) instanceof CSSViewTransitionRule) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSRule' to 'CSSViewTransitionRule'!\");
"

pub ext fun CSSViewTransitionRule::navigation(self: CSSViewTransitionRule) -> String
    = "return #fun(String::from_js)(#var(self).navigation);"

pub ext fun CSSViewTransitionRule::types(self: CSSViewTransitionRule) -> JsValue
    = "return #var(self).types;"

pub ext fun CSSViewTransitionRule::type(self: CSSViewTransitionRule) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun CSSViewTransitionRule::css_text(self: CSSViewTransitionRule) -> String
    = "return #fun(String::from_js)(#var(self).cssText);"

pub ext fun CSSViewTransitionRule::set_css_text(self: mut CSSViewTransitionRule, value: String)
    = "#var(self).cssText = #fun(String::as_js)(#var(value));"

pub ext fun CSSViewTransitionRule::parent_rule(self: CSSViewTransitionRule) -> Option[mut CSSRule]
    = "return #fun(Option::from_js[mut CSSRule])(#var(self).parentRule);"

pub ext fun CSSViewTransitionRule::parent_style_sheet(self: CSSViewTransitionRule) -> Option[mut CSSStyleSheet]
    = "return #fun(Option::from_js[mut CSSStyleSheet])(#var(self).parentStyleSheet);"

pub fun CSSViewTransitionRule::as_js(self: CSSViewTransitionRule) -> JsValue = JsValue::unsafe_from[CSSViewTransitionRule](self)

pub fun CSSViewTransitionRule::from_js(v: JsValue) -> mut CSSViewTransitionRule = JsValue::unsafe_as[mut CSSViewTransitionRule](v)

pub val CSSViewTransitionRule::style_rule: Int = 1
pub val CSSViewTransitionRule::charset_rule: Int = 2
pub val CSSViewTransitionRule::import_rule: Int = 3
pub val CSSViewTransitionRule::media_rule: Int = 4
pub val CSSViewTransitionRule::font_face_rule: Int = 5
pub val CSSViewTransitionRule::page_rule: Int = 6
pub val CSSViewTransitionRule::margin_rule: Int = 9
pub val CSSViewTransitionRule::namespace_rule: Int = 10
pub val CSSViewTransitionRule::keyframes_rule: Int = 7
pub val CSSViewTransitionRule::keyframe_rule: Int = 8
pub val CSSViewTransitionRule::counter_style_rule: Int = 11
pub val CSSViewTransitionRule::font_feature_values_rule: Int = 14
pub val CSSViewTransitionRule::supports_rule: Int = 12

struct CaretPosition()

pub ext fun CaretPosition::offset_node(self: CaretPosition) -> mut Node
    = "return #fun(Node::from_js)(#var(self).offsetNode);"

pub ext fun CaretPosition::offset(self: CaretPosition) -> Int
    = "return #fun(Int::from_js)(#var(self).offset);"

pub ext fun CaretPosition::get_client_rect(__self: mut CaretPosition) -> Option[mut DOMRect] = "
    const r = #var(__self).getClientRect();
    return #fun(Option::from_js[mut DOMRect])(r);
"

pub fun CaretPosition::as_js(self: CaretPosition) -> JsValue = JsValue::unsafe_from[CaretPosition](self)

pub fun CaretPosition::from_js(v: JsValue) -> mut CaretPosition = JsValue::unsafe_as[mut CaretPosition](v)

struct CSSColorValue()

pub ext fun CSSColorValue::to_rgb(__self: mut CSSColorValue) -> mut CSSRGB = "
    const r = #var(__self).toRGB();
    return #fun(CSSRGB::from_js)(r);
"

pub ext fun CSSColorValue::to_hsl(__self: mut CSSColorValue) -> mut CSSHSL = "
    const r = #var(__self).toHSL();
    return #fun(CSSHSL::from_js)(r);
"

pub ext fun CSSColorValue::to_hwb(__self: mut CSSColorValue) -> mut CSSHWB = "
    const r = #var(__self).toHWB();
    return #fun(CSSHWB::from_js)(r);
"

pub ext fun CSSColorValue::parse(css_text: String) -> JsValue = "
    const r = CSSColorValue.parse(#fun(String::as_js)(#var(css_text)));
    return r;
"

pub fun CSSColorValue::as_js(self: CSSColorValue) -> JsValue = JsValue::unsafe_from[CSSColorValue](self)

pub fun CSSColorValue::from_js(v: JsValue) -> mut CSSColorValue = JsValue::unsafe_as[mut CSSColorValue](v)

struct CSSHSL()

/// Converts a reference to 'CSSHSL' to a reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHSL::as_css_color_value(self: CSSHSL) -> CSSColorValue = "return #var(self);"

/// Converts a mutable reference to 'CSSHSL' to a mutable reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHSL::as_mcss_color_value(self: mut CSSHSL) -> mut CSSColorValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSColorValue' to a reference to 'CSSHSL'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSHSL' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHSL::from_css_color_value(base: CSSColorValue) -> CSSHSL = "
    if(#var(base) instanceof CSSHSL) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSHSL'!\");
"

/// Attempts to convert a mutable reference to 'CSSColorValue' to a mutable reference to 'CSSHSL'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSHSL' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHSL::from_mcss_color_value(base: mut CSSColorValue) -> mut CSSHSL = "
    if(#var(base) instanceof CSSHSL) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSHSL'!\");
"

pub ext fun CSSHSL::from_mcss_numeric_value_any_any_any(h: mut CSSNumericValue, s: JsValue, l: JsValue, alpha: JsValue) -> mut CSSHSL
    = "return new CSSHSL(#fun(CSSNumericValue::as_js)(#var(h)), #var(s), #var(l), #var(alpha));"

pub ext fun CSSHSL::h(self: CSSHSL) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).h);"

pub ext fun CSSHSL::set_h(self: mut CSSHSL, value: mut CSSNumericValue)
    = "#var(self).h = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSHSL::s(self: CSSHSL) -> JsValue
    = "return #var(self).s;"

pub ext fun CSSHSL::set_s(self: mut CSSHSL, value: JsValue)
    = "#var(self).s = #var(value);"

pub ext fun CSSHSL::l(self: CSSHSL) -> JsValue
    = "return #var(self).l;"

pub ext fun CSSHSL::set_l(self: mut CSSHSL, value: JsValue)
    = "#var(self).l = #var(value);"

pub ext fun CSSHSL::alpha(self: CSSHSL) -> JsValue
    = "return #var(self).alpha;"

pub ext fun CSSHSL::set_alpha(self: mut CSSHSL, value: JsValue)
    = "#var(self).alpha = #var(value);"

pub ext fun CSSHSL::to_rgb(__self: mut CSSHSL) -> mut CSSRGB = "
    const r = #var(__self).toRGB();
    return #fun(CSSRGB::from_js)(r);
"

pub ext fun CSSHSL::to_hsl(__self: mut CSSHSL) -> mut CSSHSL = "
    const r = #var(__self).toHSL();
    return #fun(CSSHSL::from_js)(r);
"

pub ext fun CSSHSL::to_hwb(__self: mut CSSHSL) -> mut CSSHWB = "
    const r = #var(__self).toHWB();
    return #fun(CSSHWB::from_js)(r);
"

pub ext fun CSSHSL::parse(css_text: String) -> JsValue = "
    const r = CSSHSL.parse(#fun(String::as_js)(#var(css_text)));
    return r;
"

pub fun CSSHSL::as_js(self: CSSHSL) -> JsValue = JsValue::unsafe_from[CSSHSL](self)

pub fun CSSHSL::from_js(v: JsValue) -> mut CSSHSL = JsValue::unsafe_as[mut CSSHSL](v)

struct CSSHWB()

/// Converts a reference to 'CSSHWB' to a reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHWB::as_css_color_value(self: CSSHWB) -> CSSColorValue = "return #var(self);"

/// Converts a mutable reference to 'CSSHWB' to a mutable reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHWB::as_mcss_color_value(self: mut CSSHWB) -> mut CSSColorValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSColorValue' to a reference to 'CSSHWB'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSHWB' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHWB::from_css_color_value(base: CSSColorValue) -> CSSHWB = "
    if(#var(base) instanceof CSSHWB) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSHWB'!\");
"

/// Attempts to convert a mutable reference to 'CSSColorValue' to a mutable reference to 'CSSHWB'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSHWB' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSHWB::from_mcss_color_value(base: mut CSSColorValue) -> mut CSSHWB = "
    if(#var(base) instanceof CSSHWB) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSHWB'!\");
"

pub ext fun CSSHWB::from_mcss_numeric_value_any_any_any(h: mut CSSNumericValue, w: JsValue, b: JsValue, alpha: JsValue) -> mut CSSHWB
    = "return new CSSHWB(#fun(CSSNumericValue::as_js)(#var(h)), #var(w), #var(b), #var(alpha));"

pub ext fun CSSHWB::h(self: CSSHWB) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).h);"

pub ext fun CSSHWB::set_h(self: mut CSSHWB, value: mut CSSNumericValue)
    = "#var(self).h = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSHWB::w(self: CSSHWB) -> JsValue
    = "return #var(self).w;"

pub ext fun CSSHWB::set_w(self: mut CSSHWB, value: JsValue)
    = "#var(self).w = #var(value);"

pub ext fun CSSHWB::b(self: CSSHWB) -> JsValue
    = "return #var(self).b;"

pub ext fun CSSHWB::set_b(self: mut CSSHWB, value: JsValue)
    = "#var(self).b = #var(value);"

pub ext fun CSSHWB::alpha(self: CSSHWB) -> JsValue
    = "return #var(self).alpha;"

pub ext fun CSSHWB::set_alpha(self: mut CSSHWB, value: JsValue)
    = "#var(self).alpha = #var(value);"

pub ext fun CSSHWB::to_rgb(__self: mut CSSHWB) -> mut CSSRGB = "
    const r = #var(__self).toRGB();
    return #fun(CSSRGB::from_js)(r);
"

pub ext fun CSSHWB::to_hsl(__self: mut CSSHWB) -> mut CSSHSL = "
    const r = #var(__self).toHSL();
    return #fun(CSSHSL::from_js)(r);
"

pub ext fun CSSHWB::to_hwb(__self: mut CSSHWB) -> mut CSSHWB = "
    const r = #var(__self).toHWB();
    return #fun(CSSHWB::from_js)(r);
"

pub ext fun CSSHWB::parse(css_text: String) -> JsValue = "
    const r = CSSHWB.parse(#fun(String::as_js)(#var(css_text)));
    return r;
"

pub fun CSSHWB::as_js(self: CSSHWB) -> JsValue = JsValue::unsafe_from[CSSHWB](self)

pub fun CSSHWB::from_js(v: JsValue) -> mut CSSHWB = JsValue::unsafe_as[mut CSSHWB](v)

struct CSSImageValue()

/// Converts a reference to 'CSSImageValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImageValue::as_css_style_value(self: CSSImageValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSImageValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImageValue::as_mcss_style_value(self: mut CSSImageValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSImageValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSImageValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImageValue::from_css_style_value(base: CSSStyleValue) -> CSSImageValue = "
    if(#var(base) instanceof CSSImageValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSImageValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSImageValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSImageValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSImageValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSImageValue = "
    if(#var(base) instanceof CSSImageValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSImageValue'!\");
"

pub ext fun CSSImageValue::as_string(__self: mut CSSImageValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSImageValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSImageValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSImageValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSImageValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSImageValue::as_js(self: CSSImageValue) -> JsValue = JsValue::unsafe_from[CSSImageValue](self)

pub fun CSSImageValue::from_js(v: JsValue) -> mut CSSImageValue = JsValue::unsafe_as[mut CSSImageValue](v)

struct CSSKeywordValue()

/// Converts a reference to 'CSSKeywordValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeywordValue::as_css_style_value(self: CSSKeywordValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSKeywordValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeywordValue::as_mcss_style_value(self: mut CSSKeywordValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSKeywordValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeywordValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeywordValue::from_css_style_value(base: CSSStyleValue) -> CSSKeywordValue = "
    if(#var(base) instanceof CSSKeywordValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSKeywordValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSKeywordValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSKeywordValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSKeywordValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSKeywordValue = "
    if(#var(base) instanceof CSSKeywordValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSKeywordValue'!\");
"

pub ext fun CSSKeywordValue::from_str(keyword: String) -> mut CSSKeywordValue
    = "return new CSSKeywordValue(#fun(String::as_js)(#var(keyword)));"

pub ext fun CSSKeywordValue::value(self: CSSKeywordValue) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun CSSKeywordValue::set_value(self: mut CSSKeywordValue, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun CSSKeywordValue::as_string(__self: mut CSSKeywordValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSKeywordValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSKeywordValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSKeywordValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSKeywordValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSKeywordValue::as_js(self: CSSKeywordValue) -> JsValue = JsValue::unsafe_from[CSSKeywordValue](self)

pub fun CSSKeywordValue::from_js(v: JsValue) -> mut CSSKeywordValue = JsValue::unsafe_as[mut CSSKeywordValue](v)

struct CSSMathClamp()

/// Converts a reference to 'CSSMathClamp' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_css_math_value(self: CSSMathClamp) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathClamp' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_mcss_math_value(self: mut CSSMathClamp) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_css_math_value(base: CSSMathValue) -> CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathClamp'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathClamp'!\");
"

/// Converts a reference to 'CSSMathClamp' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_css_numeric_value(self: CSSMathClamp) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathClamp' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_mcss_numeric_value(self: mut CSSMathClamp) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_css_numeric_value(base: CSSNumericValue) -> CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathClamp'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathClamp'!\");
"

/// Converts a reference to 'CSSMathClamp' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_css_style_value(self: CSSMathClamp) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathClamp' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::as_mcss_style_value(self: mut CSSMathClamp) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_css_style_value(base: CSSStyleValue) -> CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathClamp'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathClamp'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathClamp' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathClamp::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathClamp = "
    if(#var(base) instanceof CSSMathClamp) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathClamp'!\");
"

pub ext fun CSSMathClamp::from_any_any_any(lower: JsValue, value: JsValue, upper: JsValue) -> mut CSSMathClamp
    = "return new CSSMathClamp(#var(lower), #var(value), #var(upper));"

pub ext fun CSSMathClamp::lower(self: CSSMathClamp) -> JsValue
    = "return #var(self).lower;"

pub ext fun CSSMathClamp::value(self: CSSMathClamp) -> JsValue
    = "return #var(self).value;"

pub ext fun CSSMathClamp::upper(self: CSSMathClamp) -> JsValue
    = "return #var(self).upper;"

pub ext fun CSSMathClamp::operator(self: CSSMathClamp) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathClamp::add(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::sub(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::mul(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::div(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::min(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::max(__self: mut CSSMathClamp, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::equals(__self: mut CSSMathClamp, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathClamp::to(__self: mut CSSMathClamp, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathClamp::to_sum(__self: mut CSSMathClamp, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathClamp::type(__self: mut CSSMathClamp) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathClamp::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathClamp.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathClamp::as_string(__self: mut CSSMathClamp) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathClamp::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathClamp.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathClamp::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathClamp.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathClamp::as_js(self: CSSMathClamp) -> JsValue = JsValue::unsafe_from[CSSMathClamp](self)

pub fun CSSMathClamp::from_js(v: JsValue) -> mut CSSMathClamp = JsValue::unsafe_as[mut CSSMathClamp](v)

struct CSSMathInvert()

/// Converts a reference to 'CSSMathInvert' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_css_math_value(self: CSSMathInvert) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathInvert' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_mcss_math_value(self: mut CSSMathInvert) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_css_math_value(base: CSSMathValue) -> CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathInvert'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathInvert'!\");
"

/// Converts a reference to 'CSSMathInvert' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_css_numeric_value(self: CSSMathInvert) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathInvert' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_mcss_numeric_value(self: mut CSSMathInvert) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_css_numeric_value(base: CSSNumericValue) -> CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathInvert'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathInvert'!\");
"

/// Converts a reference to 'CSSMathInvert' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_css_style_value(self: CSSMathInvert) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathInvert' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::as_mcss_style_value(self: mut CSSMathInvert) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_css_style_value(base: CSSStyleValue) -> CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathInvert'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathInvert'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathInvert' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathInvert::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathInvert = "
    if(#var(base) instanceof CSSMathInvert) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathInvert'!\");
"

pub ext fun CSSMathInvert::from_any(arg: JsValue) -> mut CSSMathInvert
    = "return new CSSMathInvert(#var(arg));"

pub ext fun CSSMathInvert::value(self: CSSMathInvert) -> JsValue
    = "return #var(self).value;"

pub ext fun CSSMathInvert::operator(self: CSSMathInvert) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathInvert::add(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::sub(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::mul(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::div(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::min(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::max(__self: mut CSSMathInvert, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::equals(__self: mut CSSMathInvert, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathInvert::to(__self: mut CSSMathInvert, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathInvert::to_sum(__self: mut CSSMathInvert, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathInvert::type(__self: mut CSSMathInvert) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathInvert::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathInvert.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathInvert::as_string(__self: mut CSSMathInvert) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathInvert::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathInvert.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathInvert::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathInvert.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathInvert::as_js(self: CSSMathInvert) -> JsValue = JsValue::unsafe_from[CSSMathInvert](self)

pub fun CSSMathInvert::from_js(v: JsValue) -> mut CSSMathInvert = JsValue::unsafe_as[mut CSSMathInvert](v)

struct CSSMathMax()

/// Converts a reference to 'CSSMathMax' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_css_math_value(self: CSSMathMax) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMax' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_mcss_math_value(self: mut CSSMathMax) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_css_math_value(base: CSSMathValue) -> CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathMax'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathMax'!\");
"

/// Converts a reference to 'CSSMathMax' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_css_numeric_value(self: CSSMathMax) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMax' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_mcss_numeric_value(self: mut CSSMathMax) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_css_numeric_value(base: CSSNumericValue) -> CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathMax'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathMax'!\");
"

/// Converts a reference to 'CSSMathMax' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_css_style_value(self: CSSMathMax) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMax' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::as_mcss_style_value(self: mut CSSMathMax) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_css_style_value(base: CSSStyleValue) -> CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathMax'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathMax'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMax' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMax::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathMax = "
    if(#var(base) instanceof CSSMathMax) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathMax'!\");
"

pub ext fun CSSMathMax::from_any(...args: List[JsValue]) -> mut CSSMathMax
    = "return new CSSMathMax(...((#var(args)).map(v => v)));"

pub ext fun CSSMathMax::values(self: CSSMathMax) -> mut CSSNumericArray
    = "return #fun(CSSNumericArray::from_js)(#var(self).values);"

pub ext fun CSSMathMax::operator(self: CSSMathMax) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathMax::add(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::sub(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::mul(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::div(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::min(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::max(__self: mut CSSMathMax, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::equals(__self: mut CSSMathMax, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathMax::to(__self: mut CSSMathMax, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathMax::to_sum(__self: mut CSSMathMax, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathMax::type(__self: mut CSSMathMax) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathMax::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathMax.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMax::as_string(__self: mut CSSMathMax) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathMax::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathMax.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathMax::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathMax.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathMax::as_js(self: CSSMathMax) -> JsValue = JsValue::unsafe_from[CSSMathMax](self)

pub fun CSSMathMax::from_js(v: JsValue) -> mut CSSMathMax = JsValue::unsafe_as[mut CSSMathMax](v)

struct CSSMathMin()

/// Converts a reference to 'CSSMathMin' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_css_math_value(self: CSSMathMin) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMin' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_mcss_math_value(self: mut CSSMathMin) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_css_math_value(base: CSSMathValue) -> CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathMin'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathMin'!\");
"

/// Converts a reference to 'CSSMathMin' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_css_numeric_value(self: CSSMathMin) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMin' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_mcss_numeric_value(self: mut CSSMathMin) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_css_numeric_value(base: CSSNumericValue) -> CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathMin'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathMin'!\");
"

/// Converts a reference to 'CSSMathMin' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_css_style_value(self: CSSMathMin) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathMin' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::as_mcss_style_value(self: mut CSSMathMin) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_css_style_value(base: CSSStyleValue) -> CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathMin'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathMin'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathMin' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathMin::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathMin = "
    if(#var(base) instanceof CSSMathMin) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathMin'!\");
"

pub ext fun CSSMathMin::from_any(...args: List[JsValue]) -> mut CSSMathMin
    = "return new CSSMathMin(...((#var(args)).map(v => v)));"

pub ext fun CSSMathMin::values(self: CSSMathMin) -> mut CSSNumericArray
    = "return #fun(CSSNumericArray::from_js)(#var(self).values);"

pub ext fun CSSMathMin::operator(self: CSSMathMin) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathMin::add(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::sub(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::mul(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::div(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::min(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::max(__self: mut CSSMathMin, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::equals(__self: mut CSSMathMin, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathMin::to(__self: mut CSSMathMin, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathMin::to_sum(__self: mut CSSMathMin, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathMin::type(__self: mut CSSMathMin) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathMin::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathMin.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathMin::as_string(__self: mut CSSMathMin) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathMin::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathMin.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathMin::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathMin.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathMin::as_js(self: CSSMathMin) -> JsValue = JsValue::unsafe_from[CSSMathMin](self)

pub fun CSSMathMin::from_js(v: JsValue) -> mut CSSMathMin = JsValue::unsafe_as[mut CSSMathMin](v)

struct CSSMathNegate()

/// Converts a reference to 'CSSMathNegate' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_css_math_value(self: CSSMathNegate) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathNegate' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_mcss_math_value(self: mut CSSMathNegate) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_css_math_value(base: CSSMathValue) -> CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathNegate'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathNegate'!\");
"

/// Converts a reference to 'CSSMathNegate' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_css_numeric_value(self: CSSMathNegate) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathNegate' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_mcss_numeric_value(self: mut CSSMathNegate) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_css_numeric_value(base: CSSNumericValue) -> CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathNegate'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathNegate'!\");
"

/// Converts a reference to 'CSSMathNegate' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_css_style_value(self: CSSMathNegate) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathNegate' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::as_mcss_style_value(self: mut CSSMathNegate) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_css_style_value(base: CSSStyleValue) -> CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathNegate'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathNegate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathNegate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathNegate::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathNegate = "
    if(#var(base) instanceof CSSMathNegate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathNegate'!\");
"

pub ext fun CSSMathNegate::from_any(arg: JsValue) -> mut CSSMathNegate
    = "return new CSSMathNegate(#var(arg));"

pub ext fun CSSMathNegate::value(self: CSSMathNegate) -> JsValue
    = "return #var(self).value;"

pub ext fun CSSMathNegate::operator(self: CSSMathNegate) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathNegate::add(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::sub(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::mul(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::div(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::min(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::max(__self: mut CSSMathNegate, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::equals(__self: mut CSSMathNegate, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathNegate::to(__self: mut CSSMathNegate, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathNegate::to_sum(__self: mut CSSMathNegate, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathNegate::type(__self: mut CSSMathNegate) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathNegate::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathNegate.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathNegate::as_string(__self: mut CSSMathNegate) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathNegate::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathNegate.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathNegate::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathNegate.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathNegate::as_js(self: CSSMathNegate) -> JsValue = JsValue::unsafe_from[CSSMathNegate](self)

pub fun CSSMathNegate::from_js(v: JsValue) -> mut CSSMathNegate = JsValue::unsafe_as[mut CSSMathNegate](v)

struct CSSMathProduct()

/// Converts a reference to 'CSSMathProduct' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_css_math_value(self: CSSMathProduct) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathProduct' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_mcss_math_value(self: mut CSSMathProduct) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_css_math_value(base: CSSMathValue) -> CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathProduct'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathProduct'!\");
"

/// Converts a reference to 'CSSMathProduct' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_css_numeric_value(self: CSSMathProduct) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathProduct' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_mcss_numeric_value(self: mut CSSMathProduct) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_css_numeric_value(base: CSSNumericValue) -> CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathProduct'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathProduct'!\");
"

/// Converts a reference to 'CSSMathProduct' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_css_style_value(self: CSSMathProduct) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathProduct' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::as_mcss_style_value(self: mut CSSMathProduct) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_css_style_value(base: CSSStyleValue) -> CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathProduct'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathProduct'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathProduct' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathProduct::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathProduct = "
    if(#var(base) instanceof CSSMathProduct) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathProduct'!\");
"

pub ext fun CSSMathProduct::from_any(...args: List[JsValue]) -> mut CSSMathProduct
    = "return new CSSMathProduct(...((#var(args)).map(v => v)));"

pub ext fun CSSMathProduct::values(self: CSSMathProduct) -> mut CSSNumericArray
    = "return #fun(CSSNumericArray::from_js)(#var(self).values);"

pub ext fun CSSMathProduct::operator(self: CSSMathProduct) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathProduct::add(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::sub(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::mul(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::div(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::min(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::max(__self: mut CSSMathProduct, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::equals(__self: mut CSSMathProduct, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathProduct::to(__self: mut CSSMathProduct, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathProduct::to_sum(__self: mut CSSMathProduct, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathProduct::type(__self: mut CSSMathProduct) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathProduct::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathProduct.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathProduct::as_string(__self: mut CSSMathProduct) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathProduct::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathProduct.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathProduct::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathProduct.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathProduct::as_js(self: CSSMathProduct) -> JsValue = JsValue::unsafe_from[CSSMathProduct](self)

pub fun CSSMathProduct::from_js(v: JsValue) -> mut CSSMathProduct = JsValue::unsafe_as[mut CSSMathProduct](v)

struct CSSMathSum()

/// Converts a reference to 'CSSMathSum' to a reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_css_math_value(self: CSSMathSum) -> CSSMathValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathSum' to a mutable reference to 'CSSMathValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_mcss_math_value(self: mut CSSMathSum) -> mut CSSMathValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSMathValue' to a reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_css_math_value(base: CSSMathValue) -> CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathSum'!\");
"

/// Attempts to convert a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_mcss_math_value(base: mut CSSMathValue) -> mut CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSMathValue' to 'CSSMathSum'!\");
"

/// Converts a reference to 'CSSMathSum' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_css_numeric_value(self: CSSMathSum) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathSum' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_mcss_numeric_value(self: mut CSSMathSum) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_css_numeric_value(base: CSSNumericValue) -> CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathSum'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathSum'!\");
"

/// Converts a reference to 'CSSMathSum' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_css_style_value(self: CSSMathSum) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathSum' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::as_mcss_style_value(self: mut CSSMathSum) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_css_style_value(base: CSSStyleValue) -> CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathSum'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathSum'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathSum' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathSum::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathSum = "
    if(#var(base) instanceof CSSMathSum) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathSum'!\");
"

pub ext fun CSSMathSum::from_any(...args: List[JsValue]) -> mut CSSMathSum
    = "return new CSSMathSum(...((#var(args)).map(v => v)));"

pub ext fun CSSMathSum::values(self: CSSMathSum) -> mut CSSNumericArray
    = "return #fun(CSSNumericArray::from_js)(#var(self).values);"

pub ext fun CSSMathSum::operator(self: CSSMathSum) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathSum::add(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::sub(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::mul(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::div(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::min(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::max(__self: mut CSSMathSum, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::equals(__self: mut CSSMathSum, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathSum::to(__self: mut CSSMathSum, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathSum::to_sum(__self: mut CSSMathSum, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathSum::type(__self: mut CSSMathSum) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathSum::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathSum.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathSum::as_string(__self: mut CSSMathSum) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathSum::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathSum.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathSum::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathSum.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathSum::as_js(self: CSSMathSum) -> JsValue = JsValue::unsafe_from[CSSMathSum](self)

pub fun CSSMathSum::from_js(v: JsValue) -> mut CSSMathSum = JsValue::unsafe_as[mut CSSMathSum](v)

pub val CSSMathOperator::Sum: String = "sum"
pub val CSSMathOperator::Product: String = "product"
pub val CSSMathOperator::Negate: String = "negate"
pub val CSSMathOperator::Invert: String = "invert"
pub val CSSMathOperator::Min: String = "min"
pub val CSSMathOperator::Max: String = "max"
pub val CSSMathOperator::Clamp: String = "clamp"

struct CSSMathValue()

/// Converts a reference to 'CSSMathValue' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::as_css_numeric_value(self: CSSMathValue) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::as_mcss_numeric_value(self: mut CSSMathValue) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSMathValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::from_css_numeric_value(base: CSSNumericValue) -> CSSMathValue = "
    if(#var(base) instanceof CSSMathValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSMathValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSMathValue = "
    if(#var(base) instanceof CSSMathValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSMathValue'!\");
"

/// Converts a reference to 'CSSMathValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::as_css_style_value(self: CSSMathValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSMathValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::as_mcss_style_value(self: mut CSSMathValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSMathValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::from_css_style_value(base: CSSStyleValue) -> CSSMathValue = "
    if(#var(base) instanceof CSSMathValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSMathValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMathValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMathValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSMathValue = "
    if(#var(base) instanceof CSSMathValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSMathValue'!\");
"

pub ext fun CSSMathValue::operator(self: CSSMathValue) -> String
    = "return #fun(String::from_js)(#var(self).operator);"

pub ext fun CSSMathValue::add(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::sub(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::mul(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::div(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::min(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::max(__self: mut CSSMathValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::equals(__self: mut CSSMathValue, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSMathValue::to(__self: mut CSSMathValue, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSMathValue::to_sum(__self: mut CSSMathValue, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSMathValue::type(__self: mut CSSMathValue) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSMathValue::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSMathValue.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSMathValue::as_string(__self: mut CSSMathValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMathValue::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSMathValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSMathValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSMathValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSMathValue::as_js(self: CSSMathValue) -> JsValue = JsValue::unsafe_from[CSSMathValue](self)

pub fun CSSMathValue::from_js(v: JsValue) -> mut CSSMathValue = JsValue::unsafe_as[mut CSSMathValue](v)

struct CSSMatrixComponent()

/// Converts a reference to 'CSSMatrixComponent' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMatrixComponent::as_css_transform_component(self: CSSMatrixComponent) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSMatrixComponent' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMatrixComponent::as_mcss_transform_component(self: mut CSSMatrixComponent) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSMatrixComponent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMatrixComponent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMatrixComponent::from_css_transform_component(base: CSSTransformComponent) -> CSSMatrixComponent = "
    if(#var(base) instanceof CSSMatrixComponent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSMatrixComponent'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSMatrixComponent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSMatrixComponent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSMatrixComponent::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSMatrixComponent = "
    if(#var(base) instanceof CSSMatrixComponent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSMatrixComponent'!\");
"

pub ext fun CSSMatrixComponent::from_mdom_matrix_read_only_mcss_matrix_component_options(matrix: mut DOMMatrixReadOnly, options: mut CSSMatrixComponentOptions) -> mut CSSMatrixComponent
    = "return new CSSMatrixComponent(#fun(DOMMatrixReadOnly::as_js)(#var(matrix)), #fun(CSSMatrixComponentOptions::as_js)(#var(options)));"

pub ext fun CSSMatrixComponent::matrix(self: CSSMatrixComponent) -> mut DOMMatrix
    = "return #fun(DOMMatrix::from_js)(#var(self).matrix);"

pub ext fun CSSMatrixComponent::set_matrix(self: mut CSSMatrixComponent, value: mut DOMMatrix)
    = "#var(self).matrix = #fun(DOMMatrix::as_js)(#var(value));"

pub ext fun CSSMatrixComponent::is_2d(self: CSSMatrixComponent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSMatrixComponent::set_is_2d(self: mut CSSMatrixComponent, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSMatrixComponent::as_string(__self: mut CSSMatrixComponent) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSMatrixComponent::to_matrix(__self: mut CSSMatrixComponent) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSMatrixComponent::as_js(self: CSSMatrixComponent) -> JsValue = JsValue::unsafe_from[CSSMatrixComponent](self)

pub fun CSSMatrixComponent::from_js(v: JsValue) -> mut CSSMatrixComponent = JsValue::unsafe_as[mut CSSMatrixComponent](v)

pub struct CSSMatrixComponentOptions(
    is_2d: Option[Bool]
)

pub fun CSSMatrixComponentOptions::default() -> mut CSSMatrixComponentOptions
    = CSSMatrixComponentOptions(Option::None)

pub ext fun CSSMatrixComponentOptions::from_js(value: JsValue) -> mut CSSMatrixComponentOptions = "
    const r = {};
    r.m_is_2d = #fun(Option::from_js[Bool])(#var(value).is2D);
    return r;
"

pub ext fun CSSMatrixComponentOptions::as_js(self: CSSMatrixComponentOptions) -> JsValue = "
    const r = {};
    r.is2D = #fun(Option::as_js_undef[Bool])(#var(self).m_is_2d);
    return r;
"

struct CSSNumericArray()

pub ext fun CSSNumericArray::length(self: CSSNumericArray) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSNumericArray::get(__self: CSSNumericArray, index: Int) -> mut CSSNumericValue = "
    const r = CSSNumericArray[#fun(Int::as_js)(#var(index))];
    return #fun(CSSNumericValue::from_js)(r);
"

pub fun CSSNumericArray::as_js(self: CSSNumericArray) -> JsValue = JsValue::unsafe_from[CSSNumericArray](self)

pub fun CSSNumericArray::from_js(v: JsValue) -> mut CSSNumericArray = JsValue::unsafe_as[mut CSSNumericArray](v)

pub val CSSNumericBaseType::Length: String = "length"
pub val CSSNumericBaseType::Angle: String = "angle"
pub val CSSNumericBaseType::Time: String = "time"
pub val CSSNumericBaseType::Frequency: String = "frequency"
pub val CSSNumericBaseType::Resolution: String = "resolution"
pub val CSSNumericBaseType::Flex: String = "flex"
pub val CSSNumericBaseType::Percent: String = "percent"

pub struct CSSNumericType(
    length: Option[Int],
    angle: Option[Int],
    time: Option[Int],
    frequency: Option[Int],
    resolution: Option[Int],
    flex: Option[Int],
    percent: Option[Int],
    percent_hint: Option[String]
)

pub fun CSSNumericType::default() -> mut CSSNumericType
    = CSSNumericType(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun CSSNumericType::from_js(value: JsValue) -> mut CSSNumericType = "
    const r = {};
    r.m_length = #fun(Option::from_js[Int])(#var(value).length);
    r.m_angle = #fun(Option::from_js[Int])(#var(value).angle);
    r.m_time = #fun(Option::from_js[Int])(#var(value).time);
    r.m_frequency = #fun(Option::from_js[Int])(#var(value).frequency);
    r.m_resolution = #fun(Option::from_js[Int])(#var(value).resolution);
    r.m_flex = #fun(Option::from_js[Int])(#var(value).flex);
    r.m_percent = #fun(Option::from_js[Int])(#var(value).percent);
    r.m_percent_hint = #fun(Option::from_js[String])(#var(value).percentHint);
    return r;
"

pub ext fun CSSNumericType::as_js(self: CSSNumericType) -> JsValue = "
    const r = {};
    r.length = #fun(Option::as_js_undef[Int])(#var(self).m_length);
    r.angle = #fun(Option::as_js_undef[Int])(#var(self).m_angle);
    r.time = #fun(Option::as_js_undef[Int])(#var(self).m_time);
    r.frequency = #fun(Option::as_js_undef[Int])(#var(self).m_frequency);
    r.resolution = #fun(Option::as_js_undef[Int])(#var(self).m_resolution);
    r.flex = #fun(Option::as_js_undef[Int])(#var(self).m_flex);
    r.percent = #fun(Option::as_js_undef[Int])(#var(self).m_percent);
    r.percentHint = #fun(Option::as_js_undef[String])(#var(self).m_percent_hint);
    return r;
"

struct CSSNumericValue()

/// Converts a reference to 'CSSNumericValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNumericValue::as_css_style_value(self: CSSNumericValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNumericValue::as_mcss_style_value(self: mut CSSNumericValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSNumericValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNumericValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNumericValue::from_css_style_value(base: CSSStyleValue) -> CSSNumericValue = "
    if(#var(base) instanceof CSSNumericValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSNumericValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSNumericValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSNumericValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSNumericValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSNumericValue = "
    if(#var(base) instanceof CSSNumericValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSNumericValue'!\");
"

pub ext fun CSSNumericValue::add(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::sub(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::mul(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::div(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::min(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::max(__self: mut CSSNumericValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::equals(__self: mut CSSNumericValue, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSNumericValue::to(__self: mut CSSNumericValue, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSNumericValue::to_sum(__self: mut CSSNumericValue, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSNumericValue::type(__self: mut CSSNumericValue) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSNumericValue::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSNumericValue.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSNumericValue::as_string(__self: mut CSSNumericValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSNumericValue::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSNumericValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSNumericValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSNumericValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSNumericValue::as_js(self: CSSNumericValue) -> JsValue = JsValue::unsafe_from[CSSNumericValue](self)

pub fun CSSNumericValue::from_js(v: JsValue) -> mut CSSNumericValue = JsValue::unsafe_as[mut CSSNumericValue](v)

struct CSSPerspective()

/// Converts a reference to 'CSSPerspective' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPerspective::as_css_transform_component(self: CSSPerspective) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSPerspective' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPerspective::as_mcss_transform_component(self: mut CSSPerspective) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSPerspective'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPerspective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPerspective::from_css_transform_component(base: CSSTransformComponent) -> CSSPerspective = "
    if(#var(base) instanceof CSSPerspective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSPerspective'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSPerspective'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPerspective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPerspective::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSPerspective = "
    if(#var(base) instanceof CSSPerspective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSPerspective'!\");
"

pub ext fun CSSPerspective::from_any(length: JsValue) -> mut CSSPerspective
    = "return new CSSPerspective(#var(length));"

pub ext fun CSSPerspective::length(self: CSSPerspective) -> JsValue
    = "return #var(self).length;"

pub ext fun CSSPerspective::set_length(self: mut CSSPerspective, value: JsValue)
    = "#var(self).length = #var(value);"

pub ext fun CSSPerspective::is_2d(self: CSSPerspective) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSPerspective::set_is_2d(self: mut CSSPerspective, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSPerspective::as_string(__self: mut CSSPerspective) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSPerspective::to_matrix(__self: mut CSSPerspective) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSPerspective::as_js(self: CSSPerspective) -> JsValue = JsValue::unsafe_from[CSSPerspective](self)

pub fun CSSPerspective::from_js(v: JsValue) -> mut CSSPerspective = JsValue::unsafe_as[mut CSSPerspective](v)

struct CSSPositionValue()

/// Converts a reference to 'CSSPositionValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionValue::as_css_style_value(self: CSSPositionValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSPositionValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionValue::as_mcss_style_value(self: mut CSSPositionValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSPositionValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionValue::from_css_style_value(base: CSSStyleValue) -> CSSPositionValue = "
    if(#var(base) instanceof CSSPositionValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSPositionValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSPositionValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSPositionValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSPositionValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSPositionValue = "
    if(#var(base) instanceof CSSPositionValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSPositionValue'!\");
"

pub ext fun CSSPositionValue::from_mcss_numeric_value_mcss_numeric_value(x: mut CSSNumericValue, y: mut CSSNumericValue) -> mut CSSPositionValue
    = "return new CSSPositionValue(#fun(CSSNumericValue::as_js)(#var(x)), #fun(CSSNumericValue::as_js)(#var(y)));"

pub ext fun CSSPositionValue::x(self: CSSPositionValue) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).x);"

pub ext fun CSSPositionValue::set_x(self: mut CSSPositionValue, value: mut CSSNumericValue)
    = "#var(self).x = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSPositionValue::y(self: CSSPositionValue) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).y);"

pub ext fun CSSPositionValue::set_y(self: mut CSSPositionValue, value: mut CSSNumericValue)
    = "#var(self).y = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSPositionValue::as_string(__self: mut CSSPositionValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSPositionValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSPositionValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSPositionValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSPositionValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSPositionValue::as_js(self: CSSPositionValue) -> JsValue = JsValue::unsafe_from[CSSPositionValue](self)

pub fun CSSPositionValue::from_js(v: JsValue) -> mut CSSPositionValue = JsValue::unsafe_as[mut CSSPositionValue](v)

struct CSSRGB()

/// Converts a reference to 'CSSRGB' to a reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRGB::as_css_color_value(self: CSSRGB) -> CSSColorValue = "return #var(self);"

/// Converts a mutable reference to 'CSSRGB' to a mutable reference to 'CSSColorValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRGB::as_mcss_color_value(self: mut CSSRGB) -> mut CSSColorValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSColorValue' to a reference to 'CSSRGB'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSRGB' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRGB::from_css_color_value(base: CSSColorValue) -> CSSRGB = "
    if(#var(base) instanceof CSSRGB) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSRGB'!\");
"

/// Attempts to convert a mutable reference to 'CSSColorValue' to a mutable reference to 'CSSRGB'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSRGB' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRGB::from_mcss_color_value(base: mut CSSColorValue) -> mut CSSRGB = "
    if(#var(base) instanceof CSSRGB) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSColorValue' to 'CSSRGB'!\");
"

pub ext fun CSSRGB::from_any_any_any_any(r: JsValue, g: JsValue, b: JsValue, alpha: JsValue) -> mut CSSRGB
    = "return new CSSRGB(#var(r), #var(g), #var(b), #var(alpha));"

pub ext fun CSSRGB::r(self: CSSRGB) -> JsValue
    = "return #var(self).r;"

pub ext fun CSSRGB::set_r(self: mut CSSRGB, value: JsValue)
    = "#var(self).r = #var(value);"

pub ext fun CSSRGB::g(self: CSSRGB) -> JsValue
    = "return #var(self).g;"

pub ext fun CSSRGB::set_g(self: mut CSSRGB, value: JsValue)
    = "#var(self).g = #var(value);"

pub ext fun CSSRGB::b(self: CSSRGB) -> JsValue
    = "return #var(self).b;"

pub ext fun CSSRGB::set_b(self: mut CSSRGB, value: JsValue)
    = "#var(self).b = #var(value);"

pub ext fun CSSRGB::alpha(self: CSSRGB) -> JsValue
    = "return #var(self).alpha;"

pub ext fun CSSRGB::set_alpha(self: mut CSSRGB, value: JsValue)
    = "#var(self).alpha = #var(value);"

pub ext fun CSSRGB::to_rgb(__self: mut CSSRGB) -> mut CSSRGB = "
    const r = #var(__self).toRGB();
    return #fun(CSSRGB::from_js)(r);
"

pub ext fun CSSRGB::to_hsl(__self: mut CSSRGB) -> mut CSSHSL = "
    const r = #var(__self).toHSL();
    return #fun(CSSHSL::from_js)(r);
"

pub ext fun CSSRGB::to_hwb(__self: mut CSSRGB) -> mut CSSHWB = "
    const r = #var(__self).toHWB();
    return #fun(CSSHWB::from_js)(r);
"

pub ext fun CSSRGB::parse(css_text: String) -> JsValue = "
    const r = CSSRGB.parse(#fun(String::as_js)(#var(css_text)));
    return r;
"

pub fun CSSRGB::as_js(self: CSSRGB) -> JsValue = JsValue::unsafe_from[CSSRGB](self)

pub fun CSSRGB::from_js(v: JsValue) -> mut CSSRGB = JsValue::unsafe_as[mut CSSRGB](v)

struct CSSRotate()

/// Converts a reference to 'CSSRotate' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRotate::as_css_transform_component(self: CSSRotate) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSRotate' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRotate::as_mcss_transform_component(self: mut CSSRotate) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSRotate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSRotate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRotate::from_css_transform_component(base: CSSTransformComponent) -> CSSRotate = "
    if(#var(base) instanceof CSSRotate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSRotate'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSRotate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSRotate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSRotate::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSRotate = "
    if(#var(base) instanceof CSSRotate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSRotate'!\");
"

pub ext fun CSSRotate::from_mcss_numeric_value(angle_value: mut CSSNumericValue) -> mut CSSRotate
    = "return new CSSRotate(#fun(CSSNumericValue::as_js)(#var(angle_value)));"

pub ext fun CSSRotate::from_any_any_any_mcss_numeric_value(x: JsValue, y: JsValue, z: JsValue, angle: mut CSSNumericValue) -> mut CSSRotate
    = "return new CSSRotate(#var(x), #var(y), #var(z), #fun(CSSNumericValue::as_js)(#var(angle)));"

pub ext fun CSSRotate::angle(self: CSSRotate) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).angle);"

pub ext fun CSSRotate::set_angle(self: mut CSSRotate, value: mut CSSNumericValue)
    = "#var(self).angle = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSRotate::x(self: CSSRotate) -> JsValue
    = "return #var(self).x;"

pub ext fun CSSRotate::set_x(self: mut CSSRotate, value: JsValue)
    = "#var(self).x = #var(value);"

pub ext fun CSSRotate::y(self: CSSRotate) -> JsValue
    = "return #var(self).y;"

pub ext fun CSSRotate::set_y(self: mut CSSRotate, value: JsValue)
    = "#var(self).y = #var(value);"

pub ext fun CSSRotate::z(self: CSSRotate) -> JsValue
    = "return #var(self).z;"

pub ext fun CSSRotate::set_z(self: mut CSSRotate, value: JsValue)
    = "#var(self).z = #var(value);"

pub ext fun CSSRotate::is_2d(self: CSSRotate) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSRotate::set_is_2d(self: mut CSSRotate, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSRotate::as_string(__self: mut CSSRotate) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSRotate::to_matrix(__self: mut CSSRotate) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSRotate::as_js(self: CSSRotate) -> JsValue = JsValue::unsafe_from[CSSRotate](self)

pub fun CSSRotate::from_js(v: JsValue) -> mut CSSRotate = JsValue::unsafe_as[mut CSSRotate](v)

struct CSSScale()

/// Converts a reference to 'CSSScale' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScale::as_css_transform_component(self: CSSScale) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSScale' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScale::as_mcss_transform_component(self: mut CSSScale) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSScale'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScale' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScale::from_css_transform_component(base: CSSTransformComponent) -> CSSScale = "
    if(#var(base) instanceof CSSScale) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSScale'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSScale'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSScale' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSScale::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSScale = "
    if(#var(base) instanceof CSSScale) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSScale'!\");
"

pub ext fun CSSScale::from_any_any_any(x: JsValue, y: JsValue, z: JsValue) -> mut CSSScale
    = "return new CSSScale(#var(x), #var(y), #var(z));"

pub ext fun CSSScale::x(self: CSSScale) -> JsValue
    = "return #var(self).x;"

pub ext fun CSSScale::set_x(self: mut CSSScale, value: JsValue)
    = "#var(self).x = #var(value);"

pub ext fun CSSScale::y(self: CSSScale) -> JsValue
    = "return #var(self).y;"

pub ext fun CSSScale::set_y(self: mut CSSScale, value: JsValue)
    = "#var(self).y = #var(value);"

pub ext fun CSSScale::z(self: CSSScale) -> JsValue
    = "return #var(self).z;"

pub ext fun CSSScale::set_z(self: mut CSSScale, value: JsValue)
    = "#var(self).z = #var(value);"

pub ext fun CSSScale::is_2d(self: CSSScale) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSScale::set_is_2d(self: mut CSSScale, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSScale::as_string(__self: mut CSSScale) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSScale::to_matrix(__self: mut CSSScale) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSScale::as_js(self: CSSScale) -> JsValue = JsValue::unsafe_from[CSSScale](self)

pub fun CSSScale::from_js(v: JsValue) -> mut CSSScale = JsValue::unsafe_as[mut CSSScale](v)

struct CSSSkew()

/// Converts a reference to 'CSSSkew' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkew::as_css_transform_component(self: CSSSkew) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSSkew' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkew::as_mcss_transform_component(self: mut CSSSkew) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSSkew'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkew' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkew::from_css_transform_component(base: CSSTransformComponent) -> CSSSkew = "
    if(#var(base) instanceof CSSSkew) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkew'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSSkew'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkew' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkew::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSSkew = "
    if(#var(base) instanceof CSSSkew) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkew'!\");
"

pub ext fun CSSSkew::from_mcss_numeric_value_mcss_numeric_value(ax: mut CSSNumericValue, ay: mut CSSNumericValue) -> mut CSSSkew
    = "return new CSSSkew(#fun(CSSNumericValue::as_js)(#var(ax)), #fun(CSSNumericValue::as_js)(#var(ay)));"

pub ext fun CSSSkew::ax(self: CSSSkew) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).ax);"

pub ext fun CSSSkew::set_ax(self: mut CSSSkew, value: mut CSSNumericValue)
    = "#var(self).ax = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSSkew::ay(self: CSSSkew) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).ay);"

pub ext fun CSSSkew::set_ay(self: mut CSSSkew, value: mut CSSNumericValue)
    = "#var(self).ay = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSSkew::is_2d(self: CSSSkew) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSSkew::set_is_2d(self: mut CSSSkew, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSSkew::as_string(__self: mut CSSSkew) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSSkew::to_matrix(__self: mut CSSSkew) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSSkew::as_js(self: CSSSkew) -> JsValue = JsValue::unsafe_from[CSSSkew](self)

pub fun CSSSkew::from_js(v: JsValue) -> mut CSSSkew = JsValue::unsafe_as[mut CSSSkew](v)

struct CSSSkewX()

/// Converts a reference to 'CSSSkewX' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewX::as_css_transform_component(self: CSSSkewX) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSSkewX' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewX::as_mcss_transform_component(self: mut CSSSkewX) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSSkewX'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkewX' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewX::from_css_transform_component(base: CSSTransformComponent) -> CSSSkewX = "
    if(#var(base) instanceof CSSSkewX) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkewX'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSSkewX'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkewX' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewX::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSSkewX = "
    if(#var(base) instanceof CSSSkewX) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkewX'!\");
"

pub ext fun CSSSkewX::from_mcss_numeric_value(ax: mut CSSNumericValue) -> mut CSSSkewX
    = "return new CSSSkewX(#fun(CSSNumericValue::as_js)(#var(ax)));"

pub ext fun CSSSkewX::ax(self: CSSSkewX) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).ax);"

pub ext fun CSSSkewX::set_ax(self: mut CSSSkewX, value: mut CSSNumericValue)
    = "#var(self).ax = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSSkewX::is_2d(self: CSSSkewX) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSSkewX::set_is_2d(self: mut CSSSkewX, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSSkewX::as_string(__self: mut CSSSkewX) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSSkewX::to_matrix(__self: mut CSSSkewX) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSSkewX::as_js(self: CSSSkewX) -> JsValue = JsValue::unsafe_from[CSSSkewX](self)

pub fun CSSSkewX::from_js(v: JsValue) -> mut CSSSkewX = JsValue::unsafe_as[mut CSSSkewX](v)

struct CSSSkewY()

/// Converts a reference to 'CSSSkewY' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewY::as_css_transform_component(self: CSSSkewY) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSSkewY' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewY::as_mcss_transform_component(self: mut CSSSkewY) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSSkewY'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkewY' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewY::from_css_transform_component(base: CSSTransformComponent) -> CSSSkewY = "
    if(#var(base) instanceof CSSSkewY) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkewY'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSSkewY'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSSkewY' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSSkewY::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSSkewY = "
    if(#var(base) instanceof CSSSkewY) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSSkewY'!\");
"

pub ext fun CSSSkewY::from_mcss_numeric_value(ay: mut CSSNumericValue) -> mut CSSSkewY
    = "return new CSSSkewY(#fun(CSSNumericValue::as_js)(#var(ay)));"

pub ext fun CSSSkewY::ay(self: CSSSkewY) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).ay);"

pub ext fun CSSSkewY::set_ay(self: mut CSSSkewY, value: mut CSSNumericValue)
    = "#var(self).ay = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSSkewY::is_2d(self: CSSSkewY) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSSkewY::set_is_2d(self: mut CSSSkewY, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSSkewY::as_string(__self: mut CSSSkewY) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSSkewY::to_matrix(__self: mut CSSSkewY) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSSkewY::as_js(self: CSSSkewY) -> JsValue = JsValue::unsafe_from[CSSSkewY](self)

pub fun CSSSkewY::from_js(v: JsValue) -> mut CSSSkewY = JsValue::unsafe_as[mut CSSSkewY](v)

struct CSSStyleValue()

pub ext fun CSSStyleValue::as_string(__self: mut CSSStyleValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSStyleValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSStyleValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSStyleValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSStyleValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSStyleValue::as_js(self: CSSStyleValue) -> JsValue = JsValue::unsafe_from[CSSStyleValue](self)

pub fun CSSStyleValue::from_js(v: JsValue) -> mut CSSStyleValue = JsValue::unsafe_as[mut CSSStyleValue](v)

struct CSSTransformComponent()

pub ext fun CSSTransformComponent::is_2d(self: CSSTransformComponent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSTransformComponent::set_is_2d(self: mut CSSTransformComponent, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSTransformComponent::as_string(__self: mut CSSTransformComponent) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSTransformComponent::to_matrix(__self: mut CSSTransformComponent) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSTransformComponent::as_js(self: CSSTransformComponent) -> JsValue = JsValue::unsafe_from[CSSTransformComponent](self)

pub fun CSSTransformComponent::from_js(v: JsValue) -> mut CSSTransformComponent = JsValue::unsafe_as[mut CSSTransformComponent](v)

struct CSSTransformValue()

/// Converts a reference to 'CSSTransformValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransformValue::as_css_style_value(self: CSSTransformValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSTransformValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransformValue::as_mcss_style_value(self: mut CSSTransformValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSTransformValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransformValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransformValue::from_css_style_value(base: CSSStyleValue) -> CSSTransformValue = "
    if(#var(base) instanceof CSSTransformValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSTransformValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSTransformValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTransformValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTransformValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSTransformValue = "
    if(#var(base) instanceof CSSTransformValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSTransformValue'!\");
"

pub ext fun CSSTransformValue::from_list_mcss_transform_component(transforms: List[mut CSSTransformComponent]) -> mut CSSTransformValue
    = "return new CSSTransformValue(#fun(List::as_js[mut CSSTransformComponent])(#var(transforms)));"

pub ext fun CSSTransformValue::length(self: CSSTransformValue) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSTransformValue::is_2d(self: CSSTransformValue) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSTransformValue::get(__self: CSSTransformValue, index: Int) -> mut CSSTransformComponent = "
    const r = CSSTransformValue[#fun(Int::as_js)(#var(index))];
    return #fun(CSSTransformComponent::from_js)(r);
"

pub ext fun CSSTransformValue::set(__self: mut CSSTransformValue, index: Int, val_: mut CSSTransformComponent) = "
    CSSTransformValue[#fun(Int::as_js)(#var(index))] = #fun(CSSTransformComponent::as_js)(#var(val_));
"

pub ext fun CSSTransformValue::to_matrix(__self: mut CSSTransformValue) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun CSSTransformValue::as_string(__self: mut CSSTransformValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSTransformValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSTransformValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSTransformValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSTransformValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSTransformValue::as_js(self: CSSTransformValue) -> JsValue = JsValue::unsafe_from[CSSTransformValue](self)

pub fun CSSTransformValue::from_js(v: JsValue) -> mut CSSTransformValue = JsValue::unsafe_as[mut CSSTransformValue](v)

struct CSSTranslate()

/// Converts a reference to 'CSSTranslate' to a reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTranslate::as_css_transform_component(self: CSSTranslate) -> CSSTransformComponent = "return #var(self);"

/// Converts a mutable reference to 'CSSTranslate' to a mutable reference to 'CSSTransformComponent'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTranslate::as_mcss_transform_component(self: mut CSSTranslate) -> mut CSSTransformComponent = "return #var(self);"

/// Attempts to convert a reference to 'CSSTransformComponent' to a reference to 'CSSTranslate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTranslate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTranslate::from_css_transform_component(base: CSSTransformComponent) -> CSSTranslate = "
    if(#var(base) instanceof CSSTranslate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSTranslate'!\");
"

/// Attempts to convert a mutable reference to 'CSSTransformComponent' to a mutable reference to 'CSSTranslate'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSTranslate' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSTranslate::from_mcss_transform_component(base: mut CSSTransformComponent) -> mut CSSTranslate = "
    if(#var(base) instanceof CSSTranslate) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSTransformComponent' to 'CSSTranslate'!\");
"

pub ext fun CSSTranslate::from_mcss_numeric_value_mcss_numeric_value_mcss_numeric_value(x: mut CSSNumericValue, y: mut CSSNumericValue, z: mut CSSNumericValue) -> mut CSSTranslate
    = "return new CSSTranslate(#fun(CSSNumericValue::as_js)(#var(x)), #fun(CSSNumericValue::as_js)(#var(y)), #fun(CSSNumericValue::as_js)(#var(z)));"

pub ext fun CSSTranslate::x(self: CSSTranslate) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).x);"

pub ext fun CSSTranslate::set_x(self: mut CSSTranslate, value: mut CSSNumericValue)
    = "#var(self).x = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSTranslate::y(self: CSSTranslate) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).y);"

pub ext fun CSSTranslate::set_y(self: mut CSSTranslate, value: mut CSSNumericValue)
    = "#var(self).y = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSTranslate::z(self: CSSTranslate) -> mut CSSNumericValue
    = "return #fun(CSSNumericValue::from_js)(#var(self).z);"

pub ext fun CSSTranslate::set_z(self: mut CSSTranslate, value: mut CSSNumericValue)
    = "#var(self).z = #fun(CSSNumericValue::as_js)(#var(value));"

pub ext fun CSSTranslate::is_2d(self: CSSTranslate) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun CSSTranslate::set_is_2d(self: mut CSSTranslate, value: Bool)
    = "#var(self).is2D = #fun(Bool::as_js)(#var(value));"

pub ext fun CSSTranslate::as_string(__self: mut CSSTranslate) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSTranslate::to_matrix(__self: mut CSSTranslate) -> mut DOMMatrix = "
    const r = #var(__self).toMatrix();
    return #fun(DOMMatrix::from_js)(r);
"

pub fun CSSTranslate::as_js(self: CSSTranslate) -> JsValue = JsValue::unsafe_from[CSSTranslate](self)

pub fun CSSTranslate::from_js(v: JsValue) -> mut CSSTranslate = JsValue::unsafe_as[mut CSSTranslate](v)

struct CSSUnitValue()

/// Converts a reference to 'CSSUnitValue' to a reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::as_css_numeric_value(self: CSSUnitValue) -> CSSNumericValue = "return #var(self);"

/// Converts a mutable reference to 'CSSUnitValue' to a mutable reference to 'CSSNumericValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::as_mcss_numeric_value(self: mut CSSUnitValue) -> mut CSSNumericValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSNumericValue' to a reference to 'CSSUnitValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnitValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::from_css_numeric_value(base: CSSNumericValue) -> CSSUnitValue = "
    if(#var(base) instanceof CSSUnitValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSUnitValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSNumericValue' to a mutable reference to 'CSSUnitValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnitValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::from_mcss_numeric_value(base: mut CSSNumericValue) -> mut CSSUnitValue = "
    if(#var(base) instanceof CSSUnitValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSNumericValue' to 'CSSUnitValue'!\");
"

/// Converts a reference to 'CSSUnitValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::as_css_style_value(self: CSSUnitValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSUnitValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::as_mcss_style_value(self: mut CSSUnitValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSUnitValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnitValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::from_css_style_value(base: CSSStyleValue) -> CSSUnitValue = "
    if(#var(base) instanceof CSSUnitValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSUnitValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSUnitValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnitValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnitValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSUnitValue = "
    if(#var(base) instanceof CSSUnitValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSUnitValue'!\");
"

pub ext fun CSSUnitValue::from_flt_str(value: Float, unit_: String) -> mut CSSUnitValue
    = "return new CSSUnitValue(#fun(Float::as_js)(#var(value)), #fun(String::as_js)(#var(unit_)));"

pub ext fun CSSUnitValue::value(self: CSSUnitValue) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun CSSUnitValue::set_value(self: mut CSSUnitValue, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub ext fun CSSUnitValue::unit_(self: CSSUnitValue) -> String
    = "return #fun(String::from_js)(#var(self).unit);"

pub ext fun CSSUnitValue::add(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).add(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::sub(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).sub(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::mul(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).mul(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::div(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).div(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::min(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).min(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::max(__self: mut CSSUnitValue, ...values: List[JsValue]) -> mut CSSNumericValue = "
    const r = #var(__self).max(...((#var(values)).map(v => v)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::equals(__self: mut CSSUnitValue, ...values: List[JsValue]) -> Bool = "
    const r = #var(__self).equals(...((#var(values)).map(v => v)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CSSUnitValue::to(__self: mut CSSUnitValue, unit_: String) -> mut CSSUnitValue = "
    const r = #var(__self).to(#fun(String::as_js)(#var(unit_)));
    return #fun(CSSUnitValue::from_js)(r);
"

pub ext fun CSSUnitValue::to_sum(__self: mut CSSUnitValue, ...units: List[String]) -> mut CSSMathSum = "
    const r = #var(__self).toSum(...((#var(units)).map(v => #fun(String::as_js)(v))));
    return #fun(CSSMathSum::from_js)(r);
"

pub ext fun CSSUnitValue::type(__self: mut CSSUnitValue) -> mut CSSNumericType = "
    const r = #var(__self).type();
    return #fun(CSSNumericType::from_js)(r);
"

pub ext fun CSSUnitValue::parse_str(css_text: String) -> mut CSSNumericValue = "
    const r = CSSUnitValue.parse(#fun(String::as_js)(#var(css_text)));
    return #fun(CSSNumericValue::from_js)(r);
"

pub ext fun CSSUnitValue::as_string(__self: mut CSSUnitValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSUnitValue::parse_str_str(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSUnitValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSUnitValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSUnitValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSUnitValue::as_js(self: CSSUnitValue) -> JsValue = JsValue::unsafe_from[CSSUnitValue](self)

pub fun CSSUnitValue::from_js(v: JsValue) -> mut CSSUnitValue = JsValue::unsafe_as[mut CSSUnitValue](v)

// TODO: Definitions of type 'namespace'

struct CSSUnparsedValue()

/// Converts a reference to 'CSSUnparsedValue' to a reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnparsedValue::as_css_style_value(self: CSSUnparsedValue) -> CSSStyleValue = "return #var(self);"

/// Converts a mutable reference to 'CSSUnparsedValue' to a mutable reference to 'CSSStyleValue'.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnparsedValue::as_mcss_style_value(self: mut CSSUnparsedValue) -> mut CSSStyleValue = "return #var(self);"

/// Attempts to convert a reference to 'CSSStyleValue' to a reference to 'CSSUnparsedValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnparsedValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnparsedValue::from_css_style_value(base: CSSStyleValue) -> CSSUnparsedValue = "
    if(#var(base) instanceof CSSUnparsedValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSUnparsedValue'!\");
"

/// Attempts to convert a mutable reference to 'CSSStyleValue' to a mutable reference to 'CSSUnparsedValue'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSSUnparsedValue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSSUnparsedValue::from_mcss_style_value(base: mut CSSStyleValue) -> mut CSSUnparsedValue = "
    if(#var(base) instanceof CSSUnparsedValue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CSSStyleValue' to 'CSSUnparsedValue'!\");
"

pub ext fun CSSUnparsedValue::from_list_any(members: List[JsValue]) -> mut CSSUnparsedValue
    = "return new CSSUnparsedValue(#fun(List::as_js[JsValue])(#var(members)));"

pub ext fun CSSUnparsedValue::length(self: CSSUnparsedValue) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CSSUnparsedValue::get(__self: CSSUnparsedValue, index: Int) -> JsValue = "
    const r = CSSUnparsedValue[#fun(Int::as_js)(#var(index))];
    return r;
"

pub ext fun CSSUnparsedValue::set(__self: mut CSSUnparsedValue, index: Int, val_: JsValue) = "
    CSSUnparsedValue[#fun(Int::as_js)(#var(index))] = #var(val_);
"

pub ext fun CSSUnparsedValue::as_string(__self: mut CSSUnparsedValue) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun CSSUnparsedValue::parse(property: String, css_text: String) -> mut CSSStyleValue = "
    const r = CSSUnparsedValue.parse(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(CSSStyleValue::from_js)(r);
"

pub ext fun CSSUnparsedValue::parse_all(property: String, css_text: String) -> List[mut CSSStyleValue] = "
    const r = CSSUnparsedValue.parseAll(#fun(String::as_js)(#var(property)), #fun(String::as_js)(#var(css_text)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub fun CSSUnparsedValue::as_js(self: CSSUnparsedValue) -> JsValue = JsValue::unsafe_from[CSSUnparsedValue](self)

pub fun CSSUnparsedValue::from_js(v: JsValue) -> mut CSSUnparsedValue = JsValue::unsafe_as[mut CSSUnparsedValue](v)

struct CSSVariableReferenceValue()

pub ext fun CSSVariableReferenceValue::from_str_omcss_unparsed_value(variable: String, fallback: Option[mut CSSUnparsedValue]) -> mut CSSVariableReferenceValue
    = "return new CSSVariableReferenceValue(#fun(String::as_js)(#var(variable)), #fun(Option::as_js[mut CSSUnparsedValue])(#var(fallback)));"

pub ext fun CSSVariableReferenceValue::variable(self: CSSVariableReferenceValue) -> String
    = "return #fun(String::from_js)(#var(self).variable);"

pub ext fun CSSVariableReferenceValue::set_variable(self: mut CSSVariableReferenceValue, value: String)
    = "#var(self).variable = #fun(String::as_js)(#var(value));"

pub ext fun CSSVariableReferenceValue::fallback(self: CSSVariableReferenceValue) -> Option[mut CSSUnparsedValue]
    = "return #fun(Option::from_js[mut CSSUnparsedValue])(#var(self).fallback);"

pub fun CSSVariableReferenceValue::as_js(self: CSSVariableReferenceValue) -> JsValue = JsValue::unsafe_from[CSSVariableReferenceValue](self)

pub fun CSSVariableReferenceValue::from_js(v: JsValue) -> mut CSSVariableReferenceValue = JsValue::unsafe_as[mut CSSVariableReferenceValue](v)

struct Element()

pub ext fun Element::role(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).role);"

pub ext fun Element::set_role(self: mut Element, value: Option[String])
    = "#var(self).role = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_atomic(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaAtomic);"

pub ext fun Element::set_aria_atomic(self: mut Element, value: Option[String])
    = "#var(self).ariaAtomic = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_auto_complete(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaAutoComplete);"

pub ext fun Element::set_aria_auto_complete(self: mut Element, value: Option[String])
    = "#var(self).ariaAutoComplete = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_busy(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBusy);"

pub ext fun Element::set_aria_busy(self: mut Element, value: Option[String])
    = "#var(self).ariaBusy = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_braille_label(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBrailleLabel);"

pub ext fun Element::set_aria_braille_label(self: mut Element, value: Option[String])
    = "#var(self).ariaBrailleLabel = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_braille_role_description(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBrailleRoleDescription);"

pub ext fun Element::set_aria_braille_role_description(self: mut Element, value: Option[String])
    = "#var(self).ariaBrailleRoleDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_checked(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaChecked);"

pub ext fun Element::set_aria_checked(self: mut Element, value: Option[String])
    = "#var(self).ariaChecked = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_col_count(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColCount);"

pub ext fun Element::set_aria_col_count(self: mut Element, value: Option[String])
    = "#var(self).ariaColCount = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_col_index(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColIndex);"

pub ext fun Element::set_aria_col_index(self: mut Element, value: Option[String])
    = "#var(self).ariaColIndex = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_col_index_text(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColIndexText);"

pub ext fun Element::set_aria_col_index_text(self: mut Element, value: Option[String])
    = "#var(self).ariaColIndexText = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_col_span(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColSpan);"

pub ext fun Element::set_aria_col_span(self: mut Element, value: Option[String])
    = "#var(self).ariaColSpan = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_current(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaCurrent);"

pub ext fun Element::set_aria_current(self: mut Element, value: Option[String])
    = "#var(self).ariaCurrent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_description(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaDescription);"

pub ext fun Element::set_aria_description(self: mut Element, value: Option[String])
    = "#var(self).ariaDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_disabled(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaDisabled);"

pub ext fun Element::set_aria_disabled(self: mut Element, value: Option[String])
    = "#var(self).ariaDisabled = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_expanded(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaExpanded);"

pub ext fun Element::set_aria_expanded(self: mut Element, value: Option[String])
    = "#var(self).ariaExpanded = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_has_popup(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaHasPopup);"

pub ext fun Element::set_aria_has_popup(self: mut Element, value: Option[String])
    = "#var(self).ariaHasPopup = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_hidden(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaHidden);"

pub ext fun Element::set_aria_hidden(self: mut Element, value: Option[String])
    = "#var(self).ariaHidden = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_invalid(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaInvalid);"

pub ext fun Element::set_aria_invalid(self: mut Element, value: Option[String])
    = "#var(self).ariaInvalid = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_key_shortcuts(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaKeyShortcuts);"

pub ext fun Element::set_aria_key_shortcuts(self: mut Element, value: Option[String])
    = "#var(self).ariaKeyShortcuts = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_label(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLabel);"

pub ext fun Element::set_aria_label(self: mut Element, value: Option[String])
    = "#var(self).ariaLabel = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_level(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLevel);"

pub ext fun Element::set_aria_level(self: mut Element, value: Option[String])
    = "#var(self).ariaLevel = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_live(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLive);"

pub ext fun Element::set_aria_live(self: mut Element, value: Option[String])
    = "#var(self).ariaLive = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_modal(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaModal);"

pub ext fun Element::set_aria_modal(self: mut Element, value: Option[String])
    = "#var(self).ariaModal = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_multi_line(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaMultiLine);"

pub ext fun Element::set_aria_multi_line(self: mut Element, value: Option[String])
    = "#var(self).ariaMultiLine = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_multi_selectable(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaMultiSelectable);"

pub ext fun Element::set_aria_multi_selectable(self: mut Element, value: Option[String])
    = "#var(self).ariaMultiSelectable = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_orientation(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaOrientation);"

pub ext fun Element::set_aria_orientation(self: mut Element, value: Option[String])
    = "#var(self).ariaOrientation = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_placeholder(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPlaceholder);"

pub ext fun Element::set_aria_placeholder(self: mut Element, value: Option[String])
    = "#var(self).ariaPlaceholder = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_pos_in_set(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPosInSet);"

pub ext fun Element::set_aria_pos_in_set(self: mut Element, value: Option[String])
    = "#var(self).ariaPosInSet = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_pressed(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPressed);"

pub ext fun Element::set_aria_pressed(self: mut Element, value: Option[String])
    = "#var(self).ariaPressed = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_read_only(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaReadOnly);"

pub ext fun Element::set_aria_read_only(self: mut Element, value: Option[String])
    = "#var(self).ariaReadOnly = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_relevant(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRelevant);"

pub ext fun Element::set_aria_relevant(self: mut Element, value: Option[String])
    = "#var(self).ariaRelevant = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_required(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRequired);"

pub ext fun Element::set_aria_required(self: mut Element, value: Option[String])
    = "#var(self).ariaRequired = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_role_description(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRoleDescription);"

pub ext fun Element::set_aria_role_description(self: mut Element, value: Option[String])
    = "#var(self).ariaRoleDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_row_count(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowCount);"

pub ext fun Element::set_aria_row_count(self: mut Element, value: Option[String])
    = "#var(self).ariaRowCount = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_row_index(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowIndex);"

pub ext fun Element::set_aria_row_index(self: mut Element, value: Option[String])
    = "#var(self).ariaRowIndex = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_row_index_text(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowIndexText);"

pub ext fun Element::set_aria_row_index_text(self: mut Element, value: Option[String])
    = "#var(self).ariaRowIndexText = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_row_span(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowSpan);"

pub ext fun Element::set_aria_row_span(self: mut Element, value: Option[String])
    = "#var(self).ariaRowSpan = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_selected(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSelected);"

pub ext fun Element::set_aria_selected(self: mut Element, value: Option[String])
    = "#var(self).ariaSelected = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_set_size(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSetSize);"

pub ext fun Element::set_aria_set_size(self: mut Element, value: Option[String])
    = "#var(self).ariaSetSize = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_sort(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSort);"

pub ext fun Element::set_aria_sort(self: mut Element, value: Option[String])
    = "#var(self).ariaSort = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_value_max(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueMax);"

pub ext fun Element::set_aria_value_max(self: mut Element, value: Option[String])
    = "#var(self).ariaValueMax = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_value_min(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueMin);"

pub ext fun Element::set_aria_value_min(self: mut Element, value: Option[String])
    = "#var(self).ariaValueMin = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_value_now(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueNow);"

pub ext fun Element::set_aria_value_now(self: mut Element, value: Option[String])
    = "#var(self).ariaValueNow = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_value_text(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueText);"

pub ext fun Element::set_aria_value_text(self: mut Element, value: Option[String])
    = "#var(self).ariaValueText = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_virtual_content(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaVirtualContent);"

pub ext fun Element::set_aria_virtual_content(self: mut Element, value: Option[String])
    = "#var(self).ariaVirtualContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::aria_active_descendant_element(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).ariaActiveDescendantElement);"

pub ext fun Element::set_aria_active_descendant_element(self: mut Element, value: Option[mut Element])
    = "#var(self).ariaActiveDescendantElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun Element::aria_controls_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaControlsElements);"

pub ext fun Element::set_aria_controls_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaControlsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_described_by_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaDescribedByElements);"

pub ext fun Element::set_aria_described_by_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaDescribedByElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_details_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaDetailsElements);"

pub ext fun Element::set_aria_details_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaDetailsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_error_message_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaErrorMessageElements);"

pub ext fun Element::set_aria_error_message_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaErrorMessageElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_flow_to_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaFlowToElements);"

pub ext fun Element::set_aria_flow_to_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaFlowToElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_labelled_by_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaLabelledByElements);"

pub ext fun Element::set_aria_labelled_by_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaLabelledByElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::aria_owns_elements(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaOwnsElements);"

pub ext fun Element::set_aria_owns_elements(self: mut Element, value: Option[JsValue])
    = "#var(self).ariaOwnsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::children(self: Element) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun Element::first_element_child(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun Element::last_element_child(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun Element::child_element_count(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun Element::previous_element_sibling(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).previousElementSibling);"

pub ext fun Element::next_element_sibling(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).nextElementSibling);"

pub ext fun Element::computed_style_map(__self: mut Element) -> mut StylePropertyMapReadOnly = "
    const r = #var(__self).computedStyleMap();
    return #fun(StylePropertyMapReadOnly::from_js)(r);
"

pub ext fun Element::animate(__self: mut Element, keyframes: Option[JsObject], options: JsValue) -> mut Animation = "
    const r = #var(__self).animate(#fun(Option::as_js[JsObject])(#var(keyframes)), #var(options));
    return #fun(Animation::from_js)(r);
"

pub ext fun Element::get_animations(__self: mut Element, options: mut GetAnimationsOptions) -> List[mut Animation] = "
    const r = #var(__self).getAnimations(#fun(GetAnimationsOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut Animation])(r);
"

pub ext fun Element::prepend(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::append(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::replace_children(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::move_before(__self: mut Element, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::query_selector(__self: mut Element, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::query_selector_all(__self: mut Element, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Element::before(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::after(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::replace_with(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove(__self: mut Element) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun Element::as_js(self: Element) -> JsValue = JsValue::unsafe_from[Element](self)

pub fun Element::from_js(v: JsValue) -> mut Element = JsValue::unsafe_as[mut Element](v)

struct StylePropertyMap()

/// Converts a reference to 'StylePropertyMap' to a reference to 'StylePropertyMapReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun StylePropertyMap::as_style_property_map_read_only(self: StylePropertyMap) -> StylePropertyMapReadOnly = "return #var(self);"

/// Converts a mutable reference to 'StylePropertyMap' to a mutable reference to 'StylePropertyMapReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun StylePropertyMap::as_mstyle_property_map_read_only(self: mut StylePropertyMap) -> mut StylePropertyMapReadOnly = "return #var(self);"

/// Attempts to convert a reference to 'StylePropertyMapReadOnly' to a reference to 'StylePropertyMap'.
/// The conversion may fail and panic if 'base' is not a reference to 'StylePropertyMap' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StylePropertyMap::from_style_property_map_read_only(base: StylePropertyMapReadOnly) -> StylePropertyMap = "
    if(#var(base) instanceof StylePropertyMap) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'StylePropertyMapReadOnly' to 'StylePropertyMap'!\");
"

/// Attempts to convert a mutable reference to 'StylePropertyMapReadOnly' to a mutable reference to 'StylePropertyMap'.
/// The conversion may fail and panic if 'base' is not a reference to 'StylePropertyMap' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StylePropertyMap::from_mstyle_property_map_read_only(base: mut StylePropertyMapReadOnly) -> mut StylePropertyMap = "
    if(#var(base) instanceof StylePropertyMap) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'StylePropertyMapReadOnly' to 'StylePropertyMap'!\");
"

pub ext fun StylePropertyMap::size(self: StylePropertyMap) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun StylePropertyMap::set(__self: mut StylePropertyMap, property: String, ...values: List[JsValue]) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(property)), ...((#var(values)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun StylePropertyMap::append(__self: mut StylePropertyMap, property: String, ...values: List[JsValue]) -> Unit = "
    const r = #var(__self).append(#fun(String::as_js)(#var(property)), ...((#var(values)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun StylePropertyMap::delete(__self: mut StylePropertyMap, property: String) -> Unit = "
    const r = #var(__self).delete(#fun(String::as_js)(#var(property)));
    return #fun(Unit::from_js)(r);
"

pub ext fun StylePropertyMap::clear(__self: mut StylePropertyMap) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun StylePropertyMap::get(__self: mut StylePropertyMap, property: String) -> Option[mut CSSStyleValue] = "
    const r = #var(__self).get(#fun(String::as_js)(#var(property)));
    return #fun(Option::from_js[mut CSSStyleValue])(r);
"

pub ext fun StylePropertyMap::get_all(__self: mut StylePropertyMap, property: String) -> List[mut CSSStyleValue] = "
    const r = #var(__self).getAll(#fun(String::as_js)(#var(property)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub ext fun StylePropertyMap::has(__self: mut StylePropertyMap, property: String) -> Bool = "
    const r = #var(__self).has(#fun(String::as_js)(#var(property)));
    return #fun(Bool::from_js)(r);
"

pub fun StylePropertyMap::as_js(self: StylePropertyMap) -> JsValue = JsValue::unsafe_from[StylePropertyMap](self)

pub fun StylePropertyMap::from_js(v: JsValue) -> mut StylePropertyMap = JsValue::unsafe_as[mut StylePropertyMap](v)

struct StylePropertyMapReadOnly()

pub ext fun StylePropertyMapReadOnly::size(self: StylePropertyMapReadOnly) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun StylePropertyMapReadOnly::get(__self: mut StylePropertyMapReadOnly, property: String) -> Option[mut CSSStyleValue] = "
    const r = #var(__self).get(#fun(String::as_js)(#var(property)));
    return #fun(Option::from_js[mut CSSStyleValue])(r);
"

pub ext fun StylePropertyMapReadOnly::get_all(__self: mut StylePropertyMapReadOnly, property: String) -> List[mut CSSStyleValue] = "
    const r = #var(__self).getAll(#fun(String::as_js)(#var(property)));
    return #fun(List::from_js[mut CSSStyleValue])(r);
"

pub ext fun StylePropertyMapReadOnly::has(__self: mut StylePropertyMapReadOnly, property: String) -> Bool = "
    const r = #var(__self).has(#fun(String::as_js)(#var(property)));
    return #fun(Bool::from_js)(r);
"

pub fun StylePropertyMapReadOnly::as_js(self: StylePropertyMapReadOnly) -> JsValue = JsValue::unsafe_from[StylePropertyMapReadOnly](self)

pub fun StylePropertyMapReadOnly::from_js(v: JsValue) -> mut StylePropertyMapReadOnly = JsValue::unsafe_as[mut StylePropertyMapReadOnly](v)

pub val FontFaceLoadStatus::Unloaded: String = "unloaded"
pub val FontFaceLoadStatus::Loading: String = "loading"
pub val FontFaceLoadStatus::Loaded: String = "loaded"
pub val FontFaceLoadStatus::Error: String = "error"

struct FontFace()

pub ext fun FontFace::from_str_any_mfont_face_descriptors(family: String, source: JsValue, descriptors: mut FontFaceDescriptors) -> mut FontFace
    = "return new FontFace(#fun(String::as_js)(#var(family)), #var(source), #fun(FontFaceDescriptors::as_js)(#var(descriptors)));"

pub ext fun FontFace::family(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).family);"

pub ext fun FontFace::set_family(self: mut FontFace, value: String)
    = "#var(self).family = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::style(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).style);"

pub ext fun FontFace::set_style(self: mut FontFace, value: String)
    = "#var(self).style = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::weight(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).weight);"

pub ext fun FontFace::set_weight(self: mut FontFace, value: String)
    = "#var(self).weight = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::stretch(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).stretch);"

pub ext fun FontFace::set_stretch(self: mut FontFace, value: String)
    = "#var(self).stretch = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::unicode_range(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).unicodeRange);"

pub ext fun FontFace::set_unicode_range(self: mut FontFace, value: String)
    = "#var(self).unicodeRange = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::variant(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).variant);"

pub ext fun FontFace::set_variant(self: mut FontFace, value: String)
    = "#var(self).variant = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::feature_settings(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).featureSettings);"

pub ext fun FontFace::set_feature_settings(self: mut FontFace, value: String)
    = "#var(self).featureSettings = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::variation_settings(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).variationSettings);"

pub ext fun FontFace::set_variation_settings(self: mut FontFace, value: String)
    = "#var(self).variationSettings = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::display(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).display);"

pub ext fun FontFace::set_display(self: mut FontFace, value: String)
    = "#var(self).display = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::ascent_override(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).ascentOverride);"

pub ext fun FontFace::set_ascent_override(self: mut FontFace, value: String)
    = "#var(self).ascentOverride = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::descent_override(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).descentOverride);"

pub ext fun FontFace::set_descent_override(self: mut FontFace, value: String)
    = "#var(self).descentOverride = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::line_gap_override(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).lineGapOverride);"

pub ext fun FontFace::set_line_gap_override(self: mut FontFace, value: String)
    = "#var(self).lineGapOverride = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::size_adjust(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).sizeAdjust);"

pub ext fun FontFace::set_size_adjust(self: mut FontFace, value: String)
    = "#var(self).sizeAdjust = #fun(String::as_js)(#var(value));"

pub ext fun FontFace::status(self: FontFace) -> String
    = "return #fun(String::from_js)(#var(self).status);"

pub ext fun FontFace::loaded(self: FontFace) -> Promise[mut FontFace]
    = "return #fun(Promise::from_js[mut FontFace])(#var(self).loaded);"

pub ext fun FontFace::load(__self: mut FontFace) -> Promise[mut FontFace] = "
    const r = #var(__self).load();
    return #fun(Promise::from_js[mut FontFace])(r);
"

pub fun FontFace::as_js(self: FontFace) -> JsValue = JsValue::unsafe_from[FontFace](self)

pub fun FontFace::from_js(v: JsValue) -> mut FontFace = JsValue::unsafe_as[mut FontFace](v)

pub struct FontFaceDescriptors(
    style: Option[String],
    weight: Option[String],
    stretch: Option[String],
    unicode_range: Option[String],
    variant: Option[String],
    feature_settings: Option[String],
    variation_settings: Option[String],
    display: Option[String],
    ascent_override: Option[String],
    descent_override: Option[String],
    line_gap_override: Option[String],
    size_adjust: Option[String]
)

pub fun FontFaceDescriptors::default() -> mut FontFaceDescriptors
    = FontFaceDescriptors(Option::Some("normal"), Option::Some("normal"), Option::Some("normal"), Option::Some("U+0-10FFFF"), Option::Some("normal"), Option::Some("normal"), Option::Some("normal"), Option::Some("auto"), Option::Some("normal"), Option::Some("normal"), Option::Some("normal"), Option::Some("100%"))

pub ext fun FontFaceDescriptors::from_js(value: JsValue) -> mut FontFaceDescriptors = "
    const r = {};
    r.m_style = #fun(Option::from_js[String])(#var(value).style);
    r.m_weight = #fun(Option::from_js[String])(#var(value).weight);
    r.m_stretch = #fun(Option::from_js[String])(#var(value).stretch);
    r.m_unicode_range = #fun(Option::from_js[String])(#var(value).unicodeRange);
    r.m_variant = #fun(Option::from_js[String])(#var(value).variant);
    r.m_feature_settings = #fun(Option::from_js[String])(#var(value).featureSettings);
    r.m_variation_settings = #fun(Option::from_js[String])(#var(value).variationSettings);
    r.m_display = #fun(Option::from_js[String])(#var(value).display);
    r.m_ascent_override = #fun(Option::from_js[String])(#var(value).ascentOverride);
    r.m_descent_override = #fun(Option::from_js[String])(#var(value).descentOverride);
    r.m_line_gap_override = #fun(Option::from_js[String])(#var(value).lineGapOverride);
    r.m_size_adjust = #fun(Option::from_js[String])(#var(value).sizeAdjust);
    return r;
"

pub ext fun FontFaceDescriptors::as_js(self: FontFaceDescriptors) -> JsValue = "
    const r = {};
    r.style = #fun(Option::as_js_undef[String])(#var(self).m_style);
    r.weight = #fun(Option::as_js_undef[String])(#var(self).m_weight);
    r.stretch = #fun(Option::as_js_undef[String])(#var(self).m_stretch);
    r.unicodeRange = #fun(Option::as_js_undef[String])(#var(self).m_unicode_range);
    r.variant = #fun(Option::as_js_undef[String])(#var(self).m_variant);
    r.featureSettings = #fun(Option::as_js_undef[String])(#var(self).m_feature_settings);
    r.variationSettings = #fun(Option::as_js_undef[String])(#var(self).m_variation_settings);
    r.display = #fun(Option::as_js_undef[String])(#var(self).m_display);
    r.ascentOverride = #fun(Option::as_js_undef[String])(#var(self).m_ascent_override);
    r.descentOverride = #fun(Option::as_js_undef[String])(#var(self).m_descent_override);
    r.lineGapOverride = #fun(Option::as_js_undef[String])(#var(self).m_line_gap_override);
    r.sizeAdjust = #fun(Option::as_js_undef[String])(#var(self).m_size_adjust);
    return r;
"

pub val FontFaceSetLoadStatus::Loading: String = "loading"
pub val FontFaceSetLoadStatus::Loaded: String = "loaded"

struct FontFaceSet()

/// Converts a reference to 'FontFaceSet' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSet::as_event_target(self: FontFaceSet) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'FontFaceSet' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSet::as_mevent_target(self: mut FontFaceSet) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'FontFaceSet'.
/// The conversion may fail and panic if 'base' is not a reference to 'FontFaceSet' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSet::from_event_target(base: EventTarget) -> FontFaceSet = "
    if(#var(base) instanceof FontFaceSet) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'FontFaceSet'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'FontFaceSet'.
/// The conversion may fail and panic if 'base' is not a reference to 'FontFaceSet' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSet::from_mevent_target(base: mut EventTarget) -> mut FontFaceSet = "
    if(#var(base) instanceof FontFaceSet) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'FontFaceSet'!\");
"

pub ext fun FontFaceSet::onloading(self: FontFaceSet) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloading);"

pub ext fun FontFaceSet::set_onloading(self: mut FontFaceSet, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloading = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FontFaceSet::onloadingdone(self: FontFaceSet) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadingdone);"

pub ext fun FontFaceSet::set_onloadingdone(self: mut FontFaceSet, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadingdone = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FontFaceSet::onloadingerror(self: FontFaceSet) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadingerror);"

pub ext fun FontFaceSet::set_onloadingerror(self: mut FontFaceSet, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadingerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FontFaceSet::ready(self: FontFaceSet) -> Promise[mut FontFaceSet]
    = "return #fun(Promise::from_js[mut FontFaceSet])(#var(self).ready);"

pub ext fun FontFaceSet::status(self: FontFaceSet) -> String
    = "return #fun(String::from_js)(#var(self).status);"

pub ext fun FontFaceSet::load(__self: mut FontFaceSet, font: String, text: String) -> Promise[List[mut FontFace]] = "
    const r = #var(__self).load(#fun(String::as_js)(#var(font)), #fun(String::as_js)(#var(text)));
    return #fun(Promise::from_js[List[mut FontFace]])(r);
"

pub ext fun FontFaceSet::check(__self: mut FontFaceSet, font: String, text: String) -> Bool = "
    const r = #var(__self).check(#fun(String::as_js)(#var(font)), #fun(String::as_js)(#var(text)));
    return #fun(Bool::from_js)(r);
"

pub ext fun FontFaceSet::add_event_listener(__self: mut FontFaceSet, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun FontFaceSet::remove_event_listener(__self: mut FontFaceSet, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun FontFaceSet::dispatch_event(__self: mut FontFaceSet, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun FontFaceSet::when(__self: mut FontFaceSet, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun FontFaceSet::as_js(self: FontFaceSet) -> JsValue = JsValue::unsafe_from[FontFaceSet](self)

pub fun FontFaceSet::from_js(v: JsValue) -> mut FontFaceSet = JsValue::unsafe_as[mut FontFaceSet](v)

struct FontFaceSetLoadEvent()

/// Converts a reference to 'FontFaceSetLoadEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEvent::as_event(self: FontFaceSetLoadEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'FontFaceSetLoadEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEvent::as_mevent(self: mut FontFaceSetLoadEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'FontFaceSetLoadEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FontFaceSetLoadEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEvent::from_event(base: Event) -> FontFaceSetLoadEvent = "
    if(#var(base) instanceof FontFaceSetLoadEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FontFaceSetLoadEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'FontFaceSetLoadEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FontFaceSetLoadEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEvent::from_mevent(base: mut Event) -> mut FontFaceSetLoadEvent = "
    if(#var(base) instanceof FontFaceSetLoadEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FontFaceSetLoadEvent'!\");
"

pub ext fun FontFaceSetLoadEvent::from_str_mfont_face_set_load_event_init(type: String, event_init_dict: mut FontFaceSetLoadEventInit) -> mut FontFaceSetLoadEvent
    = "return new FontFaceSetLoadEvent(#fun(String::as_js)(#var(type)), #fun(FontFaceSetLoadEventInit::as_js)(#var(event_init_dict)));"

pub ext fun FontFaceSetLoadEvent::fontfaces(self: FontFaceSetLoadEvent) -> JsValue
    = "return #var(self).fontfaces;"

pub ext fun FontFaceSetLoadEvent::type(self: FontFaceSetLoadEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun FontFaceSetLoadEvent::target(self: FontFaceSetLoadEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun FontFaceSetLoadEvent::current_target(self: FontFaceSetLoadEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun FontFaceSetLoadEvent::event_phase(self: FontFaceSetLoadEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun FontFaceSetLoadEvent::bubbles(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun FontFaceSetLoadEvent::cancelable(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun FontFaceSetLoadEvent::default_prevented(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun FontFaceSetLoadEvent::composed(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun FontFaceSetLoadEvent::is_trusted(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun FontFaceSetLoadEvent::time_stamp(self: FontFaceSetLoadEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun FontFaceSetLoadEvent::src_element(self: FontFaceSetLoadEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun FontFaceSetLoadEvent::return_value(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun FontFaceSetLoadEvent::set_return_value(self: mut FontFaceSetLoadEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun FontFaceSetLoadEvent::cancel_bubble(self: FontFaceSetLoadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun FontFaceSetLoadEvent::set_cancel_bubble(self: mut FontFaceSetLoadEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun FontFaceSetLoadEvent::composed_path(__self: mut FontFaceSetLoadEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun FontFaceSetLoadEvent::stop_propagation(__self: mut FontFaceSetLoadEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FontFaceSetLoadEvent::stop_immediate_propagation(__self: mut FontFaceSetLoadEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FontFaceSetLoadEvent::prevent_default(__self: mut FontFaceSetLoadEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun FontFaceSetLoadEvent::init_event(__self: mut FontFaceSetLoadEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun FontFaceSetLoadEvent::as_js(self: FontFaceSetLoadEvent) -> JsValue = JsValue::unsafe_from[FontFaceSetLoadEvent](self)

pub fun FontFaceSetLoadEvent::from_js(v: JsValue) -> mut FontFaceSetLoadEvent = JsValue::unsafe_as[mut FontFaceSetLoadEvent](v)

pub val FontFaceSetLoadEvent::none: Int = 0
pub val FontFaceSetLoadEvent::capturing_phase: Int = 1
pub val FontFaceSetLoadEvent::at_target: Int = 2
pub val FontFaceSetLoadEvent::bubbling_phase: Int = 3

pub struct FontFaceSetLoadEventInit(
    fontfaces: Option[List[mut FontFace]],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun FontFaceSetLoadEventInit::default() -> mut FontFaceSetLoadEventInit
    = FontFaceSetLoadEventInit(Option::Some(List::empty()), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'FontFaceSetLoadEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEventInit::as_event_init(self: FontFaceSetLoadEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'FontFaceSetLoadEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEventInit::as_mevent_init(self: mut FontFaceSetLoadEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'FontFaceSetLoadEventInit'.
/// A 'base' that is not a reference to 'FontFaceSetLoadEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEventInit::from_event_init_unchecked(base: EventInit) -> FontFaceSetLoadEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'FontFaceSetLoadEventInit'.
/// A 'base' that is not a reference to 'FontFaceSetLoadEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FontFaceSetLoadEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut FontFaceSetLoadEventInit = "return #var(base);"

pub ext fun FontFaceSetLoadEventInit::from_js(value: JsValue) -> mut FontFaceSetLoadEventInit = "
    const r = {};
    r.m_fontfaces = #fun(Option::from_js[List[mut FontFace]])(#var(value).fontfaces);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun FontFaceSetLoadEventInit::as_js(self: FontFaceSetLoadEventInit) -> JsValue = "
    const r = {};
    r.fontfaces = #fun(Option::as_js_undef[List[mut FontFace]])(#var(self).m_fontfaces);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct MediaList()

pub ext fun MediaList::media_text(self: MediaList) -> String
    = "return #fun(String::from_js)(#var(self).mediaText);"

pub ext fun MediaList::set_media_text(self: mut MediaList, value: String)
    = "#var(self).mediaText = #fun(String::as_js)(#var(value));"

pub ext fun MediaList::length(self: MediaList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun MediaList::item(__self: mut MediaList, index: Int) -> Option[String] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun MediaList::append_medium(__self: mut MediaList, medium: String) -> Unit = "
    const r = #var(__self).appendMedium(#fun(String::as_js)(#var(medium)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaList::delete_medium(__self: mut MediaList, medium: String) -> Unit = "
    const r = #var(__self).deleteMedium(#fun(String::as_js)(#var(medium)));
    return #fun(Unit::from_js)(r);
"

pub fun MediaList::as_js(self: MediaList) -> JsValue = JsValue::unsafe_from[MediaList](self)

pub fun MediaList::from_js(v: JsValue) -> mut MediaList = JsValue::unsafe_as[mut MediaList](v)

struct MediaQueryList()

/// Converts a reference to 'MediaQueryList' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryList::as_event_target(self: MediaQueryList) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'MediaQueryList' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryList::as_mevent_target(self: mut MediaQueryList) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'MediaQueryList'.
/// The conversion may fail and panic if 'base' is not a reference to 'MediaQueryList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryList::from_event_target(base: EventTarget) -> MediaQueryList = "
    if(#var(base) instanceof MediaQueryList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MediaQueryList'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'MediaQueryList'.
/// The conversion may fail and panic if 'base' is not a reference to 'MediaQueryList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryList::from_mevent_target(base: mut EventTarget) -> mut MediaQueryList = "
    if(#var(base) instanceof MediaQueryList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MediaQueryList'!\");
"

pub ext fun MediaQueryList::media(self: MediaQueryList) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun MediaQueryList::matches(self: MediaQueryList) -> Bool
    = "return #fun(Bool::from_js)(#var(self).matches);"

pub ext fun MediaQueryList::onchange(self: MediaQueryList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun MediaQueryList::set_onchange(self: mut MediaQueryList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MediaQueryList::add_listener(__self: mut MediaQueryList, listener: Option[Fun(mut Event) -> Unit]) -> Unit = "
    const r = #var(__self).addListener(#fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryList::remove_listener(__self: mut MediaQueryList, listener: Option[Fun(mut Event) -> Unit]) -> Unit = "
    const r = #var(__self).removeListener(#fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryList::add_event_listener(__self: mut MediaQueryList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryList::remove_event_listener(__self: mut MediaQueryList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryList::dispatch_event(__self: mut MediaQueryList, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun MediaQueryList::when(__self: mut MediaQueryList, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun MediaQueryList::as_js(self: MediaQueryList) -> JsValue = JsValue::unsafe_from[MediaQueryList](self)

pub fun MediaQueryList::from_js(v: JsValue) -> mut MediaQueryList = JsValue::unsafe_as[mut MediaQueryList](v)

struct MediaQueryListEvent()

/// Converts a reference to 'MediaQueryListEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEvent::as_event(self: MediaQueryListEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'MediaQueryListEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEvent::as_mevent(self: mut MediaQueryListEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'MediaQueryListEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MediaQueryListEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEvent::from_event(base: Event) -> MediaQueryListEvent = "
    if(#var(base) instanceof MediaQueryListEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MediaQueryListEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'MediaQueryListEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MediaQueryListEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEvent::from_mevent(base: mut Event) -> mut MediaQueryListEvent = "
    if(#var(base) instanceof MediaQueryListEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MediaQueryListEvent'!\");
"

pub ext fun MediaQueryListEvent::from_str_mmedia_query_list_event_init(type: String, event_init_dict: mut MediaQueryListEventInit) -> mut MediaQueryListEvent
    = "return new MediaQueryListEvent(#fun(String::as_js)(#var(type)), #fun(MediaQueryListEventInit::as_js)(#var(event_init_dict)));"

pub ext fun MediaQueryListEvent::media(self: MediaQueryListEvent) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun MediaQueryListEvent::matches(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).matches);"

pub ext fun MediaQueryListEvent::type(self: MediaQueryListEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MediaQueryListEvent::target(self: MediaQueryListEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun MediaQueryListEvent::current_target(self: MediaQueryListEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun MediaQueryListEvent::event_phase(self: MediaQueryListEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun MediaQueryListEvent::bubbles(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun MediaQueryListEvent::cancelable(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun MediaQueryListEvent::default_prevented(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun MediaQueryListEvent::composed(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun MediaQueryListEvent::is_trusted(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun MediaQueryListEvent::time_stamp(self: MediaQueryListEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun MediaQueryListEvent::src_element(self: MediaQueryListEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun MediaQueryListEvent::return_value(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun MediaQueryListEvent::set_return_value(self: mut MediaQueryListEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun MediaQueryListEvent::cancel_bubble(self: MediaQueryListEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun MediaQueryListEvent::set_cancel_bubble(self: mut MediaQueryListEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun MediaQueryListEvent::composed_path(__self: mut MediaQueryListEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun MediaQueryListEvent::stop_propagation(__self: mut MediaQueryListEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryListEvent::stop_immediate_propagation(__self: mut MediaQueryListEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryListEvent::prevent_default(__self: mut MediaQueryListEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun MediaQueryListEvent::init_event(__self: mut MediaQueryListEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun MediaQueryListEvent::as_js(self: MediaQueryListEvent) -> JsValue = JsValue::unsafe_from[MediaQueryListEvent](self)

pub fun MediaQueryListEvent::from_js(v: JsValue) -> mut MediaQueryListEvent = JsValue::unsafe_as[mut MediaQueryListEvent](v)

pub val MediaQueryListEvent::none: Int = 0
pub val MediaQueryListEvent::capturing_phase: Int = 1
pub val MediaQueryListEvent::at_target: Int = 2
pub val MediaQueryListEvent::bubbling_phase: Int = 3

pub struct MediaQueryListEventInit(
    media: Option[String],
    matches: Option[Bool],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun MediaQueryListEventInit::default() -> mut MediaQueryListEventInit
    = MediaQueryListEventInit(Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'MediaQueryListEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEventInit::as_event_init(self: MediaQueryListEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'MediaQueryListEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEventInit::as_mevent_init(self: mut MediaQueryListEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'MediaQueryListEventInit'.
/// A 'base' that is not a reference to 'MediaQueryListEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEventInit::from_event_init_unchecked(base: EventInit) -> MediaQueryListEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'MediaQueryListEventInit'.
/// A 'base' that is not a reference to 'MediaQueryListEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MediaQueryListEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut MediaQueryListEventInit = "return #var(base);"

pub ext fun MediaQueryListEventInit::from_js(value: JsValue) -> mut MediaQueryListEventInit = "
    const r = {};
    r.m_media = #fun(Option::from_js[String])(#var(value).media);
    r.m_matches = #fun(Option::from_js[Bool])(#var(value).matches);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun MediaQueryListEventInit::as_js(self: MediaQueryListEventInit) -> JsValue = "
    const r = {};
    r.media = #fun(Option::as_js_undef[String])(#var(self).m_media);
    r.matches = #fun(Option::as_js_undef[Bool])(#var(self).m_matches);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub struct PropertyDefinition(
    name: String,
    syntax: Option[String],
    inherits: Bool,
    initial_value: Option[String]
)

pub fun PropertyDefinition::default(name: String, inherits: Bool) -> mut PropertyDefinition
    = PropertyDefinition(name, Option::Some("*"), inherits, Option::None)

pub ext fun PropertyDefinition::from_js(value: JsValue) -> mut PropertyDefinition = "
    const r = {};
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_syntax = #fun(Option::from_js[String])(#var(value).syntax);
    r.m_inherits = #fun(Bool::from_js)(#var(value).inherits);
    r.m_initial_value = #fun(Option::from_js[String])(#var(value).initialValue);
    return r;
"

pub ext fun PropertyDefinition::as_js(self: PropertyDefinition) -> JsValue = "
    const r = {};
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.syntax = #fun(Option::as_js_undef[String])(#var(self).m_syntax);
    r.inherits = #fun(Bool::as_js)(#var(self).m_inherits);
    r.initialValue = #fun(Option::as_js_undef[String])(#var(self).m_initial_value);
    return r;
"

// TODO: Definitions of type 'namespace'

struct StyleMedia()

pub ext fun StyleMedia::type(self: StyleMedia) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun StyleMedia::match_medium(__self: mut StyleMedia, mediaquery: String) -> Bool = "
    const r = #var(__self).matchMedium(#fun(String::as_js)(#var(mediaquery)));
    return #fun(Bool::from_js)(r);
"

pub fun StyleMedia::as_js(self: StyleMedia) -> JsValue = JsValue::unsafe_from[StyleMedia](self)

pub fun StyleMedia::from_js(v: JsValue) -> mut StyleMedia = JsValue::unsafe_as[mut StyleMedia](v)

struct StyleSheet()

pub ext fun StyleSheet::type(self: StyleSheet) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun StyleSheet::href(self: StyleSheet) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).href);"

pub ext fun StyleSheet::owner_node(self: StyleSheet) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).ownerNode);"

pub ext fun StyleSheet::parent_style_sheet(self: StyleSheet) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).parentStyleSheet);"

pub ext fun StyleSheet::title(self: StyleSheet) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).title);"

pub ext fun StyleSheet::media(self: StyleSheet) -> mut MediaList
    = "return #fun(MediaList::from_js)(#var(self).media);"

pub ext fun StyleSheet::disabled(self: StyleSheet) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun StyleSheet::set_disabled(self: mut StyleSheet, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub fun StyleSheet::as_js(self: StyleSheet) -> JsValue = JsValue::unsafe_from[StyleSheet](self)

pub fun StyleSheet::from_js(v: JsValue) -> mut StyleSheet = JsValue::unsafe_as[mut StyleSheet](v)

struct StyleSheetList()

pub ext fun StyleSheetList::length(self: StyleSheetList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun StyleSheetList::item(__self: mut StyleSheetList, index: Int) -> Option[mut StyleSheet] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut StyleSheet])(r);
"

pub ext fun StyleSheetList::get(__self: StyleSheetList, name: String) -> mut CSSStyleSheet = "
    const r = StyleSheetList[#fun(String::as_js)(#var(name))];
    return #fun(CSSStyleSheet::from_js)(r);
"

pub fun StyleSheetList::as_js(self: StyleSheetList) -> JsValue = JsValue::unsafe_from[StyleSheetList](self)

pub fun StyleSheetList::from_js(v: JsValue) -> mut StyleSheetList = JsValue::unsafe_as[mut StyleSheetList](v)

struct ContentVisibilityAutoStateChangeEvent()

/// Converts a reference to 'ContentVisibilityAutoStateChangeEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEvent::as_event(self: ContentVisibilityAutoStateChangeEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ContentVisibilityAutoStateChangeEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEvent::as_mevent(self: mut ContentVisibilityAutoStateChangeEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ContentVisibilityAutoStateChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ContentVisibilityAutoStateChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEvent::from_event(base: Event) -> ContentVisibilityAutoStateChangeEvent = "
    if(#var(base) instanceof ContentVisibilityAutoStateChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ContentVisibilityAutoStateChangeEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ContentVisibilityAutoStateChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ContentVisibilityAutoStateChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEvent::from_mevent(base: mut Event) -> mut ContentVisibilityAutoStateChangeEvent = "
    if(#var(base) instanceof ContentVisibilityAutoStateChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ContentVisibilityAutoStateChangeEvent'!\");
"

pub ext fun ContentVisibilityAutoStateChangeEvent::from_str_mcontent_visibility_auto_state_change_event_init(type: String, event_init_dict: mut ContentVisibilityAutoStateChangeEventInit) -> mut ContentVisibilityAutoStateChangeEvent
    = "return new ContentVisibilityAutoStateChangeEvent(#fun(String::as_js)(#var(type)), #fun(ContentVisibilityAutoStateChangeEventInit::as_js)(#var(event_init_dict)));"

pub ext fun ContentVisibilityAutoStateChangeEvent::skipped(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).skipped);"

pub ext fun ContentVisibilityAutoStateChangeEvent::type(self: ContentVisibilityAutoStateChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ContentVisibilityAutoStateChangeEvent::target(self: ContentVisibilityAutoStateChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ContentVisibilityAutoStateChangeEvent::current_target(self: ContentVisibilityAutoStateChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ContentVisibilityAutoStateChangeEvent::event_phase(self: ContentVisibilityAutoStateChangeEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ContentVisibilityAutoStateChangeEvent::bubbles(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ContentVisibilityAutoStateChangeEvent::cancelable(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ContentVisibilityAutoStateChangeEvent::default_prevented(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ContentVisibilityAutoStateChangeEvent::composed(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ContentVisibilityAutoStateChangeEvent::is_trusted(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ContentVisibilityAutoStateChangeEvent::time_stamp(self: ContentVisibilityAutoStateChangeEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ContentVisibilityAutoStateChangeEvent::src_element(self: ContentVisibilityAutoStateChangeEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ContentVisibilityAutoStateChangeEvent::return_value(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ContentVisibilityAutoStateChangeEvent::set_return_value(self: mut ContentVisibilityAutoStateChangeEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ContentVisibilityAutoStateChangeEvent::cancel_bubble(self: ContentVisibilityAutoStateChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ContentVisibilityAutoStateChangeEvent::set_cancel_bubble(self: mut ContentVisibilityAutoStateChangeEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ContentVisibilityAutoStateChangeEvent::composed_path(__self: mut ContentVisibilityAutoStateChangeEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ContentVisibilityAutoStateChangeEvent::stop_propagation(__self: mut ContentVisibilityAutoStateChangeEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ContentVisibilityAutoStateChangeEvent::stop_immediate_propagation(__self: mut ContentVisibilityAutoStateChangeEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ContentVisibilityAutoStateChangeEvent::prevent_default(__self: mut ContentVisibilityAutoStateChangeEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ContentVisibilityAutoStateChangeEvent::init_event(__self: mut ContentVisibilityAutoStateChangeEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ContentVisibilityAutoStateChangeEvent::as_js(self: ContentVisibilityAutoStateChangeEvent) -> JsValue = JsValue::unsafe_from[ContentVisibilityAutoStateChangeEvent](self)

pub fun ContentVisibilityAutoStateChangeEvent::from_js(v: JsValue) -> mut ContentVisibilityAutoStateChangeEvent = JsValue::unsafe_as[mut ContentVisibilityAutoStateChangeEvent](v)

pub val ContentVisibilityAutoStateChangeEvent::none: Int = 0
pub val ContentVisibilityAutoStateChangeEvent::capturing_phase: Int = 1
pub val ContentVisibilityAutoStateChangeEvent::at_target: Int = 2
pub val ContentVisibilityAutoStateChangeEvent::bubbling_phase: Int = 3

pub struct ContentVisibilityAutoStateChangeEventInit(
    skipped: Option[Bool],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun ContentVisibilityAutoStateChangeEventInit::default() -> mut ContentVisibilityAutoStateChangeEventInit
    = ContentVisibilityAutoStateChangeEventInit(Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'ContentVisibilityAutoStateChangeEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEventInit::as_event_init(self: ContentVisibilityAutoStateChangeEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'ContentVisibilityAutoStateChangeEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEventInit::as_mevent_init(self: mut ContentVisibilityAutoStateChangeEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'ContentVisibilityAutoStateChangeEventInit'.
/// A 'base' that is not a reference to 'ContentVisibilityAutoStateChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEventInit::from_event_init_unchecked(base: EventInit) -> ContentVisibilityAutoStateChangeEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'ContentVisibilityAutoStateChangeEventInit'.
/// A 'base' that is not a reference to 'ContentVisibilityAutoStateChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ContentVisibilityAutoStateChangeEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut ContentVisibilityAutoStateChangeEventInit = "return #var(base);"

pub ext fun ContentVisibilityAutoStateChangeEventInit::from_js(value: JsValue) -> mut ContentVisibilityAutoStateChangeEventInit = "
    const r = {};
    r.m_skipped = #fun(Option::from_js[Bool])(#var(value).skipped);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun ContentVisibilityAutoStateChangeEventInit::as_js(self: ContentVisibilityAutoStateChangeEventInit) -> JsValue = "
    const r = {};
    r.skipped = #fun(Option::as_js_undef[Bool])(#var(self).m_skipped);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct AbortController()

pub ext fun AbortController::new() -> mut AbortController
    = "return new AbortController();"

pub ext fun AbortController::signal(self: AbortController) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun AbortController::abort(__self: mut AbortController, reason: JsValue) -> Unit = "
    const r = #var(__self).abort(#var(reason));
    return #fun(Unit::from_js)(r);
"

pub fun AbortController::as_js(self: AbortController) -> JsValue = JsValue::unsafe_from[AbortController](self)

pub fun AbortController::from_js(v: JsValue) -> mut AbortController = JsValue::unsafe_as[mut AbortController](v)

struct AbortSignal()

/// Converts a reference to 'AbortSignal' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::as_event_target(self: AbortSignal) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'AbortSignal' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::as_mevent_target(self: mut AbortSignal) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'AbortSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'AbortSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::from_event_target(base: EventTarget) -> AbortSignal = "
    if(#var(base) instanceof AbortSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AbortSignal'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'AbortSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'AbortSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::from_mevent_target(base: mut EventTarget) -> mut AbortSignal = "
    if(#var(base) instanceof AbortSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AbortSignal'!\");
"

pub ext fun AbortSignal::aborted(self: AbortSignal) -> Bool
    = "return #fun(Bool::from_js)(#var(self).aborted);"

pub ext fun AbortSignal::reason(self: AbortSignal) -> JsValue
    = "return #var(self).reason;"

pub ext fun AbortSignal::onabort(self: AbortSignal) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun AbortSignal::set_onabort(self: mut AbortSignal, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun AbortSignal::abort(reason: JsValue) -> mut AbortSignal = "
    const r = AbortSignal.abort(#var(reason));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::timeout(milliseconds: Int) -> mut AbortSignal = "
    const r = AbortSignal.timeout(#fun(Int::as_js)(#var(milliseconds)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::any(signals: List[mut AbortSignal]) -> mut AbortSignal = "
    const r = AbortSignal.any(#fun(List::as_js[mut AbortSignal])(#var(signals)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::throw_if_aborted(__self: mut AbortSignal) -> Unit = "
    const r = #var(__self).throwIfAborted();
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::add_event_listener(__self: mut AbortSignal, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::remove_event_listener(__self: mut AbortSignal, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::dispatch_event(__self: mut AbortSignal, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun AbortSignal::when(__self: mut AbortSignal, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun AbortSignal::as_js(self: AbortSignal) -> JsValue = JsValue::unsafe_from[AbortSignal](self)

pub fun AbortSignal::from_js(v: JsValue) -> mut AbortSignal = JsValue::unsafe_as[mut AbortSignal](v)

struct AbstractRange()

pub ext fun AbstractRange::start_container(self: AbstractRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun AbstractRange::start_offset(self: AbstractRange) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun AbstractRange::end_container(self: AbstractRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun AbstractRange::end_offset(self: AbstractRange) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun AbstractRange::collapsed(self: AbstractRange) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub fun AbstractRange::as_js(self: AbstractRange) -> JsValue = JsValue::unsafe_from[AbstractRange](self)

pub fun AbstractRange::from_js(v: JsValue) -> mut AbstractRange = JsValue::unsafe_as[mut AbstractRange](v)

struct Attr()

/// Converts a reference to 'Attr' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_node(self: Attr) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Attr' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_mnode(self: mut Attr) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_node(base: Node) -> Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Attr'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_mnode(base: mut Node) -> mut Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Attr'!\");
"

/// Converts a reference to 'Attr' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_event_target(self: Attr) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Attr' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_mevent_target(self: mut Attr) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_event_target(base: EventTarget) -> Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Attr'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_mevent_target(base: mut EventTarget) -> mut Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Attr'!\");
"

pub ext fun Attr::namespace_uri(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).namespaceURI);"

pub ext fun Attr::prefix(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).prefix);"

pub ext fun Attr::local_name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).localName);"

pub ext fun Attr::name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun Attr::value(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun Attr::set_value(self: mut Attr, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun Attr::owner_element(self: Attr) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).ownerElement);"

pub ext fun Attr::specified(self: Attr) -> Bool
    = "return #fun(Bool::from_js)(#var(self).specified);"

pub ext fun Attr::node_type(self: Attr) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Attr::node_name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Attr::base_uri(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Attr::is_connected(self: Attr) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Attr::owner_document(self: Attr) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Attr::parent_node(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Attr::parent_element(self: Attr) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Attr::child_nodes(self: Attr) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Attr::first_child(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Attr::last_child(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Attr::previous_sibling(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Attr::next_sibling(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Attr::node_value(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Attr::set_node_value(self: mut Attr, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Attr::text_content(self: Attr) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Attr::set_text_content(self: mut Attr, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Attr::has_child_nodes(__self: mut Attr) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::get_root_node(__self: mut Attr, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::normalize(__self: mut Attr) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::clone_node(__self: mut Attr, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::is_equal_node(__self: mut Attr, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::is_same_node(__self: mut Attr, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::compare_document_position(__self: mut Attr, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Attr::contains(__self: mut Attr, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::lookup_prefix(__self: mut Attr, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Attr::lookup_namespace_uri(__self: mut Attr, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Attr::is_default_namespace(__self: mut Attr, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::insert_before(__self: mut Attr, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::append_child(__self: mut Attr, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::replace_child(__self: mut Attr, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::remove_child(__self: mut Attr, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::add_event_listener(__self: mut Attr, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::remove_event_listener(__self: mut Attr, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::dispatch_event(__self: mut Attr, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::when(__self: mut Attr, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Attr::as_js(self: Attr) -> JsValue = JsValue::unsafe_from[Attr](self)

pub fun Attr::from_js(v: JsValue) -> mut Attr = JsValue::unsafe_as[mut Attr](v)

pub val Attr::element_node: Int = 1
pub val Attr::attribute_node: Int = 2
pub val Attr::text_node: Int = 3
pub val Attr::cdata_section_node: Int = 4
pub val Attr::entity_reference_node: Int = 5
pub val Attr::entity_node: Int = 6
pub val Attr::processing_instruction_node: Int = 7
pub val Attr::comment_node: Int = 8
pub val Attr::document_node: Int = 9
pub val Attr::document_type_node: Int = 10
pub val Attr::document_fragment_node: Int = 11
pub val Attr::notation_node: Int = 12
pub val Attr::document_position_disconnected: Int = 1
pub val Attr::document_position_preceding: Int = 2
pub val Attr::document_position_following: Int = 4
pub val Attr::document_position_contains: Int = 8
pub val Attr::document_position_contained_by: Int = 16
pub val Attr::document_position_implementation_specific: Int = 32

struct AttributePart()

/// Converts a reference to 'AttributePart' to a reference to 'NodePart'.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::as_node_part(self: AttributePart) -> NodePart = "return #var(self);"

/// Converts a mutable reference to 'AttributePart' to a mutable reference to 'NodePart'.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::as_mnode_part(self: mut AttributePart) -> mut NodePart = "return #var(self);"

/// Attempts to convert a reference to 'NodePart' to a reference to 'AttributePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'AttributePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::from_node_part(base: NodePart) -> AttributePart = "
    if(#var(base) instanceof AttributePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'NodePart' to 'AttributePart'!\");
"

/// Attempts to convert a mutable reference to 'NodePart' to a mutable reference to 'AttributePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'AttributePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::from_mnode_part(base: mut NodePart) -> mut AttributePart = "
    if(#var(base) instanceof AttributePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'NodePart' to 'AttributePart'!\");
"

/// Converts a reference to 'AttributePart' to a reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::as_part(self: AttributePart) -> Part = "return #var(self);"

/// Converts a mutable reference to 'AttributePart' to a mutable reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::as_mpart(self: mut AttributePart) -> mut Part = "return #var(self);"

/// Attempts to convert a reference to 'Part' to a reference to 'AttributePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'AttributePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::from_part(base: Part) -> AttributePart = "
    if(#var(base) instanceof AttributePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'AttributePart'!\");
"

/// Attempts to convert a mutable reference to 'Part' to a mutable reference to 'AttributePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'AttributePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AttributePart::from_mpart(base: mut Part) -> mut AttributePart = "
    if(#var(base) instanceof AttributePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'AttributePart'!\");
"

pub ext fun AttributePart::from_any_melement_str_mpart_init(root: JsValue, element: mut Element, local_name: String, init: mut PartInit) -> mut AttributePart
    = "return new AttributePart(#var(root), #fun(Element::as_js)(#var(element)), #fun(String::as_js)(#var(local_name)), #fun(PartInit::as_js)(#var(init)));"

pub ext fun AttributePart::local_name(self: AttributePart) -> String
    = "return #fun(String::from_js)(#var(self).localName);"

pub ext fun AttributePart::node(self: AttributePart) -> mut Node
    = "return #fun(Node::from_js)(#var(self).node);"

pub ext fun AttributePart::root(self: AttributePart) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).root);"

pub ext fun AttributePart::metadata(self: AttributePart) -> JsValue
    = "return #var(self).metadata;"

pub ext fun AttributePart::disconnect(__self: mut AttributePart) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub fun AttributePart::as_js(self: AttributePart) -> JsValue = JsValue::unsafe_from[AttributePart](self)

pub fun AttributePart::from_js(v: JsValue) -> mut AttributePart = JsValue::unsafe_as[mut AttributePart](v)

pub struct CaretPositionFromPointOptions(
    shadow_roots: Option[List[mut ShadowRoot]]
)

pub fun CaretPositionFromPointOptions::default() -> mut CaretPositionFromPointOptions
    = CaretPositionFromPointOptions(Option::Some(List::empty()))

pub ext fun CaretPositionFromPointOptions::from_js(value: JsValue) -> mut CaretPositionFromPointOptions = "
    const r = {};
    r.m_shadow_roots = #fun(Option::from_js[List[mut ShadowRoot]])(#var(value).shadowRoots);
    return r;
"

pub ext fun CaretPositionFromPointOptions::as_js(self: CaretPositionFromPointOptions) -> JsValue = "
    const r = {};
    r.shadowRoots = #fun(Option::as_js_undef[List[mut ShadowRoot]])(#var(self).m_shadow_roots);
    return r;
"

struct CDATASection()

/// Converts a reference to 'CDATASection' to a reference to 'Text'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_text(self: CDATASection) -> Text = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'Text'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mtext(self: mut CDATASection) -> mut Text = "return #var(self);"

/// Attempts to convert a reference to 'Text' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_text(base: Text) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Text' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'Text' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mtext(base: mut Text) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Text' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_character_data(self: CDATASection) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mcharacter_data(self: mut CDATASection) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_character_data(base: CharacterData) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mcharacter_data(base: mut CharacterData) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_node(self: CDATASection) -> Node = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mnode(self: mut CDATASection) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_node(base: Node) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mnode(base: mut Node) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_event_target(self: CDATASection) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mevent_target(self: mut CDATASection) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_event_target(base: EventTarget) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mevent_target(base: mut EventTarget) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CDATASection'!\");
"

pub ext fun CDATASection::whole_text(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).wholeText);"

pub ext fun CDATASection::assigned_slot(self: CDATASection) -> Option[mut HTMLSlotElement]
    = "return #fun(Option::from_js[mut HTMLSlotElement])(#var(self).assignedSlot);"

pub ext fun CDATASection::data(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun CDATASection::set_data(self: mut CDATASection, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun CDATASection::length(self: CDATASection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CDATASection::node_type(self: CDATASection) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun CDATASection::node_name(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun CDATASection::base_uri(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun CDATASection::is_connected(self: CDATASection) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun CDATASection::owner_document(self: CDATASection) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun CDATASection::parent_node(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun CDATASection::parent_element(self: CDATASection) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun CDATASection::child_nodes(self: CDATASection) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun CDATASection::first_child(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun CDATASection::last_child(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun CDATASection::previous_sibling(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun CDATASection::next_sibling(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun CDATASection::node_value(self: CDATASection) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun CDATASection::set_node_value(self: mut CDATASection, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun CDATASection::text_content(self: CDATASection) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun CDATASection::set_text_content(self: mut CDATASection, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CDATASection::split_text(__self: mut CDATASection, offset: Int) -> mut Text = "
    const r = #var(__self).splitText(#fun(Int::as_js)(#var(offset)));
    return #fun(Text::from_js)(r);
"

pub ext fun CDATASection::substring_data(__self: mut CDATASection, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun CDATASection::append_data(__self: mut CDATASection, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::insert_data(__self: mut CDATASection, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::delete_data(__self: mut CDATASection, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::replace_data(__self: mut CDATASection, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::has_child_nodes(__self: mut CDATASection) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::get_root_node(__self: mut CDATASection, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::normalize(__self: mut CDATASection) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::clone_node(__self: mut CDATASection, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::is_equal_node(__self: mut CDATASection, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::is_same_node(__self: mut CDATASection, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::compare_document_position(__self: mut CDATASection, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun CDATASection::contains(__self: mut CDATASection, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::lookup_prefix(__self: mut CDATASection, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CDATASection::lookup_namespace_uri(__self: mut CDATASection, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CDATASection::is_default_namespace(__self: mut CDATASection, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::insert_before(__self: mut CDATASection, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::append_child(__self: mut CDATASection, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::replace_child(__self: mut CDATASection, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::remove_child(__self: mut CDATASection, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::add_event_listener(__self: mut CDATASection, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::remove_event_listener(__self: mut CDATASection, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::dispatch_event(__self: mut CDATASection, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::when(__self: mut CDATASection, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun CDATASection::as_js(self: CDATASection) -> JsValue = JsValue::unsafe_from[CDATASection](self)

pub fun CDATASection::from_js(v: JsValue) -> mut CDATASection = JsValue::unsafe_as[mut CDATASection](v)

pub val CDATASection::element_node: Int = 1
pub val CDATASection::attribute_node: Int = 2
pub val CDATASection::text_node: Int = 3
pub val CDATASection::cdata_section_node: Int = 4
pub val CDATASection::entity_reference_node: Int = 5
pub val CDATASection::entity_node: Int = 6
pub val CDATASection::processing_instruction_node: Int = 7
pub val CDATASection::comment_node: Int = 8
pub val CDATASection::document_node: Int = 9
pub val CDATASection::document_type_node: Int = 10
pub val CDATASection::document_fragment_node: Int = 11
pub val CDATASection::notation_node: Int = 12
pub val CDATASection::document_position_disconnected: Int = 1
pub val CDATASection::document_position_preceding: Int = 2
pub val CDATASection::document_position_following: Int = 4
pub val CDATASection::document_position_contains: Int = 8
pub val CDATASection::document_position_contained_by: Int = 16
pub val CDATASection::document_position_implementation_specific: Int = 32

struct CharacterData()

/// Converts a reference to 'CharacterData' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_node(self: CharacterData) -> Node = "return #var(self);"

/// Converts a mutable reference to 'CharacterData' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_mnode(self: mut CharacterData) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_node(base: Node) -> CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CharacterData'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_mnode(base: mut Node) -> mut CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CharacterData'!\");
"

/// Converts a reference to 'CharacterData' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_event_target(self: CharacterData) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CharacterData' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_mevent_target(self: mut CharacterData) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_event_target(base: EventTarget) -> CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CharacterData'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_mevent_target(base: mut EventTarget) -> mut CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CharacterData'!\");
"

pub ext fun CharacterData::data(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun CharacterData::set_data(self: mut CharacterData, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun CharacterData::length(self: CharacterData) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CharacterData::node_type(self: CharacterData) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun CharacterData::node_name(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun CharacterData::base_uri(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun CharacterData::is_connected(self: CharacterData) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun CharacterData::owner_document(self: CharacterData) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun CharacterData::parent_node(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun CharacterData::parent_element(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun CharacterData::child_nodes(self: CharacterData) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun CharacterData::first_child(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun CharacterData::last_child(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun CharacterData::previous_sibling(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun CharacterData::next_sibling(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun CharacterData::node_value(self: CharacterData) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun CharacterData::set_node_value(self: mut CharacterData, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun CharacterData::text_content(self: CharacterData) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun CharacterData::set_text_content(self: mut CharacterData, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun CharacterData::previous_element_sibling(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).previousElementSibling);"

pub ext fun CharacterData::next_element_sibling(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).nextElementSibling);"

pub ext fun CharacterData::substring_data(__self: mut CharacterData, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun CharacterData::append_data(__self: mut CharacterData, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::insert_data(__self: mut CharacterData, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::delete_data(__self: mut CharacterData, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::replace_data(__self: mut CharacterData, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::has_child_nodes(__self: mut CharacterData) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::get_root_node(__self: mut CharacterData, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::normalize(__self: mut CharacterData) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::clone_node(__self: mut CharacterData, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::is_equal_node(__self: mut CharacterData, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::is_same_node(__self: mut CharacterData, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::compare_document_position(__self: mut CharacterData, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun CharacterData::contains(__self: mut CharacterData, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::lookup_prefix(__self: mut CharacterData, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CharacterData::lookup_namespace_uri(__self: mut CharacterData, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CharacterData::is_default_namespace(__self: mut CharacterData, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::insert_before(__self: mut CharacterData, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::append_child(__self: mut CharacterData, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::replace_child(__self: mut CharacterData, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::remove_child(__self: mut CharacterData, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::add_event_listener(__self: mut CharacterData, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::remove_event_listener(__self: mut CharacterData, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::dispatch_event(__self: mut CharacterData, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::when(__self: mut CharacterData, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub ext fun CharacterData::before(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::after(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::replace_with(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::remove(__self: mut CharacterData) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun CharacterData::as_js(self: CharacterData) -> JsValue = JsValue::unsafe_from[CharacterData](self)

pub fun CharacterData::from_js(v: JsValue) -> mut CharacterData = JsValue::unsafe_as[mut CharacterData](v)

pub val CharacterData::element_node: Int = 1
pub val CharacterData::attribute_node: Int = 2
pub val CharacterData::text_node: Int = 3
pub val CharacterData::cdata_section_node: Int = 4
pub val CharacterData::entity_reference_node: Int = 5
pub val CharacterData::entity_node: Int = 6
pub val CharacterData::processing_instruction_node: Int = 7
pub val CharacterData::comment_node: Int = 8
pub val CharacterData::document_node: Int = 9
pub val CharacterData::document_type_node: Int = 10
pub val CharacterData::document_fragment_node: Int = 11
pub val CharacterData::notation_node: Int = 12
pub val CharacterData::document_position_disconnected: Int = 1
pub val CharacterData::document_position_preceding: Int = 2
pub val CharacterData::document_position_following: Int = 4
pub val CharacterData::document_position_contains: Int = 8
pub val CharacterData::document_position_contained_by: Int = 16
pub val CharacterData::document_position_implementation_specific: Int = 32

struct ChildNodePart()

/// Converts a reference to 'ChildNodePart' to a reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun ChildNodePart::as_part(self: ChildNodePart) -> Part = "return #var(self);"

/// Converts a mutable reference to 'ChildNodePart' to a mutable reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun ChildNodePart::as_mpart(self: mut ChildNodePart) -> mut Part = "return #var(self);"

/// Attempts to convert a reference to 'Part' to a reference to 'ChildNodePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'ChildNodePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ChildNodePart::from_part(base: Part) -> ChildNodePart = "
    if(#var(base) instanceof ChildNodePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'ChildNodePart'!\");
"

/// Attempts to convert a mutable reference to 'Part' to a mutable reference to 'ChildNodePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'ChildNodePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ChildNodePart::from_mpart(base: mut Part) -> mut ChildNodePart = "
    if(#var(base) instanceof ChildNodePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'ChildNodePart'!\");
"

pub ext fun ChildNodePart::from_any_mnode_mnode_mpart_init(root: JsValue, previous_sibling: mut Node, next_sibling: mut Node, init: mut PartInit) -> mut ChildNodePart
    = "return new ChildNodePart(#var(root), #fun(Node::as_js)(#var(previous_sibling)), #fun(Node::as_js)(#var(next_sibling)), #fun(PartInit::as_js)(#var(init)));"

pub ext fun ChildNodePart::previous_sibling(self: ChildNodePart) -> mut Node
    = "return #fun(Node::from_js)(#var(self).previousSibling);"

pub ext fun ChildNodePart::next_sibling(self: ChildNodePart) -> mut Node
    = "return #fun(Node::from_js)(#var(self).nextSibling);"

pub ext fun ChildNodePart::children(self: ChildNodePart) -> JsValue
    = "return #var(self).children;"

pub ext fun ChildNodePart::root(self: ChildNodePart) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).root);"

pub ext fun ChildNodePart::metadata(self: ChildNodePart) -> JsValue
    = "return #var(self).metadata;"

pub ext fun ChildNodePart::root_container(self: ChildNodePart) -> mut Node
    = "return #fun(Node::from_js)(#var(self).rootContainer);"

pub ext fun ChildNodePart::replace_children(__self: mut ChildNodePart, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ChildNodePart::disconnect(__self: mut ChildNodePart) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun ChildNodePart::get_parts(__self: mut ChildNodePart) -> List[mut Part] = "
    const r = #var(__self).getParts();
    return #fun(List::from_js[mut Part])(r);
"

pub ext fun ChildNodePart::get_node_part_nodes(__self: mut ChildNodePart) -> List[mut Node] = "
    const r = #var(__self).getNodePartNodes();
    return #fun(List::from_js[mut Node])(r);
"

pub ext fun ChildNodePart::get_child_node_part_nodes(__self: mut ChildNodePart) -> List[mut Node] = "
    const r = #var(__self).getChildNodePartNodes();
    return #fun(List::from_js[mut Node])(r);
"

pub ext fun ChildNodePart::clone(__self: mut ChildNodePart) -> JsValue = "
    const r = #var(__self).clone();
    return r;
"

pub fun ChildNodePart::as_js(self: ChildNodePart) -> JsValue = JsValue::unsafe_from[ChildNodePart](self)

pub fun ChildNodePart::from_js(v: JsValue) -> mut ChildNodePart = JsValue::unsafe_as[mut ChildNodePart](v)

struct Comment()

/// Converts a reference to 'Comment' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_character_data(self: Comment) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mcharacter_data(self: mut Comment) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_character_data(base: CharacterData) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mcharacter_data(base: mut CharacterData) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Comment'!\");
"

/// Converts a reference to 'Comment' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_node(self: Comment) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mnode(self: mut Comment) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_node(base: Node) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mnode(base: mut Node) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Comment'!\");
"

/// Converts a reference to 'Comment' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_event_target(self: Comment) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mevent_target(self: mut Comment) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_event_target(base: EventTarget) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mevent_target(base: mut EventTarget) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Comment'!\");
"

pub ext fun Comment::from_str(data: String) -> mut Comment
    = "return new Comment(#fun(String::as_js)(#var(data)));"

pub ext fun Comment::data(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun Comment::set_data(self: mut Comment, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun Comment::length(self: Comment) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Comment::node_type(self: Comment) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Comment::node_name(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Comment::base_uri(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Comment::is_connected(self: Comment) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Comment::owner_document(self: Comment) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Comment::parent_node(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Comment::parent_element(self: Comment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Comment::child_nodes(self: Comment) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Comment::first_child(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Comment::last_child(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Comment::previous_sibling(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Comment::next_sibling(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Comment::node_value(self: Comment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Comment::set_node_value(self: mut Comment, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Comment::text_content(self: Comment) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Comment::set_text_content(self: mut Comment, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Comment::substring_data(__self: mut Comment, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun Comment::append_data(__self: mut Comment, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::insert_data(__self: mut Comment, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::delete_data(__self: mut Comment, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::replace_data(__self: mut Comment, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::has_child_nodes(__self: mut Comment) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::get_root_node(__self: mut Comment, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::normalize(__self: mut Comment) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::clone_node(__self: mut Comment, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::is_equal_node(__self: mut Comment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::is_same_node(__self: mut Comment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::compare_document_position(__self: mut Comment, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Comment::contains(__self: mut Comment, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::lookup_prefix(__self: mut Comment, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Comment::lookup_namespace_uri(__self: mut Comment, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Comment::is_default_namespace(__self: mut Comment, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::insert_before(__self: mut Comment, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::append_child(__self: mut Comment, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::replace_child(__self: mut Comment, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::remove_child(__self: mut Comment, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::add_event_listener(__self: mut Comment, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::remove_event_listener(__self: mut Comment, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::dispatch_event(__self: mut Comment, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::when(__self: mut Comment, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Comment::as_js(self: Comment) -> JsValue = JsValue::unsafe_from[Comment](self)

pub fun Comment::from_js(v: JsValue) -> mut Comment = JsValue::unsafe_as[mut Comment](v)

pub val Comment::element_node: Int = 1
pub val Comment::attribute_node: Int = 2
pub val Comment::text_node: Int = 3
pub val Comment::cdata_section_node: Int = 4
pub val Comment::entity_reference_node: Int = 5
pub val Comment::entity_node: Int = 6
pub val Comment::processing_instruction_node: Int = 7
pub val Comment::comment_node: Int = 8
pub val Comment::document_node: Int = 9
pub val Comment::document_type_node: Int = 10
pub val Comment::document_fragment_node: Int = 11
pub val Comment::notation_node: Int = 12
pub val Comment::document_position_disconnected: Int = 1
pub val Comment::document_position_preceding: Int = 2
pub val Comment::document_position_following: Int = 4
pub val Comment::document_position_contains: Int = 8
pub val Comment::document_position_contained_by: Int = 16
pub val Comment::document_position_implementation_specific: Int = 32

pub val DocumentReadyState::Loading: String = "loading"
pub val DocumentReadyState::Interactive: String = "interactive"
pub val DocumentReadyState::Complete: String = "complete"

pub val VisibilityState::Hidden: String = "hidden"
pub val VisibilityState::Visible: String = "visible"

/// Converts a reference to 'Document' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_node(self: Document) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Document' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_mnode(self: mut Document) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_node(base: Node) -> Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Document'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_mnode(base: mut Node) -> mut Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Document'!\");
"

/// Converts a reference to 'Document' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_event_target(self: Document) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Document' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_mevent_target(self: mut Document) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_event_target(base: EventTarget) -> Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Document'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_mevent_target(base: mut EventTarget) -> mut Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Document'!\");
"

pub ext fun Document::new() -> mut Document
    = "return new Document();"

pub ext fun Document::implementation(self: Document) -> mut DOMImplementation
    = "return #fun(DOMImplementation::from_js)(#var(self).implementation);"

pub ext fun Document::url(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).URL);"

pub ext fun Document::document_uri(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).documentURI);"

pub ext fun Document::compat_mode(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).compatMode);"

pub ext fun Document::character_set(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).characterSet);"

pub ext fun Document::charset(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun Document::input_encoding(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).inputEncoding);"

pub ext fun Document::content_type(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).contentType);"

pub ext fun Document::doctype(self: Document) -> Option[mut DocumentType]
    = "return #fun(Option::from_js[mut DocumentType])(#var(self).doctype);"

pub ext fun Document::document_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).documentElement);"

pub ext fun Document::xml_encoding(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).xmlEncoding);"

pub ext fun Document::xml_version(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).xmlVersion);"

pub ext fun Document::set_xml_version(self: mut Document, value: Option[String])
    = "#var(self).xmlVersion = #fun(Option::as_js[String])(#var(value));"

pub ext fun Document::xml_standalone(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).xmlStandalone);"

pub ext fun Document::set_xml_standalone(self: mut Document, value: Bool)
    = "#var(self).xmlStandalone = #fun(Bool::as_js)(#var(value));"

pub ext fun Document::location(self: Document) -> Option[mut Location]
    = "return #fun(Option::from_js[mut Location])(#var(self).location);"

pub ext fun Document::domain(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).domain);"

pub ext fun Document::set_domain(self: mut Document, value: String)
    = "#var(self).domain = #fun(String::as_js)(#var(value));"

pub ext fun Document::referrer(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).referrer);"

pub ext fun Document::cookie(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).cookie);"

pub ext fun Document::set_cookie(self: mut Document, value: String)
    = "#var(self).cookie = #fun(String::as_js)(#var(value));"

pub ext fun Document::last_modified(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).lastModified);"

pub ext fun Document::ready_state(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).readyState);"

pub ext fun Document::title(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun Document::set_title(self: mut Document, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun Document::dir(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun Document::set_dir(self: mut Document, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun Document::body(self: Document) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).body);"

pub ext fun Document::set_body(self: mut Document, value: Option[mut HTMLElement])
    = "#var(self).body = #fun(Option::as_js[mut HTMLElement])(#var(value));"

pub ext fun Document::head(self: Document) -> Option[mut HTMLHeadElement]
    = "return #fun(Option::from_js[mut HTMLHeadElement])(#var(self).head);"

pub ext fun Document::images(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).images);"

pub ext fun Document::embeds(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).embeds);"

pub ext fun Document::plugins(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).plugins);"

pub ext fun Document::links(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).links);"

pub ext fun Document::forms(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).forms);"

pub ext fun Document::scripts(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).scripts);"

pub ext fun Document::current_script(self: Document) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentScript);"

pub ext fun Document::default_view(self: Document) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).defaultView);"

pub ext fun Document::design_mode(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).designMode);"

pub ext fun Document::set_design_mode(self: mut Document, value: String)
    = "#var(self).designMode = #fun(String::as_js)(#var(value));"

pub ext fun Document::onreadystatechange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreadystatechange);"

pub ext fun Document::set_onreadystatechange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreadystatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::anchors(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).anchors);"

pub ext fun Document::applets(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).applets);"

pub ext fun Document::fg_color(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).fgColor);"

pub ext fun Document::set_fg_color(self: mut Document, value: String)
    = "#var(self).fgColor = #fun(String::as_js)(#var(value));"

pub ext fun Document::link_color(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).linkColor);"

pub ext fun Document::set_link_color(self: mut Document, value: String)
    = "#var(self).linkColor = #fun(String::as_js)(#var(value));"

pub ext fun Document::vlink_color(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).vlinkColor);"

pub ext fun Document::set_vlink_color(self: mut Document, value: String)
    = "#var(self).vlinkColor = #fun(String::as_js)(#var(value));"

pub ext fun Document::alink_color(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).alinkColor);"

pub ext fun Document::set_alink_color(self: mut Document, value: String)
    = "#var(self).alinkColor = #fun(String::as_js)(#var(value));"

pub ext fun Document::bg_color(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun Document::set_bg_color(self: mut Document, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun Document::all(self: Document) -> mut HTMLAllCollection
    = "return #fun(HTMLAllCollection::from_js)(#var(self).all);"

pub ext fun Document::scrolling_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollingElement);"

pub ext fun Document::onpointerlockchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerlockchange);"

pub ext fun Document::set_onpointerlockchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerlockchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onpointerlockerror(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerlockerror);"

pub ext fun Document::set_onpointerlockerror(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerlockerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::hidden(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hidden);"

pub ext fun Document::visibility_state(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).visibilityState);"

pub ext fun Document::was_discarded(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).wasDiscarded);"

pub ext fun Document::prerendering(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).prerendering);"

pub ext fun Document::soft_navigations(self: Document) -> Int
    = "return #fun(Int::from_js)(#var(self).softNavigations);"

pub ext fun Document::fragment_directive(self: Document) -> mut FragmentDirective
    = "return #fun(FragmentDirective::from_js)(#var(self).fragmentDirective);"

pub ext fun Document::feature_policy(self: Document) -> mut FeaturePolicy
    = "return #fun(FeaturePolicy::from_js)(#var(self).featurePolicy);"

pub ext fun Document::webkit_visibility_state(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).webkitVisibilityState);"

pub ext fun Document::webkit_hidden(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).webkitHidden);"

pub ext fun Document::onbeforecopy(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforecopy);"

pub ext fun Document::set_onbeforecopy(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforecopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onbeforecut(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforecut);"

pub ext fun Document::set_onbeforecut(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforecut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onbeforepaste(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforepaste);"

pub ext fun Document::set_onbeforepaste(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforepaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onfreeze(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfreeze);"

pub ext fun Document::set_onfreeze(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfreeze = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onprerenderingchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprerenderingchange);"

pub ext fun Document::set_onprerenderingchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprerenderingchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onresume(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresume);"

pub ext fun Document::set_onresume(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresume = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onsearch(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsearch);"

pub ext fun Document::set_onsearch(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsearch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onvisibilitychange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvisibilitychange);"

pub ext fun Document::set_onvisibilitychange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvisibilitychange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::node_type(self: Document) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Document::node_name(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Document::base_uri(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Document::is_connected(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Document::owner_document(self: Document) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Document::parent_node(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Document::parent_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Document::child_nodes(self: Document) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Document::first_child(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Document::last_child(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Document::previous_sibling(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Document::next_sibling(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Document::node_value(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Document::set_node_value(self: mut Document, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Document::text_content(self: Document) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Document::set_text_content(self: mut Document, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Document::get_elements_by_tag_name(__self: mut Document, local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagName(#fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::get_elements_by_tag_name_ns(__self: mut Document, namespace_uri: Option[String], local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagNameNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::get_elements_by_class_name(__self: mut Document, class_names: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByClassName(#fun(String::as_js)(#var(class_names)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::create_element_str(__self: mut Document, local_name: String) -> mut Element = "
    const r = #var(__self).createElement(#fun(String::as_js)(#var(local_name)));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::create_element_ns_ostr_str(__self: mut Document, namespace_uri: Option[String], qualified_name: String) -> mut Element = "
    const r = #var(__self).createElementNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(qualified_name)));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::create_document_fragment(__self: mut Document) -> mut DocumentFragment = "
    const r = #var(__self).createDocumentFragment();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Document::create_text_node(__self: mut Document, data: String) -> mut Text = "
    const r = #var(__self).createTextNode(#fun(String::as_js)(#var(data)));
    return #fun(Text::from_js)(r);
"

pub ext fun Document::create_cdata_section(__self: mut Document, data: String) -> mut CDATASection = "
    const r = #var(__self).createCDATASection(#fun(String::as_js)(#var(data)));
    return #fun(CDATASection::from_js)(r);
"

pub ext fun Document::create_comment(__self: mut Document, data: String) -> mut Comment = "
    const r = #var(__self).createComment(#fun(String::as_js)(#var(data)));
    return #fun(Comment::from_js)(r);
"

pub ext fun Document::create_processing_instruction(__self: mut Document, target: String, data: String) -> mut ProcessingInstruction = "
    const r = #var(__self).createProcessingInstruction(#fun(String::as_js)(#var(target)), #fun(String::as_js)(#var(data)));
    return #fun(ProcessingInstruction::from_js)(r);
"

pub ext fun Document::import_node_mnode_bool(__self: mut Document, node: mut Node, deep: Bool) -> mut Node = "
    const r = #var(__self).importNode(#fun(Node::as_js)(#var(node)), #fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::import_node_mnode_mimport_node_options(__self: mut Document, node: mut Node, options: mut ImportNodeOptions) -> mut Node = "
    const r = #var(__self).importNode(#fun(Node::as_js)(#var(node)), #fun(ImportNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::adopt_node(__self: mut Document, node: mut Node) -> mut Node = "
    const r = #var(__self).adoptNode(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::create_attribute(__self: mut Document, local_name: String) -> mut Attr = "
    const r = #var(__self).createAttribute(#fun(String::as_js)(#var(local_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Document::create_attribute_ns(__self: mut Document, namespace_uri: Option[String], qualified_name: String) -> mut Attr = "
    const r = #var(__self).createAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(qualified_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Document::create_event(__self: mut Document, event_type: String) -> mut Event = "
    const r = #var(__self).createEvent(#fun(String::as_js)(#var(event_type)));
    return #fun(Event::from_js)(r);
"

pub ext fun Document::create_range(__self: mut Document) -> mut Range = "
    const r = #var(__self).createRange();
    return #fun(Range::from_js)(r);
"

pub ext fun Document::create_node_iterator(__self: mut Document, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut NodeIterator = "
    const r = #var(__self).createNodeIterator(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(NodeIterator::from_js)(r);
"

pub ext fun Document::create_tree_walker(__self: mut Document, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut TreeWalker = "
    const r = #var(__self).createTreeWalker(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(TreeWalker::from_js)(r);
"

pub ext fun Document::parse_html_unsafe_str(html: String) -> mut Document = "
    const r = Document.parseHTMLUnsafe(#fun(String::as_js)(#var(html)));
    return #fun(Document::from_js)(r);
"

pub ext fun Document::parse_html_unsafe_str_mset_html_unsafe_options(html: String, options: mut SetHTMLUnsafeOptions) -> mut Document = "
    const r = Document.parseHTMLUnsafe(#fun(String::as_js)(#var(html)), #fun(SetHTMLUnsafeOptions::as_js)(#var(options)));
    return #fun(Document::from_js)(r);
"

pub ext fun Document::parse_html(html: String, options: mut SetHTMLOptions) -> mut Document = "
    const r = Document.parseHTML(#fun(String::as_js)(#var(html)), #fun(SetHTMLOptions::as_js)(#var(options)));
    return #fun(Document::from_js)(r);
"

pub ext fun Document::get_elements_by_name(__self: mut Document, element_name: String) -> mut NodeList = "
    const r = #var(__self).getElementsByName(#fun(String::as_js)(#var(element_name)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Document::open_str_str(__self: mut Document, type: String, replace: String) -> mut Document = "
    const r = #var(__self).open(#fun(String::as_js)(#var(type)), #fun(String::as_js)(#var(replace)));
    return #fun(Document::from_js)(r);
"

pub ext fun Document::open_str_str_str(__self: mut Document, url: String, name: String, features: String) -> mut Window = "
    const r = #var(__self).open(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(features)));
    return #fun(Window::from_js)(r);
"

pub ext fun Document::close(__self: mut Document) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::write_str(__self: mut Document, ...text: List[String]) -> Unit = "
    const r = #var(__self).write(...((#var(text)).map(v => #fun(String::as_js)(v))));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::writeln_str(__self: mut Document, ...text: List[String]) -> Unit = "
    const r = #var(__self).writeln(...((#var(text)).map(v => #fun(String::as_js)(v))));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::write_mtrusted_html(__self: mut Document, text: mut TrustedHTML) -> Unit = "
    const r = #var(__self).write(#fun(TrustedHTML::as_js)(#var(text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::writeln_mtrusted_html(__self: mut Document, text: mut TrustedHTML) -> Unit = "
    const r = #var(__self).writeln(#fun(TrustedHTML::as_js)(#var(text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::write_mtrusted_html_any(__self: mut Document, text_1: mut TrustedHTML, ...text: List[JsValue]) -> Unit = "
    const r = #var(__self).write(#fun(TrustedHTML::as_js)(#var(text_1)), ...((#var(text)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::writeln_mtrusted_html_any(__self: mut Document, text_1: mut TrustedHTML, ...text: List[JsValue]) -> Unit = "
    const r = #var(__self).writeln(#fun(TrustedHTML::as_js)(#var(text_1)), ...((#var(text)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::has_focus(__self: mut Document) -> Bool = "
    const r = #var(__self).hasFocus();
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::exec_command(__self: mut Document, command_id: String, show_ui: Bool, value: JsValue) -> Bool = "
    const r = #var(__self).execCommand(#fun(String::as_js)(#var(command_id)), #fun(Bool::as_js)(#var(show_ui)), #var(value));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::query_command_enabled(__self: mut Document, command_id: String) -> Bool = "
    const r = #var(__self).queryCommandEnabled(#fun(String::as_js)(#var(command_id)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::query_command_indeterm(__self: mut Document, command_id: String) -> Bool = "
    const r = #var(__self).queryCommandIndeterm(#fun(String::as_js)(#var(command_id)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::query_command_state(__self: mut Document, command_id: String) -> Bool = "
    const r = #var(__self).queryCommandState(#fun(String::as_js)(#var(command_id)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::query_command_supported(__self: mut Document, command_id: String) -> Bool = "
    const r = #var(__self).queryCommandSupported(#fun(String::as_js)(#var(command_id)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::query_command_value(__self: mut Document, command_id: String) -> String = "
    const r = #var(__self).queryCommandValue(#fun(String::as_js)(#var(command_id)));
    return #fun(String::from_js)(r);
"

pub ext fun Document::clear(__self: mut Document) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::capture_events(__self: mut Document) -> Unit = "
    const r = #var(__self).captureEvents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::release_events(__self: mut Document) -> Unit = "
    const r = #var(__self).releaseEvents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::exit_pointer_lock(__self: mut Document) -> Unit = "
    const r = #var(__self).exitPointerLock();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::create_element_str_any(__self: mut Document, local_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElement(#fun(String::as_js)(#var(local_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::create_element_ns_ostr_str_any(__self: mut Document, namespace_uri: Option[String], qualified_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElementNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(qualified_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::caret_range_from_point(__self: mut Document, x: Int, y: Int) -> mut Range = "
    const r = #var(__self).caretRangeFromPoint(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Range::from_js)(r);
"

pub ext fun Document::caret_position_from_point(__self: mut Document, x: Float, y: Float, options: mut CaretPositionFromPointOptions) -> Option[mut CaretPosition] = "
    const r = #var(__self).caretPositionFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(CaretPositionFromPointOptions::as_js)(#var(options)));
    return #fun(Option::from_js[mut CaretPosition])(r);
"

pub ext fun Document::has_private_token(__self: mut Document, issuer: String) -> Promise[Bool] = "
    const r = #var(__self).hasPrivateToken(#fun(String::as_js)(#var(issuer)));
    return #fun(Promise::from_js[Bool])(r);
"

pub ext fun Document::has_redemption_record(__self: mut Document, issuer: String) -> Promise[Bool] = "
    const r = #var(__self).hasRedemptionRecord(#fun(String::as_js)(#var(issuer)));
    return #fun(Promise::from_js[Bool])(r);
"

pub ext fun Document::aria_notify(__self: mut Document, announcement: String, options: mut AriaNotificationOptions) -> Unit = "
    const r = #var(__self).ariaNotify(#fun(String::as_js)(#var(announcement)), #fun(AriaNotificationOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::get_part_root(__self: mut Document) -> mut DocumentPartRoot = "
    const r = #var(__self).getPartRoot();
    return #fun(DocumentPartRoot::from_js)(r);
"

pub ext fun Document::set_sequential_focus_starting_point(__self: mut Document, element: mut Element) -> Unit = "
    const r = #var(__self).setSequentialFocusStartingPoint(#fun(Element::as_js)(#var(element)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::has_child_nodes(__self: mut Document) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::get_root_node(__self: mut Document, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::normalize(__self: mut Document) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::clone_node(__self: mut Document, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::is_equal_node(__self: mut Document, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::is_same_node(__self: mut Document, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::compare_document_position(__self: mut Document, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Document::contains(__self: mut Document, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::lookup_prefix(__self: mut Document, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Document::lookup_namespace_uri(__self: mut Document, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Document::is_default_namespace(__self: mut Document, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::insert_before(__self: mut Document, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::append_child(__self: mut Document, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::replace_child(__self: mut Document, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::remove_child(__self: mut Document, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::add_event_listener(__self: mut Document, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::remove_event_listener(__self: mut Document, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::dispatch_event(__self: mut Document, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::when(__self: mut Document, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub val Document::element_node: Int = 1
pub val Document::attribute_node: Int = 2
pub val Document::text_node: Int = 3
pub val Document::cdata_section_node: Int = 4
pub val Document::entity_reference_node: Int = 5
pub val Document::entity_node: Int = 6
pub val Document::processing_instruction_node: Int = 7
pub val Document::comment_node: Int = 8
pub val Document::document_node: Int = 9
pub val Document::document_type_node: Int = 10
pub val Document::document_fragment_node: Int = 11
pub val Document::notation_node: Int = 12
pub val Document::document_position_disconnected: Int = 1
pub val Document::document_position_preceding: Int = 2
pub val Document::document_position_following: Int = 4
pub val Document::document_position_contains: Int = 8
pub val Document::document_position_contained_by: Int = 16
pub val Document::document_position_implementation_specific: Int = 32

struct DocumentFragment()

/// Converts a reference to 'DocumentFragment' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_node(self: DocumentFragment) -> Node = "return #var(self);"

/// Converts a mutable reference to 'DocumentFragment' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_mnode(self: mut DocumentFragment) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_node(base: Node) -> DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentFragment'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_mnode(base: mut Node) -> mut DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentFragment'!\");
"

/// Converts a reference to 'DocumentFragment' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_event_target(self: DocumentFragment) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'DocumentFragment' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_mevent_target(self: mut DocumentFragment) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_event_target(base: EventTarget) -> DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentFragment'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_mevent_target(base: mut EventTarget) -> mut DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentFragment'!\");
"

pub ext fun DocumentFragment::new() -> mut DocumentFragment
    = "return new DocumentFragment();"

pub ext fun DocumentFragment::node_type(self: DocumentFragment) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun DocumentFragment::node_name(self: DocumentFragment) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun DocumentFragment::base_uri(self: DocumentFragment) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun DocumentFragment::is_connected(self: DocumentFragment) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun DocumentFragment::owner_document(self: DocumentFragment) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun DocumentFragment::parent_node(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun DocumentFragment::parent_element(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun DocumentFragment::child_nodes(self: DocumentFragment) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun DocumentFragment::first_child(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun DocumentFragment::last_child(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun DocumentFragment::previous_sibling(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun DocumentFragment::next_sibling(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun DocumentFragment::node_value(self: DocumentFragment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun DocumentFragment::set_node_value(self: mut DocumentFragment, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentFragment::text_content(self: DocumentFragment) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun DocumentFragment::set_text_content(self: mut DocumentFragment, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun DocumentFragment::children(self: DocumentFragment) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun DocumentFragment::first_element_child(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun DocumentFragment::last_element_child(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun DocumentFragment::child_element_count(self: DocumentFragment) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun DocumentFragment::get_part_root(__self: mut DocumentFragment) -> mut DocumentPartRoot = "
    const r = #var(__self).getPartRoot();
    return #fun(DocumentPartRoot::from_js)(r);
"

pub ext fun DocumentFragment::has_child_nodes(__self: mut DocumentFragment) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::get_root_node(__self: mut DocumentFragment, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::normalize(__self: mut DocumentFragment) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::clone_node(__self: mut DocumentFragment, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::is_equal_node(__self: mut DocumentFragment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::is_same_node(__self: mut DocumentFragment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::compare_document_position(__self: mut DocumentFragment, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun DocumentFragment::contains(__self: mut DocumentFragment, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::lookup_prefix(__self: mut DocumentFragment, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentFragment::lookup_namespace_uri(__self: mut DocumentFragment, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentFragment::is_default_namespace(__self: mut DocumentFragment, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::insert_before(__self: mut DocumentFragment, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::append_child(__self: mut DocumentFragment, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::replace_child(__self: mut DocumentFragment, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::remove_child(__self: mut DocumentFragment, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::add_event_listener(__self: mut DocumentFragment, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::remove_event_listener(__self: mut DocumentFragment, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::dispatch_event(__self: mut DocumentFragment, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::when(__self: mut DocumentFragment, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub ext fun DocumentFragment::prepend(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::append(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::replace_children(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::move_before(__self: mut DocumentFragment, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::query_selector(__self: mut DocumentFragment, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun DocumentFragment::query_selector_all(__self: mut DocumentFragment, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun DocumentFragment::get_element_by_id(__self: mut DocumentFragment, element_id: String) -> Option[mut Element] = "
    const r = #var(__self).getElementById(#fun(String::as_js)(#var(element_id)));
    return #fun(Option::from_js[mut Element])(r);
"

pub fun DocumentFragment::as_js(self: DocumentFragment) -> JsValue = JsValue::unsafe_from[DocumentFragment](self)

pub fun DocumentFragment::from_js(v: JsValue) -> mut DocumentFragment = JsValue::unsafe_as[mut DocumentFragment](v)

pub val DocumentFragment::element_node: Int = 1
pub val DocumentFragment::attribute_node: Int = 2
pub val DocumentFragment::text_node: Int = 3
pub val DocumentFragment::cdata_section_node: Int = 4
pub val DocumentFragment::entity_reference_node: Int = 5
pub val DocumentFragment::entity_node: Int = 6
pub val DocumentFragment::processing_instruction_node: Int = 7
pub val DocumentFragment::comment_node: Int = 8
pub val DocumentFragment::document_node: Int = 9
pub val DocumentFragment::document_type_node: Int = 10
pub val DocumentFragment::document_fragment_node: Int = 11
pub val DocumentFragment::notation_node: Int = 12
pub val DocumentFragment::document_position_disconnected: Int = 1
pub val DocumentFragment::document_position_preceding: Int = 2
pub val DocumentFragment::document_position_following: Int = 4
pub val DocumentFragment::document_position_contains: Int = 8
pub val DocumentFragment::document_position_contained_by: Int = 16
pub val DocumentFragment::document_position_implementation_specific: Int = 32

struct DocumentPartRoot()

pub ext fun DocumentPartRoot::root_container(self: DocumentPartRoot) -> mut Node
    = "return #fun(Node::from_js)(#var(self).rootContainer);"

pub ext fun DocumentPartRoot::get_parts(__self: mut DocumentPartRoot) -> List[mut Part] = "
    const r = #var(__self).getParts();
    return #fun(List::from_js[mut Part])(r);
"

pub ext fun DocumentPartRoot::get_node_part_nodes(__self: mut DocumentPartRoot) -> List[mut Node] = "
    const r = #var(__self).getNodePartNodes();
    return #fun(List::from_js[mut Node])(r);
"

pub ext fun DocumentPartRoot::get_child_node_part_nodes(__self: mut DocumentPartRoot) -> List[mut Node] = "
    const r = #var(__self).getChildNodePartNodes();
    return #fun(List::from_js[mut Node])(r);
"

pub ext fun DocumentPartRoot::clone(__self: mut DocumentPartRoot) -> JsValue = "
    const r = #var(__self).clone();
    return r;
"

pub fun DocumentPartRoot::as_js(self: DocumentPartRoot) -> JsValue = JsValue::unsafe_from[DocumentPartRoot](self)

pub fun DocumentPartRoot::from_js(v: JsValue) -> mut DocumentPartRoot = JsValue::unsafe_as[mut DocumentPartRoot](v)

struct DocumentType()

/// Converts a reference to 'DocumentType' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_node(self: DocumentType) -> Node = "return #var(self);"

/// Converts a mutable reference to 'DocumentType' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_mnode(self: mut DocumentType) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_node(base: Node) -> DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentType'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_mnode(base: mut Node) -> mut DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentType'!\");
"

/// Converts a reference to 'DocumentType' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_event_target(self: DocumentType) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'DocumentType' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_mevent_target(self: mut DocumentType) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_event_target(base: EventTarget) -> DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentType'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_mevent_target(base: mut EventTarget) -> mut DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentType'!\");
"

pub ext fun DocumentType::name(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun DocumentType::public_id(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).publicId);"

pub ext fun DocumentType::system_id(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).systemId);"

pub ext fun DocumentType::node_type(self: DocumentType) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun DocumentType::node_name(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun DocumentType::base_uri(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun DocumentType::is_connected(self: DocumentType) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun DocumentType::owner_document(self: DocumentType) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun DocumentType::parent_node(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun DocumentType::parent_element(self: DocumentType) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun DocumentType::child_nodes(self: DocumentType) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun DocumentType::first_child(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun DocumentType::last_child(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun DocumentType::previous_sibling(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun DocumentType::next_sibling(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun DocumentType::node_value(self: DocumentType) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun DocumentType::set_node_value(self: mut DocumentType, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentType::text_content(self: DocumentType) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun DocumentType::set_text_content(self: mut DocumentType, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun DocumentType::has_child_nodes(__self: mut DocumentType) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::get_root_node(__self: mut DocumentType, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::normalize(__self: mut DocumentType) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::clone_node(__self: mut DocumentType, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::is_equal_node(__self: mut DocumentType, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::is_same_node(__self: mut DocumentType, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::compare_document_position(__self: mut DocumentType, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun DocumentType::contains(__self: mut DocumentType, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::lookup_prefix(__self: mut DocumentType, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentType::lookup_namespace_uri(__self: mut DocumentType, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentType::is_default_namespace(__self: mut DocumentType, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::insert_before(__self: mut DocumentType, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::append_child(__self: mut DocumentType, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::replace_child(__self: mut DocumentType, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::remove_child(__self: mut DocumentType, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::add_event_listener(__self: mut DocumentType, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::remove_event_listener(__self: mut DocumentType, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::dispatch_event(__self: mut DocumentType, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::when(__self: mut DocumentType, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub ext fun DocumentType::before(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::after(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::replace_with(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::remove(__self: mut DocumentType) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun DocumentType::as_js(self: DocumentType) -> JsValue = JsValue::unsafe_from[DocumentType](self)

pub fun DocumentType::from_js(v: JsValue) -> mut DocumentType = JsValue::unsafe_as[mut DocumentType](v)

pub val DocumentType::element_node: Int = 1
pub val DocumentType::attribute_node: Int = 2
pub val DocumentType::text_node: Int = 3
pub val DocumentType::cdata_section_node: Int = 4
pub val DocumentType::entity_reference_node: Int = 5
pub val DocumentType::entity_node: Int = 6
pub val DocumentType::processing_instruction_node: Int = 7
pub val DocumentType::comment_node: Int = 8
pub val DocumentType::document_node: Int = 9
pub val DocumentType::document_type_node: Int = 10
pub val DocumentType::document_fragment_node: Int = 11
pub val DocumentType::notation_node: Int = 12
pub val DocumentType::document_position_disconnected: Int = 1
pub val DocumentType::document_position_preceding: Int = 2
pub val DocumentType::document_position_following: Int = 4
pub val DocumentType::document_position_contains: Int = 8
pub val DocumentType::document_position_contained_by: Int = 16
pub val DocumentType::document_position_implementation_specific: Int = 32

struct DOMException()

pub ext fun DOMException::from_str_str(message: String, name: String) -> mut DOMException
    = "return new DOMException(#fun(String::as_js)(#var(message)), #fun(String::as_js)(#var(name)));"

pub ext fun DOMException::code(self: DOMException) -> Int
    = "return #fun(Int::from_js)(#var(self).code);"

pub ext fun DOMException::name(self: DOMException) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun DOMException::message(self: DOMException) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub fun DOMException::as_js(self: DOMException) -> JsValue = JsValue::unsafe_from[DOMException](self)

pub fun DOMException::from_js(v: JsValue) -> mut DOMException = JsValue::unsafe_as[mut DOMException](v)

pub val DOMException::index_size_err: Int = 1
pub val DOMException::domstring_size_err: Int = 2
pub val DOMException::hierarchy_request_err: Int = 3
pub val DOMException::wrong_document_err: Int = 4
pub val DOMException::invalid_character_err: Int = 5
pub val DOMException::no_data_allowed_err: Int = 6
pub val DOMException::no_modification_allowed_err: Int = 7
pub val DOMException::not_found_err: Int = 8
pub val DOMException::not_supported_err: Int = 9
pub val DOMException::inuse_attribute_err: Int = 10
pub val DOMException::invalid_state_err: Int = 11
pub val DOMException::syntax_err: Int = 12
pub val DOMException::invalid_modification_err: Int = 13
pub val DOMException::namespace_err: Int = 14
pub val DOMException::invalid_access_err: Int = 15
pub val DOMException::validation_err: Int = 16
pub val DOMException::type_mismatch_err: Int = 17
pub val DOMException::security_err: Int = 18
pub val DOMException::network_err: Int = 19
pub val DOMException::abort_err: Int = 20
pub val DOMException::url_mismatch_err: Int = 21
pub val DOMException::quota_exceeded_err: Int = 22
pub val DOMException::timeout_err: Int = 23
pub val DOMException::invalid_node_type_err: Int = 24
pub val DOMException::data_clone_err: Int = 25

struct DOMImplementation()

pub ext fun DOMImplementation::create_document_type(__self: mut DOMImplementation, qualified_name: String, public_id: String, system_id: String) -> mut DocumentType = "
    const r = #var(__self).createDocumentType(#fun(String::as_js)(#var(qualified_name)), #fun(String::as_js)(#var(public_id)), #fun(String::as_js)(#var(system_id)));
    return #fun(DocumentType::from_js)(r);
"

pub ext fun DOMImplementation::create_document(__self: mut DOMImplementation, namespace_uri: Option[String], qualified_name: String, doctype: Option[mut DocumentType]) -> mut XMLDocument = "
    const r = #var(__self).createDocument(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(qualified_name)), #fun(Option::as_js[mut DocumentType])(#var(doctype)));
    return #fun(XMLDocument::from_js)(r);
"

pub ext fun DOMImplementation::create_html_document(__self: mut DOMImplementation, title: String) -> mut Document = "
    const r = #var(__self).createHTMLDocument(#fun(String::as_js)(#var(title)));
    return #fun(Document::from_js)(r);
"

pub ext fun DOMImplementation::has_feature(__self: mut DOMImplementation) -> Bool = "
    const r = #var(__self).hasFeature();
    return #fun(Bool::from_js)(r);
"

pub fun DOMImplementation::as_js(self: DOMImplementation) -> JsValue = JsValue::unsafe_from[DOMImplementation](self)

pub fun DOMImplementation::from_js(v: JsValue) -> mut DOMImplementation = JsValue::unsafe_as[mut DOMImplementation](v)

struct DOMStringList()

pub ext fun DOMStringList::length(self: DOMStringList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun DOMStringList::item(__self: mut DOMStringList, index: Int) -> Option[String] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DOMStringList::contains(__self: mut DOMStringList, string: String) -> Bool = "
    const r = #var(__self).contains(#fun(String::as_js)(#var(string)));
    return #fun(Bool::from_js)(r);
"

pub fun DOMStringList::as_js(self: DOMStringList) -> JsValue = JsValue::unsafe_from[DOMStringList](self)

pub fun DOMStringList::from_js(v: JsValue) -> mut DOMStringList = JsValue::unsafe_as[mut DOMStringList](v)

struct DOMStringMap()

pub ext fun DOMStringMap::get(__self: DOMStringMap, name: String) -> String = "
    const r = DOMStringMap[#fun(String::as_js)(#var(name))];
    return #fun(String::from_js)(r);
"

pub ext fun DOMStringMap::set(__self: mut DOMStringMap, name: String, value: String) = "
    DOMStringMap[#fun(String::as_js)(#var(name))] = #fun(String::as_js)(#var(value));
"

pub ext fun DOMStringMap::remove(__self: mut DOMStringMap, name: String) = "
    delete DOMStringMap[#fun(String::as_js)(#var(name))];
"

pub fun DOMStringMap::as_js(self: DOMStringMap) -> JsValue = JsValue::unsafe_from[DOMStringMap](self)

pub fun DOMStringMap::from_js(v: JsValue) -> mut DOMStringMap = JsValue::unsafe_as[mut DOMStringMap](v)

struct DOMTokenList()

pub ext fun DOMTokenList::length(self: DOMTokenList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun DOMTokenList::value(self: DOMTokenList) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun DOMTokenList::set_value(self: mut DOMTokenList, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun DOMTokenList::item(__self: mut DOMTokenList, index: Int) -> Option[String] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DOMTokenList::contains(__self: mut DOMTokenList, token: String) -> Bool = "
    const r = #var(__self).contains(#fun(String::as_js)(#var(token)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::add(__self: mut DOMTokenList, ...tokens: List[String]) -> Unit = "
    const r = #var(__self).add(...((#var(tokens)).map(v => #fun(String::as_js)(v))));
    return #fun(Unit::from_js)(r);
"

pub ext fun DOMTokenList::remove(__self: mut DOMTokenList, ...tokens: List[String]) -> Unit = "
    const r = #var(__self).remove(...((#var(tokens)).map(v => #fun(String::as_js)(v))));
    return #fun(Unit::from_js)(r);
"

pub ext fun DOMTokenList::toggle(__self: mut DOMTokenList, token: String, force: Bool) -> Bool = "
    const r = #var(__self).toggle(#fun(String::as_js)(#var(token)), #fun(Bool::as_js)(#var(force)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::replace(__self: mut DOMTokenList, token: String, new_token: String) -> Bool = "
    const r = #var(__self).replace(#fun(String::as_js)(#var(token)), #fun(String::as_js)(#var(new_token)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::supports(__self: mut DOMTokenList, token: String) -> Bool = "
    const r = #var(__self).supports(#fun(String::as_js)(#var(token)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::as_string(__self: mut DOMTokenList) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub fun DOMTokenList::as_js(self: DOMTokenList) -> JsValue = JsValue::unsafe_from[DOMTokenList](self)

pub fun DOMTokenList::from_js(v: JsValue) -> mut DOMTokenList = JsValue::unsafe_as[mut DOMTokenList](v)

pub struct CheckVisibilityOptions(
    check_opacity: Option[Bool],
    check_visibility_css: Option[Bool],
    content_visibility_auto: Option[Bool],
    opacity_property: Option[Bool],
    visibility_property: Option[Bool]
)

pub fun CheckVisibilityOptions::default() -> mut CheckVisibilityOptions
    = CheckVisibilityOptions(Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun CheckVisibilityOptions::from_js(value: JsValue) -> mut CheckVisibilityOptions = "
    const r = {};
    r.m_check_opacity = #fun(Option::from_js[Bool])(#var(value).checkOpacity);
    r.m_check_visibility_css = #fun(Option::from_js[Bool])(#var(value).checkVisibilityCSS);
    r.m_content_visibility_auto = #fun(Option::from_js[Bool])(#var(value).contentVisibilityAuto);
    r.m_opacity_property = #fun(Option::from_js[Bool])(#var(value).opacityProperty);
    r.m_visibility_property = #fun(Option::from_js[Bool])(#var(value).visibilityProperty);
    return r;
"

pub ext fun CheckVisibilityOptions::as_js(self: CheckVisibilityOptions) -> JsValue = "
    const r = {};
    r.checkOpacity = #fun(Option::as_js_undef[Bool])(#var(self).m_check_opacity);
    r.checkVisibilityCSS = #fun(Option::as_js_undef[Bool])(#var(self).m_check_visibility_css);
    r.contentVisibilityAuto = #fun(Option::as_js_undef[Bool])(#var(self).m_content_visibility_auto);
    r.opacityProperty = #fun(Option::as_js_undef[Bool])(#var(self).m_opacity_property);
    r.visibilityProperty = #fun(Option::as_js_undef[Bool])(#var(self).m_visibility_property);
    return r;
"

pub val SanitizerPresets::Default: String = "default"

pub struct SetHTMLOptions(
    sanitizer: Option[JsValue]
)

pub fun SetHTMLOptions::default() -> mut SetHTMLOptions
    = SetHTMLOptions(Option::Some("default" |> as_js()))

pub ext fun SetHTMLOptions::from_js(value: JsValue) -> mut SetHTMLOptions = "
    const r = {};
    r.m_sanitizer = #fun(Option::from_js[JsValue])(#var(value).sanitizer);
    return r;
"

pub ext fun SetHTMLOptions::as_js(self: SetHTMLOptions) -> JsValue = "
    const r = {};
    r.sanitizer = #fun(Option::as_js_undef[JsValue])(#var(self).m_sanitizer);
    return r;
"

pub struct SetHTMLUnsafeOptions(
    sanitizer: Option[JsValue]
)

pub fun SetHTMLUnsafeOptions::default() -> mut SetHTMLUnsafeOptions
    = SetHTMLUnsafeOptions(Option::Some(JsValue::from_js(JsObject::empty() |> as_js()) |> as_js()))

pub ext fun SetHTMLUnsafeOptions::from_js(value: JsValue) -> mut SetHTMLUnsafeOptions = "
    const r = {};
    r.m_sanitizer = #fun(Option::from_js[JsValue])(#var(value).sanitizer);
    return r;
"

pub ext fun SetHTMLUnsafeOptions::as_js(self: SetHTMLUnsafeOptions) -> JsValue = "
    const r = {};
    r.sanitizer = #fun(Option::as_js_undef[JsValue])(#var(self).m_sanitizer);
    return r;
"

/// Converts a reference to 'Element' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_node(self: Element) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Element' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_mnode(self: mut Element) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_node(base: Node) -> Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Element'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_mnode(base: mut Node) -> mut Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Element'!\");
"

/// Converts a reference to 'Element' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_event_target(self: Element) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Element' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_mevent_target(self: mut Element) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_event_target(base: EventTarget) -> Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Element'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_mevent_target(base: mut EventTarget) -> mut Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Element'!\");
"

pub ext fun Element::namespace_uri(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).namespaceURI);"

pub ext fun Element::prefix(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).prefix);"

pub ext fun Element::local_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).localName);"

pub ext fun Element::tag_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).tagName);"

pub ext fun Element::id(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun Element::set_id(self: mut Element, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun Element::class_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).className);"

pub ext fun Element::set_class_name(self: mut Element, value: String)
    = "#var(self).className = #fun(String::as_js)(#var(value));"

pub ext fun Element::class_list(self: Element) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).classList);"

pub ext fun Element::slot(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).slot);"

pub ext fun Element::set_slot(self: mut Element, value: String)
    = "#var(self).slot = #fun(String::as_js)(#var(value));"

pub ext fun Element::attributes(self: Element) -> mut NamedNodeMap
    = "return #fun(NamedNodeMap::from_js)(#var(self).attributes);"

pub ext fun Element::shadow_root(self: Element) -> Option[mut ShadowRoot]
    = "return #fun(Option::from_js[mut ShadowRoot])(#var(self).shadowRoot);"

pub ext fun Element::part(self: Element) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).part);"

pub ext fun Element::assigned_slot(self: Element) -> Option[mut HTMLSlotElement]
    = "return #fun(Option::from_js[mut HTMLSlotElement])(#var(self).assignedSlot);"

pub ext fun Element::inner_html(self: Element) -> JsValue
    = "return #var(self).innerHTML;"

pub ext fun Element::set_inner_html(self: mut Element, value: JsValue)
    = "#var(self).innerHTML = #var(value);"

pub ext fun Element::outer_html(self: Element) -> JsValue
    = "return #var(self).outerHTML;"

pub ext fun Element::set_outer_html(self: mut Element, value: JsValue)
    = "#var(self).outerHTML = #var(value);"

pub ext fun Element::scroll_top(self: Element) -> Float
    = "return #fun(Float::from_js)(#var(self).scrollTop);"

pub ext fun Element::set_scroll_top(self: mut Element, value: Float)
    = "#var(self).scrollTop = #fun(Float::as_js)(#var(value));"

pub ext fun Element::scroll_left(self: Element) -> Float
    = "return #fun(Float::from_js)(#var(self).scrollLeft);"

pub ext fun Element::set_scroll_left(self: mut Element, value: Float)
    = "#var(self).scrollLeft = #fun(Float::as_js)(#var(value));"

pub ext fun Element::scroll_width(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).scrollWidth);"

pub ext fun Element::scroll_height(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).scrollHeight);"

pub ext fun Element::client_top(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).clientTop);"

pub ext fun Element::client_left(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).clientLeft);"

pub ext fun Element::client_width(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).clientWidth);"

pub ext fun Element::client_height(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).clientHeight);"

pub ext fun Element::current_css_zoom(self: Element) -> Float
    = "return #fun(Float::from_js)(#var(self).currentCSSZoom);"

pub ext fun Element::anchor_element(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).anchorElement);"

pub ext fun Element::set_anchor_element(self: mut Element, value: Option[mut Element])
    = "#var(self).anchorElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun Element::computed_role(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).computedRole);"

pub ext fun Element::computed_name(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).computedName);"

pub ext fun Element::onbeforecopy(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforecopy);"

pub ext fun Element::set_onbeforecopy(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforecopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onbeforecut(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforecut);"

pub ext fun Element::set_onbeforecut(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforecut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onbeforepaste(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforepaste);"

pub ext fun Element::set_onbeforepaste(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforepaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onsearch(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsearch);"

pub ext fun Element::set_onsearch(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsearch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::element_timing(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).elementTiming);"

pub ext fun Element::set_element_timing(self: mut Element, value: String)
    = "#var(self).elementTiming = #fun(String::as_js)(#var(value));"

pub ext fun Element::container_timing(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).containerTiming);"

pub ext fun Element::set_container_timing(self: mut Element, value: String)
    = "#var(self).containerTiming = #fun(String::as_js)(#var(value));"

pub ext fun Element::container_timing_ignore(self: Element) -> Bool
    = "return #fun(Bool::from_js)(#var(self).containerTimingIgnore);"

pub ext fun Element::set_container_timing_ignore(self: mut Element, value: Bool)
    = "#var(self).containerTimingIgnore = #fun(Bool::as_js)(#var(value));"

pub ext fun Element::heading_offset(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).headingOffset);"

pub ext fun Element::set_heading_offset(self: mut Element, value: Int)
    = "#var(self).headingOffset = #fun(Int::as_js)(#var(value));"

pub ext fun Element::heading_reset(self: Element) -> Bool
    = "return #fun(Bool::from_js)(#var(self).headingReset);"

pub ext fun Element::set_heading_reset(self: mut Element, value: Bool)
    = "#var(self).headingReset = #fun(Bool::as_js)(#var(value));"

pub ext fun Element::custom_element_registry(self: Element) -> Option[mut CustomElementRegistry]
    = "return #fun(Option::from_js[mut CustomElementRegistry])(#var(self).customElementRegistry);"

pub ext fun Element::node_type(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Element::node_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Element::base_uri(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Element::is_connected(self: Element) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Element::owner_document(self: Element) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Element::parent_node(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Element::parent_element(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Element::child_nodes(self: Element) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Element::first_child(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Element::last_child(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Element::previous_sibling(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Element::next_sibling(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Element::node_value(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Element::set_node_value(self: mut Element, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::text_content(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Element::set_text_content(self: mut Element, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Element::has_attributes(__self: mut Element) -> Bool = "
    const r = #var(__self).hasAttributes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_attribute_names(__self: mut Element) -> List[String] = "
    const r = #var(__self).getAttributeNames();
    return #fun(List::from_js[String])(r);
"

pub ext fun Element::get_attribute(__self: mut Element, name: String) -> Option[String] = "
    const r = #var(__self).getAttribute(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::get_attribute_ns(__self: mut Element, namespace_uri: Option[String], local_name: String) -> Option[String] = "
    const r = #var(__self).getAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::set_attribute_str_str(__self: mut Element, name: String, value: String) -> Unit = "
    const r = #var(__self).setAttribute(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_attribute_str_any(__self: mut Element, name: String, value: JsValue) -> Unit = "
    const r = #var(__self).setAttribute(#fun(String::as_js)(#var(name)), #var(value));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_attribute_ns_ostr_str_str(__self: mut Element, namespace_uri: Option[String], name: String, value: String) -> Unit = "
    const r = #var(__self).setAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_attribute_ns_ostr_str_any(__self: mut Element, namespace_uri: Option[String], name: String, value: JsValue) -> Unit = "
    const r = #var(__self).setAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(name)), #var(value));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_attribute(__self: mut Element, name: String) -> Unit = "
    const r = #var(__self).removeAttribute(#fun(String::as_js)(#var(name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_attribute_ns(__self: mut Element, namespace_uri: Option[String], local_name: String) -> Unit = "
    const r = #var(__self).removeAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::toggle_attribute(__self: mut Element, qualified_name: String, force: Bool) -> Bool = "
    const r = #var(__self).toggleAttribute(#fun(String::as_js)(#var(qualified_name)), #fun(Bool::as_js)(#var(force)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::has_attribute(__self: mut Element, name: String) -> Bool = "
    const r = #var(__self).hasAttribute(#fun(String::as_js)(#var(name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::has_attribute_ns(__self: mut Element, namespace_uri: Option[String], local_name: String) -> Bool = "
    const r = #var(__self).hasAttributeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_attribute_node(__self: mut Element, name: String) -> Option[mut Attr] = "
    const r = #var(__self).getAttributeNode(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::get_attribute_node_ns(__self: mut Element, namespace_uri: Option[String], local_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getAttributeNodeNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::set_attribute_node(__self: mut Element, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setAttributeNode(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::set_attribute_node_ns(__self: mut Element, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setAttributeNodeNS(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::remove_attribute_node(__self: mut Element, attr: mut Attr) -> mut Attr = "
    const r = #var(__self).removeAttributeNode(#fun(Attr::as_js)(#var(attr)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Element::attach_shadow(__self: mut Element, shadow_root_init_dict: mut ShadowRootInit) -> mut ShadowRoot = "
    const r = #var(__self).attachShadow(#fun(ShadowRootInit::as_js)(#var(shadow_root_init_dict)));
    return #fun(ShadowRoot::from_js)(r);
"

pub ext fun Element::closest(__self: mut Element, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).closest(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::matches(__self: mut Element, selectors: String) -> Bool = "
    const r = #var(__self).matches(#fun(String::as_js)(#var(selectors)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::webkit_matches_selector(__self: mut Element, selectors: String) -> Bool = "
    const r = #var(__self).webkitMatchesSelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_elements_by_tag_name(__self: mut Element, local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagName(#fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::get_elements_by_tag_name_ns(__self: mut Element, namespace_uri: Option[String], local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagNameNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::get_elements_by_class_name(__self: mut Element, class_names: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByClassName(#fun(String::as_js)(#var(class_names)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::insert_adjacent_element(__self: mut Element, where: String, element: mut Element) -> Option[mut Element] = "
    const r = #var(__self).insertAdjacentElement(#fun(String::as_js)(#var(where)), #fun(Element::as_js)(#var(element)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::insert_adjacent_text(__self: mut Element, where: String, data: String) -> Unit = "
    const r = #var(__self).insertAdjacentText(#fun(String::as_js)(#var(where)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_pointer_capture(__self: mut Element, pointer_id: Int) -> Unit = "
    const r = #var(__self).setPointerCapture(#fun(Int::as_js)(#var(pointer_id)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::release_pointer_capture(__self: mut Element, pointer_id: Int) -> Unit = "
    const r = #var(__self).releasePointerCapture(#fun(Int::as_js)(#var(pointer_id)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::has_pointer_capture(__self: mut Element, pointer_id: Int) -> Bool = "
    const r = #var(__self).hasPointerCapture(#fun(Int::as_js)(#var(pointer_id)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::insert_adjacent_html(__self: mut Element, position: String, text: String) -> Unit = "
    const r = #var(__self).insertAdjacentHTML(#fun(String::as_js)(#var(position)), #fun(String::as_js)(#var(text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_html_unsafe_str(__self: mut Element, html: String) -> Unit = "
    const r = #var(__self).setHTMLUnsafe(#fun(String::as_js)(#var(html)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_html_unsafe_str_mset_html_unsafe_options(__self: mut Element, html: String, options: mut SetHTMLUnsafeOptions) -> Unit = "
    const r = #var(__self).setHTMLUnsafe(#fun(String::as_js)(#var(html)), #fun(SetHTMLUnsafeOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_html(__self: mut Element, html: String, options: mut SetHTMLOptions) -> Unit = "
    const r = #var(__self).setHTML(#fun(String::as_js)(#var(html)), #fun(SetHTMLOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::get_html(__self: mut Element, options: mut GetHTMLOptions) -> String = "
    const r = #var(__self).getHTML(#fun(GetHTMLOptions::as_js)(#var(options)));
    return #fun(String::from_js)(r);
"

pub ext fun Element::request_pointer_lock(__self: mut Element, options: mut PointerLockOptions) -> Promise[Unit] = "
    const r = #var(__self).requestPointerLock(#fun(PointerLockOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::get_client_rects(__self: mut Element) -> mut DOMRectList = "
    const r = #var(__self).getClientRects();
    return #fun(DOMRectList::from_js)(r);
"

pub ext fun Element::get_bounding_client_rect(__self: mut Element) -> mut DOMRect = "
    const r = #var(__self).getBoundingClientRect();
    return #fun(DOMRect::from_js)(r);
"

pub ext fun Element::check_visibility(__self: mut Element, options: mut CheckVisibilityOptions) -> Bool = "
    const r = #var(__self).checkVisibility(#fun(CheckVisibilityOptions::as_js)(#var(options)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::scroll_into_view(__self: mut Element, arg: JsValue) -> Promise[Unit] = "
    const r = #var(__self).scrollIntoView(#var(arg));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_mscroll_to_options(__self: mut Element, options: mut ScrollToOptions) -> Promise[Unit] = "
    const r = #var(__self).scroll(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_flt_flt(__self: mut Element, x: Float, y: Float) -> Promise[Unit] = "
    const r = #var(__self).scroll(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_to_mscroll_to_options(__self: mut Element, options: mut ScrollToOptions) -> Promise[Unit] = "
    const r = #var(__self).scrollTo(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_to_flt_flt(__self: mut Element, x: Float, y: Float) -> Promise[Unit] = "
    const r = #var(__self).scrollTo(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_by_mscroll_to_options(__self: mut Element, options: mut ScrollToOptions) -> Promise[Unit] = "
    const r = #var(__self).scrollBy(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_by_flt_flt(__self: mut Element, x: Float, y: Float) -> Promise[Unit] = "
    const r = #var(__self).scrollBy(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::scroll_into_view_if_needed(__self: mut Element, center_if_needed: Bool) -> Unit = "
    const r = #var(__self).scrollIntoViewIfNeeded(#fun(Bool::as_js)(#var(center_if_needed)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::aria_notify(__self: mut Element, announcement: String, options: mut AriaNotificationOptions) -> Unit = "
    const r = #var(__self).ariaNotify(#fun(String::as_js)(#var(announcement)), #fun(AriaNotificationOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::has_child_nodes(__self: mut Element) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_root_node(__self: mut Element, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::normalize(__self: mut Element) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::clone_node(__self: mut Element, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::is_equal_node(__self: mut Element, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::is_same_node(__self: mut Element, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::compare_document_position(__self: mut Element, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Element::contains(__self: mut Element, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::lookup_prefix(__self: mut Element, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::lookup_namespace_uri(__self: mut Element, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::is_default_namespace(__self: mut Element, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::insert_before(__self: mut Element, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::append_child(__self: mut Element, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::replace_child(__self: mut Element, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::remove_child(__self: mut Element, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::add_event_listener(__self: mut Element, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_event_listener(__self: mut Element, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::dispatch_event(__self: mut Element, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::when(__self: mut Element, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub val Element::element_node: Int = 1
pub val Element::attribute_node: Int = 2
pub val Element::text_node: Int = 3
pub val Element::cdata_section_node: Int = 4
pub val Element::entity_reference_node: Int = 5
pub val Element::entity_node: Int = 6
pub val Element::processing_instruction_node: Int = 7
pub val Element::comment_node: Int = 8
pub val Element::document_node: Int = 9
pub val Element::document_type_node: Int = 10
pub val Element::document_fragment_node: Int = 11
pub val Element::notation_node: Int = 12
pub val Element::document_position_disconnected: Int = 1
pub val Element::document_position_preceding: Int = 2
pub val Element::document_position_following: Int = 4
pub val Element::document_position_contains: Int = 8
pub val Element::document_position_contained_by: Int = 16
pub val Element::document_position_implementation_specific: Int = 32

pub struct ElementCreationOptions(
    is: Option[String],
    custom_element_registry: Option[mut CustomElementRegistry]
)

pub fun ElementCreationOptions::default() -> mut ElementCreationOptions
    = ElementCreationOptions(Option::None, Option::None)

pub ext fun ElementCreationOptions::from_js(value: JsValue) -> mut ElementCreationOptions = "
    const r = {};
    r.m_is = #fun(Option::from_js[String])(#var(value).is);
    r.m_custom_element_registry = #fun(Option::from_js[mut CustomElementRegistry])(#var(value).customElementRegistry);
    return r;
"

pub ext fun ElementCreationOptions::as_js(self: ElementCreationOptions) -> JsValue = "
    const r = {};
    r.is = #fun(Option::as_js_undef[String])(#var(self).m_is);
    r.customElementRegistry = #fun(Option::as_js_undef[mut CustomElementRegistry])(#var(self).m_custom_element_registry);
    return r;
"

pub struct ElementDefinitionOptions(
    extends: Option[String]
)

pub fun ElementDefinitionOptions::default() -> mut ElementDefinitionOptions
    = ElementDefinitionOptions(Option::None)

pub ext fun ElementDefinitionOptions::from_js(value: JsValue) -> mut ElementDefinitionOptions = "
    const r = {};
    r.m_extends = #fun(Option::from_js[String])(#var(value).extends);
    return r;
"

pub ext fun ElementDefinitionOptions::as_js(self: ElementDefinitionOptions) -> JsValue = "
    const r = {};
    r.extends = #fun(Option::as_js_undef[String])(#var(self).m_extends);
    return r;
"

pub struct ElementRegistrationOptions(
    prototype: Option[JsObject],
    extends: Option[String]
)

pub fun ElementRegistrationOptions::default() -> mut ElementRegistrationOptions
    = ElementRegistrationOptions(Option::None, Option::None)

pub ext fun ElementRegistrationOptions::from_js(value: JsValue) -> mut ElementRegistrationOptions = "
    const r = {};
    r.m_prototype = #fun(Option::from_js[JsObject])(#var(value).prototype);
    r.m_extends = #fun(Option::from_js[String])(#var(value).extends);
    return r;
"

pub ext fun ElementRegistrationOptions::as_js(self: ElementRegistrationOptions) -> JsValue = "
    const r = {};
    r.prototype = #fun(Option::as_js_undef[JsObject])(#var(self).m_prototype);
    r.extends = #fun(Option::as_js_undef[String])(#var(self).m_extends);
    return r;
"

pub struct AddEventListenerOptions(
    passive: Option[Bool],
    once: Option[Bool],
    signal: Option[mut AbortSignal],
    capture: Option[Bool]
)

pub fun AddEventListenerOptions::default() -> mut AddEventListenerOptions
    = AddEventListenerOptions(Option::None, Option::Some(false), Option::None, Option::Some(false))

/// Converts a reference to 'AddEventListenerOptions' to a reference to 'EventListenerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::as_event_listener_options(self: AddEventListenerOptions) -> EventListenerOptions = "return #var(self);"

/// Converts a mutable reference to 'AddEventListenerOptions' to a mutable reference to 'EventListenerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::as_mevent_listener_options(self: mut AddEventListenerOptions) -> mut EventListenerOptions = "return #var(self);"

/// Attempts to convert a reference to 'EventListenerOptions' to a reference to 'AddEventListenerOptions'.
/// A 'base' that is not a reference to 'AddEventListenerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::from_event_listener_options_unchecked(base: EventListenerOptions) -> AddEventListenerOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventListenerOptions' to a mutable reference to 'AddEventListenerOptions'.
/// A 'base' that is not a reference to 'AddEventListenerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::from_mevent_listener_options_unchecked(base: mut EventListenerOptions) -> mut AddEventListenerOptions = "return #var(base);"

pub ext fun AddEventListenerOptions::from_js(value: JsValue) -> mut AddEventListenerOptions = "
    const r = {};
    r.m_passive = #fun(Option::from_js[Bool])(#var(value).passive);
    r.m_once = #fun(Option::from_js[Bool])(#var(value).once);
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    r.m_capture = #fun(Option::from_js[Bool])(#var(value).capture);
    return r;
"

pub ext fun AddEventListenerOptions::as_js(self: AddEventListenerOptions) -> JsValue = "
    const r = {};
    r.passive = #fun(Option::as_js_undef[Bool])(#var(self).m_passive);
    r.once = #fun(Option::as_js_undef[Bool])(#var(self).m_once);
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    r.capture = #fun(Option::as_js_undef[Bool])(#var(self).m_capture);
    return r;
"

struct CustomEvent()

/// Converts a reference to 'CustomEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::as_event(self: CustomEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'CustomEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::as_mevent(self: mut CustomEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'CustomEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CustomEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::from_event(base: Event) -> CustomEvent = "
    if(#var(base) instanceof CustomEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CustomEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'CustomEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CustomEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::from_mevent(base: mut Event) -> mut CustomEvent = "
    if(#var(base) instanceof CustomEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CustomEvent'!\");
"

pub ext fun CustomEvent::from_str_mcustom_event_init(type: String, event_init_dict: mut CustomEventInit) -> mut CustomEvent
    = "return new CustomEvent(#fun(String::as_js)(#var(type)), #fun(CustomEventInit::as_js)(#var(event_init_dict)));"

pub ext fun CustomEvent::detail(self: CustomEvent) -> JsValue
    = "return #var(self).detail;"

pub ext fun CustomEvent::type(self: CustomEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CustomEvent::target(self: CustomEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun CustomEvent::current_target(self: CustomEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun CustomEvent::event_phase(self: CustomEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun CustomEvent::bubbles(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun CustomEvent::cancelable(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun CustomEvent::default_prevented(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun CustomEvent::composed(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun CustomEvent::is_trusted(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun CustomEvent::time_stamp(self: CustomEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun CustomEvent::src_element(self: CustomEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun CustomEvent::return_value(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun CustomEvent::set_return_value(self: mut CustomEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun CustomEvent::cancel_bubble(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun CustomEvent::set_cancel_bubble(self: mut CustomEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun CustomEvent::init_custom_event(__self: mut CustomEvent, type: String, bubbles: Bool, cancelable: Bool, detail: JsValue) -> Unit = "
    const r = #var(__self).initCustomEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #var(detail));
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::composed_path(__self: mut CustomEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun CustomEvent::stop_propagation(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::stop_immediate_propagation(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::prevent_default(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::init_event(__self: mut CustomEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun CustomEvent::as_js(self: CustomEvent) -> JsValue = JsValue::unsafe_from[CustomEvent](self)

pub fun CustomEvent::from_js(v: JsValue) -> mut CustomEvent = JsValue::unsafe_as[mut CustomEvent](v)

pub val CustomEvent::none: Int = 0
pub val CustomEvent::capturing_phase: Int = 1
pub val CustomEvent::at_target: Int = 2
pub val CustomEvent::bubbling_phase: Int = 3

pub struct CustomEventInit(
    detail: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun CustomEventInit::default() -> mut CustomEventInit
    = CustomEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'CustomEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::as_event_init(self: CustomEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'CustomEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::as_mevent_init(self: mut CustomEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'CustomEventInit'.
/// A 'base' that is not a reference to 'CustomEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::from_event_init_unchecked(base: EventInit) -> CustomEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'CustomEventInit'.
/// A 'base' that is not a reference to 'CustomEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut CustomEventInit = "return #var(base);"

pub ext fun CustomEventInit::from_js(value: JsValue) -> mut CustomEventInit = "
    const r = {};
    r.m_detail = #fun(Option::from_js[JsValue])(#var(value).detail);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun CustomEventInit::as_js(self: CustomEventInit) -> JsValue = "
    const r = {};
    r.detail = #fun(Option::as_js_undef[JsValue])(#var(self).m_detail);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct Event()

pub ext fun Event::from_str_mevent_init(type: String, event_init_dict: mut EventInit) -> mut Event
    = "return new Event(#fun(String::as_js)(#var(type)), #fun(EventInit::as_js)(#var(event_init_dict)));"

pub ext fun Event::type(self: Event) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Event::target(self: Event) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun Event::current_target(self: Event) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun Event::event_phase(self: Event) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun Event::bubbles(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun Event::cancelable(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun Event::default_prevented(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun Event::composed(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun Event::is_trusted(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun Event::time_stamp(self: Event) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun Event::src_element(self: Event) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun Event::return_value(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun Event::set_return_value(self: mut Event, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun Event::cancel_bubble(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun Event::set_cancel_bubble(self: mut Event, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun Event::composed_path(__self: mut Event) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun Event::stop_propagation(__self: mut Event) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::stop_immediate_propagation(__self: mut Event) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::prevent_default(__self: mut Event) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::init_event(__self: mut Event, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun Event::as_js(self: Event) -> JsValue = JsValue::unsafe_from[Event](self)

pub fun Event::from_js(v: JsValue) -> mut Event = JsValue::unsafe_as[mut Event](v)

pub val Event::none: Int = 0
pub val Event::capturing_phase: Int = 1
pub val Event::at_target: Int = 2
pub val Event::bubbling_phase: Int = 3

pub struct EventInit(
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun EventInit::default() -> mut EventInit
    = EventInit(Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun EventInit::from_js(value: JsValue) -> mut EventInit = "
    const r = {};
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun EventInit::as_js(self: EventInit) -> JsValue = "
    const r = {};
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub struct EventListenerOptions(
    capture: Option[Bool]
)

pub fun EventListenerOptions::default() -> mut EventListenerOptions
    = EventListenerOptions(Option::Some(false))

pub ext fun EventListenerOptions::from_js(value: JsValue) -> mut EventListenerOptions = "
    const r = {};
    r.m_capture = #fun(Option::from_js[Bool])(#var(value).capture);
    return r;
"

pub ext fun EventListenerOptions::as_js(self: EventListenerOptions) -> JsValue = "
    const r = {};
    r.capture = #fun(Option::as_js_undef[Bool])(#var(self).m_capture);
    return r;
"

pub struct EventModifierInit(
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun EventModifierInit::default() -> mut EventModifierInit
    = EventModifierInit(Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'EventModifierInit' to a reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun EventModifierInit::as_ui_event_init(self: EventModifierInit) -> UIEventInit = "return #var(self);"

/// Converts a mutable reference to 'EventModifierInit' to a mutable reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun EventModifierInit::as_mui_event_init(self: mut EventModifierInit) -> mut UIEventInit = "return #var(self);"

/// Attempts to convert a reference to 'UIEventInit' to a reference to 'EventModifierInit'.
/// A 'base' that is not a reference to 'EventModifierInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun EventModifierInit::from_ui_event_init_unchecked(base: UIEventInit) -> EventModifierInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'UIEventInit' to a mutable reference to 'EventModifierInit'.
/// A 'base' that is not a reference to 'EventModifierInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun EventModifierInit::from_mui_event_init_unchecked(base: mut UIEventInit) -> mut EventModifierInit = "return #var(base);"

pub ext fun EventModifierInit::from_js(value: JsValue) -> mut EventModifierInit = "
    const r = {};
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun EventModifierInit::as_js(self: EventModifierInit) -> JsValue = "
    const r = {};
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub struct ObservableEventListenerOptions(
    capture: Option[Bool],
    passive: Option[Bool]
)

pub fun ObservableEventListenerOptions::default() -> mut ObservableEventListenerOptions
    = ObservableEventListenerOptions(Option::Some(false), Option::None)

pub ext fun ObservableEventListenerOptions::from_js(value: JsValue) -> mut ObservableEventListenerOptions = "
    const r = {};
    r.m_capture = #fun(Option::from_js[Bool])(#var(value).capture);
    r.m_passive = #fun(Option::from_js[Bool])(#var(value).passive);
    return r;
"

pub ext fun ObservableEventListenerOptions::as_js(self: ObservableEventListenerOptions) -> JsValue = "
    const r = {};
    r.capture = #fun(Option::as_js_undef[Bool])(#var(self).m_capture);
    r.passive = #fun(Option::as_js_undef[Bool])(#var(self).m_passive);
    return r;
"

struct EventTarget()

pub ext fun EventTarget::new() -> mut EventTarget
    = "return new EventTarget();"

pub ext fun EventTarget::add_event_listener(__self: mut EventTarget, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EventTarget::remove_event_listener(__self: mut EventTarget, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EventTarget::dispatch_event(__self: mut EventTarget, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun EventTarget::when(__self: mut EventTarget, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun EventTarget::as_js(self: EventTarget) -> JsValue = JsValue::unsafe_from[EventTarget](self)

pub fun EventTarget::from_js(v: JsValue) -> mut EventTarget = JsValue::unsafe_as[mut EventTarget](v)

pub struct GetHTMLOptions(
    serializable_shadow_roots: Option[Bool],
    shadow_roots: Option[List[mut ShadowRoot]]
)

pub fun GetHTMLOptions::default() -> mut GetHTMLOptions
    = GetHTMLOptions(Option::Some(false), Option::Some(List::empty()))

pub ext fun GetHTMLOptions::from_js(value: JsValue) -> mut GetHTMLOptions = "
    const r = {};
    r.m_serializable_shadow_roots = #fun(Option::from_js[Bool])(#var(value).serializableShadowRoots);
    r.m_shadow_roots = #fun(Option::from_js[List[mut ShadowRoot]])(#var(value).shadowRoots);
    return r;
"

pub ext fun GetHTMLOptions::as_js(self: GetHTMLOptions) -> JsValue = "
    const r = {};
    r.serializableShadowRoots = #fun(Option::as_js_undef[Bool])(#var(self).m_serializable_shadow_roots);
    r.shadowRoots = #fun(Option::as_js_undef[List[mut ShadowRoot]])(#var(self).m_shadow_roots);
    return r;
"

pub struct GetRootNodeOptions(
    composed: Option[Bool]
)

pub fun GetRootNodeOptions::default() -> mut GetRootNodeOptions
    = GetRootNodeOptions(Option::Some(false))

pub ext fun GetRootNodeOptions::from_js(value: JsValue) -> mut GetRootNodeOptions = "
    const r = {};
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun GetRootNodeOptions::as_js(self: GetRootNodeOptions) -> JsValue = "
    const r = {};
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub struct ImportNodeOptions(
    custom_element_registry: Option[mut CustomElementRegistry],
    self_only: Option[Bool]
)

pub fun ImportNodeOptions::default() -> mut ImportNodeOptions
    = ImportNodeOptions(Option::None, Option::Some(false))

pub ext fun ImportNodeOptions::from_js(value: JsValue) -> mut ImportNodeOptions = "
    const r = {};
    r.m_custom_element_registry = #fun(Option::from_js[mut CustomElementRegistry])(#var(value).customElementRegistry);
    r.m_self_only = #fun(Option::from_js[Bool])(#var(value).selfOnly);
    return r;
"

pub ext fun ImportNodeOptions::as_js(self: ImportNodeOptions) -> JsValue = "
    const r = {};
    r.customElementRegistry = #fun(Option::as_js_undef[mut CustomElementRegistry])(#var(self).m_custom_element_registry);
    r.selfOnly = #fun(Option::as_js_undef[Bool])(#var(self).m_self_only);
    return r;
"

struct MutationObserver()

pub ext fun MutationObserver::from_f_list_mmutation_record_mmutation_observer_unit(callback: Fun(List[mut MutationRecord], mut MutationObserver) -> Unit) -> mut MutationObserver
    = "return new MutationObserver(((p0, p1) => { const r = #var(callback)(#fun(List::from_js[mut MutationRecord])(p0), #fun(MutationObserver::from_js)(p1)); return #fun(Unit::as_js)(r); }));"

pub ext fun MutationObserver::observe(__self: mut MutationObserver, target: mut Node, options: mut MutationObserverInit) -> Unit = "
    const r = #var(__self).observe(#fun(Node::as_js)(#var(target)), #fun(MutationObserverInit::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MutationObserver::disconnect(__self: mut MutationObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun MutationObserver::take_records(__self: mut MutationObserver) -> List[mut MutationRecord] = "
    const r = #var(__self).takeRecords();
    return #fun(List::from_js[mut MutationRecord])(r);
"

pub fun MutationObserver::as_js(self: MutationObserver) -> JsValue = JsValue::unsafe_from[MutationObserver](self)

pub fun MutationObserver::from_js(v: JsValue) -> mut MutationObserver = JsValue::unsafe_as[mut MutationObserver](v)

pub struct MutationObserverInit(
    child_list: Option[Bool],
    attributes: Option[Bool],
    character_data: Option[Bool],
    subtree: Option[Bool],
    attribute_old_value: Option[Bool],
    character_data_old_value: Option[Bool],
    attribute_filter: Option[List[String]]
)

pub fun MutationObserverInit::default() -> mut MutationObserverInit
    = MutationObserverInit(Option::Some(false), Option::None, Option::None, Option::Some(false), Option::None, Option::None, Option::None)

pub ext fun MutationObserverInit::from_js(value: JsValue) -> mut MutationObserverInit = "
    const r = {};
    r.m_child_list = #fun(Option::from_js[Bool])(#var(value).childList);
    r.m_attributes = #fun(Option::from_js[Bool])(#var(value).attributes);
    r.m_character_data = #fun(Option::from_js[Bool])(#var(value).characterData);
    r.m_subtree = #fun(Option::from_js[Bool])(#var(value).subtree);
    r.m_attribute_old_value = #fun(Option::from_js[Bool])(#var(value).attributeOldValue);
    r.m_character_data_old_value = #fun(Option::from_js[Bool])(#var(value).characterDataOldValue);
    r.m_attribute_filter = #fun(Option::from_js[List[String]])(#var(value).attributeFilter);
    return r;
"

pub ext fun MutationObserverInit::as_js(self: MutationObserverInit) -> JsValue = "
    const r = {};
    r.childList = #fun(Option::as_js_undef[Bool])(#var(self).m_child_list);
    r.attributes = #fun(Option::as_js_undef[Bool])(#var(self).m_attributes);
    r.characterData = #fun(Option::as_js_undef[Bool])(#var(self).m_character_data);
    r.subtree = #fun(Option::as_js_undef[Bool])(#var(self).m_subtree);
    r.attributeOldValue = #fun(Option::as_js_undef[Bool])(#var(self).m_attribute_old_value);
    r.characterDataOldValue = #fun(Option::as_js_undef[Bool])(#var(self).m_character_data_old_value);
    r.attributeFilter = #fun(Option::as_js_undef[List[String]])(#var(self).m_attribute_filter);
    return r;
"

struct MutationRecord()

pub ext fun MutationRecord::type(self: MutationRecord) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MutationRecord::target(self: MutationRecord) -> mut Node
    = "return #fun(Node::from_js)(#var(self).target);"

pub ext fun MutationRecord::added_nodes(self: MutationRecord) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).addedNodes);"

pub ext fun MutationRecord::removed_nodes(self: MutationRecord) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).removedNodes);"

pub ext fun MutationRecord::previous_sibling(self: MutationRecord) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun MutationRecord::next_sibling(self: MutationRecord) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun MutationRecord::attribute_name(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).attributeName);"

pub ext fun MutationRecord::attribute_namespace(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).attributeNamespace);"

pub ext fun MutationRecord::old_value(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).oldValue);"

pub fun MutationRecord::as_js(self: MutationRecord) -> JsValue = JsValue::unsafe_from[MutationRecord](self)

pub fun MutationRecord::from_js(v: JsValue) -> mut MutationRecord = JsValue::unsafe_as[mut MutationRecord](v)

struct NamedNodeMap()

pub ext fun NamedNodeMap::length(self: NamedNodeMap) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun NamedNodeMap::item(__self: mut NamedNodeMap, index: Int) -> Option[mut Attr] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::get_named_item(__self: mut NamedNodeMap, name: String) -> Option[mut Attr] = "
    const r = #var(__self).getNamedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::get_named_item_ns(__self: mut NamedNodeMap, namespace_uri: Option[String], local_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getNamedItemNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::set_named_item(__self: mut NamedNodeMap, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setNamedItem(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::set_named_item_ns(__self: mut NamedNodeMap, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setNamedItemNS(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::remove_named_item(__self: mut NamedNodeMap, name: String) -> mut Attr = "
    const r = #var(__self).removeNamedItem(#fun(String::as_js)(#var(name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun NamedNodeMap::remove_named_item_ns(__self: mut NamedNodeMap, namespace_uri: Option[String], local_name: String) -> mut Attr = "
    const r = #var(__self).removeNamedItemNS(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Attr::from_js)(r);
"

pub fun NamedNodeMap::as_js(self: NamedNodeMap) -> JsValue = JsValue::unsafe_from[NamedNodeMap](self)

pub fun NamedNodeMap::from_js(v: JsValue) -> mut NamedNodeMap = JsValue::unsafe_as[mut NamedNodeMap](v)

struct Node()

/// Converts a reference to 'Node' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Node::as_event_target(self: Node) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Node' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Node::as_mevent_target(self: mut Node) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Node'.
/// The conversion may fail and panic if 'base' is not a reference to 'Node' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Node::from_event_target(base: EventTarget) -> Node = "
    if(#var(base) instanceof Node) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Node'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Node'.
/// The conversion may fail and panic if 'base' is not a reference to 'Node' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Node::from_mevent_target(base: mut EventTarget) -> mut Node = "
    if(#var(base) instanceof Node) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Node'!\");
"

pub ext fun Node::node_type(self: Node) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Node::node_name(self: Node) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Node::base_uri(self: Node) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Node::is_connected(self: Node) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Node::owner_document(self: Node) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Node::parent_node(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Node::parent_element(self: Node) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Node::child_nodes(self: Node) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Node::first_child(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Node::last_child(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Node::previous_sibling(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Node::next_sibling(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Node::node_value(self: Node) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Node::set_node_value(self: mut Node, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Node::text_content(self: Node) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Node::set_text_content(self: mut Node, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Node::has_child_nodes(__self: mut Node) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::get_root_node(__self: mut Node, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::normalize(__self: mut Node) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::clone_node(__self: mut Node, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::is_equal_node(__self: mut Node, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::is_same_node(__self: mut Node, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::compare_document_position(__self: mut Node, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Node::contains(__self: mut Node, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::lookup_prefix(__self: mut Node, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Node::lookup_namespace_uri(__self: mut Node, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Node::is_default_namespace(__self: mut Node, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::insert_before(__self: mut Node, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::append_child(__self: mut Node, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::replace_child(__self: mut Node, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::remove_child(__self: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::add_event_listener(__self: mut Node, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::remove_event_listener(__self: mut Node, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::dispatch_event(__self: mut Node, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::when(__self: mut Node, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Node::as_js(self: Node) -> JsValue = JsValue::unsafe_from[Node](self)

pub fun Node::from_js(v: JsValue) -> mut Node = JsValue::unsafe_as[mut Node](v)

pub val Node::element_node: Int = 1
pub val Node::attribute_node: Int = 2
pub val Node::text_node: Int = 3
pub val Node::cdata_section_node: Int = 4
pub val Node::entity_reference_node: Int = 5
pub val Node::entity_node: Int = 6
pub val Node::processing_instruction_node: Int = 7
pub val Node::comment_node: Int = 8
pub val Node::document_node: Int = 9
pub val Node::document_type_node: Int = 10
pub val Node::document_fragment_node: Int = 11
pub val Node::notation_node: Int = 12
pub val Node::document_position_disconnected: Int = 1
pub val Node::document_position_preceding: Int = 2
pub val Node::document_position_following: Int = 4
pub val Node::document_position_contains: Int = 8
pub val Node::document_position_contained_by: Int = 16
pub val Node::document_position_implementation_specific: Int = 32

pub val NodeFilter::filter_accept: Int = 1
pub val NodeFilter::filter_reject: Int = 2
pub val NodeFilter::filter_skip: Int = 3
pub val NodeFilter::show_all: Int = 4294967295
pub val NodeFilter::show_element: Int = 1
pub val NodeFilter::show_attribute: Int = 2
pub val NodeFilter::show_text: Int = 4
pub val NodeFilter::show_cdata_section: Int = 8
pub val NodeFilter::show_entity_reference: Int = 16
pub val NodeFilter::show_entity: Int = 32
pub val NodeFilter::show_processing_instruction: Int = 64
pub val NodeFilter::show_comment: Int = 128
pub val NodeFilter::show_document: Int = 256
pub val NodeFilter::show_document_type: Int = 512
pub val NodeFilter::show_document_fragment: Int = 1024
pub val NodeFilter::show_notation: Int = 2048

struct NodeIterator()

pub ext fun NodeIterator::root(self: NodeIterator) -> mut Node
    = "return #fun(Node::from_js)(#var(self).root);"

pub ext fun NodeIterator::reference_node(self: NodeIterator) -> mut Node
    = "return #fun(Node::from_js)(#var(self).referenceNode);"

pub ext fun NodeIterator::pointer_before_reference_node(self: NodeIterator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pointerBeforeReferenceNode);"

pub ext fun NodeIterator::what_to_show(self: NodeIterator) -> Int
    = "return #fun(Int::from_js)(#var(self).whatToShow);"

pub ext fun NodeIterator::filter(self: NodeIterator) -> Option[Fun(mut Node) -> Int]
    = "return #fun(Option::from_js[Fun(mut Node) -> Int])(#var(self).filter);"

pub ext fun NodeIterator::next_node(__self: mut NodeIterator) -> Option[mut Node] = "
    const r = #var(__self).nextNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun NodeIterator::previous_node(__self: mut NodeIterator) -> Option[mut Node] = "
    const r = #var(__self).previousNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun NodeIterator::detach(__self: mut NodeIterator) -> Unit = "
    const r = #var(__self).detach();
    return #fun(Unit::from_js)(r);
"

pub fun NodeIterator::as_js(self: NodeIterator) -> JsValue = JsValue::unsafe_from[NodeIterator](self)

pub fun NodeIterator::from_js(v: JsValue) -> mut NodeIterator = JsValue::unsafe_as[mut NodeIterator](v)

struct NodeList()

pub ext fun NodeList::length(self: NodeList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun NodeList::item(__self: mut NodeList, index: Int) -> Option[mut Node] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Node])(r);
"

pub fun NodeList::as_js(self: NodeList) -> JsValue = JsValue::unsafe_from[NodeList](self)

pub fun NodeList::from_js(v: JsValue) -> mut NodeList = JsValue::unsafe_as[mut NodeList](v)

struct NodePart()

/// Converts a reference to 'NodePart' to a reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun NodePart::as_part(self: NodePart) -> Part = "return #var(self);"

/// Converts a mutable reference to 'NodePart' to a mutable reference to 'Part'.
/// This does not involve manipulating the object or reference.
pub ext fun NodePart::as_mpart(self: mut NodePart) -> mut Part = "return #var(self);"

/// Attempts to convert a reference to 'Part' to a reference to 'NodePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'NodePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NodePart::from_part(base: Part) -> NodePart = "
    if(#var(base) instanceof NodePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'NodePart'!\");
"

/// Attempts to convert a mutable reference to 'Part' to a mutable reference to 'NodePart'.
/// The conversion may fail and panic if 'base' is not a reference to 'NodePart' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NodePart::from_mpart(base: mut Part) -> mut NodePart = "
    if(#var(base) instanceof NodePart) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Part' to 'NodePart'!\");
"

pub ext fun NodePart::from_any_mnode_mpart_init(root: JsValue, node: mut Node, init: mut PartInit) -> mut NodePart
    = "return new NodePart(#var(root), #fun(Node::as_js)(#var(node)), #fun(PartInit::as_js)(#var(init)));"

pub ext fun NodePart::node(self: NodePart) -> mut Node
    = "return #fun(Node::from_js)(#var(self).node);"

pub ext fun NodePart::root(self: NodePart) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).root);"

pub ext fun NodePart::metadata(self: NodePart) -> JsValue
    = "return #var(self).metadata;"

pub ext fun NodePart::disconnect(__self: mut NodePart) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub fun NodePart::as_js(self: NodePart) -> JsValue = JsValue::unsafe_from[NodePart](self)

pub fun NodePart::from_js(v: JsValue) -> mut NodePart = JsValue::unsafe_as[mut NodePart](v)

pub struct ObservableInspector(
    next: Option[Fun(JsValue) -> Unit],
    error: Option[Fun(JsValue) -> Unit],
    complete: Option[Fun() -> Unit],
    subscribe: Option[Fun() -> Unit],
    abort: Option[Fun(JsValue) -> Unit]
)

pub fun ObservableInspector::default() -> mut ObservableInspector
    = ObservableInspector(Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun ObservableInspector::from_js(value: JsValue) -> mut ObservableInspector = "
    const r = {};
    r.m_next = #fun(Option::from_js[Fun(JsValue) -> Unit])(#var(value).next);
    r.m_error = #fun(Option::from_js[Fun(JsValue) -> Unit])(#var(value).error);
    r.m_complete = #fun(Option::from_js[Fun() -> Unit])(#var(value).complete);
    r.m_subscribe = #fun(Option::from_js[Fun() -> Unit])(#var(value).subscribe);
    r.m_abort = #fun(Option::from_js[Fun(JsValue) -> Unit])(#var(value).abort);
    return r;
"

pub ext fun ObservableInspector::as_js(self: ObservableInspector) -> JsValue = "
    const r = {};
    r.next = #fun(Option::as_js_undef[Fun(JsValue) -> Unit])(#var(self).m_next);
    r.error = #fun(Option::as_js_undef[Fun(JsValue) -> Unit])(#var(self).m_error);
    r.complete = #fun(Option::as_js_undef[Fun() -> Unit])(#var(self).m_complete);
    r.subscribe = #fun(Option::as_js_undef[Fun() -> Unit])(#var(self).m_subscribe);
    r.abort = #fun(Option::as_js_undef[Fun(JsValue) -> Unit])(#var(self).m_abort);
    return r;
"

pub struct Observer(
    next: Option[Fun(JsValue) -> Unit],
    error: Option[Fun(JsValue) -> Unit],
    complete: Option[Fun() -> Unit]
)

pub fun Observer::default() -> mut Observer
    = Observer(Option::None, Option::None, Option::None)

pub ext fun Observer::from_js(value: JsValue) -> mut Observer = "
    const r = {};
    r.m_next = #fun(Option::from_js[Fun(JsValue) -> Unit])(#var(value).next);
    r.m_error = #fun(Option::from_js[Fun(JsValue) -> Unit])(#var(value).error);
    r.m_complete = #fun(Option::from_js[Fun() -> Unit])(#var(value).complete);
    return r;
"

pub ext fun Observer::as_js(self: Observer) -> JsValue = "
    const r = {};
    r.next = #fun(Option::as_js_undef[Fun(JsValue) -> Unit])(#var(self).m_next);
    r.error = #fun(Option::as_js_undef[Fun(JsValue) -> Unit])(#var(self).m_error);
    r.complete = #fun(Option::as_js_undef[Fun() -> Unit])(#var(self).m_complete);
    return r;
"

pub struct SubscribeOptions(
    signal: Option[mut AbortSignal]
)

pub fun SubscribeOptions::default() -> mut SubscribeOptions
    = SubscribeOptions(Option::None)

pub ext fun SubscribeOptions::from_js(value: JsValue) -> mut SubscribeOptions = "
    const r = {};
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    return r;
"

pub ext fun SubscribeOptions::as_js(self: SubscribeOptions) -> JsValue = "
    const r = {};
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    return r;
"

struct Observable()

pub ext fun Observable::from_f_msubscriber_unit(callback: Fun(mut Subscriber) -> Unit) -> mut Observable
    = "return new Observable(((p0) => { const r = #var(callback)(#fun(Subscriber::from_js)(p0)); return #fun(Unit::as_js)(r); }));"

pub ext fun Observable::subscribe(__self: mut Observable, observer: JsValue, options: mut SubscribeOptions) -> Unit = "
    const r = #var(__self).subscribe(#var(observer), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Observable::from(value: JsValue) -> mut Observable = "
    const r = Observable.from(#var(value));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::take_until(__self: mut Observable, notifier: mut Observable) -> mut Observable = "
    const r = #var(__self).takeUntil(#fun(Observable::as_js)(#var(notifier)));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::map(__self: mut Observable, mapper: Fun(JsValue, Int) -> JsValue) -> mut Observable = "
    const r = #var(__self).map(((p0, p1) => { const r = #var(mapper)(p0, #fun(Int::from_js)(p1)); return r; }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::filter(__self: mut Observable, predicate: Fun(JsValue, Int) -> Bool) -> mut Observable = "
    const r = #var(__self).filter(((p0, p1) => { const r = #var(predicate)(p0, #fun(Int::from_js)(p1)); return #fun(Bool::as_js)(r); }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::take(__self: mut Observable, number__to__take: Int) -> mut Observable = "
    const r = #var(__self).take(#fun(Int::as_js)(#var(number__to__take)));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::drop(__self: mut Observable, number__to__drop: Int) -> mut Observable = "
    const r = #var(__self).drop(#fun(Int::as_js)(#var(number__to__drop)));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::flat_map(__self: mut Observable, mapper: Fun(JsValue, Int) -> JsValue) -> mut Observable = "
    const r = #var(__self).flatMap(((p0, p1) => { const r = #var(mapper)(p0, #fun(Int::from_js)(p1)); return r; }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::switch_map(__self: mut Observable, mapper: Fun(JsValue, Int) -> JsValue) -> mut Observable = "
    const r = #var(__self).switchMap(((p0, p1) => { const r = #var(mapper)(p0, #fun(Int::from_js)(p1)); return r; }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::inspect(__self: mut Observable, inspect__observer: JsValue) -> mut Observable = "
    const r = #var(__self).inspect(#var(inspect__observer));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::catch(__self: mut Observable, callback: Fun(JsValue) -> JsValue) -> mut Observable = "
    const r = #var(__self).catch(((p0) => { const r = #var(callback)(p0); return r; }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::finally(__self: mut Observable, callback: Fun() -> Unit) -> mut Observable = "
    const r = #var(__self).finally((() => { const r = #var(callback)(); return #fun(Unit::as_js)(r); }));
    return #fun(Observable::from_js)(r);
"

pub ext fun Observable::to_array(__self: mut Observable, options: mut SubscribeOptions) -> Promise[List[JsValue]] = "
    const r = #var(__self).toArray(#fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[List[JsValue]])(r);
"

pub ext fun Observable::for_each(__self: mut Observable, callback: Fun(JsValue, Int) -> Unit, options: mut SubscribeOptions) -> Promise[Unit] = "
    const r = #var(__self).forEach(((p0, p1) => { const r = #var(callback)(p0, #fun(Int::from_js)(p1)); return #fun(Unit::as_js)(r); }), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Observable::first(__self: mut Observable, options: mut SubscribeOptions) -> Promise[JsValue] = "
    const r = #var(__self).first(#fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Observable::last(__self: mut Observable, options: mut SubscribeOptions) -> Promise[JsValue] = "
    const r = #var(__self).last(#fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Observable::some(__self: mut Observable, predicate: Fun(JsValue, Int) -> Bool, options: mut SubscribeOptions) -> Promise[Bool] = "
    const r = #var(__self).some(((p0, p1) => { const r = #var(predicate)(p0, #fun(Int::from_js)(p1)); return #fun(Bool::as_js)(r); }), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Bool])(r);
"

pub ext fun Observable::every(__self: mut Observable, predicate: Fun(JsValue, Int) -> Bool, options: mut SubscribeOptions) -> Promise[Bool] = "
    const r = #var(__self).every(((p0, p1) => { const r = #var(predicate)(p0, #fun(Int::from_js)(p1)); return #fun(Bool::as_js)(r); }), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Bool])(r);
"

pub ext fun Observable::find(__self: mut Observable, predicate: Fun(JsValue, Int) -> Bool, options: mut SubscribeOptions) -> Promise[JsValue] = "
    const r = #var(__self).find(((p0, p1) => { const r = #var(predicate)(p0, #fun(Int::from_js)(p1)); return #fun(Bool::as_js)(r); }), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Observable::reduce(__self: mut Observable, reducer: Fun(JsValue, JsValue, Int) -> JsValue, initial_value: JsValue, options: mut SubscribeOptions) -> Promise[JsValue] = "
    const r = #var(__self).reduce(((p0, p1, p2) => { const r = #var(reducer)(p0, p1, #fun(Int::from_js)(p2)); return r; }), #var(initial_value), #fun(SubscribeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub fun Observable::as_js(self: Observable) -> JsValue = JsValue::unsafe_from[Observable](self)

pub fun Observable::from_js(v: JsValue) -> mut Observable = JsValue::unsafe_as[mut Observable](v)

struct Part()

pub ext fun Part::root(self: Part) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).root);"

pub ext fun Part::metadata(self: Part) -> JsValue
    = "return #var(self).metadata;"

pub ext fun Part::disconnect(__self: mut Part) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub fun Part::as_js(self: Part) -> JsValue = JsValue::unsafe_from[Part](self)

pub fun Part::from_js(v: JsValue) -> mut Part = JsValue::unsafe_as[mut Part](v)

pub struct PartInit(
    metadata: Option[JsValue]
)

pub fun PartInit::default() -> mut PartInit
    = PartInit(Option::None)

pub ext fun PartInit::from_js(value: JsValue) -> mut PartInit = "
    const r = {};
    r.m_metadata = #fun(Option::from_js[JsValue])(#var(value).metadata);
    return r;
"

pub ext fun PartInit::as_js(self: PartInit) -> JsValue = "
    const r = {};
    r.metadata = #fun(Option::as_js_undef[JsValue])(#var(self).m_metadata);
    return r;
"

pub struct PointerLockOptions(
    unadjusted_movement: Option[Bool]
)

pub fun PointerLockOptions::default() -> mut PointerLockOptions
    = PointerLockOptions(Option::Some(false))

pub ext fun PointerLockOptions::from_js(value: JsValue) -> mut PointerLockOptions = "
    const r = {};
    r.m_unadjusted_movement = #fun(Option::from_js[Bool])(#var(value).unadjustedMovement);
    return r;
"

pub ext fun PointerLockOptions::as_js(self: PointerLockOptions) -> JsValue = "
    const r = {};
    r.unadjustedMovement = #fun(Option::as_js_undef[Bool])(#var(self).m_unadjusted_movement);
    return r;
"

struct ProcessingInstruction()

/// Converts a reference to 'ProcessingInstruction' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_character_data(self: ProcessingInstruction) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mcharacter_data(self: mut ProcessingInstruction) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_character_data(base: CharacterData) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mcharacter_data(base: mut CharacterData) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'ProcessingInstruction'!\");
"

/// Converts a reference to 'ProcessingInstruction' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_node(self: ProcessingInstruction) -> Node = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mnode(self: mut ProcessingInstruction) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_node(base: Node) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mnode(base: mut Node) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ProcessingInstruction'!\");
"

/// Converts a reference to 'ProcessingInstruction' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_event_target(self: ProcessingInstruction) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mevent_target(self: mut ProcessingInstruction) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_event_target(base: EventTarget) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mevent_target(base: mut EventTarget) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ProcessingInstruction'!\");
"

pub ext fun ProcessingInstruction::target(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun ProcessingInstruction::sheet(self: ProcessingInstruction) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).sheet);"

pub ext fun ProcessingInstruction::data(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun ProcessingInstruction::set_data(self: mut ProcessingInstruction, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun ProcessingInstruction::length(self: ProcessingInstruction) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun ProcessingInstruction::node_type(self: ProcessingInstruction) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun ProcessingInstruction::node_name(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun ProcessingInstruction::base_uri(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun ProcessingInstruction::is_connected(self: ProcessingInstruction) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun ProcessingInstruction::owner_document(self: ProcessingInstruction) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun ProcessingInstruction::parent_node(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun ProcessingInstruction::parent_element(self: ProcessingInstruction) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun ProcessingInstruction::child_nodes(self: ProcessingInstruction) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun ProcessingInstruction::first_child(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun ProcessingInstruction::last_child(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun ProcessingInstruction::previous_sibling(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun ProcessingInstruction::next_sibling(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun ProcessingInstruction::node_value(self: ProcessingInstruction) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun ProcessingInstruction::set_node_value(self: mut ProcessingInstruction, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun ProcessingInstruction::text_content(self: ProcessingInstruction) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun ProcessingInstruction::set_text_content(self: mut ProcessingInstruction, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ProcessingInstruction::substring_data(__self: mut ProcessingInstruction, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun ProcessingInstruction::append_data(__self: mut ProcessingInstruction, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::insert_data(__self: mut ProcessingInstruction, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::delete_data(__self: mut ProcessingInstruction, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::replace_data(__self: mut ProcessingInstruction, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::has_child_nodes(__self: mut ProcessingInstruction) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::get_root_node(__self: mut ProcessingInstruction, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::normalize(__self: mut ProcessingInstruction) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::clone_node(__self: mut ProcessingInstruction, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::is_equal_node(__self: mut ProcessingInstruction, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::is_same_node(__self: mut ProcessingInstruction, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::compare_document_position(__self: mut ProcessingInstruction, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun ProcessingInstruction::contains(__self: mut ProcessingInstruction, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::lookup_prefix(__self: mut ProcessingInstruction, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ProcessingInstruction::lookup_namespace_uri(__self: mut ProcessingInstruction, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ProcessingInstruction::is_default_namespace(__self: mut ProcessingInstruction, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::insert_before(__self: mut ProcessingInstruction, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::append_child(__self: mut ProcessingInstruction, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::replace_child(__self: mut ProcessingInstruction, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::remove_child(__self: mut ProcessingInstruction, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::add_event_listener(__self: mut ProcessingInstruction, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::remove_event_listener(__self: mut ProcessingInstruction, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::dispatch_event(__self: mut ProcessingInstruction, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::when(__self: mut ProcessingInstruction, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun ProcessingInstruction::as_js(self: ProcessingInstruction) -> JsValue = JsValue::unsafe_from[ProcessingInstruction](self)

pub fun ProcessingInstruction::from_js(v: JsValue) -> mut ProcessingInstruction = JsValue::unsafe_as[mut ProcessingInstruction](v)

pub val ProcessingInstruction::element_node: Int = 1
pub val ProcessingInstruction::attribute_node: Int = 2
pub val ProcessingInstruction::text_node: Int = 3
pub val ProcessingInstruction::cdata_section_node: Int = 4
pub val ProcessingInstruction::entity_reference_node: Int = 5
pub val ProcessingInstruction::entity_node: Int = 6
pub val ProcessingInstruction::processing_instruction_node: Int = 7
pub val ProcessingInstruction::comment_node: Int = 8
pub val ProcessingInstruction::document_node: Int = 9
pub val ProcessingInstruction::document_type_node: Int = 10
pub val ProcessingInstruction::document_fragment_node: Int = 11
pub val ProcessingInstruction::notation_node: Int = 12
pub val ProcessingInstruction::document_position_disconnected: Int = 1
pub val ProcessingInstruction::document_position_preceding: Int = 2
pub val ProcessingInstruction::document_position_following: Int = 4
pub val ProcessingInstruction::document_position_contains: Int = 8
pub val ProcessingInstruction::document_position_contained_by: Int = 16
pub val ProcessingInstruction::document_position_implementation_specific: Int = 32

pub struct QuotaExceededErrorOptions(
    quota: Option[Float],
    requested: Option[Float]
)

pub fun QuotaExceededErrorOptions::default() -> mut QuotaExceededErrorOptions
    = QuotaExceededErrorOptions(Option::None, Option::None)

pub ext fun QuotaExceededErrorOptions::from_js(value: JsValue) -> mut QuotaExceededErrorOptions = "
    const r = {};
    r.m_quota = #fun(Option::from_js[Float])(#var(value).quota);
    r.m_requested = #fun(Option::from_js[Float])(#var(value).requested);
    return r;
"

pub ext fun QuotaExceededErrorOptions::as_js(self: QuotaExceededErrorOptions) -> JsValue = "
    const r = {};
    r.quota = #fun(Option::as_js_undef[Float])(#var(self).m_quota);
    r.requested = #fun(Option::as_js_undef[Float])(#var(self).m_requested);
    return r;
"

struct QuotaExceededError()

/// Converts a reference to 'QuotaExceededError' to a reference to 'DOMException'.
/// This does not involve manipulating the object or reference.
pub ext fun QuotaExceededError::as_dom_exception(self: QuotaExceededError) -> DOMException = "return #var(self);"

/// Converts a mutable reference to 'QuotaExceededError' to a mutable reference to 'DOMException'.
/// This does not involve manipulating the object or reference.
pub ext fun QuotaExceededError::as_mdom_exception(self: mut QuotaExceededError) -> mut DOMException = "return #var(self);"

/// Attempts to convert a reference to 'DOMException' to a reference to 'QuotaExceededError'.
/// The conversion may fail and panic if 'base' is not a reference to 'QuotaExceededError' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun QuotaExceededError::from_dom_exception(base: DOMException) -> QuotaExceededError = "
    if(#var(base) instanceof QuotaExceededError) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMException' to 'QuotaExceededError'!\");
"

/// Attempts to convert a mutable reference to 'DOMException' to a mutable reference to 'QuotaExceededError'.
/// The conversion may fail and panic if 'base' is not a reference to 'QuotaExceededError' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun QuotaExceededError::from_mdom_exception(base: mut DOMException) -> mut QuotaExceededError = "
    if(#var(base) instanceof QuotaExceededError) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMException' to 'QuotaExceededError'!\");
"

pub ext fun QuotaExceededError::from_str_mquota_exceeded_error_options(message: String, options: mut QuotaExceededErrorOptions) -> mut QuotaExceededError
    = "return new QuotaExceededError(#fun(String::as_js)(#var(message)), #fun(QuotaExceededErrorOptions::as_js)(#var(options)));"

pub ext fun QuotaExceededError::quota(self: QuotaExceededError) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).quota);"

pub ext fun QuotaExceededError::requested(self: QuotaExceededError) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).requested);"

pub ext fun QuotaExceededError::code(self: QuotaExceededError) -> Int
    = "return #fun(Int::from_js)(#var(self).code);"

pub ext fun QuotaExceededError::name(self: QuotaExceededError) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun QuotaExceededError::message(self: QuotaExceededError) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub fun QuotaExceededError::as_js(self: QuotaExceededError) -> JsValue = JsValue::unsafe_from[QuotaExceededError](self)

pub fun QuotaExceededError::from_js(v: JsValue) -> mut QuotaExceededError = JsValue::unsafe_as[mut QuotaExceededError](v)

pub val QuotaExceededError::index_size_err: Int = 1
pub val QuotaExceededError::domstring_size_err: Int = 2
pub val QuotaExceededError::hierarchy_request_err: Int = 3
pub val QuotaExceededError::wrong_document_err: Int = 4
pub val QuotaExceededError::invalid_character_err: Int = 5
pub val QuotaExceededError::no_data_allowed_err: Int = 6
pub val QuotaExceededError::no_modification_allowed_err: Int = 7
pub val QuotaExceededError::not_found_err: Int = 8
pub val QuotaExceededError::not_supported_err: Int = 9
pub val QuotaExceededError::inuse_attribute_err: Int = 10
pub val QuotaExceededError::invalid_state_err: Int = 11
pub val QuotaExceededError::syntax_err: Int = 12
pub val QuotaExceededError::invalid_modification_err: Int = 13
pub val QuotaExceededError::namespace_err: Int = 14
pub val QuotaExceededError::invalid_access_err: Int = 15
pub val QuotaExceededError::validation_err: Int = 16
pub val QuotaExceededError::type_mismatch_err: Int = 17
pub val QuotaExceededError::security_err: Int = 18
pub val QuotaExceededError::network_err: Int = 19
pub val QuotaExceededError::abort_err: Int = 20
pub val QuotaExceededError::url_mismatch_err: Int = 21
pub val QuotaExceededError::quota_exceeded_err: Int = 22
pub val QuotaExceededError::timeout_err: Int = 23
pub val QuotaExceededError::invalid_node_type_err: Int = 24
pub val QuotaExceededError::data_clone_err: Int = 25

struct Range()

/// Converts a reference to 'Range' to a reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun Range::as_abstract_range(self: Range) -> AbstractRange = "return #var(self);"

/// Converts a mutable reference to 'Range' to a mutable reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun Range::as_mabstract_range(self: mut Range) -> mut AbstractRange = "return #var(self);"

/// Attempts to convert a reference to 'AbstractRange' to a reference to 'Range'.
/// The conversion may fail and panic if 'base' is not a reference to 'Range' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Range::from_abstract_range(base: AbstractRange) -> Range = "
    if(#var(base) instanceof Range) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'Range'!\");
"

/// Attempts to convert a mutable reference to 'AbstractRange' to a mutable reference to 'Range'.
/// The conversion may fail and panic if 'base' is not a reference to 'Range' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Range::from_mabstract_range(base: mut AbstractRange) -> mut Range = "
    if(#var(base) instanceof Range) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'Range'!\");
"

pub ext fun Range::new() -> mut Range
    = "return new Range();"

pub ext fun Range::common_ancestor_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).commonAncestorContainer);"

pub ext fun Range::start_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun Range::start_offset(self: Range) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun Range::end_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun Range::end_offset(self: Range) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun Range::collapsed(self: Range) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub ext fun Range::set_start(__self: mut Range, node: mut Node, offset: Int) -> Unit = "
    const r = #var(__self).setStart(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end(__self: mut Range, node: mut Node, offset: Int) -> Unit = "
    const r = #var(__self).setEnd(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_start_before(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setStartBefore(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_start_after(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setStartAfter(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end_before(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setEndBefore(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end_after(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setEndAfter(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::collapse(__self: mut Range, to_start: Bool) -> Unit = "
    const r = #var(__self).collapse(#fun(Bool::as_js)(#var(to_start)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::select_node(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).selectNode(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::select_node_contents(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).selectNodeContents(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::compare_boundary_points(__self: mut Range, how: Int, source_range: mut Range) -> Int = "
    const r = #var(__self).compareBoundaryPoints(#fun(Int::as_js)(#var(how)), #fun(Range::as_js)(#var(source_range)));
    return #fun(Int::from_js)(r);
"

pub ext fun Range::delete_contents(__self: mut Range) -> Unit = "
    const r = #var(__self).deleteContents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::extract_contents(__self: mut Range) -> mut DocumentFragment = "
    const r = #var(__self).extractContents();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Range::clone_contents(__self: mut Range) -> mut DocumentFragment = "
    const r = #var(__self).cloneContents();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Range::insert_node(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).insertNode(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::surround_contents(__self: mut Range, new_parent: mut Node) -> Unit = "
    const r = #var(__self).surroundContents(#fun(Node::as_js)(#var(new_parent)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::clone_range(__self: mut Range) -> mut Range = "
    const r = #var(__self).cloneRange();
    return #fun(Range::from_js)(r);
"

pub ext fun Range::detach(__self: mut Range) -> Unit = "
    const r = #var(__self).detach();
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::is_point_in_range(__self: mut Range, node: mut Node, offset: Int) -> Bool = "
    const r = #var(__self).isPointInRange(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Range::compare_point(__self: mut Range, node: mut Node, offset: Int) -> Int = "
    const r = #var(__self).comparePoint(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Int::from_js)(r);
"

pub ext fun Range::intersects_node(__self: mut Range, node: mut Node) -> Bool = "
    const r = #var(__self).intersectsNode(#fun(Node::as_js)(#var(node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Range::as_string(__self: mut Range) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun Range::get_client_rects(__self: mut Range) -> mut DOMRectList = "
    const r = #var(__self).getClientRects();
    return #fun(DOMRectList::from_js)(r);
"

pub ext fun Range::get_bounding_client_rect(__self: mut Range) -> mut DOMRect = "
    const r = #var(__self).getBoundingClientRect();
    return #fun(DOMRect::from_js)(r);
"

pub ext fun Range::create_contextual_fragment(__self: mut Range, fragment: String) -> mut DocumentFragment = "
    const r = #var(__self).createContextualFragment(#fun(String::as_js)(#var(fragment)));
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Range::expand(__self: mut Range, unit_: String) -> Unit = "
    const r = #var(__self).expand(#fun(String::as_js)(#var(unit_)));
    return #fun(Unit::from_js)(r);
"

pub fun Range::as_js(self: Range) -> JsValue = JsValue::unsafe_from[Range](self)

pub fun Range::from_js(v: JsValue) -> mut Range = JsValue::unsafe_as[mut Range](v)

pub val Range::start_to_start: Int = 0
pub val Range::start_to_end: Int = 1
pub val Range::end_to_end: Int = 2
pub val Range::end_to_start: Int = 3

struct ShadowRoot()

/// Converts a reference to 'ShadowRoot' to a reference to 'DocumentFragment'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_document_fragment(self: ShadowRoot) -> DocumentFragment = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'DocumentFragment'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mdocument_fragment(self: mut ShadowRoot) -> mut DocumentFragment = "return #var(self);"

/// Attempts to convert a reference to 'DocumentFragment' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_document_fragment(base: DocumentFragment) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DocumentFragment' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'DocumentFragment' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mdocument_fragment(base: mut DocumentFragment) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DocumentFragment' to 'ShadowRoot'!\");
"

/// Converts a reference to 'ShadowRoot' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_node(self: ShadowRoot) -> Node = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mnode(self: mut ShadowRoot) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_node(base: Node) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mnode(base: mut Node) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ShadowRoot'!\");
"

/// Converts a reference to 'ShadowRoot' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_event_target(self: ShadowRoot) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mevent_target(self: mut ShadowRoot) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_event_target(base: EventTarget) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mevent_target(base: mut EventTarget) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ShadowRoot'!\");
"

pub ext fun ShadowRoot::mode(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).mode);"

pub ext fun ShadowRoot::host(self: ShadowRoot) -> mut Element
    = "return #fun(Element::from_js)(#var(self).host);"

pub ext fun ShadowRoot::onslotchange(self: ShadowRoot) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun ShadowRoot::set_onslotchange(self: mut ShadowRoot, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun ShadowRoot::inner_html(self: ShadowRoot) -> JsValue
    = "return #var(self).innerHTML;"

pub ext fun ShadowRoot::set_inner_html(self: mut ShadowRoot, value: JsValue)
    = "#var(self).innerHTML = #var(value);"

pub ext fun ShadowRoot::delegates_focus(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).delegatesFocus);"

pub ext fun ShadowRoot::slot_assignment(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).slotAssignment);"

pub ext fun ShadowRoot::serializable(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).serializable);"

pub ext fun ShadowRoot::clonable(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).clonable);"

pub ext fun ShadowRoot::reference_target(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).referenceTarget);"

pub ext fun ShadowRoot::set_reference_target(self: mut ShadowRoot, value: String)
    = "#var(self).referenceTarget = #fun(String::as_js)(#var(value));"

pub ext fun ShadowRoot::node_type(self: ShadowRoot) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun ShadowRoot::node_name(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun ShadowRoot::base_uri(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun ShadowRoot::is_connected(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun ShadowRoot::owner_document(self: ShadowRoot) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun ShadowRoot::parent_node(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun ShadowRoot::parent_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun ShadowRoot::child_nodes(self: ShadowRoot) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun ShadowRoot::first_child(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun ShadowRoot::last_child(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun ShadowRoot::previous_sibling(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun ShadowRoot::next_sibling(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun ShadowRoot::node_value(self: ShadowRoot) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun ShadowRoot::set_node_value(self: mut ShadowRoot, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun ShadowRoot::text_content(self: ShadowRoot) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun ShadowRoot::set_text_content(self: mut ShadowRoot, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ShadowRoot::active_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).activeElement);"

pub ext fun ShadowRoot::style_sheets(self: ShadowRoot) -> mut StyleSheetList
    = "return #fun(StyleSheetList::from_js)(#var(self).styleSheets);"

pub ext fun ShadowRoot::pointer_lock_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).pointerLockElement);"

pub ext fun ShadowRoot::fullscreen_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).fullscreenElement);"

pub ext fun ShadowRoot::adopted_style_sheets(self: ShadowRoot) -> JsValue
    = "return #var(self).adoptedStyleSheets;"

pub ext fun ShadowRoot::set_adopted_style_sheets(self: mut ShadowRoot, value: JsValue)
    = "#var(self).adoptedStyleSheets = #var(value);"

pub ext fun ShadowRoot::picture_in_picture_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).pictureInPictureElement);"

pub ext fun ShadowRoot::custom_element_registry(self: ShadowRoot) -> Option[mut CustomElementRegistry]
    = "return #fun(Option::from_js[mut CustomElementRegistry])(#var(self).customElementRegistry);"

pub ext fun ShadowRoot::get_html(__self: mut ShadowRoot, options: mut GetHTMLOptions) -> String = "
    const r = #var(__self).getHTML(#fun(GetHTMLOptions::as_js)(#var(options)));
    return #fun(String::from_js)(r);
"

pub ext fun ShadowRoot::set_html_unsafe_str(__self: mut ShadowRoot, string: String) -> Unit = "
    const r = #var(__self).setHTMLUnsafe(#fun(String::as_js)(#var(string)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::set_html_unsafe_str_mset_html_unsafe_options(__self: mut ShadowRoot, html: String, options: mut SetHTMLUnsafeOptions) -> Unit = "
    const r = #var(__self).setHTMLUnsafe(#fun(String::as_js)(#var(html)), #fun(SetHTMLUnsafeOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::set_html(__self: mut ShadowRoot, html: String, options: mut SetHTMLOptions) -> Unit = "
    const r = #var(__self).setHTML(#fun(String::as_js)(#var(html)), #fun(SetHTMLOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::get_part_root(__self: mut ShadowRoot) -> mut DocumentPartRoot = "
    const r = #var(__self).getPartRoot();
    return #fun(DocumentPartRoot::from_js)(r);
"

pub ext fun ShadowRoot::has_child_nodes(__self: mut ShadowRoot) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::get_root_node(__self: mut ShadowRoot, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::normalize(__self: mut ShadowRoot) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::clone_node(__self: mut ShadowRoot, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::is_equal_node(__self: mut ShadowRoot, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::is_same_node(__self: mut ShadowRoot, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::compare_document_position(__self: mut ShadowRoot, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun ShadowRoot::contains(__self: mut ShadowRoot, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::lookup_prefix(__self: mut ShadowRoot, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ShadowRoot::lookup_namespace_uri(__self: mut ShadowRoot, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ShadowRoot::is_default_namespace(__self: mut ShadowRoot, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::insert_before(__self: mut ShadowRoot, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::append_child(__self: mut ShadowRoot, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::replace_child(__self: mut ShadowRoot, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::remove_child(__self: mut ShadowRoot, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::add_event_listener(__self: mut ShadowRoot, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::remove_event_listener(__self: mut ShadowRoot, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::dispatch_event(__self: mut ShadowRoot, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::when(__self: mut ShadowRoot, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub ext fun ShadowRoot::get_selection(__self: mut ShadowRoot) -> Option[mut Selection] = "
    const r = #var(__self).getSelection();
    return #fun(Option::from_js[mut Selection])(r);
"

pub ext fun ShadowRoot::get_animations(__self: mut ShadowRoot) -> List[mut Animation] = "
    const r = #var(__self).getAnimations();
    return #fun(List::from_js[mut Animation])(r);
"

pub ext fun ShadowRoot::element_from_point(__self: mut ShadowRoot, x: Float, y: Float) -> Option[mut Element] = "
    const r = #var(__self).elementFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun ShadowRoot::elements_from_point(__self: mut ShadowRoot, x: Float, y: Float) -> List[mut Element] = "
    const r = #var(__self).elementsFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(List::from_js[mut Element])(r);
"

pub fun ShadowRoot::as_js(self: ShadowRoot) -> JsValue = JsValue::unsafe_from[ShadowRoot](self)

pub fun ShadowRoot::from_js(v: JsValue) -> mut ShadowRoot = JsValue::unsafe_as[mut ShadowRoot](v)

pub val ShadowRoot::element_node: Int = 1
pub val ShadowRoot::attribute_node: Int = 2
pub val ShadowRoot::text_node: Int = 3
pub val ShadowRoot::cdata_section_node: Int = 4
pub val ShadowRoot::entity_reference_node: Int = 5
pub val ShadowRoot::entity_node: Int = 6
pub val ShadowRoot::processing_instruction_node: Int = 7
pub val ShadowRoot::comment_node: Int = 8
pub val ShadowRoot::document_node: Int = 9
pub val ShadowRoot::document_type_node: Int = 10
pub val ShadowRoot::document_fragment_node: Int = 11
pub val ShadowRoot::notation_node: Int = 12
pub val ShadowRoot::document_position_disconnected: Int = 1
pub val ShadowRoot::document_position_preceding: Int = 2
pub val ShadowRoot::document_position_following: Int = 4
pub val ShadowRoot::document_position_contains: Int = 8
pub val ShadowRoot::document_position_contained_by: Int = 16
pub val ShadowRoot::document_position_implementation_specific: Int = 32

pub val ShadowRootMode::Open: String = "open"
pub val ShadowRootMode::Closed: String = "closed"

pub val SlotAssignmentMode::Manual: String = "manual"
pub val SlotAssignmentMode::Named: String = "named"

pub struct ShadowRootInit(
    mode: String,
    delegates_focus: Option[Bool],
    slot_assignment: Option[String],
    registry: Option[mut CustomElementRegistry],
    serializable: Option[Bool],
    clonable: Option[Bool],
    reference_target: Option[String]
)

pub fun ShadowRootInit::default(mode: String) -> mut ShadowRootInit
    = ShadowRootInit(mode, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun ShadowRootInit::from_js(value: JsValue) -> mut ShadowRootInit = "
    const r = {};
    r.m_mode = #fun(String::from_js)(#var(value).mode);
    r.m_delegates_focus = #fun(Option::from_js[Bool])(#var(value).delegatesFocus);
    r.m_slot_assignment = #fun(Option::from_js[String])(#var(value).slotAssignment);
    r.m_registry = #fun(Option::from_js[mut CustomElementRegistry])(#var(value).registry);
    r.m_serializable = #fun(Option::from_js[Bool])(#var(value).serializable);
    r.m_clonable = #fun(Option::from_js[Bool])(#var(value).clonable);
    r.m_reference_target = #fun(Option::from_js[String])(#var(value).referenceTarget);
    return r;
"

pub ext fun ShadowRootInit::as_js(self: ShadowRootInit) -> JsValue = "
    const r = {};
    r.mode = #var(self).m_mode;
    r.delegatesFocus = #fun(Option::as_js_undef[Bool])(#var(self).m_delegates_focus);
    r.slotAssignment = #fun(Option::as_js_undef[String])(#var(self).m_slot_assignment);
    r.registry = #fun(Option::as_js_undef[mut CustomElementRegistry])(#var(self).m_registry);
    r.serializable = #fun(Option::as_js_undef[Bool])(#var(self).m_serializable);
    r.clonable = #fun(Option::as_js_undef[Bool])(#var(self).m_clonable);
    r.referenceTarget = #fun(Option::as_js_undef[String])(#var(self).m_reference_target);
    return r;
"

struct StaticRange()

/// Converts a reference to 'StaticRange' to a reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::as_abstract_range(self: StaticRange) -> AbstractRange = "return #var(self);"

/// Converts a mutable reference to 'StaticRange' to a mutable reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::as_mabstract_range(self: mut StaticRange) -> mut AbstractRange = "return #var(self);"

/// Attempts to convert a reference to 'AbstractRange' to a reference to 'StaticRange'.
/// The conversion may fail and panic if 'base' is not a reference to 'StaticRange' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::from_abstract_range(base: AbstractRange) -> StaticRange = "
    if(#var(base) instanceof StaticRange) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'StaticRange'!\");
"

/// Attempts to convert a mutable reference to 'AbstractRange' to a mutable reference to 'StaticRange'.
/// The conversion may fail and panic if 'base' is not a reference to 'StaticRange' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::from_mabstract_range(base: mut AbstractRange) -> mut StaticRange = "
    if(#var(base) instanceof StaticRange) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'StaticRange'!\");
"

pub ext fun StaticRange::from_mstatic_range_init(init: mut StaticRangeInit) -> mut StaticRange
    = "return new StaticRange(#fun(StaticRangeInit::as_js)(#var(init)));"

pub ext fun StaticRange::start_container(self: StaticRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun StaticRange::start_offset(self: StaticRange) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun StaticRange::end_container(self: StaticRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun StaticRange::end_offset(self: StaticRange) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun StaticRange::collapsed(self: StaticRange) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub fun StaticRange::as_js(self: StaticRange) -> JsValue = JsValue::unsafe_from[StaticRange](self)

pub fun StaticRange::from_js(v: JsValue) -> mut StaticRange = JsValue::unsafe_as[mut StaticRange](v)

pub struct StaticRangeInit(
    start_container: mut Node,
    start_offset: Int,
    end_container: mut Node,
    end_offset: Int
)

pub fun StaticRangeInit::default(start_container: mut Node, start_offset: Int, end_container: mut Node, end_offset: Int) -> mut StaticRangeInit
    = StaticRangeInit(start_container, start_offset, end_container, end_offset)

pub ext fun StaticRangeInit::from_js(value: JsValue) -> mut StaticRangeInit = "
    const r = {};
    r.m_start_container = #fun(Node::from_js)(#var(value).startContainer);
    r.m_start_offset = #fun(Int::from_js)(#var(value).startOffset);
    r.m_end_container = #fun(Node::from_js)(#var(value).endContainer);
    r.m_end_offset = #fun(Int::from_js)(#var(value).endOffset);
    return r;
"

pub ext fun StaticRangeInit::as_js(self: StaticRangeInit) -> JsValue = "
    const r = {};
    r.startContainer = #fun(Node::as_js)(#var(self).m_start_container);
    r.startOffset = #fun(Int::as_js)(#var(self).m_start_offset);
    r.endContainer = #fun(Node::as_js)(#var(self).m_end_container);
    r.endOffset = #fun(Int::as_js)(#var(self).m_end_offset);
    return r;
"

struct Subscriber()

pub ext fun Subscriber::active(self: Subscriber) -> Bool
    = "return #fun(Bool::from_js)(#var(self).active);"

pub ext fun Subscriber::signal(self: Subscriber) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun Subscriber::next(__self: mut Subscriber, result: JsValue) -> Unit = "
    const r = #var(__self).next(#var(result));
    return #fun(Unit::from_js)(r);
"

pub ext fun Subscriber::error(__self: mut Subscriber, error: JsValue) -> Unit = "
    const r = #var(__self).error(#var(error));
    return #fun(Unit::from_js)(r);
"

pub ext fun Subscriber::complete(__self: mut Subscriber) -> Unit = "
    const r = #var(__self).complete();
    return #fun(Unit::from_js)(r);
"

pub ext fun Subscriber::add_teardown(__self: mut Subscriber, teardown: Fun() -> Unit) -> Unit = "
    const r = #var(__self).addTeardown((() => { const r = #var(teardown)(); return #fun(Unit::as_js)(r); }));
    return #fun(Unit::from_js)(r);
"

pub fun Subscriber::as_js(self: Subscriber) -> JsValue = JsValue::unsafe_from[Subscriber](self)

pub fun Subscriber::from_js(v: JsValue) -> mut Subscriber = JsValue::unsafe_as[mut Subscriber](v)

struct Internals()

pub ext fun Internals::set_storage_access(__self: mut Internals, origin: String, embedding_origin: String, blocked: Bool) -> Promise[Unit] = "
    const r = #var(__self).setStorageAccess(#fun(String::as_js)(#var(origin)), #fun(String::as_js)(#var(embedding_origin)), #fun(Bool::as_js)(#var(blocked)));
    return #fun(Promise::from_js[Unit])(r);
"

pub fun Internals::as_js(self: Internals) -> JsValue = JsValue::unsafe_from[Internals](self)

pub fun Internals::from_js(v: JsValue) -> mut Internals = JsValue::unsafe_as[mut Internals](v)

struct Text()

/// Converts a reference to 'Text' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_character_data(self: Text) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mcharacter_data(self: mut Text) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_character_data(base: CharacterData) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mcharacter_data(base: mut CharacterData) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Text'!\");
"

/// Converts a reference to 'Text' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_node(self: Text) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mnode(self: mut Text) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_node(base: Node) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mnode(base: mut Node) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Text'!\");
"

/// Converts a reference to 'Text' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_event_target(self: Text) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mevent_target(self: mut Text) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_event_target(base: EventTarget) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mevent_target(base: mut EventTarget) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Text'!\");
"

pub ext fun Text::from_str(data: String) -> mut Text
    = "return new Text(#fun(String::as_js)(#var(data)));"

pub ext fun Text::whole_text(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).wholeText);"

pub ext fun Text::assigned_slot(self: Text) -> Option[mut HTMLSlotElement]
    = "return #fun(Option::from_js[mut HTMLSlotElement])(#var(self).assignedSlot);"

pub ext fun Text::data(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun Text::set_data(self: mut Text, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun Text::length(self: Text) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Text::node_type(self: Text) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Text::node_name(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Text::base_uri(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Text::is_connected(self: Text) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Text::owner_document(self: Text) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Text::parent_node(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Text::parent_element(self: Text) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Text::child_nodes(self: Text) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Text::first_child(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Text::last_child(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Text::previous_sibling(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Text::next_sibling(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Text::node_value(self: Text) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Text::set_node_value(self: mut Text, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Text::text_content(self: Text) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).textContent);"

pub ext fun Text::set_text_content(self: mut Text, value: Option[JsValue])
    = "#var(self).textContent = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun Text::split_text(__self: mut Text, offset: Int) -> mut Text = "
    const r = #var(__self).splitText(#fun(Int::as_js)(#var(offset)));
    return #fun(Text::from_js)(r);
"

pub ext fun Text::substring_data(__self: mut Text, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun Text::append_data(__self: mut Text, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::insert_data(__self: mut Text, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::delete_data(__self: mut Text, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::replace_data(__self: mut Text, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::has_child_nodes(__self: mut Text) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::get_root_node(__self: mut Text, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::normalize(__self: mut Text) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::clone_node(__self: mut Text, deep: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(deep)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::is_equal_node(__self: mut Text, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::is_same_node(__self: mut Text, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::compare_document_position(__self: mut Text, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Text::contains(__self: mut Text, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::lookup_prefix(__self: mut Text, namespace_uri: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Text::lookup_namespace_uri(__self: mut Text, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Text::is_default_namespace(__self: mut Text, namespace_uri: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace_uri)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::insert_before(__self: mut Text, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::append_child(__self: mut Text, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::replace_child(__self: mut Text, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::remove_child(__self: mut Text, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::add_event_listener(__self: mut Text, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::remove_event_listener(__self: mut Text, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::dispatch_event(__self: mut Text, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::when(__self: mut Text, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Text::as_js(self: Text) -> JsValue = JsValue::unsafe_from[Text](self)

pub fun Text::from_js(v: JsValue) -> mut Text = JsValue::unsafe_as[mut Text](v)

pub val Text::element_node: Int = 1
pub val Text::attribute_node: Int = 2
pub val Text::text_node: Int = 3
pub val Text::cdata_section_node: Int = 4
pub val Text::entity_reference_node: Int = 5
pub val Text::entity_node: Int = 6
pub val Text::processing_instruction_node: Int = 7
pub val Text::comment_node: Int = 8
pub val Text::document_node: Int = 9
pub val Text::document_type_node: Int = 10
pub val Text::document_fragment_node: Int = 11
pub val Text::notation_node: Int = 12
pub val Text::document_position_disconnected: Int = 1
pub val Text::document_position_preceding: Int = 2
pub val Text::document_position_following: Int = 4
pub val Text::document_position_contains: Int = 8
pub val Text::document_position_contained_by: Int = 16
pub val Text::document_position_implementation_specific: Int = 32

struct TreeWalker()

pub ext fun TreeWalker::root(self: TreeWalker) -> mut Node
    = "return #fun(Node::from_js)(#var(self).root);"

pub ext fun TreeWalker::what_to_show(self: TreeWalker) -> Int
    = "return #fun(Int::from_js)(#var(self).whatToShow);"

pub ext fun TreeWalker::filter(self: TreeWalker) -> Option[Fun(mut Node) -> Int]
    = "return #fun(Option::from_js[Fun(mut Node) -> Int])(#var(self).filter);"

pub ext fun TreeWalker::current_node(self: TreeWalker) -> mut Node
    = "return #fun(Node::from_js)(#var(self).currentNode);"

pub ext fun TreeWalker::set_current_node(self: mut TreeWalker, value: mut Node)
    = "#var(self).currentNode = #fun(Node::as_js)(#var(value));"

pub ext fun TreeWalker::parent_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).parentNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::first_child(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).firstChild();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::last_child(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).lastChild();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::previous_sibling(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).previousSibling();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::next_sibling(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).nextSibling();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::previous_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).previousNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::next_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).nextNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub fun TreeWalker::as_js(self: TreeWalker) -> JsValue = JsValue::unsafe_from[TreeWalker](self)

pub fun TreeWalker::from_js(v: JsValue) -> mut TreeWalker = JsValue::unsafe_as[mut TreeWalker](v)

struct XMLDocument()

/// Converts a reference to 'XMLDocument' to a reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_document(self: XMLDocument) -> Document = "return #var(self);"

/// Converts a mutable reference to 'XMLDocument' to a mutable reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_mdocument(self: mut XMLDocument) -> mut Document = "return #var(self);"

/// Attempts to convert a reference to 'Document' to a reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_document(base: Document) -> XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'XMLDocument'!\");
"

/// Attempts to convert a mutable reference to 'Document' to a mutable reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_mdocument(base: mut Document) -> mut XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'XMLDocument'!\");
"

pub ext fun XMLDocument::create_expression(__self: mut XMLDocument, expression: String, resolver: Option[Fun(String) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun XMLDocument::create_ns_resolver(__self: mut XMLDocument, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::evaluate(__self: mut XMLDocument, expression: String, context_node: mut Node, resolver: Option[Fun(String) -> Option[String]], type: Int, in_result: Option[JsObject]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[JsObject])(#var(in_result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun XMLDocument::as_js(self: XMLDocument) -> JsValue = JsValue::unsafe_from[XMLDocument](self)

pub fun XMLDocument::from_js(v: JsValue) -> mut XMLDocument = JsValue::unsafe_as[mut XMLDocument](v)

pub struct GetComposedRangesOptions(
    shadow_roots: Option[List[mut ShadowRoot]]
)

pub fun GetComposedRangesOptions::default() -> mut GetComposedRangesOptions
    = GetComposedRangesOptions(Option::Some(List::empty()))

pub ext fun GetComposedRangesOptions::from_js(value: JsValue) -> mut GetComposedRangesOptions = "
    const r = {};
    r.m_shadow_roots = #fun(Option::from_js[List[mut ShadowRoot]])(#var(value).shadowRoots);
    return r;
"

pub ext fun GetComposedRangesOptions::as_js(self: GetComposedRangesOptions) -> JsValue = "
    const r = {};
    r.shadowRoots = #fun(Option::as_js_undef[List[mut ShadowRoot]])(#var(self).m_shadow_roots);
    return r;
"

struct CharacterBoundsUpdateEvent()

/// Converts a reference to 'CharacterBoundsUpdateEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEvent::as_event(self: CharacterBoundsUpdateEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'CharacterBoundsUpdateEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEvent::as_mevent(self: mut CharacterBoundsUpdateEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'CharacterBoundsUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterBoundsUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEvent::from_event(base: Event) -> CharacterBoundsUpdateEvent = "
    if(#var(base) instanceof CharacterBoundsUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CharacterBoundsUpdateEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'CharacterBoundsUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterBoundsUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEvent::from_mevent(base: mut Event) -> mut CharacterBoundsUpdateEvent = "
    if(#var(base) instanceof CharacterBoundsUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CharacterBoundsUpdateEvent'!\");
"

pub ext fun CharacterBoundsUpdateEvent::from_str_mcharacter_bounds_update_event_init(type: String, options: mut CharacterBoundsUpdateEventInit) -> mut CharacterBoundsUpdateEvent
    = "return new CharacterBoundsUpdateEvent(#fun(String::as_js)(#var(type)), #fun(CharacterBoundsUpdateEventInit::as_js)(#var(options)));"

pub ext fun CharacterBoundsUpdateEvent::range_start(self: CharacterBoundsUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).rangeStart);"

pub ext fun CharacterBoundsUpdateEvent::range_end(self: CharacterBoundsUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).rangeEnd);"

pub ext fun CharacterBoundsUpdateEvent::type(self: CharacterBoundsUpdateEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CharacterBoundsUpdateEvent::target(self: CharacterBoundsUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun CharacterBoundsUpdateEvent::current_target(self: CharacterBoundsUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun CharacterBoundsUpdateEvent::event_phase(self: CharacterBoundsUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun CharacterBoundsUpdateEvent::bubbles(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun CharacterBoundsUpdateEvent::cancelable(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun CharacterBoundsUpdateEvent::default_prevented(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun CharacterBoundsUpdateEvent::composed(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun CharacterBoundsUpdateEvent::is_trusted(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun CharacterBoundsUpdateEvent::time_stamp(self: CharacterBoundsUpdateEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun CharacterBoundsUpdateEvent::src_element(self: CharacterBoundsUpdateEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun CharacterBoundsUpdateEvent::return_value(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun CharacterBoundsUpdateEvent::set_return_value(self: mut CharacterBoundsUpdateEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun CharacterBoundsUpdateEvent::cancel_bubble(self: CharacterBoundsUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun CharacterBoundsUpdateEvent::set_cancel_bubble(self: mut CharacterBoundsUpdateEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun CharacterBoundsUpdateEvent::composed_path(__self: mut CharacterBoundsUpdateEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun CharacterBoundsUpdateEvent::stop_propagation(__self: mut CharacterBoundsUpdateEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterBoundsUpdateEvent::stop_immediate_propagation(__self: mut CharacterBoundsUpdateEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterBoundsUpdateEvent::prevent_default(__self: mut CharacterBoundsUpdateEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterBoundsUpdateEvent::init_event(__self: mut CharacterBoundsUpdateEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun CharacterBoundsUpdateEvent::as_js(self: CharacterBoundsUpdateEvent) -> JsValue = JsValue::unsafe_from[CharacterBoundsUpdateEvent](self)

pub fun CharacterBoundsUpdateEvent::from_js(v: JsValue) -> mut CharacterBoundsUpdateEvent = JsValue::unsafe_as[mut CharacterBoundsUpdateEvent](v)

pub val CharacterBoundsUpdateEvent::none: Int = 0
pub val CharacterBoundsUpdateEvent::capturing_phase: Int = 1
pub val CharacterBoundsUpdateEvent::at_target: Int = 2
pub val CharacterBoundsUpdateEvent::bubbling_phase: Int = 3

pub struct CharacterBoundsUpdateEventInit(
    range_start: Option[Int],
    range_end: Option[Int],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun CharacterBoundsUpdateEventInit::default() -> mut CharacterBoundsUpdateEventInit
    = CharacterBoundsUpdateEventInit(Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'CharacterBoundsUpdateEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEventInit::as_event_init(self: CharacterBoundsUpdateEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'CharacterBoundsUpdateEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEventInit::as_mevent_init(self: mut CharacterBoundsUpdateEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'CharacterBoundsUpdateEventInit'.
/// A 'base' that is not a reference to 'CharacterBoundsUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEventInit::from_event_init_unchecked(base: EventInit) -> CharacterBoundsUpdateEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'CharacterBoundsUpdateEventInit'.
/// A 'base' that is not a reference to 'CharacterBoundsUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterBoundsUpdateEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut CharacterBoundsUpdateEventInit = "return #var(base);"

pub ext fun CharacterBoundsUpdateEventInit::from_js(value: JsValue) -> mut CharacterBoundsUpdateEventInit = "
    const r = {};
    r.m_range_start = #fun(Option::from_js[Int])(#var(value).rangeStart);
    r.m_range_end = #fun(Option::from_js[Int])(#var(value).rangeEnd);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun CharacterBoundsUpdateEventInit::as_js(self: CharacterBoundsUpdateEventInit) -> JsValue = "
    const r = {};
    r.rangeStart = #fun(Option::as_js_undef[Int])(#var(self).m_range_start);
    r.rangeEnd = #fun(Option::as_js_undef[Int])(#var(self).m_range_end);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct EditContext()

/// Converts a reference to 'EditContext' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun EditContext::as_event_target(self: EditContext) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'EditContext' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun EditContext::as_mevent_target(self: mut EditContext) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'EditContext'.
/// The conversion may fail and panic if 'base' is not a reference to 'EditContext' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun EditContext::from_event_target(base: EventTarget) -> EditContext = "
    if(#var(base) instanceof EditContext) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'EditContext'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'EditContext'.
/// The conversion may fail and panic if 'base' is not a reference to 'EditContext' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun EditContext::from_mevent_target(base: mut EventTarget) -> mut EditContext = "
    if(#var(base) instanceof EditContext) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'EditContext'!\");
"

pub ext fun EditContext::from_medit_context_init(options: mut EditContextInit) -> mut EditContext
    = "return new EditContext(#fun(EditContextInit::as_js)(#var(options)));"

pub ext fun EditContext::text(self: EditContext) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun EditContext::selection_start(self: EditContext) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionStart);"

pub ext fun EditContext::selection_end(self: EditContext) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionEnd);"

pub ext fun EditContext::character_bounds_range_start(self: EditContext) -> Int
    = "return #fun(Int::from_js)(#var(self).characterBoundsRangeStart);"

pub ext fun EditContext::ontextupdate(self: EditContext) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontextupdate);"

pub ext fun EditContext::set_ontextupdate(self: mut EditContext, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontextupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun EditContext::ontextformatupdate(self: EditContext) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontextformatupdate);"

pub ext fun EditContext::set_ontextformatupdate(self: mut EditContext, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontextformatupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun EditContext::oncharacterboundsupdate(self: EditContext) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncharacterboundsupdate);"

pub ext fun EditContext::set_oncharacterboundsupdate(self: mut EditContext, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncharacterboundsupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun EditContext::oncompositionstart(self: EditContext) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncompositionstart);"

pub ext fun EditContext::set_oncompositionstart(self: mut EditContext, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncompositionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun EditContext::oncompositionend(self: EditContext) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncompositionend);"

pub ext fun EditContext::set_oncompositionend(self: mut EditContext, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncompositionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun EditContext::update_selection(__self: mut EditContext, start: Int, end: Int) -> Unit = "
    const r = #var(__self).updateSelection(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::update_control_bounds(__self: mut EditContext, control_bounds: mut DOMRect) -> Unit = "
    const r = #var(__self).updateControlBounds(#fun(DOMRect::as_js)(#var(control_bounds)));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::update_selection_bounds(__self: mut EditContext, selection_bounds: mut DOMRect) -> Unit = "
    const r = #var(__self).updateSelectionBounds(#fun(DOMRect::as_js)(#var(selection_bounds)));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::update_character_bounds(__self: mut EditContext, range_start: Int, character_bounds: List[mut DOMRect]) -> Unit = "
    const r = #var(__self).updateCharacterBounds(#fun(Int::as_js)(#var(range_start)), #fun(List::as_js[mut DOMRect])(#var(character_bounds)));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::update_text(__self: mut EditContext, start: Int, end: Int, new_text: String) -> Unit = "
    const r = #var(__self).updateText(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(String::as_js)(#var(new_text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::attached_elements(__self: mut EditContext) -> List[mut HTMLElement] = "
    const r = #var(__self).attachedElements();
    return #fun(List::from_js[mut HTMLElement])(r);
"

pub ext fun EditContext::character_bounds(__self: mut EditContext) -> List[mut DOMRect] = "
    const r = #var(__self).characterBounds();
    return #fun(List::from_js[mut DOMRect])(r);
"

pub ext fun EditContext::add_event_listener(__self: mut EditContext, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::remove_event_listener(__self: mut EditContext, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EditContext::dispatch_event(__self: mut EditContext, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun EditContext::when(__self: mut EditContext, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun EditContext::as_js(self: EditContext) -> JsValue = JsValue::unsafe_from[EditContext](self)

pub fun EditContext::from_js(v: JsValue) -> mut EditContext = JsValue::unsafe_as[mut EditContext](v)

pub struct EditContextInit(
    text: Option[String],
    selection_start: Option[Int],
    selection_end: Option[Int]
)

pub fun EditContextInit::default() -> mut EditContextInit
    = EditContextInit(Option::None, Option::None, Option::None)

pub ext fun EditContextInit::from_js(value: JsValue) -> mut EditContextInit = "
    const r = {};
    r.m_text = #fun(Option::from_js[String])(#var(value).text);
    r.m_selection_start = #fun(Option::from_js[Int])(#var(value).selectionStart);
    r.m_selection_end = #fun(Option::from_js[Int])(#var(value).selectionEnd);
    return r;
"

pub ext fun EditContextInit::as_js(self: EditContextInit) -> JsValue = "
    const r = {};
    r.text = #fun(Option::as_js_undef[String])(#var(self).m_text);
    r.selectionStart = #fun(Option::as_js_undef[Int])(#var(self).m_selection_start);
    r.selectionEnd = #fun(Option::as_js_undef[Int])(#var(self).m_selection_end);
    return r;
"

pub val UnderlineStyle::None: String = "none"
pub val UnderlineStyle::Solid: String = "solid"
pub val UnderlineStyle::Dotted: String = "dotted"
pub val UnderlineStyle::Dashed: String = "dashed"
pub val UnderlineStyle::Wavy: String = "wavy"

pub val UnderlineThickness::None: String = "none"
pub val UnderlineThickness::Thin: String = "thin"
pub val UnderlineThickness::Thick: String = "thick"

struct TextFormat()

pub ext fun TextFormat::from_mtext_format_init(options: mut TextFormatInit) -> mut TextFormat
    = "return new TextFormat(#fun(TextFormatInit::as_js)(#var(options)));"

pub ext fun TextFormat::range_start(self: TextFormat) -> Int
    = "return #fun(Int::from_js)(#var(self).rangeStart);"

pub ext fun TextFormat::range_end(self: TextFormat) -> Int
    = "return #fun(Int::from_js)(#var(self).rangeEnd);"

pub ext fun TextFormat::underline_style(self: TextFormat) -> String
    = "return #fun(String::from_js)(#var(self).underlineStyle);"

pub ext fun TextFormat::underline_thickness(self: TextFormat) -> String
    = "return #fun(String::from_js)(#var(self).underlineThickness);"

pub fun TextFormat::as_js(self: TextFormat) -> JsValue = JsValue::unsafe_from[TextFormat](self)

pub fun TextFormat::from_js(v: JsValue) -> mut TextFormat = JsValue::unsafe_as[mut TextFormat](v)

pub struct TextFormatInit(
    range_start: Option[Int],
    range_end: Option[Int],
    underline_style: Option[String],
    underline_thickness: Option[String]
)

pub fun TextFormatInit::default() -> mut TextFormatInit
    = TextFormatInit(Option::None, Option::None, Option::None, Option::None)

pub ext fun TextFormatInit::from_js(value: JsValue) -> mut TextFormatInit = "
    const r = {};
    r.m_range_start = #fun(Option::from_js[Int])(#var(value).rangeStart);
    r.m_range_end = #fun(Option::from_js[Int])(#var(value).rangeEnd);
    r.m_underline_style = #fun(Option::from_js[String])(#var(value).underlineStyle);
    r.m_underline_thickness = #fun(Option::from_js[String])(#var(value).underlineThickness);
    return r;
"

pub ext fun TextFormatInit::as_js(self: TextFormatInit) -> JsValue = "
    const r = {};
    r.rangeStart = #fun(Option::as_js_undef[Int])(#var(self).m_range_start);
    r.rangeEnd = #fun(Option::as_js_undef[Int])(#var(self).m_range_end);
    r.underlineStyle = #fun(Option::as_js_undef[String])(#var(self).m_underline_style);
    r.underlineThickness = #fun(Option::as_js_undef[String])(#var(self).m_underline_thickness);
    return r;
"

struct TextFormatUpdateEvent()

/// Converts a reference to 'TextFormatUpdateEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEvent::as_event(self: TextFormatUpdateEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TextFormatUpdateEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEvent::as_mevent(self: mut TextFormatUpdateEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TextFormatUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextFormatUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEvent::from_event(base: Event) -> TextFormatUpdateEvent = "
    if(#var(base) instanceof TextFormatUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextFormatUpdateEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TextFormatUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextFormatUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEvent::from_mevent(base: mut Event) -> mut TextFormatUpdateEvent = "
    if(#var(base) instanceof TextFormatUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextFormatUpdateEvent'!\");
"

pub ext fun TextFormatUpdateEvent::from_str_mtext_format_update_event_init(type: String, options: mut TextFormatUpdateEventInit) -> mut TextFormatUpdateEvent
    = "return new TextFormatUpdateEvent(#fun(String::as_js)(#var(type)), #fun(TextFormatUpdateEventInit::as_js)(#var(options)));"

pub ext fun TextFormatUpdateEvent::type(self: TextFormatUpdateEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TextFormatUpdateEvent::target(self: TextFormatUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TextFormatUpdateEvent::current_target(self: TextFormatUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TextFormatUpdateEvent::event_phase(self: TextFormatUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TextFormatUpdateEvent::bubbles(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TextFormatUpdateEvent::cancelable(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TextFormatUpdateEvent::default_prevented(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TextFormatUpdateEvent::composed(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TextFormatUpdateEvent::is_trusted(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TextFormatUpdateEvent::time_stamp(self: TextFormatUpdateEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TextFormatUpdateEvent::src_element(self: TextFormatUpdateEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TextFormatUpdateEvent::return_value(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TextFormatUpdateEvent::set_return_value(self: mut TextFormatUpdateEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TextFormatUpdateEvent::cancel_bubble(self: TextFormatUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TextFormatUpdateEvent::set_cancel_bubble(self: mut TextFormatUpdateEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TextFormatUpdateEvent::get_text_formats(__self: mut TextFormatUpdateEvent) -> List[mut TextFormat] = "
    const r = #var(__self).getTextFormats();
    return #fun(List::from_js[mut TextFormat])(r);
"

pub ext fun TextFormatUpdateEvent::composed_path(__self: mut TextFormatUpdateEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TextFormatUpdateEvent::stop_propagation(__self: mut TextFormatUpdateEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextFormatUpdateEvent::stop_immediate_propagation(__self: mut TextFormatUpdateEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextFormatUpdateEvent::prevent_default(__self: mut TextFormatUpdateEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextFormatUpdateEvent::init_event(__self: mut TextFormatUpdateEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TextFormatUpdateEvent::as_js(self: TextFormatUpdateEvent) -> JsValue = JsValue::unsafe_from[TextFormatUpdateEvent](self)

pub fun TextFormatUpdateEvent::from_js(v: JsValue) -> mut TextFormatUpdateEvent = JsValue::unsafe_as[mut TextFormatUpdateEvent](v)

pub val TextFormatUpdateEvent::none: Int = 0
pub val TextFormatUpdateEvent::capturing_phase: Int = 1
pub val TextFormatUpdateEvent::at_target: Int = 2
pub val TextFormatUpdateEvent::bubbling_phase: Int = 3

pub struct TextFormatUpdateEventInit(
    text_formats: Option[List[mut TextFormat]],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TextFormatUpdateEventInit::default() -> mut TextFormatUpdateEventInit
    = TextFormatUpdateEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TextFormatUpdateEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEventInit::as_event_init(self: TextFormatUpdateEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'TextFormatUpdateEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEventInit::as_mevent_init(self: mut TextFormatUpdateEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'TextFormatUpdateEventInit'.
/// A 'base' that is not a reference to 'TextFormatUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEventInit::from_event_init_unchecked(base: EventInit) -> TextFormatUpdateEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'TextFormatUpdateEventInit'.
/// A 'base' that is not a reference to 'TextFormatUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TextFormatUpdateEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut TextFormatUpdateEventInit = "return #var(base);"

pub ext fun TextFormatUpdateEventInit::from_js(value: JsValue) -> mut TextFormatUpdateEventInit = "
    const r = {};
    r.m_text_formats = #fun(Option::from_js[List[mut TextFormat]])(#var(value).textFormats);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TextFormatUpdateEventInit::as_js(self: TextFormatUpdateEventInit) -> JsValue = "
    const r = {};
    r.textFormats = #fun(Option::as_js_undef[List[mut TextFormat]])(#var(self).m_text_formats);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct TextUpdateEvent()

/// Converts a reference to 'TextUpdateEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEvent::as_event(self: TextUpdateEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TextUpdateEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEvent::as_mevent(self: mut TextUpdateEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TextUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEvent::from_event(base: Event) -> TextUpdateEvent = "
    if(#var(base) instanceof TextUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextUpdateEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TextUpdateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextUpdateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEvent::from_mevent(base: mut Event) -> mut TextUpdateEvent = "
    if(#var(base) instanceof TextUpdateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextUpdateEvent'!\");
"

pub ext fun TextUpdateEvent::from_str_mtext_update_event_init(type: String, options: mut TextUpdateEventInit) -> mut TextUpdateEvent
    = "return new TextUpdateEvent(#fun(String::as_js)(#var(type)), #fun(TextUpdateEventInit::as_js)(#var(options)));"

pub ext fun TextUpdateEvent::update_range_start(self: TextUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).updateRangeStart);"

pub ext fun TextUpdateEvent::update_range_end(self: TextUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).updateRangeEnd);"

pub ext fun TextUpdateEvent::text(self: TextUpdateEvent) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun TextUpdateEvent::selection_start(self: TextUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionStart);"

pub ext fun TextUpdateEvent::selection_end(self: TextUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionEnd);"

pub ext fun TextUpdateEvent::type(self: TextUpdateEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TextUpdateEvent::target(self: TextUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TextUpdateEvent::current_target(self: TextUpdateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TextUpdateEvent::event_phase(self: TextUpdateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TextUpdateEvent::bubbles(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TextUpdateEvent::cancelable(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TextUpdateEvent::default_prevented(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TextUpdateEvent::composed(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TextUpdateEvent::is_trusted(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TextUpdateEvent::time_stamp(self: TextUpdateEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TextUpdateEvent::src_element(self: TextUpdateEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TextUpdateEvent::return_value(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TextUpdateEvent::set_return_value(self: mut TextUpdateEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TextUpdateEvent::cancel_bubble(self: TextUpdateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TextUpdateEvent::set_cancel_bubble(self: mut TextUpdateEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TextUpdateEvent::composed_path(__self: mut TextUpdateEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TextUpdateEvent::stop_propagation(__self: mut TextUpdateEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextUpdateEvent::stop_immediate_propagation(__self: mut TextUpdateEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextUpdateEvent::prevent_default(__self: mut TextUpdateEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextUpdateEvent::init_event(__self: mut TextUpdateEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TextUpdateEvent::as_js(self: TextUpdateEvent) -> JsValue = JsValue::unsafe_from[TextUpdateEvent](self)

pub fun TextUpdateEvent::from_js(v: JsValue) -> mut TextUpdateEvent = JsValue::unsafe_as[mut TextUpdateEvent](v)

pub val TextUpdateEvent::none: Int = 0
pub val TextUpdateEvent::capturing_phase: Int = 1
pub val TextUpdateEvent::at_target: Int = 2
pub val TextUpdateEvent::bubbling_phase: Int = 3

pub struct TextUpdateEventInit(
    update_range_start: Option[Int],
    update_range_end: Option[Int],
    text: Option[String],
    selection_start: Option[Int],
    selection_end: Option[Int],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TextUpdateEventInit::default() -> mut TextUpdateEventInit
    = TextUpdateEventInit(Option::None, Option::None, Option::None, Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TextUpdateEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEventInit::as_event_init(self: TextUpdateEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'TextUpdateEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEventInit::as_mevent_init(self: mut TextUpdateEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'TextUpdateEventInit'.
/// A 'base' that is not a reference to 'TextUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEventInit::from_event_init_unchecked(base: EventInit) -> TextUpdateEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'TextUpdateEventInit'.
/// A 'base' that is not a reference to 'TextUpdateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TextUpdateEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut TextUpdateEventInit = "return #var(base);"

pub ext fun TextUpdateEventInit::from_js(value: JsValue) -> mut TextUpdateEventInit = "
    const r = {};
    r.m_update_range_start = #fun(Option::from_js[Int])(#var(value).updateRangeStart);
    r.m_update_range_end = #fun(Option::from_js[Int])(#var(value).updateRangeEnd);
    r.m_text = #fun(Option::from_js[String])(#var(value).text);
    r.m_selection_start = #fun(Option::from_js[Int])(#var(value).selectionStart);
    r.m_selection_end = #fun(Option::from_js[Int])(#var(value).selectionEnd);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TextUpdateEventInit::as_js(self: TextUpdateEventInit) -> JsValue = "
    const r = {};
    r.updateRangeStart = #fun(Option::as_js_undef[Int])(#var(self).m_update_range_start);
    r.updateRangeEnd = #fun(Option::as_js_undef[Int])(#var(self).m_update_range_end);
    r.text = #fun(Option::as_js_undef[String])(#var(self).m_text);
    r.selectionStart = #fun(Option::as_js_undef[Int])(#var(self).m_selection_start);
    r.selectionEnd = #fun(Option::as_js_undef[Int])(#var(self).m_selection_end);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct Selection()

pub ext fun Selection::anchor_node(self: Selection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).anchorNode);"

pub ext fun Selection::anchor_offset(self: Selection) -> Int
    = "return #fun(Int::from_js)(#var(self).anchorOffset);"

pub ext fun Selection::focus_node(self: Selection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).focusNode);"

pub ext fun Selection::focus_offset(self: Selection) -> Int
    = "return #fun(Int::from_js)(#var(self).focusOffset);"

pub ext fun Selection::is_collapsed(self: Selection) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isCollapsed);"

pub ext fun Selection::range_count(self: Selection) -> Int
    = "return #fun(Int::from_js)(#var(self).rangeCount);"

pub ext fun Selection::type(self: Selection) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Selection::direction(self: Selection) -> String
    = "return #fun(String::from_js)(#var(self).direction);"

pub ext fun Selection::base_node(self: Selection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).baseNode);"

pub ext fun Selection::base_offset(self: Selection) -> Int
    = "return #fun(Int::from_js)(#var(self).baseOffset);"

pub ext fun Selection::extent_node(self: Selection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).extentNode);"

pub ext fun Selection::extent_offset(self: Selection) -> Int
    = "return #fun(Int::from_js)(#var(self).extentOffset);"

pub ext fun Selection::get_range_at(__self: mut Selection, index: Int) -> mut Range = "
    const r = #var(__self).getRangeAt(#fun(Int::as_js)(#var(index)));
    return #fun(Range::from_js)(r);
"

pub ext fun Selection::add_range(__self: mut Selection, range: mut Range) -> Unit = "
    const r = #var(__self).addRange(#fun(Range::as_js)(#var(range)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::remove_range(__self: mut Selection, range: mut Range) -> Unit = "
    const r = #var(__self).removeRange(#fun(Range::as_js)(#var(range)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::remove_all_ranges(__self: mut Selection) -> Unit = "
    const r = #var(__self).removeAllRanges();
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::empty(__self: mut Selection) -> Unit = "
    const r = #var(__self).empty();
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::collapse(__self: mut Selection, node: Option[mut Node], offset: Int) -> Unit = "
    const r = #var(__self).collapse(#fun(Option::as_js[mut Node])(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::set_position(__self: mut Selection, node: Option[mut Node], offset: Int) -> Unit = "
    const r = #var(__self).setPosition(#fun(Option::as_js[mut Node])(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::collapse_to_start(__self: mut Selection) -> Unit = "
    const r = #var(__self).collapseToStart();
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::collapse_to_end(__self: mut Selection) -> Unit = "
    const r = #var(__self).collapseToEnd();
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::extend(__self: mut Selection, node: mut Node, offset: Int) -> Unit = "
    const r = #var(__self).extend(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::set_base_and_extent(__self: mut Selection, base_node: Option[mut Node], base_offset: Int, extent_node: Option[mut Node], extent_offset: Int) -> Unit = "
    const r = #var(__self).setBaseAndExtent(#fun(Option::as_js[mut Node])(#var(base_node)), #fun(Int::as_js)(#var(base_offset)), #fun(Option::as_js[mut Node])(#var(extent_node)), #fun(Int::as_js)(#var(extent_offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::select_all_children(__self: mut Selection, node: mut Node) -> Unit = "
    const r = #var(__self).selectAllChildren(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::delete_from_document(__self: mut Selection) -> Unit = "
    const r = #var(__self).deleteFromDocument();
    return #fun(Unit::from_js)(r);
"

pub ext fun Selection::contains_node(__self: mut Selection, node: mut Node, allow_partial_containment: Bool) -> Bool = "
    const r = #var(__self).containsNode(#fun(Node::as_js)(#var(node)), #fun(Bool::as_js)(#var(allow_partial_containment)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Selection::as_string(__self: mut Selection) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun Selection::get_composed_ranges(__self: mut Selection, options: mut GetComposedRangesOptions) -> List[mut StaticRange] = "
    const r = #var(__self).getComposedRanges(#fun(GetComposedRangesOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut StaticRange])(r);
"

pub ext fun Selection::modify(__self: mut Selection, alter: String, direction: String, granularity: String) -> Unit = "
    const r = #var(__self).modify(#fun(String::as_js)(#var(alter)), #fun(String::as_js)(#var(direction)), #fun(String::as_js)(#var(granularity)));
    return #fun(Unit::from_js)(r);
"

pub fun Selection::as_js(self: Selection) -> JsValue = JsValue::unsafe_from[Selection](self)

pub fun Selection::from_js(v: JsValue) -> mut Selection = JsValue::unsafe_as[mut Selection](v)

struct AnimationEvent()

/// Converts a reference to 'AnimationEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEvent::as_event(self: AnimationEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'AnimationEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEvent::as_mevent(self: mut AnimationEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'AnimationEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'AnimationEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEvent::from_event(base: Event) -> AnimationEvent = "
    if(#var(base) instanceof AnimationEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'AnimationEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'AnimationEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'AnimationEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEvent::from_mevent(base: mut Event) -> mut AnimationEvent = "
    if(#var(base) instanceof AnimationEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'AnimationEvent'!\");
"

pub ext fun AnimationEvent::from_str_manimation_event_init(type: String, event_init_dict: mut AnimationEventInit) -> mut AnimationEvent
    = "return new AnimationEvent(#fun(String::as_js)(#var(type)), #fun(AnimationEventInit::as_js)(#var(event_init_dict)));"

pub ext fun AnimationEvent::animation_name(self: AnimationEvent) -> String
    = "return #fun(String::from_js)(#var(self).animationName);"

pub ext fun AnimationEvent::elapsed_time(self: AnimationEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).elapsedTime);"

pub ext fun AnimationEvent::pseudo_element(self: AnimationEvent) -> String
    = "return #fun(String::from_js)(#var(self).pseudoElement);"

pub ext fun AnimationEvent::type(self: AnimationEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun AnimationEvent::target(self: AnimationEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun AnimationEvent::current_target(self: AnimationEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun AnimationEvent::event_phase(self: AnimationEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun AnimationEvent::bubbles(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun AnimationEvent::cancelable(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun AnimationEvent::default_prevented(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun AnimationEvent::composed(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun AnimationEvent::is_trusted(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun AnimationEvent::time_stamp(self: AnimationEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun AnimationEvent::src_element(self: AnimationEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun AnimationEvent::return_value(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun AnimationEvent::set_return_value(self: mut AnimationEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun AnimationEvent::cancel_bubble(self: AnimationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun AnimationEvent::set_cancel_bubble(self: mut AnimationEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun AnimationEvent::composed_path(__self: mut AnimationEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun AnimationEvent::stop_propagation(__self: mut AnimationEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationEvent::stop_immediate_propagation(__self: mut AnimationEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationEvent::prevent_default(__self: mut AnimationEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationEvent::init_event(__self: mut AnimationEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun AnimationEvent::as_js(self: AnimationEvent) -> JsValue = JsValue::unsafe_from[AnimationEvent](self)

pub fun AnimationEvent::from_js(v: JsValue) -> mut AnimationEvent = JsValue::unsafe_as[mut AnimationEvent](v)

pub val AnimationEvent::none: Int = 0
pub val AnimationEvent::capturing_phase: Int = 1
pub val AnimationEvent::at_target: Int = 2
pub val AnimationEvent::bubbling_phase: Int = 3

pub struct AnimationEventInit(
    animation_name: Option[String],
    elapsed_time: Option[Float],
    pseudo_element: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun AnimationEventInit::default() -> mut AnimationEventInit
    = AnimationEventInit(Option::Some(""), Option::Some(0.0), Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'AnimationEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEventInit::as_event_init(self: AnimationEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'AnimationEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEventInit::as_mevent_init(self: mut AnimationEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'AnimationEventInit'.
/// A 'base' that is not a reference to 'AnimationEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEventInit::from_event_init_unchecked(base: EventInit) -> AnimationEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'AnimationEventInit'.
/// A 'base' that is not a reference to 'AnimationEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut AnimationEventInit = "return #var(base);"

pub ext fun AnimationEventInit::from_js(value: JsValue) -> mut AnimationEventInit = "
    const r = {};
    r.m_animation_name = #fun(Option::from_js[String])(#var(value).animationName);
    r.m_elapsed_time = #fun(Option::from_js[Float])(#var(value).elapsedTime);
    r.m_pseudo_element = #fun(Option::from_js[String])(#var(value).pseudoElement);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun AnimationEventInit::as_js(self: AnimationEventInit) -> JsValue = "
    const r = {};
    r.animationName = #fun(Option::as_js_undef[String])(#var(self).m_animation_name);
    r.elapsedTime = #fun(Option::as_js_undef[Float])(#var(self).m_elapsed_time);
    r.pseudoElement = #fun(Option::as_js_undef[String])(#var(self).m_pseudo_element);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct AnimationPlaybackEvent()

/// Converts a reference to 'AnimationPlaybackEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEvent::as_event(self: AnimationPlaybackEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'AnimationPlaybackEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEvent::as_mevent(self: mut AnimationPlaybackEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'AnimationPlaybackEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'AnimationPlaybackEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEvent::from_event(base: Event) -> AnimationPlaybackEvent = "
    if(#var(base) instanceof AnimationPlaybackEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'AnimationPlaybackEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'AnimationPlaybackEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'AnimationPlaybackEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEvent::from_mevent(base: mut Event) -> mut AnimationPlaybackEvent = "
    if(#var(base) instanceof AnimationPlaybackEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'AnimationPlaybackEvent'!\");
"

pub ext fun AnimationPlaybackEvent::from_str_manimation_playback_event_init(type: String, event_init_dict: mut AnimationPlaybackEventInit) -> mut AnimationPlaybackEvent
    = "return new AnimationPlaybackEvent(#fun(String::as_js)(#var(type)), #fun(AnimationPlaybackEventInit::as_js)(#var(event_init_dict)));"

pub ext fun AnimationPlaybackEvent::current_time(self: AnimationPlaybackEvent) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).currentTime);"

pub ext fun AnimationPlaybackEvent::timeline_time(self: AnimationPlaybackEvent) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).timelineTime);"

pub ext fun AnimationPlaybackEvent::type(self: AnimationPlaybackEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun AnimationPlaybackEvent::target(self: AnimationPlaybackEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun AnimationPlaybackEvent::current_target(self: AnimationPlaybackEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun AnimationPlaybackEvent::event_phase(self: AnimationPlaybackEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun AnimationPlaybackEvent::bubbles(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun AnimationPlaybackEvent::cancelable(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun AnimationPlaybackEvent::default_prevented(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun AnimationPlaybackEvent::composed(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun AnimationPlaybackEvent::is_trusted(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun AnimationPlaybackEvent::time_stamp(self: AnimationPlaybackEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun AnimationPlaybackEvent::src_element(self: AnimationPlaybackEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun AnimationPlaybackEvent::return_value(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun AnimationPlaybackEvent::set_return_value(self: mut AnimationPlaybackEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun AnimationPlaybackEvent::cancel_bubble(self: AnimationPlaybackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun AnimationPlaybackEvent::set_cancel_bubble(self: mut AnimationPlaybackEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun AnimationPlaybackEvent::composed_path(__self: mut AnimationPlaybackEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun AnimationPlaybackEvent::stop_propagation(__self: mut AnimationPlaybackEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationPlaybackEvent::stop_immediate_propagation(__self: mut AnimationPlaybackEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationPlaybackEvent::prevent_default(__self: mut AnimationPlaybackEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun AnimationPlaybackEvent::init_event(__self: mut AnimationPlaybackEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun AnimationPlaybackEvent::as_js(self: AnimationPlaybackEvent) -> JsValue = JsValue::unsafe_from[AnimationPlaybackEvent](self)

pub fun AnimationPlaybackEvent::from_js(v: JsValue) -> mut AnimationPlaybackEvent = JsValue::unsafe_as[mut AnimationPlaybackEvent](v)

pub val AnimationPlaybackEvent::none: Int = 0
pub val AnimationPlaybackEvent::capturing_phase: Int = 1
pub val AnimationPlaybackEvent::at_target: Int = 2
pub val AnimationPlaybackEvent::bubbling_phase: Int = 3

pub struct AnimationPlaybackEventInit(
    current_time: Option[JsValue],
    timeline_time: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun AnimationPlaybackEventInit::default() -> mut AnimationPlaybackEventInit
    = AnimationPlaybackEventInit(Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'AnimationPlaybackEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEventInit::as_event_init(self: AnimationPlaybackEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'AnimationPlaybackEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEventInit::as_mevent_init(self: mut AnimationPlaybackEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'AnimationPlaybackEventInit'.
/// A 'base' that is not a reference to 'AnimationPlaybackEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEventInit::from_event_init_unchecked(base: EventInit) -> AnimationPlaybackEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'AnimationPlaybackEventInit'.
/// A 'base' that is not a reference to 'AnimationPlaybackEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AnimationPlaybackEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut AnimationPlaybackEventInit = "return #var(base);"

pub ext fun AnimationPlaybackEventInit::from_js(value: JsValue) -> mut AnimationPlaybackEventInit = "
    const r = {};
    r.m_current_time = #fun(Option::from_js[JsValue])(#var(value).currentTime);
    r.m_timeline_time = #fun(Option::from_js[JsValue])(#var(value).timelineTime);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun AnimationPlaybackEventInit::as_js(self: AnimationPlaybackEventInit) -> JsValue = "
    const r = {};
    r.currentTime = #fun(Option::as_js_undef[JsValue])(#var(self).m_current_time);
    r.timelineTime = #fun(Option::as_js_undef[JsValue])(#var(self).m_timeline_time);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct BeforeCreatePolicyEvent()

/// Converts a reference to 'BeforeCreatePolicyEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeCreatePolicyEvent::as_event(self: BeforeCreatePolicyEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'BeforeCreatePolicyEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeCreatePolicyEvent::as_mevent(self: mut BeforeCreatePolicyEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'BeforeCreatePolicyEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'BeforeCreatePolicyEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeCreatePolicyEvent::from_event(base: Event) -> BeforeCreatePolicyEvent = "
    if(#var(base) instanceof BeforeCreatePolicyEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'BeforeCreatePolicyEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'BeforeCreatePolicyEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'BeforeCreatePolicyEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeCreatePolicyEvent::from_mevent(base: mut Event) -> mut BeforeCreatePolicyEvent = "
    if(#var(base) instanceof BeforeCreatePolicyEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'BeforeCreatePolicyEvent'!\");
"

pub ext fun BeforeCreatePolicyEvent::policy_name(self: BeforeCreatePolicyEvent) -> String
    = "return #fun(String::from_js)(#var(self).policyName);"

pub ext fun BeforeCreatePolicyEvent::set_policy_name(self: mut BeforeCreatePolicyEvent, value: String)
    = "#var(self).policyName = #fun(String::as_js)(#var(value));"

pub ext fun BeforeCreatePolicyEvent::type(self: BeforeCreatePolicyEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun BeforeCreatePolicyEvent::target(self: BeforeCreatePolicyEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun BeforeCreatePolicyEvent::current_target(self: BeforeCreatePolicyEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun BeforeCreatePolicyEvent::event_phase(self: BeforeCreatePolicyEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun BeforeCreatePolicyEvent::bubbles(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun BeforeCreatePolicyEvent::cancelable(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun BeforeCreatePolicyEvent::default_prevented(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun BeforeCreatePolicyEvent::composed(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun BeforeCreatePolicyEvent::is_trusted(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun BeforeCreatePolicyEvent::time_stamp(self: BeforeCreatePolicyEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun BeforeCreatePolicyEvent::src_element(self: BeforeCreatePolicyEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun BeforeCreatePolicyEvent::return_value(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun BeforeCreatePolicyEvent::set_return_value(self: mut BeforeCreatePolicyEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun BeforeCreatePolicyEvent::cancel_bubble(self: BeforeCreatePolicyEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun BeforeCreatePolicyEvent::set_cancel_bubble(self: mut BeforeCreatePolicyEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun BeforeCreatePolicyEvent::composed_path(__self: mut BeforeCreatePolicyEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun BeforeCreatePolicyEvent::stop_propagation(__self: mut BeforeCreatePolicyEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeCreatePolicyEvent::stop_immediate_propagation(__self: mut BeforeCreatePolicyEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeCreatePolicyEvent::prevent_default(__self: mut BeforeCreatePolicyEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeCreatePolicyEvent::init_event(__self: mut BeforeCreatePolicyEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun BeforeCreatePolicyEvent::as_js(self: BeforeCreatePolicyEvent) -> JsValue = JsValue::unsafe_from[BeforeCreatePolicyEvent](self)

pub fun BeforeCreatePolicyEvent::from_js(v: JsValue) -> mut BeforeCreatePolicyEvent = JsValue::unsafe_as[mut BeforeCreatePolicyEvent](v)

pub val BeforeCreatePolicyEvent::none: Int = 0
pub val BeforeCreatePolicyEvent::capturing_phase: Int = 1
pub val BeforeCreatePolicyEvent::at_target: Int = 2
pub val BeforeCreatePolicyEvent::bubbling_phase: Int = 3

struct BeforeUnloadEvent()

/// Converts a reference to 'BeforeUnloadEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeUnloadEvent::as_event(self: BeforeUnloadEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'BeforeUnloadEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeUnloadEvent::as_mevent(self: mut BeforeUnloadEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'BeforeUnloadEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'BeforeUnloadEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeUnloadEvent::from_event(base: Event) -> BeforeUnloadEvent = "
    if(#var(base) instanceof BeforeUnloadEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'BeforeUnloadEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'BeforeUnloadEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'BeforeUnloadEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BeforeUnloadEvent::from_mevent(base: mut Event) -> mut BeforeUnloadEvent = "
    if(#var(base) instanceof BeforeUnloadEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'BeforeUnloadEvent'!\");
"

pub ext fun BeforeUnloadEvent::return_value(self: BeforeUnloadEvent) -> String
    = "return #fun(String::from_js)(#var(self).returnValue);"

pub ext fun BeforeUnloadEvent::set_return_value(self: mut BeforeUnloadEvent, value: String)
    = "#var(self).returnValue = #fun(String::as_js)(#var(value));"

pub ext fun BeforeUnloadEvent::type(self: BeforeUnloadEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun BeforeUnloadEvent::target(self: BeforeUnloadEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun BeforeUnloadEvent::current_target(self: BeforeUnloadEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun BeforeUnloadEvent::event_phase(self: BeforeUnloadEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun BeforeUnloadEvent::bubbles(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun BeforeUnloadEvent::cancelable(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun BeforeUnloadEvent::default_prevented(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun BeforeUnloadEvent::composed(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun BeforeUnloadEvent::is_trusted(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun BeforeUnloadEvent::time_stamp(self: BeforeUnloadEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun BeforeUnloadEvent::src_element(self: BeforeUnloadEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun BeforeUnloadEvent::cancel_bubble(self: BeforeUnloadEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun BeforeUnloadEvent::set_cancel_bubble(self: mut BeforeUnloadEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun BeforeUnloadEvent::composed_path(__self: mut BeforeUnloadEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun BeforeUnloadEvent::stop_propagation(__self: mut BeforeUnloadEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeUnloadEvent::stop_immediate_propagation(__self: mut BeforeUnloadEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeUnloadEvent::prevent_default(__self: mut BeforeUnloadEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun BeforeUnloadEvent::init_event(__self: mut BeforeUnloadEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun BeforeUnloadEvent::as_js(self: BeforeUnloadEvent) -> JsValue = JsValue::unsafe_from[BeforeUnloadEvent](self)

pub fun BeforeUnloadEvent::from_js(v: JsValue) -> mut BeforeUnloadEvent = JsValue::unsafe_as[mut BeforeUnloadEvent](v)

pub val BeforeUnloadEvent::none: Int = 0
pub val BeforeUnloadEvent::capturing_phase: Int = 1
pub val BeforeUnloadEvent::at_target: Int = 2
pub val BeforeUnloadEvent::bubbling_phase: Int = 3

struct ClipboardEvent()

/// Converts a reference to 'ClipboardEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEvent::as_event(self: ClipboardEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ClipboardEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEvent::as_mevent(self: mut ClipboardEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ClipboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ClipboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEvent::from_event(base: Event) -> ClipboardEvent = "
    if(#var(base) instanceof ClipboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ClipboardEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ClipboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ClipboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEvent::from_mevent(base: mut Event) -> mut ClipboardEvent = "
    if(#var(base) instanceof ClipboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ClipboardEvent'!\");
"

pub ext fun ClipboardEvent::from_str_mclipboard_event_init(type: String, event_init_dict: mut ClipboardEventInit) -> mut ClipboardEvent
    = "return new ClipboardEvent(#fun(String::as_js)(#var(type)), #fun(ClipboardEventInit::as_js)(#var(event_init_dict)));"

pub ext fun ClipboardEvent::clipboard_data(self: ClipboardEvent) -> Option[mut DataTransfer]
    = "return #fun(Option::from_js[mut DataTransfer])(#var(self).clipboardData);"

pub ext fun ClipboardEvent::type(self: ClipboardEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ClipboardEvent::target(self: ClipboardEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ClipboardEvent::current_target(self: ClipboardEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ClipboardEvent::event_phase(self: ClipboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ClipboardEvent::bubbles(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ClipboardEvent::cancelable(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ClipboardEvent::default_prevented(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ClipboardEvent::composed(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ClipboardEvent::is_trusted(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ClipboardEvent::time_stamp(self: ClipboardEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ClipboardEvent::src_element(self: ClipboardEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ClipboardEvent::return_value(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ClipboardEvent::set_return_value(self: mut ClipboardEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ClipboardEvent::cancel_bubble(self: ClipboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ClipboardEvent::set_cancel_bubble(self: mut ClipboardEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ClipboardEvent::composed_path(__self: mut ClipboardEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ClipboardEvent::stop_propagation(__self: mut ClipboardEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ClipboardEvent::stop_immediate_propagation(__self: mut ClipboardEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ClipboardEvent::prevent_default(__self: mut ClipboardEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ClipboardEvent::init_event(__self: mut ClipboardEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ClipboardEvent::as_js(self: ClipboardEvent) -> JsValue = JsValue::unsafe_from[ClipboardEvent](self)

pub fun ClipboardEvent::from_js(v: JsValue) -> mut ClipboardEvent = JsValue::unsafe_as[mut ClipboardEvent](v)

pub val ClipboardEvent::none: Int = 0
pub val ClipboardEvent::capturing_phase: Int = 1
pub val ClipboardEvent::at_target: Int = 2
pub val ClipboardEvent::bubbling_phase: Int = 3

pub struct ClipboardEventInit(
    clipboard_data: Option[mut DataTransfer],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun ClipboardEventInit::default() -> mut ClipboardEventInit
    = ClipboardEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'ClipboardEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEventInit::as_event_init(self: ClipboardEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'ClipboardEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEventInit::as_mevent_init(self: mut ClipboardEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'ClipboardEventInit'.
/// A 'base' that is not a reference to 'ClipboardEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEventInit::from_event_init_unchecked(base: EventInit) -> ClipboardEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'ClipboardEventInit'.
/// A 'base' that is not a reference to 'ClipboardEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ClipboardEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut ClipboardEventInit = "return #var(base);"

pub ext fun ClipboardEventInit::from_js(value: JsValue) -> mut ClipboardEventInit = "
    const r = {};
    r.m_clipboard_data = #fun(Option::from_js[mut DataTransfer])(#var(value).clipboardData);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun ClipboardEventInit::as_js(self: ClipboardEventInit) -> JsValue = "
    const r = {};
    r.clipboardData = #fun(Option::as_js_undef[mut DataTransfer])(#var(self).m_clipboard_data);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct CommandEvent()

/// Converts a reference to 'CommandEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEvent::as_event(self: CommandEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'CommandEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEvent::as_mevent(self: mut CommandEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'CommandEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CommandEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEvent::from_event(base: Event) -> CommandEvent = "
    if(#var(base) instanceof CommandEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CommandEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'CommandEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CommandEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEvent::from_mevent(base: mut Event) -> mut CommandEvent = "
    if(#var(base) instanceof CommandEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CommandEvent'!\");
"

pub ext fun CommandEvent::from_str_mcommand_event_init(type: String, event_init_dict: mut CommandEventInit) -> mut CommandEvent
    = "return new CommandEvent(#fun(String::as_js)(#var(type)), #fun(CommandEventInit::as_js)(#var(event_init_dict)));"

pub ext fun CommandEvent::source(self: CommandEvent) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).source);"

pub ext fun CommandEvent::command(self: CommandEvent) -> String
    = "return #fun(String::from_js)(#var(self).command);"

pub ext fun CommandEvent::type(self: CommandEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CommandEvent::target(self: CommandEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun CommandEvent::current_target(self: CommandEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun CommandEvent::event_phase(self: CommandEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun CommandEvent::bubbles(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun CommandEvent::cancelable(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun CommandEvent::default_prevented(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun CommandEvent::composed(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun CommandEvent::is_trusted(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun CommandEvent::time_stamp(self: CommandEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun CommandEvent::src_element(self: CommandEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun CommandEvent::return_value(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun CommandEvent::set_return_value(self: mut CommandEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun CommandEvent::cancel_bubble(self: CommandEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun CommandEvent::set_cancel_bubble(self: mut CommandEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun CommandEvent::composed_path(__self: mut CommandEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun CommandEvent::stop_propagation(__self: mut CommandEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CommandEvent::stop_immediate_propagation(__self: mut CommandEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CommandEvent::prevent_default(__self: mut CommandEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun CommandEvent::init_event(__self: mut CommandEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun CommandEvent::as_js(self: CommandEvent) -> JsValue = JsValue::unsafe_from[CommandEvent](self)

pub fun CommandEvent::from_js(v: JsValue) -> mut CommandEvent = JsValue::unsafe_as[mut CommandEvent](v)

pub val CommandEvent::none: Int = 0
pub val CommandEvent::capturing_phase: Int = 1
pub val CommandEvent::at_target: Int = 2
pub val CommandEvent::bubbling_phase: Int = 3

pub struct CommandEventInit(
    source: Option[mut Element],
    command: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun CommandEventInit::default() -> mut CommandEventInit
    = CommandEventInit(Option::None, Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'CommandEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEventInit::as_event_init(self: CommandEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'CommandEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEventInit::as_mevent_init(self: mut CommandEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'CommandEventInit'.
/// A 'base' that is not a reference to 'CommandEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEventInit::from_event_init_unchecked(base: EventInit) -> CommandEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'CommandEventInit'.
/// A 'base' that is not a reference to 'CommandEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CommandEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut CommandEventInit = "return #var(base);"

pub ext fun CommandEventInit::from_js(value: JsValue) -> mut CommandEventInit = "
    const r = {};
    r.m_source = #fun(Option::from_js[mut Element])(#var(value).source);
    r.m_command = #fun(Option::from_js[String])(#var(value).command);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun CommandEventInit::as_js(self: CommandEventInit) -> JsValue = "
    const r = {};
    r.source = #fun(Option::as_js_undef[mut Element])(#var(self).m_source);
    r.command = #fun(Option::as_js_undef[String])(#var(self).m_command);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct CompositionEvent()

/// Converts a reference to 'CompositionEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::as_ui_event(self: CompositionEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'CompositionEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::as_mui_event(self: mut CompositionEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'CompositionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CompositionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::from_ui_event(base: UIEvent) -> CompositionEvent = "
    if(#var(base) instanceof CompositionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'CompositionEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'CompositionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CompositionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::from_mui_event(base: mut UIEvent) -> mut CompositionEvent = "
    if(#var(base) instanceof CompositionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'CompositionEvent'!\");
"

/// Converts a reference to 'CompositionEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::as_event(self: CompositionEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'CompositionEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::as_mevent(self: mut CompositionEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'CompositionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CompositionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::from_event(base: Event) -> CompositionEvent = "
    if(#var(base) instanceof CompositionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CompositionEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'CompositionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CompositionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEvent::from_mevent(base: mut Event) -> mut CompositionEvent = "
    if(#var(base) instanceof CompositionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CompositionEvent'!\");
"

pub ext fun CompositionEvent::from_str_mcomposition_event_init(type: String, event_init_dict: mut CompositionEventInit) -> mut CompositionEvent
    = "return new CompositionEvent(#fun(String::as_js)(#var(type)), #fun(CompositionEventInit::as_js)(#var(event_init_dict)));"

pub ext fun CompositionEvent::data(self: CompositionEvent) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun CompositionEvent::view(self: CompositionEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun CompositionEvent::detail(self: CompositionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun CompositionEvent::source_capabilities(self: CompositionEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun CompositionEvent::which(self: CompositionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun CompositionEvent::type(self: CompositionEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CompositionEvent::target(self: CompositionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun CompositionEvent::current_target(self: CompositionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun CompositionEvent::event_phase(self: CompositionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun CompositionEvent::bubbles(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun CompositionEvent::cancelable(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun CompositionEvent::default_prevented(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun CompositionEvent::composed(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun CompositionEvent::is_trusted(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun CompositionEvent::time_stamp(self: CompositionEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun CompositionEvent::src_element(self: CompositionEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun CompositionEvent::return_value(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun CompositionEvent::set_return_value(self: mut CompositionEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun CompositionEvent::cancel_bubble(self: CompositionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun CompositionEvent::set_cancel_bubble(self: mut CompositionEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun CompositionEvent::init_composition_event(__self: mut CompositionEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], data: String) -> Unit = "
    const r = #var(__self).initCompositionEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CompositionEvent::init_ui_event(__self: mut CompositionEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CompositionEvent::composed_path(__self: mut CompositionEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun CompositionEvent::stop_propagation(__self: mut CompositionEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CompositionEvent::stop_immediate_propagation(__self: mut CompositionEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CompositionEvent::prevent_default(__self: mut CompositionEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun CompositionEvent::init_event(__self: mut CompositionEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun CompositionEvent::as_js(self: CompositionEvent) -> JsValue = JsValue::unsafe_from[CompositionEvent](self)

pub fun CompositionEvent::from_js(v: JsValue) -> mut CompositionEvent = JsValue::unsafe_as[mut CompositionEvent](v)

pub val CompositionEvent::none: Int = 0
pub val CompositionEvent::capturing_phase: Int = 1
pub val CompositionEvent::at_target: Int = 2
pub val CompositionEvent::bubbling_phase: Int = 3

pub struct CompositionEventInit(
    data: Option[String],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun CompositionEventInit::default() -> mut CompositionEventInit
    = CompositionEventInit(Option::Some(""), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'CompositionEventInit' to a reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEventInit::as_ui_event_init(self: CompositionEventInit) -> UIEventInit = "return #var(self);"

/// Converts a mutable reference to 'CompositionEventInit' to a mutable reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEventInit::as_mui_event_init(self: mut CompositionEventInit) -> mut UIEventInit = "return #var(self);"

/// Attempts to convert a reference to 'UIEventInit' to a reference to 'CompositionEventInit'.
/// A 'base' that is not a reference to 'CompositionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEventInit::from_ui_event_init_unchecked(base: UIEventInit) -> CompositionEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'UIEventInit' to a mutable reference to 'CompositionEventInit'.
/// A 'base' that is not a reference to 'CompositionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CompositionEventInit::from_mui_event_init_unchecked(base: mut UIEventInit) -> mut CompositionEventInit = "return #var(base);"

pub ext fun CompositionEventInit::from_js(value: JsValue) -> mut CompositionEventInit = "
    const r = {};
    r.m_data = #fun(Option::from_js[String])(#var(value).data);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun CompositionEventInit::as_js(self: CompositionEventInit) -> JsValue = "
    const r = {};
    r.data = #fun(Option::as_js_undef[String])(#var(self).m_data);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct DragEvent()

/// Converts a reference to 'DragEvent' to a reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_mouse_event(self: DragEvent) -> MouseEvent = "return #var(self);"

/// Converts a mutable reference to 'DragEvent' to a mutable reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_mmouse_event(self: mut DragEvent) -> mut MouseEvent = "return #var(self);"

/// Attempts to convert a reference to 'MouseEvent' to a reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_mouse_event(base: MouseEvent) -> DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'DragEvent'!\");
"

/// Attempts to convert a mutable reference to 'MouseEvent' to a mutable reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_mmouse_event(base: mut MouseEvent) -> mut DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'DragEvent'!\");
"

/// Converts a reference to 'DragEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_ui_event(self: DragEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'DragEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_mui_event(self: mut DragEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_ui_event(base: UIEvent) -> DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'DragEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_mui_event(base: mut UIEvent) -> mut DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'DragEvent'!\");
"

/// Converts a reference to 'DragEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_event(self: DragEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'DragEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::as_mevent(self: mut DragEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_event(base: Event) -> DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'DragEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'DragEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'DragEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DragEvent::from_mevent(base: mut Event) -> mut DragEvent = "
    if(#var(base) instanceof DragEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'DragEvent'!\");
"

pub ext fun DragEvent::from_str_mdrag_event_init(type: String, event_init_dict: mut DragEventInit) -> mut DragEvent
    = "return new DragEvent(#fun(String::as_js)(#var(type)), #fun(DragEventInit::as_js)(#var(event_init_dict)));"

pub ext fun DragEvent::data_transfer(self: DragEvent) -> Option[mut DataTransfer]
    = "return #fun(Option::from_js[mut DataTransfer])(#var(self).dataTransfer);"

pub ext fun DragEvent::screen_x(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun DragEvent::screen_y(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun DragEvent::client_x(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun DragEvent::client_y(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun DragEvent::ctrl_key(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun DragEvent::shift_key(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun DragEvent::alt_key(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun DragEvent::meta_key(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun DragEvent::button(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).button);"

pub ext fun DragEvent::buttons(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).buttons);"

pub ext fun DragEvent::related_target(self: DragEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun DragEvent::page_x(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun DragEvent::page_y(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun DragEvent::x(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun DragEvent::y(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun DragEvent::offset_x(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetX);"

pub ext fun DragEvent::offset_y(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetY);"

pub ext fun DragEvent::movement_x(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementX);"

pub ext fun DragEvent::movement_y(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementY);"

pub ext fun DragEvent::from_element(self: DragEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).fromElement);"

pub ext fun DragEvent::to_element(self: DragEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).toElement);"

pub ext fun DragEvent::layer_x(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerX);"

pub ext fun DragEvent::layer_y(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerY);"

pub ext fun DragEvent::view(self: DragEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun DragEvent::detail(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun DragEvent::source_capabilities(self: DragEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun DragEvent::which(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun DragEvent::type(self: DragEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun DragEvent::target(self: DragEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun DragEvent::current_target(self: DragEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun DragEvent::event_phase(self: DragEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun DragEvent::bubbles(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun DragEvent::cancelable(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun DragEvent::default_prevented(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun DragEvent::composed(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun DragEvent::is_trusted(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun DragEvent::time_stamp(self: DragEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun DragEvent::src_element(self: DragEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun DragEvent::return_value(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun DragEvent::set_return_value(self: mut DragEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun DragEvent::cancel_bubble(self: DragEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun DragEvent::set_cancel_bubble(self: mut DragEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun DragEvent::get_modifier_state(__self: mut DragEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DragEvent::init_mouse_event(__self: mut DragEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int, screen_x: Int, screen_y: Int, client_x: Int, client_y: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool, button: Int, related_target: Option[mut EventTarget]) -> Unit = "
    const r = #var(__self).initMouseEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)), #fun(Int::as_js)(#var(screen_x)), #fun(Int::as_js)(#var(screen_y)), #fun(Int::as_js)(#var(client_x)), #fun(Int::as_js)(#var(client_y)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)), #fun(Int::as_js)(#var(button)), #fun(Option::as_js[mut EventTarget])(#var(related_target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DragEvent::init_ui_event(__self: mut DragEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DragEvent::composed_path(__self: mut DragEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun DragEvent::stop_propagation(__self: mut DragEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun DragEvent::stop_immediate_propagation(__self: mut DragEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun DragEvent::prevent_default(__self: mut DragEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun DragEvent::init_event(__self: mut DragEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun DragEvent::as_js(self: DragEvent) -> JsValue = JsValue::unsafe_from[DragEvent](self)

pub fun DragEvent::from_js(v: JsValue) -> mut DragEvent = JsValue::unsafe_as[mut DragEvent](v)

pub val DragEvent::none: Int = 0
pub val DragEvent::capturing_phase: Int = 1
pub val DragEvent::at_target: Int = 2
pub val DragEvent::bubbling_phase: Int = 3

pub struct DragEventInit(
    data_transfer: Option[mut DataTransfer],
    screen_x: Option[Float],
    screen_y: Option[Float],
    client_x: Option[Float],
    client_y: Option[Float],
    button: Option[Int],
    buttons: Option[Int],
    related_target: Option[mut EventTarget],
    movement_x: Option[Int],
    movement_y: Option[Int],
    region: Option[String],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun DragEventInit::default() -> mut DragEventInit
    = DragEventInit(Option::None, Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::None, Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'DragEventInit' to a reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEventInit::as_mouse_event_init(self: DragEventInit) -> MouseEventInit = "return #var(self);"

/// Converts a mutable reference to 'DragEventInit' to a mutable reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DragEventInit::as_mmouse_event_init(self: mut DragEventInit) -> mut MouseEventInit = "return #var(self);"

/// Attempts to convert a reference to 'MouseEventInit' to a reference to 'DragEventInit'.
/// A 'base' that is not a reference to 'DragEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DragEventInit::from_mouse_event_init_unchecked(base: MouseEventInit) -> DragEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'MouseEventInit' to a mutable reference to 'DragEventInit'.
/// A 'base' that is not a reference to 'DragEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DragEventInit::from_mmouse_event_init_unchecked(base: mut MouseEventInit) -> mut DragEventInit = "return #var(base);"

pub ext fun DragEventInit::from_js(value: JsValue) -> mut DragEventInit = "
    const r = {};
    r.m_data_transfer = #fun(Option::from_js[mut DataTransfer])(#var(value).dataTransfer);
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_button = #fun(Option::from_js[Int])(#var(value).button);
    r.m_buttons = #fun(Option::from_js[Int])(#var(value).buttons);
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_movement_x = #fun(Option::from_js[Int])(#var(value).movementX);
    r.m_movement_y = #fun(Option::from_js[Int])(#var(value).movementY);
    r.m_region = #fun(Option::from_js[String])(#var(value).region);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun DragEventInit::as_js(self: DragEventInit) -> JsValue = "
    const r = {};
    r.dataTransfer = #fun(Option::as_js_undef[mut DataTransfer])(#var(self).m_data_transfer);
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.button = #fun(Option::as_js_undef[Int])(#var(self).m_button);
    r.buttons = #fun(Option::as_js_undef[Int])(#var(self).m_buttons);
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.movementX = #fun(Option::as_js_undef[Int])(#var(self).m_movement_x);
    r.movementY = #fun(Option::as_js_undef[Int])(#var(self).m_movement_y);
    r.region = #fun(Option::as_js_undef[String])(#var(self).m_region);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct ErrorEvent()

/// Converts a reference to 'ErrorEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEvent::as_event(self: ErrorEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ErrorEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEvent::as_mevent(self: mut ErrorEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ErrorEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ErrorEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEvent::from_event(base: Event) -> ErrorEvent = "
    if(#var(base) instanceof ErrorEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ErrorEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ErrorEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ErrorEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEvent::from_mevent(base: mut Event) -> mut ErrorEvent = "
    if(#var(base) instanceof ErrorEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ErrorEvent'!\");
"

pub ext fun ErrorEvent::from_str_merror_event_init(type: String, event_init_dict: mut ErrorEventInit) -> mut ErrorEvent
    = "return new ErrorEvent(#fun(String::as_js)(#var(type)), #fun(ErrorEventInit::as_js)(#var(event_init_dict)));"

pub ext fun ErrorEvent::message(self: ErrorEvent) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub ext fun ErrorEvent::filename(self: ErrorEvent) -> String
    = "return #fun(String::from_js)(#var(self).filename);"

pub ext fun ErrorEvent::lineno(self: ErrorEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).lineno);"

pub ext fun ErrorEvent::colno(self: ErrorEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).colno);"

pub ext fun ErrorEvent::error(self: ErrorEvent) -> JsValue
    = "return #var(self).error;"

pub ext fun ErrorEvent::type(self: ErrorEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ErrorEvent::target(self: ErrorEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ErrorEvent::current_target(self: ErrorEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ErrorEvent::event_phase(self: ErrorEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ErrorEvent::bubbles(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ErrorEvent::cancelable(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ErrorEvent::default_prevented(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ErrorEvent::composed(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ErrorEvent::is_trusted(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ErrorEvent::time_stamp(self: ErrorEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ErrorEvent::src_element(self: ErrorEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ErrorEvent::return_value(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ErrorEvent::set_return_value(self: mut ErrorEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ErrorEvent::cancel_bubble(self: ErrorEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ErrorEvent::set_cancel_bubble(self: mut ErrorEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ErrorEvent::composed_path(__self: mut ErrorEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ErrorEvent::stop_propagation(__self: mut ErrorEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ErrorEvent::stop_immediate_propagation(__self: mut ErrorEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ErrorEvent::prevent_default(__self: mut ErrorEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ErrorEvent::init_event(__self: mut ErrorEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ErrorEvent::as_js(self: ErrorEvent) -> JsValue = JsValue::unsafe_from[ErrorEvent](self)

pub fun ErrorEvent::from_js(v: JsValue) -> mut ErrorEvent = JsValue::unsafe_as[mut ErrorEvent](v)

pub val ErrorEvent::none: Int = 0
pub val ErrorEvent::capturing_phase: Int = 1
pub val ErrorEvent::at_target: Int = 2
pub val ErrorEvent::bubbling_phase: Int = 3

pub struct ErrorEventInit(
    message: Option[String],
    filename: Option[String],
    lineno: Option[Int],
    colno: Option[Int],
    error: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun ErrorEventInit::default() -> mut ErrorEventInit
    = ErrorEventInit(Option::Some(""), Option::Some(""), Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'ErrorEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEventInit::as_event_init(self: ErrorEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'ErrorEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEventInit::as_mevent_init(self: mut ErrorEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'ErrorEventInit'.
/// A 'base' that is not a reference to 'ErrorEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEventInit::from_event_init_unchecked(base: EventInit) -> ErrorEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'ErrorEventInit'.
/// A 'base' that is not a reference to 'ErrorEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ErrorEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut ErrorEventInit = "return #var(base);"

pub ext fun ErrorEventInit::from_js(value: JsValue) -> mut ErrorEventInit = "
    const r = {};
    r.m_message = #fun(Option::from_js[String])(#var(value).message);
    r.m_filename = #fun(Option::from_js[String])(#var(value).filename);
    r.m_lineno = #fun(Option::from_js[Int])(#var(value).lineno);
    r.m_colno = #fun(Option::from_js[Int])(#var(value).colno);
    r.m_error = #fun(Option::from_js[JsValue])(#var(value).error);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun ErrorEventInit::as_js(self: ErrorEventInit) -> JsValue = "
    const r = {};
    r.message = #fun(Option::as_js_undef[String])(#var(self).m_message);
    r.filename = #fun(Option::as_js_undef[String])(#var(self).m_filename);
    r.lineno = #fun(Option::as_js_undef[Int])(#var(self).m_lineno);
    r.colno = #fun(Option::as_js_undef[Int])(#var(self).m_colno);
    r.error = #fun(Option::as_js_undef[JsValue])(#var(self).m_error);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct FocusEvent()

/// Converts a reference to 'FocusEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::as_ui_event(self: FocusEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'FocusEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::as_mui_event(self: mut FocusEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'FocusEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FocusEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::from_ui_event(base: UIEvent) -> FocusEvent = "
    if(#var(base) instanceof FocusEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'FocusEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'FocusEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FocusEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::from_mui_event(base: mut UIEvent) -> mut FocusEvent = "
    if(#var(base) instanceof FocusEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'FocusEvent'!\");
"

/// Converts a reference to 'FocusEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::as_event(self: FocusEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'FocusEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::as_mevent(self: mut FocusEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'FocusEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FocusEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::from_event(base: Event) -> FocusEvent = "
    if(#var(base) instanceof FocusEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FocusEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'FocusEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FocusEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEvent::from_mevent(base: mut Event) -> mut FocusEvent = "
    if(#var(base) instanceof FocusEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FocusEvent'!\");
"

pub ext fun FocusEvent::from_str_mfocus_event_init(type: String, event_init_dict: mut FocusEventInit) -> mut FocusEvent
    = "return new FocusEvent(#fun(String::as_js)(#var(type)), #fun(FocusEventInit::as_js)(#var(event_init_dict)));"

pub ext fun FocusEvent::related_target(self: FocusEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun FocusEvent::view(self: FocusEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun FocusEvent::detail(self: FocusEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun FocusEvent::source_capabilities(self: FocusEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun FocusEvent::which(self: FocusEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun FocusEvent::type(self: FocusEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun FocusEvent::target(self: FocusEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun FocusEvent::current_target(self: FocusEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun FocusEvent::event_phase(self: FocusEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun FocusEvent::bubbles(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun FocusEvent::cancelable(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun FocusEvent::default_prevented(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun FocusEvent::composed(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun FocusEvent::is_trusted(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun FocusEvent::time_stamp(self: FocusEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun FocusEvent::src_element(self: FocusEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun FocusEvent::return_value(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun FocusEvent::set_return_value(self: mut FocusEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun FocusEvent::cancel_bubble(self: FocusEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun FocusEvent::set_cancel_bubble(self: mut FocusEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun FocusEvent::init_ui_event(__self: mut FocusEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FocusEvent::composed_path(__self: mut FocusEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun FocusEvent::stop_propagation(__self: mut FocusEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FocusEvent::stop_immediate_propagation(__self: mut FocusEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FocusEvent::prevent_default(__self: mut FocusEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun FocusEvent::init_event(__self: mut FocusEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun FocusEvent::as_js(self: FocusEvent) -> JsValue = JsValue::unsafe_from[FocusEvent](self)

pub fun FocusEvent::from_js(v: JsValue) -> mut FocusEvent = JsValue::unsafe_as[mut FocusEvent](v)

pub val FocusEvent::none: Int = 0
pub val FocusEvent::capturing_phase: Int = 1
pub val FocusEvent::at_target: Int = 2
pub val FocusEvent::bubbling_phase: Int = 3

pub struct FocusEventInit(
    related_target: Option[mut EventTarget],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun FocusEventInit::default() -> mut FocusEventInit
    = FocusEventInit(Option::None, Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'FocusEventInit' to a reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEventInit::as_ui_event_init(self: FocusEventInit) -> UIEventInit = "return #var(self);"

/// Converts a mutable reference to 'FocusEventInit' to a mutable reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEventInit::as_mui_event_init(self: mut FocusEventInit) -> mut UIEventInit = "return #var(self);"

/// Attempts to convert a reference to 'UIEventInit' to a reference to 'FocusEventInit'.
/// A 'base' that is not a reference to 'FocusEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEventInit::from_ui_event_init_unchecked(base: UIEventInit) -> FocusEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'UIEventInit' to a mutable reference to 'FocusEventInit'.
/// A 'base' that is not a reference to 'FocusEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FocusEventInit::from_mui_event_init_unchecked(base: mut UIEventInit) -> mut FocusEventInit = "return #var(base);"

pub ext fun FocusEventInit::from_js(value: JsValue) -> mut FocusEventInit = "
    const r = {};
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun FocusEventInit::as_js(self: FocusEventInit) -> JsValue = "
    const r = {};
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct HashChangeEvent()

/// Converts a reference to 'HashChangeEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEvent::as_event(self: HashChangeEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'HashChangeEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEvent::as_mevent(self: mut HashChangeEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'HashChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HashChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEvent::from_event(base: Event) -> HashChangeEvent = "
    if(#var(base) instanceof HashChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'HashChangeEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'HashChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HashChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEvent::from_mevent(base: mut Event) -> mut HashChangeEvent = "
    if(#var(base) instanceof HashChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'HashChangeEvent'!\");
"

pub ext fun HashChangeEvent::from_str_mhash_change_event_init(type: String, event_init_dict: mut HashChangeEventInit) -> mut HashChangeEvent
    = "return new HashChangeEvent(#fun(String::as_js)(#var(type)), #fun(HashChangeEventInit::as_js)(#var(event_init_dict)));"

pub ext fun HashChangeEvent::old_url(self: HashChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).oldURL);"

pub ext fun HashChangeEvent::new_url(self: HashChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).newURL);"

pub ext fun HashChangeEvent::type(self: HashChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HashChangeEvent::target(self: HashChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun HashChangeEvent::current_target(self: HashChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun HashChangeEvent::event_phase(self: HashChangeEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun HashChangeEvent::bubbles(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun HashChangeEvent::cancelable(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun HashChangeEvent::default_prevented(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun HashChangeEvent::composed(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun HashChangeEvent::is_trusted(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun HashChangeEvent::time_stamp(self: HashChangeEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun HashChangeEvent::src_element(self: HashChangeEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun HashChangeEvent::return_value(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun HashChangeEvent::set_return_value(self: mut HashChangeEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun HashChangeEvent::cancel_bubble(self: HashChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun HashChangeEvent::set_cancel_bubble(self: mut HashChangeEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun HashChangeEvent::composed_path(__self: mut HashChangeEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun HashChangeEvent::stop_propagation(__self: mut HashChangeEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun HashChangeEvent::stop_immediate_propagation(__self: mut HashChangeEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun HashChangeEvent::prevent_default(__self: mut HashChangeEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun HashChangeEvent::init_event(__self: mut HashChangeEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun HashChangeEvent::as_js(self: HashChangeEvent) -> JsValue = JsValue::unsafe_from[HashChangeEvent](self)

pub fun HashChangeEvent::from_js(v: JsValue) -> mut HashChangeEvent = JsValue::unsafe_as[mut HashChangeEvent](v)

pub val HashChangeEvent::none: Int = 0
pub val HashChangeEvent::capturing_phase: Int = 1
pub val HashChangeEvent::at_target: Int = 2
pub val HashChangeEvent::bubbling_phase: Int = 3

pub struct HashChangeEventInit(
    old_url: Option[String],
    new_url: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun HashChangeEventInit::default() -> mut HashChangeEventInit
    = HashChangeEventInit(Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'HashChangeEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEventInit::as_event_init(self: HashChangeEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'HashChangeEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEventInit::as_mevent_init(self: mut HashChangeEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'HashChangeEventInit'.
/// A 'base' that is not a reference to 'HashChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEventInit::from_event_init_unchecked(base: EventInit) -> HashChangeEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'HashChangeEventInit'.
/// A 'base' that is not a reference to 'HashChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun HashChangeEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut HashChangeEventInit = "return #var(base);"

pub ext fun HashChangeEventInit::from_js(value: JsValue) -> mut HashChangeEventInit = "
    const r = {};
    r.m_old_url = #fun(Option::from_js[String])(#var(value).oldURL);
    r.m_new_url = #fun(Option::from_js[String])(#var(value).newURL);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun HashChangeEventInit::as_js(self: HashChangeEventInit) -> JsValue = "
    const r = {};
    r.oldURL = #fun(Option::as_js_undef[String])(#var(self).m_old_url);
    r.newURL = #fun(Option::as_js_undef[String])(#var(self).m_new_url);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct InputEvent()

/// Converts a reference to 'InputEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::as_ui_event(self: InputEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'InputEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::as_mui_event(self: mut InputEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'InputEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InputEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::from_ui_event(base: UIEvent) -> InputEvent = "
    if(#var(base) instanceof InputEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'InputEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'InputEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InputEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::from_mui_event(base: mut UIEvent) -> mut InputEvent = "
    if(#var(base) instanceof InputEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'InputEvent'!\");
"

/// Converts a reference to 'InputEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::as_event(self: InputEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'InputEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::as_mevent(self: mut InputEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'InputEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InputEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::from_event(base: Event) -> InputEvent = "
    if(#var(base) instanceof InputEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'InputEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'InputEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InputEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InputEvent::from_mevent(base: mut Event) -> mut InputEvent = "
    if(#var(base) instanceof InputEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'InputEvent'!\");
"

pub ext fun InputEvent::from_str_minput_event_init(type: String, event_init_dict: mut InputEventInit) -> mut InputEvent
    = "return new InputEvent(#fun(String::as_js)(#var(type)), #fun(InputEventInit::as_js)(#var(event_init_dict)));"

pub ext fun InputEvent::data(self: InputEvent) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).data);"

pub ext fun InputEvent::is_composing(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isComposing);"

pub ext fun InputEvent::input_type(self: InputEvent) -> String
    = "return #fun(String::from_js)(#var(self).inputType);"

pub ext fun InputEvent::data_transfer(self: InputEvent) -> Option[mut DataTransfer]
    = "return #fun(Option::from_js[mut DataTransfer])(#var(self).dataTransfer);"

pub ext fun InputEvent::view(self: InputEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun InputEvent::detail(self: InputEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun InputEvent::source_capabilities(self: InputEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun InputEvent::which(self: InputEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun InputEvent::type(self: InputEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun InputEvent::target(self: InputEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun InputEvent::current_target(self: InputEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun InputEvent::event_phase(self: InputEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun InputEvent::bubbles(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun InputEvent::cancelable(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun InputEvent::default_prevented(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun InputEvent::composed(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun InputEvent::is_trusted(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun InputEvent::time_stamp(self: InputEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun InputEvent::src_element(self: InputEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun InputEvent::return_value(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun InputEvent::set_return_value(self: mut InputEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun InputEvent::cancel_bubble(self: InputEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun InputEvent::set_cancel_bubble(self: mut InputEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun InputEvent::get_target_ranges(__self: mut InputEvent) -> List[mut StaticRange] = "
    const r = #var(__self).getTargetRanges();
    return #fun(List::from_js[mut StaticRange])(r);
"

pub ext fun InputEvent::init_ui_event(__self: mut InputEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InputEvent::composed_path(__self: mut InputEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun InputEvent::stop_propagation(__self: mut InputEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun InputEvent::stop_immediate_propagation(__self: mut InputEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun InputEvent::prevent_default(__self: mut InputEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun InputEvent::init_event(__self: mut InputEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun InputEvent::as_js(self: InputEvent) -> JsValue = JsValue::unsafe_from[InputEvent](self)

pub fun InputEvent::from_js(v: JsValue) -> mut InputEvent = JsValue::unsafe_as[mut InputEvent](v)

pub val InputEvent::none: Int = 0
pub val InputEvent::capturing_phase: Int = 1
pub val InputEvent::at_target: Int = 2
pub val InputEvent::bubbling_phase: Int = 3

pub struct InputEventInit(
    data: Option[String],
    is_composing: Option[Bool],
    input_type: Option[String],
    data_transfer: Option[mut DataTransfer],
    target_ranges: Option[List[mut StaticRange]],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun InputEventInit::default() -> mut InputEventInit
    = InputEventInit(Option::None, Option::Some(false), Option::Some(""), Option::None, Option::Some(List::empty()), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'InputEventInit' to a reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEventInit::as_ui_event_init(self: InputEventInit) -> UIEventInit = "return #var(self);"

/// Converts a mutable reference to 'InputEventInit' to a mutable reference to 'UIEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun InputEventInit::as_mui_event_init(self: mut InputEventInit) -> mut UIEventInit = "return #var(self);"

/// Attempts to convert a reference to 'UIEventInit' to a reference to 'InputEventInit'.
/// A 'base' that is not a reference to 'InputEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InputEventInit::from_ui_event_init_unchecked(base: UIEventInit) -> InputEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'UIEventInit' to a mutable reference to 'InputEventInit'.
/// A 'base' that is not a reference to 'InputEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InputEventInit::from_mui_event_init_unchecked(base: mut UIEventInit) -> mut InputEventInit = "return #var(base);"

pub ext fun InputEventInit::from_js(value: JsValue) -> mut InputEventInit = "
    const r = {};
    r.m_data = #fun(Option::from_js[String])(#var(value).data);
    r.m_is_composing = #fun(Option::from_js[Bool])(#var(value).isComposing);
    r.m_input_type = #fun(Option::from_js[String])(#var(value).inputType);
    r.m_data_transfer = #fun(Option::from_js[mut DataTransfer])(#var(value).dataTransfer);
    r.m_target_ranges = #fun(Option::from_js[List[mut StaticRange]])(#var(value).targetRanges);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun InputEventInit::as_js(self: InputEventInit) -> JsValue = "
    const r = {};
    r.data = #fun(Option::as_js_undef[String])(#var(self).m_data);
    r.isComposing = #fun(Option::as_js_undef[Bool])(#var(self).m_is_composing);
    r.inputType = #fun(Option::as_js_undef[String])(#var(self).m_input_type);
    r.dataTransfer = #fun(Option::as_js_undef[mut DataTransfer])(#var(self).m_data_transfer);
    r.targetRanges = #fun(Option::as_js_undef[List[mut StaticRange]])(#var(self).m_target_ranges);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct InterestEvent()

/// Converts a reference to 'InterestEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEvent::as_event(self: InterestEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'InterestEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEvent::as_mevent(self: mut InterestEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'InterestEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InterestEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEvent::from_event(base: Event) -> InterestEvent = "
    if(#var(base) instanceof InterestEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'InterestEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'InterestEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'InterestEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEvent::from_mevent(base: mut Event) -> mut InterestEvent = "
    if(#var(base) instanceof InterestEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'InterestEvent'!\");
"

pub ext fun InterestEvent::from_str_minterest_event_init(type: String, event_init_dict: mut InterestEventInit) -> mut InterestEvent
    = "return new InterestEvent(#fun(String::as_js)(#var(type)), #fun(InterestEventInit::as_js)(#var(event_init_dict)));"

pub ext fun InterestEvent::source(self: InterestEvent) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).source);"

pub ext fun InterestEvent::type(self: InterestEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun InterestEvent::target(self: InterestEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun InterestEvent::current_target(self: InterestEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun InterestEvent::event_phase(self: InterestEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun InterestEvent::bubbles(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun InterestEvent::cancelable(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun InterestEvent::default_prevented(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun InterestEvent::composed(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun InterestEvent::is_trusted(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun InterestEvent::time_stamp(self: InterestEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun InterestEvent::src_element(self: InterestEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun InterestEvent::return_value(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun InterestEvent::set_return_value(self: mut InterestEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun InterestEvent::cancel_bubble(self: InterestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun InterestEvent::set_cancel_bubble(self: mut InterestEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun InterestEvent::composed_path(__self: mut InterestEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun InterestEvent::stop_propagation(__self: mut InterestEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun InterestEvent::stop_immediate_propagation(__self: mut InterestEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun InterestEvent::prevent_default(__self: mut InterestEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun InterestEvent::init_event(__self: mut InterestEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun InterestEvent::as_js(self: InterestEvent) -> JsValue = JsValue::unsafe_from[InterestEvent](self)

pub fun InterestEvent::from_js(v: JsValue) -> mut InterestEvent = JsValue::unsafe_as[mut InterestEvent](v)

pub val InterestEvent::none: Int = 0
pub val InterestEvent::capturing_phase: Int = 1
pub val InterestEvent::at_target: Int = 2
pub val InterestEvent::bubbling_phase: Int = 3

pub struct InterestEventInit(
    source: Option[mut Element],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun InterestEventInit::default() -> mut InterestEventInit
    = InterestEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'InterestEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEventInit::as_event_init(self: InterestEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'InterestEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEventInit::as_mevent_init(self: mut InterestEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'InterestEventInit'.
/// A 'base' that is not a reference to 'InterestEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEventInit::from_event_init_unchecked(base: EventInit) -> InterestEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'InterestEventInit'.
/// A 'base' that is not a reference to 'InterestEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InterestEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut InterestEventInit = "return #var(base);"

pub ext fun InterestEventInit::from_js(value: JsValue) -> mut InterestEventInit = "
    const r = {};
    r.m_source = #fun(Option::from_js[mut Element])(#var(value).source);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun InterestEventInit::as_js(self: InterestEventInit) -> JsValue = "
    const r = {};
    r.source = #fun(Option::as_js_undef[mut Element])(#var(self).m_source);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct KeyboardEvent()

/// Converts a reference to 'KeyboardEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::as_ui_event(self: KeyboardEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'KeyboardEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::as_mui_event(self: mut KeyboardEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'KeyboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::from_ui_event(base: UIEvent) -> KeyboardEvent = "
    if(#var(base) instanceof KeyboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'KeyboardEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'KeyboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::from_mui_event(base: mut UIEvent) -> mut KeyboardEvent = "
    if(#var(base) instanceof KeyboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'KeyboardEvent'!\");
"

/// Converts a reference to 'KeyboardEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::as_event(self: KeyboardEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'KeyboardEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::as_mevent(self: mut KeyboardEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'KeyboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::from_event(base: Event) -> KeyboardEvent = "
    if(#var(base) instanceof KeyboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'KeyboardEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'KeyboardEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'KeyboardEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEvent::from_mevent(base: mut Event) -> mut KeyboardEvent = "
    if(#var(base) instanceof KeyboardEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'KeyboardEvent'!\");
"

pub ext fun KeyboardEvent::from_str_mkeyboard_event_init(type: String, event_init_dict: mut KeyboardEventInit) -> mut KeyboardEvent
    = "return new KeyboardEvent(#fun(String::as_js)(#var(type)), #fun(KeyboardEventInit::as_js)(#var(event_init_dict)));"

pub ext fun KeyboardEvent::key(self: KeyboardEvent) -> String
    = "return #fun(String::from_js)(#var(self).key);"

pub ext fun KeyboardEvent::code(self: KeyboardEvent) -> String
    = "return #fun(String::from_js)(#var(self).code);"

pub ext fun KeyboardEvent::location(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).location);"

pub ext fun KeyboardEvent::ctrl_key(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun KeyboardEvent::shift_key(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun KeyboardEvent::alt_key(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun KeyboardEvent::meta_key(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun KeyboardEvent::repeat(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).repeat);"

pub ext fun KeyboardEvent::is_composing(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isComposing);"

pub ext fun KeyboardEvent::char_code(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).charCode);"

pub ext fun KeyboardEvent::key_code(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).keyCode);"

pub ext fun KeyboardEvent::view(self: KeyboardEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun KeyboardEvent::detail(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun KeyboardEvent::source_capabilities(self: KeyboardEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun KeyboardEvent::which(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun KeyboardEvent::type(self: KeyboardEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun KeyboardEvent::target(self: KeyboardEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun KeyboardEvent::current_target(self: KeyboardEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun KeyboardEvent::event_phase(self: KeyboardEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun KeyboardEvent::bubbles(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun KeyboardEvent::cancelable(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun KeyboardEvent::default_prevented(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun KeyboardEvent::composed(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun KeyboardEvent::is_trusted(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun KeyboardEvent::time_stamp(self: KeyboardEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun KeyboardEvent::src_element(self: KeyboardEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun KeyboardEvent::return_value(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun KeyboardEvent::set_return_value(self: mut KeyboardEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun KeyboardEvent::cancel_bubble(self: KeyboardEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun KeyboardEvent::set_cancel_bubble(self: mut KeyboardEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun KeyboardEvent::get_modifier_state(__self: mut KeyboardEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun KeyboardEvent::init_keyboard_event(__self: mut KeyboardEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], key_identifier: String, location: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool) -> Unit = "
    const r = #var(__self).initKeyboardEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(String::as_js)(#var(key_identifier)), #fun(Int::as_js)(#var(location)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)));
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyboardEvent::init_ui_event(__self: mut KeyboardEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyboardEvent::composed_path(__self: mut KeyboardEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun KeyboardEvent::stop_propagation(__self: mut KeyboardEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyboardEvent::stop_immediate_propagation(__self: mut KeyboardEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyboardEvent::prevent_default(__self: mut KeyboardEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun KeyboardEvent::init_event(__self: mut KeyboardEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun KeyboardEvent::as_js(self: KeyboardEvent) -> JsValue = JsValue::unsafe_from[KeyboardEvent](self)

pub fun KeyboardEvent::from_js(v: JsValue) -> mut KeyboardEvent = JsValue::unsafe_as[mut KeyboardEvent](v)

pub val KeyboardEvent::dom_key_location_standard: Int = 0
pub val KeyboardEvent::dom_key_location_left: Int = 1
pub val KeyboardEvent::dom_key_location_right: Int = 2
pub val KeyboardEvent::dom_key_location_numpad: Int = 3
pub val KeyboardEvent::none: Int = 0
pub val KeyboardEvent::capturing_phase: Int = 1
pub val KeyboardEvent::at_target: Int = 2
pub val KeyboardEvent::bubbling_phase: Int = 3

pub struct KeyboardEventInit(
    key: Option[String],
    code: Option[String],
    location: Option[Int],
    repeat: Option[Bool],
    is_composing: Option[Bool],
    char_code: Option[Int],
    key_code: Option[Int],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun KeyboardEventInit::default() -> mut KeyboardEventInit
    = KeyboardEventInit(Option::Some(""), Option::Some(""), Option::Some(0), Option::Some(false), Option::Some(false), Option::Some(0), Option::Some(0), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'KeyboardEventInit' to a reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEventInit::as_event_modifier_init(self: KeyboardEventInit) -> EventModifierInit = "return #var(self);"

/// Converts a mutable reference to 'KeyboardEventInit' to a mutable reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEventInit::as_mevent_modifier_init(self: mut KeyboardEventInit) -> mut EventModifierInit = "return #var(self);"

/// Attempts to convert a reference to 'EventModifierInit' to a reference to 'KeyboardEventInit'.
/// A 'base' that is not a reference to 'KeyboardEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEventInit::from_event_modifier_init_unchecked(base: EventModifierInit) -> KeyboardEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventModifierInit' to a mutable reference to 'KeyboardEventInit'.
/// A 'base' that is not a reference to 'KeyboardEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun KeyboardEventInit::from_mevent_modifier_init_unchecked(base: mut EventModifierInit) -> mut KeyboardEventInit = "return #var(base);"

pub ext fun KeyboardEventInit::from_js(value: JsValue) -> mut KeyboardEventInit = "
    const r = {};
    r.m_key = #fun(Option::from_js[String])(#var(value).key);
    r.m_code = #fun(Option::from_js[String])(#var(value).code);
    r.m_location = #fun(Option::from_js[Int])(#var(value).location);
    r.m_repeat = #fun(Option::from_js[Bool])(#var(value).repeat);
    r.m_is_composing = #fun(Option::from_js[Bool])(#var(value).isComposing);
    r.m_char_code = #fun(Option::from_js[Int])(#var(value).charCode);
    r.m_key_code = #fun(Option::from_js[Int])(#var(value).keyCode);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun KeyboardEventInit::as_js(self: KeyboardEventInit) -> JsValue = "
    const r = {};
    r.key = #fun(Option::as_js_undef[String])(#var(self).m_key);
    r.code = #fun(Option::as_js_undef[String])(#var(self).m_code);
    r.location = #fun(Option::as_js_undef[Int])(#var(self).m_location);
    r.repeat = #fun(Option::as_js_undef[Bool])(#var(self).m_repeat);
    r.isComposing = #fun(Option::as_js_undef[Bool])(#var(self).m_is_composing);
    r.charCode = #fun(Option::as_js_undef[Int])(#var(self).m_char_code);
    r.keyCode = #fun(Option::as_js_undef[Int])(#var(self).m_key_code);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct MessageEvent()

/// Converts a reference to 'MessageEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEvent::as_event(self: MessageEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'MessageEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEvent::as_mevent(self: mut MessageEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'MessageEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MessageEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEvent::from_event(base: Event) -> MessageEvent = "
    if(#var(base) instanceof MessageEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MessageEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'MessageEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MessageEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEvent::from_mevent(base: mut Event) -> mut MessageEvent = "
    if(#var(base) instanceof MessageEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MessageEvent'!\");
"

pub ext fun MessageEvent::from_str_mmessage_event_init(type: String, event_init_dict: mut MessageEventInit) -> mut MessageEvent
    = "return new MessageEvent(#fun(String::as_js)(#var(type)), #fun(MessageEventInit::as_js)(#var(event_init_dict)));"

pub ext fun MessageEvent::data(self: MessageEvent) -> JsValue
    = "return #var(self).data;"

pub ext fun MessageEvent::origin(self: MessageEvent) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun MessageEvent::last_event_id(self: MessageEvent) -> String
    = "return #fun(String::from_js)(#var(self).lastEventId);"

pub ext fun MessageEvent::source(self: MessageEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).source);"

pub ext fun MessageEvent::ports(self: MessageEvent) -> JsValue
    = "return #var(self).ports;"

pub ext fun MessageEvent::user_activation(self: MessageEvent) -> Option[mut UserActivation]
    = "return #fun(Option::from_js[mut UserActivation])(#var(self).userActivation);"

pub ext fun MessageEvent::type(self: MessageEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MessageEvent::target(self: MessageEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun MessageEvent::current_target(self: MessageEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun MessageEvent::event_phase(self: MessageEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun MessageEvent::bubbles(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun MessageEvent::cancelable(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun MessageEvent::default_prevented(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun MessageEvent::composed(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun MessageEvent::is_trusted(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun MessageEvent::time_stamp(self: MessageEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun MessageEvent::src_element(self: MessageEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun MessageEvent::return_value(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun MessageEvent::set_return_value(self: mut MessageEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun MessageEvent::cancel_bubble(self: MessageEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun MessageEvent::set_cancel_bubble(self: mut MessageEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun MessageEvent::init_message_event(__self: mut MessageEvent, type: String, bubbles: Bool, cancelable: Bool, data: JsValue, origin: String, last_event_id: String, source: Option[mut EventTarget], ports: List[mut MessagePort]) -> Unit = "
    const r = #var(__self).initMessageEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #var(data), #fun(String::as_js)(#var(origin)), #fun(String::as_js)(#var(last_event_id)), #fun(Option::as_js[mut EventTarget])(#var(source)), #fun(List::as_js[mut MessagePort])(#var(ports)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MessageEvent::composed_path(__self: mut MessageEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun MessageEvent::stop_propagation(__self: mut MessageEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MessageEvent::stop_immediate_propagation(__self: mut MessageEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MessageEvent::prevent_default(__self: mut MessageEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun MessageEvent::init_event(__self: mut MessageEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun MessageEvent::as_js(self: MessageEvent) -> JsValue = JsValue::unsafe_from[MessageEvent](self)

pub fun MessageEvent::from_js(v: JsValue) -> mut MessageEvent = JsValue::unsafe_as[mut MessageEvent](v)

pub val MessageEvent::none: Int = 0
pub val MessageEvent::capturing_phase: Int = 1
pub val MessageEvent::at_target: Int = 2
pub val MessageEvent::bubbling_phase: Int = 3

pub struct MessageEventInit(
    data: Option[JsValue],
    origin: Option[String],
    last_event_id: Option[String],
    source: Option[mut EventTarget],
    ports: Option[List[mut MessagePort]],
    user_activation: Option[mut UserActivation],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun MessageEventInit::default() -> mut MessageEventInit
    = MessageEventInit(Option::None, Option::Some(""), Option::Some(""), Option::None, Option::Some(List::empty()), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'MessageEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEventInit::as_event_init(self: MessageEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'MessageEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEventInit::as_mevent_init(self: mut MessageEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'MessageEventInit'.
/// A 'base' that is not a reference to 'MessageEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEventInit::from_event_init_unchecked(base: EventInit) -> MessageEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'MessageEventInit'.
/// A 'base' that is not a reference to 'MessageEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MessageEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut MessageEventInit = "return #var(base);"

pub ext fun MessageEventInit::from_js(value: JsValue) -> mut MessageEventInit = "
    const r = {};
    r.m_data = #fun(Option::from_js[JsValue])(#var(value).data);
    r.m_origin = #fun(Option::from_js[String])(#var(value).origin);
    r.m_last_event_id = #fun(Option::from_js[String])(#var(value).lastEventId);
    r.m_source = #fun(Option::from_js[mut EventTarget])(#var(value).source);
    r.m_ports = #fun(Option::from_js[List[mut MessagePort]])(#var(value).ports);
    r.m_user_activation = #fun(Option::from_js[mut UserActivation])(#var(value).userActivation);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun MessageEventInit::as_js(self: MessageEventInit) -> JsValue = "
    const r = {};
    r.data = #fun(Option::as_js_undef[JsValue])(#var(self).m_data);
    r.origin = #fun(Option::as_js_undef[String])(#var(self).m_origin);
    r.lastEventId = #fun(Option::as_js_undef[String])(#var(self).m_last_event_id);
    r.source = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_source);
    r.ports = #fun(Option::as_js_undef[List[mut MessagePort]])(#var(self).m_ports);
    r.userActivation = #fun(Option::as_js_undef[mut UserActivation])(#var(self).m_user_activation);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct MouseEvent()

/// Converts a reference to 'MouseEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::as_ui_event(self: MouseEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'MouseEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::as_mui_event(self: mut MouseEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'MouseEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MouseEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::from_ui_event(base: UIEvent) -> MouseEvent = "
    if(#var(base) instanceof MouseEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'MouseEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'MouseEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MouseEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::from_mui_event(base: mut UIEvent) -> mut MouseEvent = "
    if(#var(base) instanceof MouseEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'MouseEvent'!\");
"

/// Converts a reference to 'MouseEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::as_event(self: MouseEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'MouseEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::as_mevent(self: mut MouseEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'MouseEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MouseEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::from_event(base: Event) -> MouseEvent = "
    if(#var(base) instanceof MouseEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MouseEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'MouseEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MouseEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEvent::from_mevent(base: mut Event) -> mut MouseEvent = "
    if(#var(base) instanceof MouseEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MouseEvent'!\");
"

pub ext fun MouseEvent::from_str_mmouse_event_init(type: String, event_init_dict: mut MouseEventInit) -> mut MouseEvent
    = "return new MouseEvent(#fun(String::as_js)(#var(type)), #fun(MouseEventInit::as_js)(#var(event_init_dict)));"

pub ext fun MouseEvent::screen_x(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun MouseEvent::screen_y(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun MouseEvent::client_x(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun MouseEvent::client_y(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun MouseEvent::ctrl_key(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun MouseEvent::shift_key(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun MouseEvent::alt_key(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun MouseEvent::meta_key(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun MouseEvent::button(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).button);"

pub ext fun MouseEvent::buttons(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).buttons);"

pub ext fun MouseEvent::related_target(self: MouseEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun MouseEvent::page_x(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun MouseEvent::page_y(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun MouseEvent::x(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun MouseEvent::y(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun MouseEvent::offset_x(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetX);"

pub ext fun MouseEvent::offset_y(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetY);"

pub ext fun MouseEvent::movement_x(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementX);"

pub ext fun MouseEvent::movement_y(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementY);"

pub ext fun MouseEvent::from_element(self: MouseEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).fromElement);"

pub ext fun MouseEvent::to_element(self: MouseEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).toElement);"

pub ext fun MouseEvent::layer_x(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerX);"

pub ext fun MouseEvent::layer_y(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerY);"

pub ext fun MouseEvent::view(self: MouseEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun MouseEvent::detail(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun MouseEvent::source_capabilities(self: MouseEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun MouseEvent::which(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun MouseEvent::type(self: MouseEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MouseEvent::target(self: MouseEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun MouseEvent::current_target(self: MouseEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun MouseEvent::event_phase(self: MouseEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun MouseEvent::bubbles(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun MouseEvent::cancelable(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun MouseEvent::default_prevented(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun MouseEvent::composed(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun MouseEvent::is_trusted(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun MouseEvent::time_stamp(self: MouseEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun MouseEvent::src_element(self: MouseEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun MouseEvent::return_value(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun MouseEvent::set_return_value(self: mut MouseEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun MouseEvent::cancel_bubble(self: MouseEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun MouseEvent::set_cancel_bubble(self: mut MouseEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun MouseEvent::get_modifier_state(__self: mut MouseEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun MouseEvent::init_mouse_event(__self: mut MouseEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int, screen_x: Int, screen_y: Int, client_x: Int, client_y: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool, button: Int, related_target: Option[mut EventTarget]) -> Unit = "
    const r = #var(__self).initMouseEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)), #fun(Int::as_js)(#var(screen_x)), #fun(Int::as_js)(#var(screen_y)), #fun(Int::as_js)(#var(client_x)), #fun(Int::as_js)(#var(client_y)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)), #fun(Int::as_js)(#var(button)), #fun(Option::as_js[mut EventTarget])(#var(related_target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MouseEvent::init_ui_event(__self: mut MouseEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MouseEvent::composed_path(__self: mut MouseEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun MouseEvent::stop_propagation(__self: mut MouseEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MouseEvent::stop_immediate_propagation(__self: mut MouseEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MouseEvent::prevent_default(__self: mut MouseEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun MouseEvent::init_event(__self: mut MouseEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun MouseEvent::as_js(self: MouseEvent) -> JsValue = JsValue::unsafe_from[MouseEvent](self)

pub fun MouseEvent::from_js(v: JsValue) -> mut MouseEvent = JsValue::unsafe_as[mut MouseEvent](v)

pub val MouseEvent::none: Int = 0
pub val MouseEvent::capturing_phase: Int = 1
pub val MouseEvent::at_target: Int = 2
pub val MouseEvent::bubbling_phase: Int = 3

pub struct MouseEventInit(
    screen_x: Option[Float],
    screen_y: Option[Float],
    client_x: Option[Float],
    client_y: Option[Float],
    button: Option[Int],
    buttons: Option[Int],
    related_target: Option[mut EventTarget],
    movement_x: Option[Int],
    movement_y: Option[Int],
    region: Option[String],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun MouseEventInit::default() -> mut MouseEventInit
    = MouseEventInit(Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::None, Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'MouseEventInit' to a reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEventInit::as_event_modifier_init(self: MouseEventInit) -> EventModifierInit = "return #var(self);"

/// Converts a mutable reference to 'MouseEventInit' to a mutable reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEventInit::as_mevent_modifier_init(self: mut MouseEventInit) -> mut EventModifierInit = "return #var(self);"

/// Attempts to convert a reference to 'EventModifierInit' to a reference to 'MouseEventInit'.
/// A 'base' that is not a reference to 'MouseEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEventInit::from_event_modifier_init_unchecked(base: EventModifierInit) -> MouseEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventModifierInit' to a mutable reference to 'MouseEventInit'.
/// A 'base' that is not a reference to 'MouseEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MouseEventInit::from_mevent_modifier_init_unchecked(base: mut EventModifierInit) -> mut MouseEventInit = "return #var(base);"

pub ext fun MouseEventInit::from_js(value: JsValue) -> mut MouseEventInit = "
    const r = {};
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_button = #fun(Option::from_js[Int])(#var(value).button);
    r.m_buttons = #fun(Option::from_js[Int])(#var(value).buttons);
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_movement_x = #fun(Option::from_js[Int])(#var(value).movementX);
    r.m_movement_y = #fun(Option::from_js[Int])(#var(value).movementY);
    r.m_region = #fun(Option::from_js[String])(#var(value).region);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun MouseEventInit::as_js(self: MouseEventInit) -> JsValue = "
    const r = {};
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.button = #fun(Option::as_js_undef[Int])(#var(self).m_button);
    r.buttons = #fun(Option::as_js_undef[Int])(#var(self).m_buttons);
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.movementX = #fun(Option::as_js_undef[Int])(#var(self).m_movement_x);
    r.movementY = #fun(Option::as_js_undef[Int])(#var(self).m_movement_y);
    r.region = #fun(Option::as_js_undef[String])(#var(self).m_region);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct Navigator()

pub ext fun Navigator::max_touch_points(self: Navigator) -> Int
    = "return #fun(Int::from_js)(#var(self).maxTouchPoints);"

pub ext fun Navigator::hardware_concurrency(self: Navigator) -> Int
    = "return #fun(Int::from_js)(#var(self).hardwareConcurrency);"

pub ext fun Navigator::cookie_enabled(self: Navigator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cookieEnabled);"

pub ext fun Navigator::device_memory(self: Navigator) -> Float
    = "return #fun(Float::from_js)(#var(self).deviceMemory);"

pub ext fun Navigator::app_code_name(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).appCodeName);"

pub ext fun Navigator::app_name(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).appName);"

pub ext fun Navigator::app_version(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).appVersion);"

pub ext fun Navigator::platform(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).platform);"

pub ext fun Navigator::product(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).product);"

pub ext fun Navigator::user_agent(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).userAgent);"

pub ext fun Navigator::language(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).language);"

pub ext fun Navigator::languages(self: Navigator) -> JsValue
    = "return #var(self).languages;"

pub ext fun Navigator::on_line(self: Navigator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).onLine);"

pub ext fun Navigator::webdriver(self: Navigator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).webdriver);"

pub ext fun Navigator::user_agent_data(self: Navigator) -> mut NavigatorUAData
    = "return #fun(NavigatorUAData::from_js)(#var(self).userAgentData);"

pub fun Navigator::as_js(self: Navigator) -> JsValue = JsValue::unsafe_from[Navigator](self)

pub fun Navigator::from_js(v: JsValue) -> mut Navigator = JsValue::unsafe_as[mut Navigator](v)

struct OverscrollEvent()

/// Converts a reference to 'OverscrollEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEvent::as_event(self: OverscrollEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'OverscrollEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEvent::as_mevent(self: mut OverscrollEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'OverscrollEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'OverscrollEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEvent::from_event(base: Event) -> OverscrollEvent = "
    if(#var(base) instanceof OverscrollEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'OverscrollEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'OverscrollEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'OverscrollEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEvent::from_mevent(base: mut Event) -> mut OverscrollEvent = "
    if(#var(base) instanceof OverscrollEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'OverscrollEvent'!\");
"

pub ext fun OverscrollEvent::from_str_bool_moverscroll_event_init(type: String, bubbles: Bool, event_init_dict: mut OverscrollEventInit) -> mut OverscrollEvent
    = "return new OverscrollEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(OverscrollEventInit::as_js)(#var(event_init_dict)));"

pub ext fun OverscrollEvent::delta_x(self: OverscrollEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).deltaX);"

pub ext fun OverscrollEvent::delta_y(self: OverscrollEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).deltaY);"

pub ext fun OverscrollEvent::type(self: OverscrollEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun OverscrollEvent::target(self: OverscrollEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun OverscrollEvent::current_target(self: OverscrollEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun OverscrollEvent::event_phase(self: OverscrollEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun OverscrollEvent::bubbles(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun OverscrollEvent::cancelable(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun OverscrollEvent::default_prevented(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun OverscrollEvent::composed(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun OverscrollEvent::is_trusted(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun OverscrollEvent::time_stamp(self: OverscrollEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun OverscrollEvent::src_element(self: OverscrollEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun OverscrollEvent::return_value(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun OverscrollEvent::set_return_value(self: mut OverscrollEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun OverscrollEvent::cancel_bubble(self: OverscrollEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun OverscrollEvent::set_cancel_bubble(self: mut OverscrollEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun OverscrollEvent::composed_path(__self: mut OverscrollEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun OverscrollEvent::stop_propagation(__self: mut OverscrollEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun OverscrollEvent::stop_immediate_propagation(__self: mut OverscrollEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun OverscrollEvent::prevent_default(__self: mut OverscrollEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun OverscrollEvent::init_event(__self: mut OverscrollEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun OverscrollEvent::as_js(self: OverscrollEvent) -> JsValue = JsValue::unsafe_from[OverscrollEvent](self)

pub fun OverscrollEvent::from_js(v: JsValue) -> mut OverscrollEvent = JsValue::unsafe_as[mut OverscrollEvent](v)

pub val OverscrollEvent::none: Int = 0
pub val OverscrollEvent::capturing_phase: Int = 1
pub val OverscrollEvent::at_target: Int = 2
pub val OverscrollEvent::bubbling_phase: Int = 3

pub struct OverscrollEventInit(
    delta_x: Option[Float],
    delta_y: Option[Float],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun OverscrollEventInit::default() -> mut OverscrollEventInit
    = OverscrollEventInit(Option::Some(0.0), Option::Some(0.0), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'OverscrollEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEventInit::as_event_init(self: OverscrollEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'OverscrollEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEventInit::as_mevent_init(self: mut OverscrollEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'OverscrollEventInit'.
/// A 'base' that is not a reference to 'OverscrollEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEventInit::from_event_init_unchecked(base: EventInit) -> OverscrollEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'OverscrollEventInit'.
/// A 'base' that is not a reference to 'OverscrollEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun OverscrollEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut OverscrollEventInit = "return #var(base);"

pub ext fun OverscrollEventInit::from_js(value: JsValue) -> mut OverscrollEventInit = "
    const r = {};
    r.m_delta_x = #fun(Option::from_js[Float])(#var(value).deltaX);
    r.m_delta_y = #fun(Option::from_js[Float])(#var(value).deltaY);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun OverscrollEventInit::as_js(self: OverscrollEventInit) -> JsValue = "
    const r = {};
    r.deltaX = #fun(Option::as_js_undef[Float])(#var(self).m_delta_x);
    r.deltaY = #fun(Option::as_js_undef[Float])(#var(self).m_delta_y);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct PageTransitionEvent()

/// Converts a reference to 'PageTransitionEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEvent::as_event(self: PageTransitionEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PageTransitionEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEvent::as_mevent(self: mut PageTransitionEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PageTransitionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageTransitionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEvent::from_event(base: Event) -> PageTransitionEvent = "
    if(#var(base) instanceof PageTransitionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageTransitionEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PageTransitionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageTransitionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEvent::from_mevent(base: mut Event) -> mut PageTransitionEvent = "
    if(#var(base) instanceof PageTransitionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageTransitionEvent'!\");
"

pub ext fun PageTransitionEvent::from_str_mpage_transition_event_init(type: String, event_init_dict: mut PageTransitionEventInit) -> mut PageTransitionEvent
    = "return new PageTransitionEvent(#fun(String::as_js)(#var(type)), #fun(PageTransitionEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PageTransitionEvent::persisted(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).persisted);"

pub ext fun PageTransitionEvent::type(self: PageTransitionEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PageTransitionEvent::target(self: PageTransitionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PageTransitionEvent::current_target(self: PageTransitionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PageTransitionEvent::event_phase(self: PageTransitionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PageTransitionEvent::bubbles(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PageTransitionEvent::cancelable(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PageTransitionEvent::default_prevented(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PageTransitionEvent::composed(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PageTransitionEvent::is_trusted(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PageTransitionEvent::time_stamp(self: PageTransitionEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PageTransitionEvent::src_element(self: PageTransitionEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PageTransitionEvent::return_value(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PageTransitionEvent::set_return_value(self: mut PageTransitionEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PageTransitionEvent::cancel_bubble(self: PageTransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PageTransitionEvent::set_cancel_bubble(self: mut PageTransitionEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PageTransitionEvent::composed_path(__self: mut PageTransitionEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PageTransitionEvent::stop_propagation(__self: mut PageTransitionEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageTransitionEvent::stop_immediate_propagation(__self: mut PageTransitionEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageTransitionEvent::prevent_default(__self: mut PageTransitionEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageTransitionEvent::init_event(__self: mut PageTransitionEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PageTransitionEvent::as_js(self: PageTransitionEvent) -> JsValue = JsValue::unsafe_from[PageTransitionEvent](self)

pub fun PageTransitionEvent::from_js(v: JsValue) -> mut PageTransitionEvent = JsValue::unsafe_as[mut PageTransitionEvent](v)

pub val PageTransitionEvent::none: Int = 0
pub val PageTransitionEvent::capturing_phase: Int = 1
pub val PageTransitionEvent::at_target: Int = 2
pub val PageTransitionEvent::bubbling_phase: Int = 3

pub struct PageTransitionEventInit(
    persisted: Option[Bool],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PageTransitionEventInit::default() -> mut PageTransitionEventInit
    = PageTransitionEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PageTransitionEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEventInit::as_event_init(self: PageTransitionEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'PageTransitionEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEventInit::as_mevent_init(self: mut PageTransitionEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'PageTransitionEventInit'.
/// A 'base' that is not a reference to 'PageTransitionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEventInit::from_event_init_unchecked(base: EventInit) -> PageTransitionEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'PageTransitionEventInit'.
/// A 'base' that is not a reference to 'PageTransitionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageTransitionEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut PageTransitionEventInit = "return #var(base);"

pub ext fun PageTransitionEventInit::from_js(value: JsValue) -> mut PageTransitionEventInit = "
    const r = {};
    r.m_persisted = #fun(Option::from_js[Bool])(#var(value).persisted);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PageTransitionEventInit::as_js(self: PageTransitionEventInit) -> JsValue = "
    const r = {};
    r.persisted = #fun(Option::as_js_undef[Bool])(#var(self).m_persisted);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct PointerEvent()

/// Converts a reference to 'PointerEvent' to a reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_mouse_event(self: PointerEvent) -> MouseEvent = "return #var(self);"

/// Converts a mutable reference to 'PointerEvent' to a mutable reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_mmouse_event(self: mut PointerEvent) -> mut MouseEvent = "return #var(self);"

/// Attempts to convert a reference to 'MouseEvent' to a reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_mouse_event(base: MouseEvent) -> PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'PointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'MouseEvent' to a mutable reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_mmouse_event(base: mut MouseEvent) -> mut PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'PointerEvent'!\");
"

/// Converts a reference to 'PointerEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_ui_event(self: PointerEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'PointerEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_mui_event(self: mut PointerEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_ui_event(base: UIEvent) -> PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'PointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_mui_event(base: mut UIEvent) -> mut PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'PointerEvent'!\");
"

/// Converts a reference to 'PointerEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_event(self: PointerEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PointerEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::as_mevent(self: mut PointerEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_event(base: Event) -> PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEvent::from_mevent(base: mut Event) -> mut PointerEvent = "
    if(#var(base) instanceof PointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PointerEvent'!\");
"

pub ext fun PointerEvent::from_str_mpointer_event_init(type: String, event_init_dict: mut PointerEventInit) -> mut PointerEvent
    = "return new PointerEvent(#fun(String::as_js)(#var(type)), #fun(PointerEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PointerEvent::pointer_id(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).pointerId);"

pub ext fun PointerEvent::width(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun PointerEvent::height(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun PointerEvent::pressure(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pressure);"

pub ext fun PointerEvent::tilt_x(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).tiltX);"

pub ext fun PointerEvent::tilt_y(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).tiltY);"

pub ext fun PointerEvent::azimuth_angle(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).azimuthAngle);"

pub ext fun PointerEvent::altitude_angle(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).altitudeAngle);"

pub ext fun PointerEvent::tangential_pressure(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).tangentialPressure);"

pub ext fun PointerEvent::twist(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).twist);"

pub ext fun PointerEvent::pointer_type(self: PointerEvent) -> String
    = "return #fun(String::from_js)(#var(self).pointerType);"

pub ext fun PointerEvent::is_primary(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isPrimary);"

pub ext fun PointerEvent::persistent_device_id(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).persistentDeviceId);"

pub ext fun PointerEvent::screen_x(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun PointerEvent::screen_y(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun PointerEvent::client_x(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun PointerEvent::client_y(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun PointerEvent::ctrl_key(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun PointerEvent::shift_key(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun PointerEvent::alt_key(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun PointerEvent::meta_key(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun PointerEvent::button(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).button);"

pub ext fun PointerEvent::buttons(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).buttons);"

pub ext fun PointerEvent::related_target(self: PointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun PointerEvent::page_x(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun PointerEvent::page_y(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun PointerEvent::x(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun PointerEvent::y(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun PointerEvent::offset_x(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetX);"

pub ext fun PointerEvent::offset_y(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetY);"

pub ext fun PointerEvent::movement_x(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementX);"

pub ext fun PointerEvent::movement_y(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementY);"

pub ext fun PointerEvent::from_element(self: PointerEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).fromElement);"

pub ext fun PointerEvent::to_element(self: PointerEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).toElement);"

pub ext fun PointerEvent::layer_x(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerX);"

pub ext fun PointerEvent::layer_y(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerY);"

pub ext fun PointerEvent::view(self: PointerEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun PointerEvent::detail(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun PointerEvent::source_capabilities(self: PointerEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun PointerEvent::which(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun PointerEvent::type(self: PointerEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PointerEvent::target(self: PointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PointerEvent::current_target(self: PointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PointerEvent::event_phase(self: PointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PointerEvent::bubbles(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PointerEvent::cancelable(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PointerEvent::default_prevented(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PointerEvent::composed(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PointerEvent::is_trusted(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PointerEvent::time_stamp(self: PointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PointerEvent::src_element(self: PointerEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PointerEvent::return_value(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PointerEvent::set_return_value(self: mut PointerEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PointerEvent::cancel_bubble(self: PointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PointerEvent::set_cancel_bubble(self: mut PointerEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PointerEvent::get_coalesced_events(__self: mut PointerEvent) -> List[mut PointerEvent] = "
    const r = #var(__self).getCoalescedEvents();
    return #fun(List::from_js[mut PointerEvent])(r);
"

pub ext fun PointerEvent::get_predicted_events(__self: mut PointerEvent) -> List[mut PointerEvent] = "
    const r = #var(__self).getPredictedEvents();
    return #fun(List::from_js[mut PointerEvent])(r);
"

pub ext fun PointerEvent::get_modifier_state(__self: mut PointerEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun PointerEvent::init_mouse_event(__self: mut PointerEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int, screen_x: Int, screen_y: Int, client_x: Int, client_y: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool, button: Int, related_target: Option[mut EventTarget]) -> Unit = "
    const r = #var(__self).initMouseEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)), #fun(Int::as_js)(#var(screen_x)), #fun(Int::as_js)(#var(screen_y)), #fun(Int::as_js)(#var(client_x)), #fun(Int::as_js)(#var(client_y)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)), #fun(Int::as_js)(#var(button)), #fun(Option::as_js[mut EventTarget])(#var(related_target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PointerEvent::init_ui_event(__self: mut PointerEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PointerEvent::composed_path(__self: mut PointerEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PointerEvent::stop_propagation(__self: mut PointerEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PointerEvent::stop_immediate_propagation(__self: mut PointerEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PointerEvent::prevent_default(__self: mut PointerEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PointerEvent::init_event(__self: mut PointerEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PointerEvent::as_js(self: PointerEvent) -> JsValue = JsValue::unsafe_from[PointerEvent](self)

pub fun PointerEvent::from_js(v: JsValue) -> mut PointerEvent = JsValue::unsafe_as[mut PointerEvent](v)

pub val PointerEvent::none: Int = 0
pub val PointerEvent::capturing_phase: Int = 1
pub val PointerEvent::at_target: Int = 2
pub val PointerEvent::bubbling_phase: Int = 3

pub struct PointerEventInit(
    pointer_id: Option[Int],
    width: Option[Float],
    height: Option[Float],
    pressure: Option[Float],
    tilt_x: Option[Int],
    tilt_y: Option[Int],
    azimuth_angle: Option[Float],
    altitude_angle: Option[Float],
    tangential_pressure: Option[Float],
    twist: Option[Int],
    pointer_type: Option[String],
    is_primary: Option[Bool],
    persistent_device_id: Option[Int],
    coalesced_events: Option[List[mut PointerEvent]],
    predicted_events: Option[List[mut PointerEvent]],
    screen_x: Option[Float],
    screen_y: Option[Float],
    client_x: Option[Float],
    client_y: Option[Float],
    button: Option[Int],
    buttons: Option[Int],
    related_target: Option[mut EventTarget],
    movement_x: Option[Int],
    movement_y: Option[Int],
    region: Option[String],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PointerEventInit::default() -> mut PointerEventInit
    = PointerEventInit(Option::Some(0), Option::Some(1.0), Option::Some(1.0), Option::Some(0.0), Option::None, Option::None, Option::None, Option::None, Option::Some(0.0), Option::Some(0), Option::Some(""), Option::Some(false), Option::Some(0), Option::Some(List::empty()), Option::Some(List::empty()), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::None, Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PointerEventInit' to a reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEventInit::as_mouse_event_init(self: PointerEventInit) -> MouseEventInit = "return #var(self);"

/// Converts a mutable reference to 'PointerEventInit' to a mutable reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEventInit::as_mmouse_event_init(self: mut PointerEventInit) -> mut MouseEventInit = "return #var(self);"

/// Attempts to convert a reference to 'MouseEventInit' to a reference to 'PointerEventInit'.
/// A 'base' that is not a reference to 'PointerEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEventInit::from_mouse_event_init_unchecked(base: MouseEventInit) -> PointerEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'MouseEventInit' to a mutable reference to 'PointerEventInit'.
/// A 'base' that is not a reference to 'PointerEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PointerEventInit::from_mmouse_event_init_unchecked(base: mut MouseEventInit) -> mut PointerEventInit = "return #var(base);"

pub ext fun PointerEventInit::from_js(value: JsValue) -> mut PointerEventInit = "
    const r = {};
    r.m_pointer_id = #fun(Option::from_js[Int])(#var(value).pointerId);
    r.m_width = #fun(Option::from_js[Float])(#var(value).width);
    r.m_height = #fun(Option::from_js[Float])(#var(value).height);
    r.m_pressure = #fun(Option::from_js[Float])(#var(value).pressure);
    r.m_tilt_x = #fun(Option::from_js[Int])(#var(value).tiltX);
    r.m_tilt_y = #fun(Option::from_js[Int])(#var(value).tiltY);
    r.m_azimuth_angle = #fun(Option::from_js[Float])(#var(value).azimuthAngle);
    r.m_altitude_angle = #fun(Option::from_js[Float])(#var(value).altitudeAngle);
    r.m_tangential_pressure = #fun(Option::from_js[Float])(#var(value).tangentialPressure);
    r.m_twist = #fun(Option::from_js[Int])(#var(value).twist);
    r.m_pointer_type = #fun(Option::from_js[String])(#var(value).pointerType);
    r.m_is_primary = #fun(Option::from_js[Bool])(#var(value).isPrimary);
    r.m_persistent_device_id = #fun(Option::from_js[Int])(#var(value).persistentDeviceId);
    r.m_coalesced_events = #fun(Option::from_js[List[mut PointerEvent]])(#var(value).coalescedEvents);
    r.m_predicted_events = #fun(Option::from_js[List[mut PointerEvent]])(#var(value).predictedEvents);
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_button = #fun(Option::from_js[Int])(#var(value).button);
    r.m_buttons = #fun(Option::from_js[Int])(#var(value).buttons);
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_movement_x = #fun(Option::from_js[Int])(#var(value).movementX);
    r.m_movement_y = #fun(Option::from_js[Int])(#var(value).movementY);
    r.m_region = #fun(Option::from_js[String])(#var(value).region);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PointerEventInit::as_js(self: PointerEventInit) -> JsValue = "
    const r = {};
    r.pointerId = #fun(Option::as_js_undef[Int])(#var(self).m_pointer_id);
    r.width = #fun(Option::as_js_undef[Float])(#var(self).m_width);
    r.height = #fun(Option::as_js_undef[Float])(#var(self).m_height);
    r.pressure = #fun(Option::as_js_undef[Float])(#var(self).m_pressure);
    r.tiltX = #fun(Option::as_js_undef[Int])(#var(self).m_tilt_x);
    r.tiltY = #fun(Option::as_js_undef[Int])(#var(self).m_tilt_y);
    r.azimuthAngle = #fun(Option::as_js_undef[Float])(#var(self).m_azimuth_angle);
    r.altitudeAngle = #fun(Option::as_js_undef[Float])(#var(self).m_altitude_angle);
    r.tangentialPressure = #fun(Option::as_js_undef[Float])(#var(self).m_tangential_pressure);
    r.twist = #fun(Option::as_js_undef[Int])(#var(self).m_twist);
    r.pointerType = #fun(Option::as_js_undef[String])(#var(self).m_pointer_type);
    r.isPrimary = #fun(Option::as_js_undef[Bool])(#var(self).m_is_primary);
    r.persistentDeviceId = #fun(Option::as_js_undef[Int])(#var(self).m_persistent_device_id);
    r.coalescedEvents = #fun(Option::as_js_undef[List[mut PointerEvent]])(#var(self).m_coalesced_events);
    r.predictedEvents = #fun(Option::as_js_undef[List[mut PointerEvent]])(#var(self).m_predicted_events);
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.button = #fun(Option::as_js_undef[Int])(#var(self).m_button);
    r.buttons = #fun(Option::as_js_undef[Int])(#var(self).m_buttons);
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.movementX = #fun(Option::as_js_undef[Int])(#var(self).m_movement_x);
    r.movementY = #fun(Option::as_js_undef[Int])(#var(self).m_movement_y);
    r.region = #fun(Option::as_js_undef[String])(#var(self).m_region);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct PopStateEvent()

/// Converts a reference to 'PopStateEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEvent::as_event(self: PopStateEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PopStateEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEvent::as_mevent(self: mut PopStateEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PopStateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PopStateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEvent::from_event(base: Event) -> PopStateEvent = "
    if(#var(base) instanceof PopStateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PopStateEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PopStateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PopStateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEvent::from_mevent(base: mut Event) -> mut PopStateEvent = "
    if(#var(base) instanceof PopStateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PopStateEvent'!\");
"

pub ext fun PopStateEvent::from_str_mpop_state_event_init(type: String, event_init_dict: mut PopStateEventInit) -> mut PopStateEvent
    = "return new PopStateEvent(#fun(String::as_js)(#var(type)), #fun(PopStateEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PopStateEvent::state(self: PopStateEvent) -> JsValue
    = "return #var(self).state;"

pub ext fun PopStateEvent::has_ua_visual_transition(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hasUAVisualTransition);"

pub ext fun PopStateEvent::type(self: PopStateEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PopStateEvent::target(self: PopStateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PopStateEvent::current_target(self: PopStateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PopStateEvent::event_phase(self: PopStateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PopStateEvent::bubbles(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PopStateEvent::cancelable(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PopStateEvent::default_prevented(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PopStateEvent::composed(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PopStateEvent::is_trusted(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PopStateEvent::time_stamp(self: PopStateEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PopStateEvent::src_element(self: PopStateEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PopStateEvent::return_value(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PopStateEvent::set_return_value(self: mut PopStateEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PopStateEvent::cancel_bubble(self: PopStateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PopStateEvent::set_cancel_bubble(self: mut PopStateEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PopStateEvent::composed_path(__self: mut PopStateEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PopStateEvent::stop_propagation(__self: mut PopStateEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PopStateEvent::stop_immediate_propagation(__self: mut PopStateEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PopStateEvent::prevent_default(__self: mut PopStateEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PopStateEvent::init_event(__self: mut PopStateEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PopStateEvent::as_js(self: PopStateEvent) -> JsValue = JsValue::unsafe_from[PopStateEvent](self)

pub fun PopStateEvent::from_js(v: JsValue) -> mut PopStateEvent = JsValue::unsafe_as[mut PopStateEvent](v)

pub val PopStateEvent::none: Int = 0
pub val PopStateEvent::capturing_phase: Int = 1
pub val PopStateEvent::at_target: Int = 2
pub val PopStateEvent::bubbling_phase: Int = 3

pub struct PopStateEventInit(
    state: Option[JsValue],
    has_ua_visual_transition: Option[Bool],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PopStateEventInit::default() -> mut PopStateEventInit
    = PopStateEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PopStateEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEventInit::as_event_init(self: PopStateEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'PopStateEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEventInit::as_mevent_init(self: mut PopStateEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'PopStateEventInit'.
/// A 'base' that is not a reference to 'PopStateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEventInit::from_event_init_unchecked(base: EventInit) -> PopStateEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'PopStateEventInit'.
/// A 'base' that is not a reference to 'PopStateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PopStateEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut PopStateEventInit = "return #var(base);"

pub ext fun PopStateEventInit::from_js(value: JsValue) -> mut PopStateEventInit = "
    const r = {};
    r.m_state = #fun(Option::from_js[JsValue])(#var(value).state);
    r.m_has_ua_visual_transition = #fun(Option::from_js[Bool])(#var(value).hasUAVisualTransition);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PopStateEventInit::as_js(self: PopStateEventInit) -> JsValue = "
    const r = {};
    r.state = #fun(Option::as_js_undef[JsValue])(#var(self).m_state);
    r.hasUAVisualTransition = #fun(Option::as_js_undef[Bool])(#var(self).m_has_ua_visual_transition);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct ProgressEvent()

/// Converts a reference to 'ProgressEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEvent::as_event(self: ProgressEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ProgressEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEvent::as_mevent(self: mut ProgressEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEvent::from_event(base: Event) -> ProgressEvent = "
    if(#var(base) instanceof ProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ProgressEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEvent::from_mevent(base: mut Event) -> mut ProgressEvent = "
    if(#var(base) instanceof ProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ProgressEvent'!\");
"

pub ext fun ProgressEvent::from_str_mprogress_event_init(type: String, event_init_dict: mut ProgressEventInit) -> mut ProgressEvent
    = "return new ProgressEvent(#fun(String::as_js)(#var(type)), #fun(ProgressEventInit::as_js)(#var(event_init_dict)));"

pub ext fun ProgressEvent::length_computable(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).lengthComputable);"

pub ext fun ProgressEvent::loaded(self: ProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).loaded);"

pub ext fun ProgressEvent::total(self: ProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).total);"

pub ext fun ProgressEvent::type(self: ProgressEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ProgressEvent::target(self: ProgressEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ProgressEvent::current_target(self: ProgressEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ProgressEvent::event_phase(self: ProgressEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ProgressEvent::bubbles(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ProgressEvent::cancelable(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ProgressEvent::default_prevented(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ProgressEvent::composed(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ProgressEvent::is_trusted(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ProgressEvent::time_stamp(self: ProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ProgressEvent::src_element(self: ProgressEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ProgressEvent::return_value(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ProgressEvent::set_return_value(self: mut ProgressEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ProgressEvent::cancel_bubble(self: ProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ProgressEvent::set_cancel_bubble(self: mut ProgressEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ProgressEvent::composed_path(__self: mut ProgressEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ProgressEvent::stop_propagation(__self: mut ProgressEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ProgressEvent::stop_immediate_propagation(__self: mut ProgressEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ProgressEvent::prevent_default(__self: mut ProgressEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ProgressEvent::init_event(__self: mut ProgressEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ProgressEvent::as_js(self: ProgressEvent) -> JsValue = JsValue::unsafe_from[ProgressEvent](self)

pub fun ProgressEvent::from_js(v: JsValue) -> mut ProgressEvent = JsValue::unsafe_as[mut ProgressEvent](v)

pub val ProgressEvent::none: Int = 0
pub val ProgressEvent::capturing_phase: Int = 1
pub val ProgressEvent::at_target: Int = 2
pub val ProgressEvent::bubbling_phase: Int = 3

pub struct ProgressEventInit(
    length_computable: Option[Bool],
    loaded: Option[Float],
    total: Option[Float],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun ProgressEventInit::default() -> mut ProgressEventInit
    = ProgressEventInit(Option::Some(false), Option::Some(0.0), Option::Some(0.0), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'ProgressEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEventInit::as_event_init(self: ProgressEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'ProgressEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEventInit::as_mevent_init(self: mut ProgressEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'ProgressEventInit'.
/// A 'base' that is not a reference to 'ProgressEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEventInit::from_event_init_unchecked(base: EventInit) -> ProgressEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'ProgressEventInit'.
/// A 'base' that is not a reference to 'ProgressEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ProgressEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut ProgressEventInit = "return #var(base);"

pub ext fun ProgressEventInit::from_js(value: JsValue) -> mut ProgressEventInit = "
    const r = {};
    r.m_length_computable = #fun(Option::from_js[Bool])(#var(value).lengthComputable);
    r.m_loaded = #fun(Option::from_js[Float])(#var(value).loaded);
    r.m_total = #fun(Option::from_js[Float])(#var(value).total);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun ProgressEventInit::as_js(self: ProgressEventInit) -> JsValue = "
    const r = {};
    r.lengthComputable = #fun(Option::as_js_undef[Bool])(#var(self).m_length_computable);
    r.loaded = #fun(Option::as_js_undef[Float])(#var(self).m_loaded);
    r.total = #fun(Option::as_js_undef[Float])(#var(self).m_total);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct PromiseRejectionEvent()

/// Converts a reference to 'PromiseRejectionEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEvent::as_event(self: PromiseRejectionEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PromiseRejectionEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEvent::as_mevent(self: mut PromiseRejectionEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PromiseRejectionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PromiseRejectionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEvent::from_event(base: Event) -> PromiseRejectionEvent = "
    if(#var(base) instanceof PromiseRejectionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PromiseRejectionEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PromiseRejectionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PromiseRejectionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEvent::from_mevent(base: mut Event) -> mut PromiseRejectionEvent = "
    if(#var(base) instanceof PromiseRejectionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PromiseRejectionEvent'!\");
"

pub ext fun PromiseRejectionEvent::from_str_mpromise_rejection_event_init(type: String, event_init_dict: mut PromiseRejectionEventInit) -> mut PromiseRejectionEvent
    = "return new PromiseRejectionEvent(#fun(String::as_js)(#var(type)), #fun(PromiseRejectionEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PromiseRejectionEvent::promise(self: PromiseRejectionEvent) -> JsObject
    = "return #var(self).promise;"

pub ext fun PromiseRejectionEvent::reason(self: PromiseRejectionEvent) -> JsValue
    = "return #var(self).reason;"

pub ext fun PromiseRejectionEvent::type(self: PromiseRejectionEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PromiseRejectionEvent::target(self: PromiseRejectionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PromiseRejectionEvent::current_target(self: PromiseRejectionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PromiseRejectionEvent::event_phase(self: PromiseRejectionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PromiseRejectionEvent::bubbles(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PromiseRejectionEvent::cancelable(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PromiseRejectionEvent::default_prevented(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PromiseRejectionEvent::composed(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PromiseRejectionEvent::is_trusted(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PromiseRejectionEvent::time_stamp(self: PromiseRejectionEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PromiseRejectionEvent::src_element(self: PromiseRejectionEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PromiseRejectionEvent::return_value(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PromiseRejectionEvent::set_return_value(self: mut PromiseRejectionEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PromiseRejectionEvent::cancel_bubble(self: PromiseRejectionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PromiseRejectionEvent::set_cancel_bubble(self: mut PromiseRejectionEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PromiseRejectionEvent::composed_path(__self: mut PromiseRejectionEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PromiseRejectionEvent::stop_propagation(__self: mut PromiseRejectionEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PromiseRejectionEvent::stop_immediate_propagation(__self: mut PromiseRejectionEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PromiseRejectionEvent::prevent_default(__self: mut PromiseRejectionEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PromiseRejectionEvent::init_event(__self: mut PromiseRejectionEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PromiseRejectionEvent::as_js(self: PromiseRejectionEvent) -> JsValue = JsValue::unsafe_from[PromiseRejectionEvent](self)

pub fun PromiseRejectionEvent::from_js(v: JsValue) -> mut PromiseRejectionEvent = JsValue::unsafe_as[mut PromiseRejectionEvent](v)

pub val PromiseRejectionEvent::none: Int = 0
pub val PromiseRejectionEvent::capturing_phase: Int = 1
pub val PromiseRejectionEvent::at_target: Int = 2
pub val PromiseRejectionEvent::bubbling_phase: Int = 3

pub struct PromiseRejectionEventInit(
    promise: Promise[JsValue],
    reason: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PromiseRejectionEventInit::default(promise: Promise[JsValue]) -> mut PromiseRejectionEventInit
    = PromiseRejectionEventInit(promise, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PromiseRejectionEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEventInit::as_event_init(self: PromiseRejectionEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'PromiseRejectionEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEventInit::as_mevent_init(self: mut PromiseRejectionEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'PromiseRejectionEventInit'.
/// A 'base' that is not a reference to 'PromiseRejectionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEventInit::from_event_init_unchecked(base: EventInit) -> PromiseRejectionEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'PromiseRejectionEventInit'.
/// A 'base' that is not a reference to 'PromiseRejectionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PromiseRejectionEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut PromiseRejectionEventInit = "return #var(base);"

pub ext fun PromiseRejectionEventInit::from_js(value: JsValue) -> mut PromiseRejectionEventInit = "
    const r = {};
    r.m_promise = #fun(Promise::from_js[JsValue])(#var(value).promise);
    r.m_reason = #fun(Option::from_js[JsValue])(#var(value).reason);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PromiseRejectionEventInit::as_js(self: PromiseRejectionEventInit) -> JsValue = "
    const r = {};
    r.promise = #fun(Promise::as_js[JsValue])(#var(self).m_promise);
    r.reason = #fun(Option::as_js_undef[JsValue])(#var(self).m_reason);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct ResourceProgressEvent()

/// Converts a reference to 'ResourceProgressEvent' to a reference to 'ProgressEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::as_progress_event(self: ResourceProgressEvent) -> ProgressEvent = "return #var(self);"

/// Converts a mutable reference to 'ResourceProgressEvent' to a mutable reference to 'ProgressEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::as_mprogress_event(self: mut ResourceProgressEvent) -> mut ProgressEvent = "return #var(self);"

/// Attempts to convert a reference to 'ProgressEvent' to a reference to 'ResourceProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ResourceProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::from_progress_event(base: ProgressEvent) -> ResourceProgressEvent = "
    if(#var(base) instanceof ResourceProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ProgressEvent' to 'ResourceProgressEvent'!\");
"

/// Attempts to convert a mutable reference to 'ProgressEvent' to a mutable reference to 'ResourceProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ResourceProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::from_mprogress_event(base: mut ProgressEvent) -> mut ResourceProgressEvent = "
    if(#var(base) instanceof ResourceProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ProgressEvent' to 'ResourceProgressEvent'!\");
"

/// Converts a reference to 'ResourceProgressEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::as_event(self: ResourceProgressEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ResourceProgressEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::as_mevent(self: mut ResourceProgressEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ResourceProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ResourceProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::from_event(base: Event) -> ResourceProgressEvent = "
    if(#var(base) instanceof ResourceProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ResourceProgressEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ResourceProgressEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ResourceProgressEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ResourceProgressEvent::from_mevent(base: mut Event) -> mut ResourceProgressEvent = "
    if(#var(base) instanceof ResourceProgressEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ResourceProgressEvent'!\");
"

pub ext fun ResourceProgressEvent::url(self: ResourceProgressEvent) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun ResourceProgressEvent::length_computable(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).lengthComputable);"

pub ext fun ResourceProgressEvent::loaded(self: ResourceProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).loaded);"

pub ext fun ResourceProgressEvent::total(self: ResourceProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).total);"

pub ext fun ResourceProgressEvent::type(self: ResourceProgressEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ResourceProgressEvent::target(self: ResourceProgressEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ResourceProgressEvent::current_target(self: ResourceProgressEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ResourceProgressEvent::event_phase(self: ResourceProgressEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ResourceProgressEvent::bubbles(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ResourceProgressEvent::cancelable(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ResourceProgressEvent::default_prevented(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ResourceProgressEvent::composed(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ResourceProgressEvent::is_trusted(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ResourceProgressEvent::time_stamp(self: ResourceProgressEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ResourceProgressEvent::src_element(self: ResourceProgressEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ResourceProgressEvent::return_value(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ResourceProgressEvent::set_return_value(self: mut ResourceProgressEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ResourceProgressEvent::cancel_bubble(self: ResourceProgressEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ResourceProgressEvent::set_cancel_bubble(self: mut ResourceProgressEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ResourceProgressEvent::composed_path(__self: mut ResourceProgressEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ResourceProgressEvent::stop_propagation(__self: mut ResourceProgressEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ResourceProgressEvent::stop_immediate_propagation(__self: mut ResourceProgressEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ResourceProgressEvent::prevent_default(__self: mut ResourceProgressEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ResourceProgressEvent::init_event(__self: mut ResourceProgressEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ResourceProgressEvent::as_js(self: ResourceProgressEvent) -> JsValue = JsValue::unsafe_from[ResourceProgressEvent](self)

pub fun ResourceProgressEvent::from_js(v: JsValue) -> mut ResourceProgressEvent = JsValue::unsafe_as[mut ResourceProgressEvent](v)

pub val ResourceProgressEvent::none: Int = 0
pub val ResourceProgressEvent::capturing_phase: Int = 1
pub val ResourceProgressEvent::at_target: Int = 2
pub val ResourceProgressEvent::bubbling_phase: Int = 3

pub val SecurityPolicyViolationEventDisposition::Enforce: String = "enforce"
pub val SecurityPolicyViolationEventDisposition::Report: String = "report"

struct SecurityPolicyViolationEvent()

/// Converts a reference to 'SecurityPolicyViolationEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEvent::as_event(self: SecurityPolicyViolationEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'SecurityPolicyViolationEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEvent::as_mevent(self: mut SecurityPolicyViolationEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'SecurityPolicyViolationEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SecurityPolicyViolationEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEvent::from_event(base: Event) -> SecurityPolicyViolationEvent = "
    if(#var(base) instanceof SecurityPolicyViolationEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SecurityPolicyViolationEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'SecurityPolicyViolationEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SecurityPolicyViolationEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEvent::from_mevent(base: mut Event) -> mut SecurityPolicyViolationEvent = "
    if(#var(base) instanceof SecurityPolicyViolationEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SecurityPolicyViolationEvent'!\");
"

pub ext fun SecurityPolicyViolationEvent::from_str(type: String) -> mut SecurityPolicyViolationEvent
    = "return new SecurityPolicyViolationEvent(#fun(String::as_js)(#var(type)));"

pub ext fun SecurityPolicyViolationEvent::from_str_msecurity_policy_violation_event_init(type: String, event_init_dict: mut SecurityPolicyViolationEventInit) -> mut SecurityPolicyViolationEvent
    = "return new SecurityPolicyViolationEvent(#fun(String::as_js)(#var(type)), #fun(SecurityPolicyViolationEventInit::as_js)(#var(event_init_dict)));"

pub ext fun SecurityPolicyViolationEvent::document_uri(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).documentURI);"

pub ext fun SecurityPolicyViolationEvent::referrer(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).referrer);"

pub ext fun SecurityPolicyViolationEvent::blocked_uri(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).blockedURI);"

pub ext fun SecurityPolicyViolationEvent::violated_directive(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).violatedDirective);"

pub ext fun SecurityPolicyViolationEvent::effective_directive(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).effectiveDirective);"

pub ext fun SecurityPolicyViolationEvent::original_policy(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).originalPolicy);"

pub ext fun SecurityPolicyViolationEvent::disposition(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).disposition);"

pub ext fun SecurityPolicyViolationEvent::source_file(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).sourceFile);"

pub ext fun SecurityPolicyViolationEvent::status_code(self: SecurityPolicyViolationEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).statusCode);"

pub ext fun SecurityPolicyViolationEvent::line_number(self: SecurityPolicyViolationEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).lineNumber);"

pub ext fun SecurityPolicyViolationEvent::column_number(self: SecurityPolicyViolationEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).columnNumber);"

pub ext fun SecurityPolicyViolationEvent::sample(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).sample);"

pub ext fun SecurityPolicyViolationEvent::type(self: SecurityPolicyViolationEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SecurityPolicyViolationEvent::target(self: SecurityPolicyViolationEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun SecurityPolicyViolationEvent::current_target(self: SecurityPolicyViolationEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun SecurityPolicyViolationEvent::event_phase(self: SecurityPolicyViolationEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun SecurityPolicyViolationEvent::bubbles(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun SecurityPolicyViolationEvent::cancelable(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun SecurityPolicyViolationEvent::default_prevented(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun SecurityPolicyViolationEvent::composed(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun SecurityPolicyViolationEvent::is_trusted(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun SecurityPolicyViolationEvent::time_stamp(self: SecurityPolicyViolationEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun SecurityPolicyViolationEvent::src_element(self: SecurityPolicyViolationEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun SecurityPolicyViolationEvent::return_value(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun SecurityPolicyViolationEvent::set_return_value(self: mut SecurityPolicyViolationEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun SecurityPolicyViolationEvent::cancel_bubble(self: SecurityPolicyViolationEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun SecurityPolicyViolationEvent::set_cancel_bubble(self: mut SecurityPolicyViolationEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun SecurityPolicyViolationEvent::composed_path(__self: mut SecurityPolicyViolationEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun SecurityPolicyViolationEvent::stop_propagation(__self: mut SecurityPolicyViolationEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SecurityPolicyViolationEvent::stop_immediate_propagation(__self: mut SecurityPolicyViolationEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SecurityPolicyViolationEvent::prevent_default(__self: mut SecurityPolicyViolationEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun SecurityPolicyViolationEvent::init_event(__self: mut SecurityPolicyViolationEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun SecurityPolicyViolationEvent::as_js(self: SecurityPolicyViolationEvent) -> JsValue = JsValue::unsafe_from[SecurityPolicyViolationEvent](self)

pub fun SecurityPolicyViolationEvent::from_js(v: JsValue) -> mut SecurityPolicyViolationEvent = JsValue::unsafe_as[mut SecurityPolicyViolationEvent](v)

pub val SecurityPolicyViolationEvent::none: Int = 0
pub val SecurityPolicyViolationEvent::capturing_phase: Int = 1
pub val SecurityPolicyViolationEvent::at_target: Int = 2
pub val SecurityPolicyViolationEvent::bubbling_phase: Int = 3

pub struct SecurityPolicyViolationEventInit(
    document_uri: Option[String],
    referrer: Option[String],
    blocked_uri: Option[String],
    effective_directive: Option[String],
    original_policy: Option[String],
    source_file: Option[String],
    sample: Option[String],
    disposition: Option[String],
    status_code: Option[Int],
    line_number: Option[Int],
    column_number: Option[Int],
    violated_directive: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun SecurityPolicyViolationEventInit::default() -> mut SecurityPolicyViolationEventInit
    = SecurityPolicyViolationEventInit(Option::Some(""), Option::Some(""), Option::Some(""), Option::Some(""), Option::Some(""), Option::Some(""), Option::Some(""), Option::Some("enforce"), Option::Some(0), Option::Some(0), Option::Some(0), Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'SecurityPolicyViolationEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEventInit::as_event_init(self: SecurityPolicyViolationEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'SecurityPolicyViolationEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEventInit::as_mevent_init(self: mut SecurityPolicyViolationEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'SecurityPolicyViolationEventInit'.
/// A 'base' that is not a reference to 'SecurityPolicyViolationEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEventInit::from_event_init_unchecked(base: EventInit) -> SecurityPolicyViolationEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'SecurityPolicyViolationEventInit'.
/// A 'base' that is not a reference to 'SecurityPolicyViolationEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SecurityPolicyViolationEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut SecurityPolicyViolationEventInit = "return #var(base);"

pub ext fun SecurityPolicyViolationEventInit::from_js(value: JsValue) -> mut SecurityPolicyViolationEventInit = "
    const r = {};
    r.m_document_uri = #fun(Option::from_js[String])(#var(value).documentURI);
    r.m_referrer = #fun(Option::from_js[String])(#var(value).referrer);
    r.m_blocked_uri = #fun(Option::from_js[String])(#var(value).blockedURI);
    r.m_effective_directive = #fun(Option::from_js[String])(#var(value).effectiveDirective);
    r.m_original_policy = #fun(Option::from_js[String])(#var(value).originalPolicy);
    r.m_source_file = #fun(Option::from_js[String])(#var(value).sourceFile);
    r.m_sample = #fun(Option::from_js[String])(#var(value).sample);
    r.m_disposition = #fun(Option::from_js[String])(#var(value).disposition);
    r.m_status_code = #fun(Option::from_js[Int])(#var(value).statusCode);
    r.m_line_number = #fun(Option::from_js[Int])(#var(value).lineNumber);
    r.m_column_number = #fun(Option::from_js[Int])(#var(value).columnNumber);
    r.m_violated_directive = #fun(Option::from_js[String])(#var(value).violatedDirective);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun SecurityPolicyViolationEventInit::as_js(self: SecurityPolicyViolationEventInit) -> JsValue = "
    const r = {};
    r.documentURI = #fun(Option::as_js_undef[String])(#var(self).m_document_uri);
    r.referrer = #fun(Option::as_js_undef[String])(#var(self).m_referrer);
    r.blockedURI = #fun(Option::as_js_undef[String])(#var(self).m_blocked_uri);
    r.effectiveDirective = #fun(Option::as_js_undef[String])(#var(self).m_effective_directive);
    r.originalPolicy = #fun(Option::as_js_undef[String])(#var(self).m_original_policy);
    r.sourceFile = #fun(Option::as_js_undef[String])(#var(self).m_source_file);
    r.sample = #fun(Option::as_js_undef[String])(#var(self).m_sample);
    r.disposition = #fun(Option::as_js_undef[String])(#var(self).m_disposition);
    r.statusCode = #fun(Option::as_js_undef[Int])(#var(self).m_status_code);
    r.lineNumber = #fun(Option::as_js_undef[Int])(#var(self).m_line_number);
    r.columnNumber = #fun(Option::as_js_undef[Int])(#var(self).m_column_number);
    r.violatedDirective = #fun(Option::as_js_undef[String])(#var(self).m_violated_directive);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct TextEvent()

/// Converts a reference to 'TextEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::as_ui_event(self: TextEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'TextEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::as_mui_event(self: mut TextEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'TextEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::from_ui_event(base: UIEvent) -> TextEvent = "
    if(#var(base) instanceof TextEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'TextEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'TextEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::from_mui_event(base: mut UIEvent) -> mut TextEvent = "
    if(#var(base) instanceof TextEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'TextEvent'!\");
"

/// Converts a reference to 'TextEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::as_event(self: TextEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TextEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::as_mevent(self: mut TextEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TextEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::from_event(base: Event) -> TextEvent = "
    if(#var(base) instanceof TextEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TextEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextEvent::from_mevent(base: mut Event) -> mut TextEvent = "
    if(#var(base) instanceof TextEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TextEvent'!\");
"

pub ext fun TextEvent::data(self: TextEvent) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun TextEvent::view(self: TextEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun TextEvent::detail(self: TextEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun TextEvent::source_capabilities(self: TextEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun TextEvent::which(self: TextEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun TextEvent::type(self: TextEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TextEvent::target(self: TextEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TextEvent::current_target(self: TextEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TextEvent::event_phase(self: TextEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TextEvent::bubbles(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TextEvent::cancelable(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TextEvent::default_prevented(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TextEvent::composed(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TextEvent::is_trusted(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TextEvent::time_stamp(self: TextEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TextEvent::src_element(self: TextEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TextEvent::return_value(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TextEvent::set_return_value(self: mut TextEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TextEvent::cancel_bubble(self: TextEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TextEvent::set_cancel_bubble(self: mut TextEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TextEvent::init_text_event(__self: mut TextEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], data: String) -> Unit = "
    const r = #var(__self).initTextEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextEvent::init_ui_event(__self: mut TextEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextEvent::composed_path(__self: mut TextEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TextEvent::stop_propagation(__self: mut TextEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextEvent::stop_immediate_propagation(__self: mut TextEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextEvent::prevent_default(__self: mut TextEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TextEvent::init_event(__self: mut TextEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TextEvent::as_js(self: TextEvent) -> JsValue = JsValue::unsafe_from[TextEvent](self)

pub fun TextEvent::from_js(v: JsValue) -> mut TextEvent = JsValue::unsafe_as[mut TextEvent](v)

pub val TextEvent::none: Int = 0
pub val TextEvent::capturing_phase: Int = 1
pub val TextEvent::at_target: Int = 2
pub val TextEvent::bubbling_phase: Int = 3

struct ToggleEvent()

/// Converts a reference to 'ToggleEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEvent::as_event(self: ToggleEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'ToggleEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEvent::as_mevent(self: mut ToggleEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'ToggleEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ToggleEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEvent::from_event(base: Event) -> ToggleEvent = "
    if(#var(base) instanceof ToggleEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ToggleEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'ToggleEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'ToggleEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEvent::from_mevent(base: mut Event) -> mut ToggleEvent = "
    if(#var(base) instanceof ToggleEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'ToggleEvent'!\");
"

pub ext fun ToggleEvent::from_str_mtoggle_event_init(type: String, event_init_dict: mut ToggleEventInit) -> mut ToggleEvent
    = "return new ToggleEvent(#fun(String::as_js)(#var(type)), #fun(ToggleEventInit::as_js)(#var(event_init_dict)));"

pub ext fun ToggleEvent::old_state(self: ToggleEvent) -> String
    = "return #fun(String::from_js)(#var(self).oldState);"

pub ext fun ToggleEvent::new_state(self: ToggleEvent) -> String
    = "return #fun(String::from_js)(#var(self).newState);"

pub ext fun ToggleEvent::source(self: ToggleEvent) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).source);"

pub ext fun ToggleEvent::type(self: ToggleEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun ToggleEvent::target(self: ToggleEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun ToggleEvent::current_target(self: ToggleEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun ToggleEvent::event_phase(self: ToggleEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun ToggleEvent::bubbles(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun ToggleEvent::cancelable(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun ToggleEvent::default_prevented(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun ToggleEvent::composed(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun ToggleEvent::is_trusted(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun ToggleEvent::time_stamp(self: ToggleEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun ToggleEvent::src_element(self: ToggleEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun ToggleEvent::return_value(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun ToggleEvent::set_return_value(self: mut ToggleEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun ToggleEvent::cancel_bubble(self: ToggleEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun ToggleEvent::set_cancel_bubble(self: mut ToggleEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun ToggleEvent::composed_path(__self: mut ToggleEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun ToggleEvent::stop_propagation(__self: mut ToggleEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ToggleEvent::stop_immediate_propagation(__self: mut ToggleEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun ToggleEvent::prevent_default(__self: mut ToggleEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun ToggleEvent::init_event(__self: mut ToggleEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun ToggleEvent::as_js(self: ToggleEvent) -> JsValue = JsValue::unsafe_from[ToggleEvent](self)

pub fun ToggleEvent::from_js(v: JsValue) -> mut ToggleEvent = JsValue::unsafe_as[mut ToggleEvent](v)

pub val ToggleEvent::none: Int = 0
pub val ToggleEvent::capturing_phase: Int = 1
pub val ToggleEvent::at_target: Int = 2
pub val ToggleEvent::bubbling_phase: Int = 3

pub struct ToggleEventInit(
    old_state: Option[String],
    new_state: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun ToggleEventInit::default() -> mut ToggleEventInit
    = ToggleEventInit(Option::Some(""), Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'ToggleEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEventInit::as_event_init(self: ToggleEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'ToggleEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEventInit::as_mevent_init(self: mut ToggleEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'ToggleEventInit'.
/// A 'base' that is not a reference to 'ToggleEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEventInit::from_event_init_unchecked(base: EventInit) -> ToggleEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'ToggleEventInit'.
/// A 'base' that is not a reference to 'ToggleEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ToggleEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut ToggleEventInit = "return #var(base);"

pub ext fun ToggleEventInit::from_js(value: JsValue) -> mut ToggleEventInit = "
    const r = {};
    r.m_old_state = #fun(Option::from_js[String])(#var(value).oldState);
    r.m_new_state = #fun(Option::from_js[String])(#var(value).newState);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun ToggleEventInit::as_js(self: ToggleEventInit) -> JsValue = "
    const r = {};
    r.oldState = #fun(Option::as_js_undef[String])(#var(self).m_old_state);
    r.newState = #fun(Option::as_js_undef[String])(#var(self).m_new_state);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct TouchEvent()

/// Converts a reference to 'TouchEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::as_ui_event(self: TouchEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'TouchEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::as_mui_event(self: mut TouchEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'TouchEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TouchEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::from_ui_event(base: UIEvent) -> TouchEvent = "
    if(#var(base) instanceof TouchEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'TouchEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'TouchEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TouchEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::from_mui_event(base: mut UIEvent) -> mut TouchEvent = "
    if(#var(base) instanceof TouchEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'TouchEvent'!\");
"

/// Converts a reference to 'TouchEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::as_event(self: TouchEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TouchEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::as_mevent(self: mut TouchEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TouchEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TouchEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::from_event(base: Event) -> TouchEvent = "
    if(#var(base) instanceof TouchEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TouchEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TouchEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TouchEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEvent::from_mevent(base: mut Event) -> mut TouchEvent = "
    if(#var(base) instanceof TouchEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TouchEvent'!\");
"

pub ext fun TouchEvent::from_str_mtouch_event_init(type: String, event_init_dict: mut TouchEventInit) -> mut TouchEvent
    = "return new TouchEvent(#fun(String::as_js)(#var(type)), #fun(TouchEventInit::as_js)(#var(event_init_dict)));"

pub ext fun TouchEvent::touches(self: TouchEvent) -> mut TouchList
    = "return #fun(TouchList::from_js)(#var(self).touches);"

pub ext fun TouchEvent::target_touches(self: TouchEvent) -> mut TouchList
    = "return #fun(TouchList::from_js)(#var(self).targetTouches);"

pub ext fun TouchEvent::changed_touches(self: TouchEvent) -> mut TouchList
    = "return #fun(TouchList::from_js)(#var(self).changedTouches);"

pub ext fun TouchEvent::alt_key(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun TouchEvent::meta_key(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun TouchEvent::ctrl_key(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun TouchEvent::shift_key(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun TouchEvent::view(self: TouchEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun TouchEvent::detail(self: TouchEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun TouchEvent::source_capabilities(self: TouchEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun TouchEvent::which(self: TouchEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun TouchEvent::type(self: TouchEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TouchEvent::target(self: TouchEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TouchEvent::current_target(self: TouchEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TouchEvent::event_phase(self: TouchEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TouchEvent::bubbles(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TouchEvent::cancelable(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TouchEvent::default_prevented(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TouchEvent::composed(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TouchEvent::is_trusted(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TouchEvent::time_stamp(self: TouchEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TouchEvent::src_element(self: TouchEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TouchEvent::return_value(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TouchEvent::set_return_value(self: mut TouchEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TouchEvent::cancel_bubble(self: TouchEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TouchEvent::set_cancel_bubble(self: mut TouchEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TouchEvent::init_ui_event(__self: mut TouchEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun TouchEvent::composed_path(__self: mut TouchEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TouchEvent::stop_propagation(__self: mut TouchEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TouchEvent::stop_immediate_propagation(__self: mut TouchEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TouchEvent::prevent_default(__self: mut TouchEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TouchEvent::init_event(__self: mut TouchEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TouchEvent::as_js(self: TouchEvent) -> JsValue = JsValue::unsafe_from[TouchEvent](self)

pub fun TouchEvent::from_js(v: JsValue) -> mut TouchEvent = JsValue::unsafe_as[mut TouchEvent](v)

pub val TouchEvent::none: Int = 0
pub val TouchEvent::capturing_phase: Int = 1
pub val TouchEvent::at_target: Int = 2
pub val TouchEvent::bubbling_phase: Int = 3

pub struct TouchEventInit(
    touches: Option[List[mut Touch]],
    target_touches: Option[List[mut Touch]],
    changed_touches: Option[List[mut Touch]],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TouchEventInit::default() -> mut TouchEventInit
    = TouchEventInit(Option::Some(List::empty()), Option::Some(List::empty()), Option::Some(List::empty()), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TouchEventInit' to a reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEventInit::as_event_modifier_init(self: TouchEventInit) -> EventModifierInit = "return #var(self);"

/// Converts a mutable reference to 'TouchEventInit' to a mutable reference to 'EventModifierInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEventInit::as_mevent_modifier_init(self: mut TouchEventInit) -> mut EventModifierInit = "return #var(self);"

/// Attempts to convert a reference to 'EventModifierInit' to a reference to 'TouchEventInit'.
/// A 'base' that is not a reference to 'TouchEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEventInit::from_event_modifier_init_unchecked(base: EventModifierInit) -> TouchEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventModifierInit' to a mutable reference to 'TouchEventInit'.
/// A 'base' that is not a reference to 'TouchEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TouchEventInit::from_mevent_modifier_init_unchecked(base: mut EventModifierInit) -> mut TouchEventInit = "return #var(base);"

pub ext fun TouchEventInit::from_js(value: JsValue) -> mut TouchEventInit = "
    const r = {};
    r.m_touches = #fun(Option::from_js[List[mut Touch]])(#var(value).touches);
    r.m_target_touches = #fun(Option::from_js[List[mut Touch]])(#var(value).targetTouches);
    r.m_changed_touches = #fun(Option::from_js[List[mut Touch]])(#var(value).changedTouches);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TouchEventInit::as_js(self: TouchEventInit) -> JsValue = "
    const r = {};
    r.touches = #fun(Option::as_js_undef[List[mut Touch]])(#var(self).m_touches);
    r.targetTouches = #fun(Option::as_js_undef[List[mut Touch]])(#var(self).m_target_touches);
    r.changedTouches = #fun(Option::as_js_undef[List[mut Touch]])(#var(self).m_changed_touches);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct TransitionEvent()

/// Converts a reference to 'TransitionEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEvent::as_event(self: TransitionEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TransitionEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEvent::as_mevent(self: mut TransitionEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TransitionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TransitionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEvent::from_event(base: Event) -> TransitionEvent = "
    if(#var(base) instanceof TransitionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TransitionEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TransitionEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TransitionEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEvent::from_mevent(base: mut Event) -> mut TransitionEvent = "
    if(#var(base) instanceof TransitionEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TransitionEvent'!\");
"

pub ext fun TransitionEvent::from_str_mtransition_event_init(type: String, event_init_dict: mut TransitionEventInit) -> mut TransitionEvent
    = "return new TransitionEvent(#fun(String::as_js)(#var(type)), #fun(TransitionEventInit::as_js)(#var(event_init_dict)));"

pub ext fun TransitionEvent::property_name(self: TransitionEvent) -> String
    = "return #fun(String::from_js)(#var(self).propertyName);"

pub ext fun TransitionEvent::elapsed_time(self: TransitionEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).elapsedTime);"

pub ext fun TransitionEvent::pseudo_element(self: TransitionEvent) -> String
    = "return #fun(String::from_js)(#var(self).pseudoElement);"

pub ext fun TransitionEvent::type(self: TransitionEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TransitionEvent::target(self: TransitionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TransitionEvent::current_target(self: TransitionEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TransitionEvent::event_phase(self: TransitionEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TransitionEvent::bubbles(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TransitionEvent::cancelable(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TransitionEvent::default_prevented(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TransitionEvent::composed(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TransitionEvent::is_trusted(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TransitionEvent::time_stamp(self: TransitionEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TransitionEvent::src_element(self: TransitionEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TransitionEvent::return_value(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TransitionEvent::set_return_value(self: mut TransitionEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TransitionEvent::cancel_bubble(self: TransitionEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TransitionEvent::set_cancel_bubble(self: mut TransitionEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TransitionEvent::composed_path(__self: mut TransitionEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TransitionEvent::stop_propagation(__self: mut TransitionEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TransitionEvent::stop_immediate_propagation(__self: mut TransitionEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TransitionEvent::prevent_default(__self: mut TransitionEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TransitionEvent::init_event(__self: mut TransitionEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TransitionEvent::as_js(self: TransitionEvent) -> JsValue = JsValue::unsafe_from[TransitionEvent](self)

pub fun TransitionEvent::from_js(v: JsValue) -> mut TransitionEvent = JsValue::unsafe_as[mut TransitionEvent](v)

pub val TransitionEvent::none: Int = 0
pub val TransitionEvent::capturing_phase: Int = 1
pub val TransitionEvent::at_target: Int = 2
pub val TransitionEvent::bubbling_phase: Int = 3

pub struct TransitionEventInit(
    property_name: Option[String],
    elapsed_time: Option[Float],
    pseudo_element: Option[String],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TransitionEventInit::default() -> mut TransitionEventInit
    = TransitionEventInit(Option::Some(""), Option::Some(0.0), Option::Some(""), Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TransitionEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEventInit::as_event_init(self: TransitionEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'TransitionEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEventInit::as_mevent_init(self: mut TransitionEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'TransitionEventInit'.
/// A 'base' that is not a reference to 'TransitionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEventInit::from_event_init_unchecked(base: EventInit) -> TransitionEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'TransitionEventInit'.
/// A 'base' that is not a reference to 'TransitionEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TransitionEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut TransitionEventInit = "return #var(base);"

pub ext fun TransitionEventInit::from_js(value: JsValue) -> mut TransitionEventInit = "
    const r = {};
    r.m_property_name = #fun(Option::from_js[String])(#var(value).propertyName);
    r.m_elapsed_time = #fun(Option::from_js[Float])(#var(value).elapsedTime);
    r.m_pseudo_element = #fun(Option::from_js[String])(#var(value).pseudoElement);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TransitionEventInit::as_js(self: TransitionEventInit) -> JsValue = "
    const r = {};
    r.propertyName = #fun(Option::as_js_undef[String])(#var(self).m_property_name);
    r.elapsedTime = #fun(Option::as_js_undef[Float])(#var(self).m_elapsed_time);
    r.pseudoElement = #fun(Option::as_js_undef[String])(#var(self).m_pseudo_element);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct UIEvent()

/// Converts a reference to 'UIEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun UIEvent::as_event(self: UIEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'UIEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun UIEvent::as_mevent(self: mut UIEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'UIEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'UIEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun UIEvent::from_event(base: Event) -> UIEvent = "
    if(#var(base) instanceof UIEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'UIEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'UIEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'UIEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun UIEvent::from_mevent(base: mut Event) -> mut UIEvent = "
    if(#var(base) instanceof UIEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'UIEvent'!\");
"

pub ext fun UIEvent::from_str_mui_event_init(type: String, event_init_dict: mut UIEventInit) -> mut UIEvent
    = "return new UIEvent(#fun(String::as_js)(#var(type)), #fun(UIEventInit::as_js)(#var(event_init_dict)));"

pub ext fun UIEvent::view(self: UIEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun UIEvent::detail(self: UIEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun UIEvent::source_capabilities(self: UIEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun UIEvent::which(self: UIEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun UIEvent::type(self: UIEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun UIEvent::target(self: UIEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun UIEvent::current_target(self: UIEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun UIEvent::event_phase(self: UIEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun UIEvent::bubbles(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun UIEvent::cancelable(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun UIEvent::default_prevented(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun UIEvent::composed(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun UIEvent::is_trusted(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun UIEvent::time_stamp(self: UIEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun UIEvent::src_element(self: UIEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun UIEvent::return_value(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun UIEvent::set_return_value(self: mut UIEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun UIEvent::cancel_bubble(self: UIEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun UIEvent::set_cancel_bubble(self: mut UIEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun UIEvent::init_ui_event(__self: mut UIEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun UIEvent::composed_path(__self: mut UIEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun UIEvent::stop_propagation(__self: mut UIEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun UIEvent::stop_immediate_propagation(__self: mut UIEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun UIEvent::prevent_default(__self: mut UIEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun UIEvent::init_event(__self: mut UIEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun UIEvent::as_js(self: UIEvent) -> JsValue = JsValue::unsafe_from[UIEvent](self)

pub fun UIEvent::from_js(v: JsValue) -> mut UIEvent = JsValue::unsafe_as[mut UIEvent](v)

pub val UIEvent::none: Int = 0
pub val UIEvent::capturing_phase: Int = 1
pub val UIEvent::at_target: Int = 2
pub val UIEvent::bubbling_phase: Int = 3

pub struct UIEventInit(
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun UIEventInit::default() -> mut UIEventInit
    = UIEventInit(Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'UIEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun UIEventInit::as_event_init(self: UIEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'UIEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun UIEventInit::as_mevent_init(self: mut UIEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'UIEventInit'.
/// A 'base' that is not a reference to 'UIEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun UIEventInit::from_event_init_unchecked(base: EventInit) -> UIEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'UIEventInit'.
/// A 'base' that is not a reference to 'UIEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun UIEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut UIEventInit = "return #var(base);"

pub ext fun UIEventInit::from_js(value: JsValue) -> mut UIEventInit = "
    const r = {};
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun UIEventInit::as_js(self: UIEventInit) -> JsValue = "
    const r = {};
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct WheelEvent()

/// Converts a reference to 'WheelEvent' to a reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_mouse_event(self: WheelEvent) -> MouseEvent = "return #var(self);"

/// Converts a mutable reference to 'WheelEvent' to a mutable reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_mmouse_event(self: mut WheelEvent) -> mut MouseEvent = "return #var(self);"

/// Attempts to convert a reference to 'MouseEvent' to a reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_mouse_event(base: MouseEvent) -> WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'WheelEvent'!\");
"

/// Attempts to convert a mutable reference to 'MouseEvent' to a mutable reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_mmouse_event(base: mut MouseEvent) -> mut WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'WheelEvent'!\");
"

/// Converts a reference to 'WheelEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_ui_event(self: WheelEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'WheelEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_mui_event(self: mut WheelEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_ui_event(base: UIEvent) -> WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'WheelEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_mui_event(base: mut UIEvent) -> mut WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'WheelEvent'!\");
"

/// Converts a reference to 'WheelEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_event(self: WheelEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'WheelEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::as_mevent(self: mut WheelEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_event(base: Event) -> WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'WheelEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'WheelEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'WheelEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEvent::from_mevent(base: mut Event) -> mut WheelEvent = "
    if(#var(base) instanceof WheelEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'WheelEvent'!\");
"

pub ext fun WheelEvent::from_str_mwheel_event_init(type: String, event_init_dict: mut WheelEventInit) -> mut WheelEvent
    = "return new WheelEvent(#fun(String::as_js)(#var(type)), #fun(WheelEventInit::as_js)(#var(event_init_dict)));"

pub ext fun WheelEvent::delta_x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).deltaX);"

pub ext fun WheelEvent::delta_y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).deltaY);"

pub ext fun WheelEvent::delta_z(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).deltaZ);"

pub ext fun WheelEvent::delta_mode(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).deltaMode);"

pub ext fun WheelEvent::wheel_delta_x(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).wheelDeltaX);"

pub ext fun WheelEvent::wheel_delta_y(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).wheelDeltaY);"

pub ext fun WheelEvent::wheel_delta(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).wheelDelta);"

pub ext fun WheelEvent::screen_x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun WheelEvent::screen_y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun WheelEvent::client_x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun WheelEvent::client_y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun WheelEvent::ctrl_key(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun WheelEvent::shift_key(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun WheelEvent::alt_key(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun WheelEvent::meta_key(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun WheelEvent::button(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).button);"

pub ext fun WheelEvent::buttons(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).buttons);"

pub ext fun WheelEvent::related_target(self: WheelEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun WheelEvent::page_x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun WheelEvent::page_y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun WheelEvent::x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun WheelEvent::y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun WheelEvent::offset_x(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetX);"

pub ext fun WheelEvent::offset_y(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetY);"

pub ext fun WheelEvent::movement_x(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementX);"

pub ext fun WheelEvent::movement_y(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementY);"

pub ext fun WheelEvent::from_element(self: WheelEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).fromElement);"

pub ext fun WheelEvent::to_element(self: WheelEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).toElement);"

pub ext fun WheelEvent::layer_x(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerX);"

pub ext fun WheelEvent::layer_y(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerY);"

pub ext fun WheelEvent::view(self: WheelEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun WheelEvent::detail(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun WheelEvent::source_capabilities(self: WheelEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun WheelEvent::which(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun WheelEvent::type(self: WheelEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun WheelEvent::target(self: WheelEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun WheelEvent::current_target(self: WheelEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun WheelEvent::event_phase(self: WheelEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun WheelEvent::bubbles(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun WheelEvent::cancelable(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun WheelEvent::default_prevented(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun WheelEvent::composed(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun WheelEvent::is_trusted(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun WheelEvent::time_stamp(self: WheelEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun WheelEvent::src_element(self: WheelEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun WheelEvent::return_value(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun WheelEvent::set_return_value(self: mut WheelEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun WheelEvent::cancel_bubble(self: WheelEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun WheelEvent::set_cancel_bubble(self: mut WheelEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun WheelEvent::get_modifier_state(__self: mut WheelEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun WheelEvent::init_mouse_event(__self: mut WheelEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int, screen_x: Int, screen_y: Int, client_x: Int, client_y: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool, button: Int, related_target: Option[mut EventTarget]) -> Unit = "
    const r = #var(__self).initMouseEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)), #fun(Int::as_js)(#var(screen_x)), #fun(Int::as_js)(#var(screen_y)), #fun(Int::as_js)(#var(client_x)), #fun(Int::as_js)(#var(client_y)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)), #fun(Int::as_js)(#var(button)), #fun(Option::as_js[mut EventTarget])(#var(related_target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun WheelEvent::init_ui_event(__self: mut WheelEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun WheelEvent::composed_path(__self: mut WheelEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun WheelEvent::stop_propagation(__self: mut WheelEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun WheelEvent::stop_immediate_propagation(__self: mut WheelEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun WheelEvent::prevent_default(__self: mut WheelEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun WheelEvent::init_event(__self: mut WheelEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun WheelEvent::as_js(self: WheelEvent) -> JsValue = JsValue::unsafe_from[WheelEvent](self)

pub fun WheelEvent::from_js(v: JsValue) -> mut WheelEvent = JsValue::unsafe_as[mut WheelEvent](v)

pub val WheelEvent::dom_delta_pixel: Int = 0
pub val WheelEvent::dom_delta_line: Int = 1
pub val WheelEvent::dom_delta_page: Int = 2
pub val WheelEvent::none: Int = 0
pub val WheelEvent::capturing_phase: Int = 1
pub val WheelEvent::at_target: Int = 2
pub val WheelEvent::bubbling_phase: Int = 3

pub struct WheelEventInit(
    delta_x: Option[Float],
    delta_y: Option[Float],
    delta_z: Option[Float],
    delta_mode: Option[Int],
    wheel_delta_x: Option[Int],
    wheel_delta_y: Option[Int],
    screen_x: Option[Float],
    screen_y: Option[Float],
    client_x: Option[Float],
    client_y: Option[Float],
    button: Option[Int],
    buttons: Option[Int],
    related_target: Option[mut EventTarget],
    movement_x: Option[Int],
    movement_y: Option[Int],
    region: Option[String],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun WheelEventInit::default() -> mut WheelEventInit
    = WheelEventInit(Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::Some(0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::None, Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'WheelEventInit' to a reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEventInit::as_mouse_event_init(self: WheelEventInit) -> MouseEventInit = "return #var(self);"

/// Converts a mutable reference to 'WheelEventInit' to a mutable reference to 'MouseEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEventInit::as_mmouse_event_init(self: mut WheelEventInit) -> mut MouseEventInit = "return #var(self);"

/// Attempts to convert a reference to 'MouseEventInit' to a reference to 'WheelEventInit'.
/// A 'base' that is not a reference to 'WheelEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEventInit::from_mouse_event_init_unchecked(base: MouseEventInit) -> WheelEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'MouseEventInit' to a mutable reference to 'WheelEventInit'.
/// A 'base' that is not a reference to 'WheelEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun WheelEventInit::from_mmouse_event_init_unchecked(base: mut MouseEventInit) -> mut WheelEventInit = "return #var(base);"

pub ext fun WheelEventInit::from_js(value: JsValue) -> mut WheelEventInit = "
    const r = {};
    r.m_delta_x = #fun(Option::from_js[Float])(#var(value).deltaX);
    r.m_delta_y = #fun(Option::from_js[Float])(#var(value).deltaY);
    r.m_delta_z = #fun(Option::from_js[Float])(#var(value).deltaZ);
    r.m_delta_mode = #fun(Option::from_js[Int])(#var(value).deltaMode);
    r.m_wheel_delta_x = #fun(Option::from_js[Int])(#var(value).wheelDeltaX);
    r.m_wheel_delta_y = #fun(Option::from_js[Int])(#var(value).wheelDeltaY);
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_button = #fun(Option::from_js[Int])(#var(value).button);
    r.m_buttons = #fun(Option::from_js[Int])(#var(value).buttons);
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_movement_x = #fun(Option::from_js[Int])(#var(value).movementX);
    r.m_movement_y = #fun(Option::from_js[Int])(#var(value).movementY);
    r.m_region = #fun(Option::from_js[String])(#var(value).region);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun WheelEventInit::as_js(self: WheelEventInit) -> JsValue = "
    const r = {};
    r.deltaX = #fun(Option::as_js_undef[Float])(#var(self).m_delta_x);
    r.deltaY = #fun(Option::as_js_undef[Float])(#var(self).m_delta_y);
    r.deltaZ = #fun(Option::as_js_undef[Float])(#var(self).m_delta_z);
    r.deltaMode = #fun(Option::as_js_undef[Int])(#var(self).m_delta_mode);
    r.wheelDeltaX = #fun(Option::as_js_undef[Int])(#var(self).m_wheel_delta_x);
    r.wheelDeltaY = #fun(Option::as_js_undef[Int])(#var(self).m_wheel_delta_y);
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.button = #fun(Option::as_js_undef[Int])(#var(self).m_button);
    r.buttons = #fun(Option::as_js_undef[Int])(#var(self).m_buttons);
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.movementX = #fun(Option::as_js_undef[Int])(#var(self).m_movement_x);
    r.movementY = #fun(Option::as_js_undef[Int])(#var(self).m_movement_y);
    r.region = #fun(Option::as_js_undef[String])(#var(self).m_region);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub struct AttributionReportingRequestOptions(
    event_source_eligible: Bool,
    trigger_eligible: Bool
)

pub fun AttributionReportingRequestOptions::default(event_source_eligible: Bool, trigger_eligible: Bool) -> mut AttributionReportingRequestOptions
    = AttributionReportingRequestOptions(event_source_eligible, trigger_eligible)

pub ext fun AttributionReportingRequestOptions::from_js(value: JsValue) -> mut AttributionReportingRequestOptions = "
    const r = {};
    r.m_event_source_eligible = #fun(Bool::from_js)(#var(value).eventSourceEligible);
    r.m_trigger_eligible = #fun(Bool::from_js)(#var(value).triggerEligible);
    return r;
"

pub ext fun AttributionReportingRequestOptions::as_js(self: AttributionReportingRequestOptions) -> JsValue = "
    const r = {};
    r.eventSourceEligible = #fun(Bool::as_js)(#var(self).m_event_source_eligible);
    r.triggerEligible = #fun(Bool::as_js)(#var(self).m_trigger_eligible);
    return r;
"

pub struct DeferredRequestInit(
    activate_after: Option[Float],
    method: Option[String],
    headers: Option[JsValue],
    body: Option[JsValue],
    referrer: Option[String],
    referrer_policy: Option[String],
    mode: Option[String],
    credentials: Option[String],
    cache: Option[String],
    redirect: Option[String],
    integrity: Option[String],
    keepalive: Option[Bool],
    priority: Option[String],
    browsing_topics: Option[Bool],
    ad_auction_headers: Option[Bool],
    shared_storage_writable: Option[Bool],
    signal: Option[mut AbortSignal],
    duplex: Option[String],
    target_address_space: Option[String],
    private_token: Option[mut PrivateToken],
    attribution_reporting: Option[mut AttributionReportingRequestOptions],
    retry_options: Option[mut RetryOptions]
)

pub fun DeferredRequestInit::default() -> mut DeferredRequestInit
    = DeferredRequestInit(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

/// Converts a reference to 'DeferredRequestInit' to a reference to 'RequestInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DeferredRequestInit::as_request_init(self: DeferredRequestInit) -> RequestInit = "return #var(self);"

/// Converts a mutable reference to 'DeferredRequestInit' to a mutable reference to 'RequestInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DeferredRequestInit::as_mrequest_init(self: mut DeferredRequestInit) -> mut RequestInit = "return #var(self);"

/// Attempts to convert a reference to 'RequestInit' to a reference to 'DeferredRequestInit'.
/// A 'base' that is not a reference to 'DeferredRequestInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DeferredRequestInit::from_request_init_unchecked(base: RequestInit) -> DeferredRequestInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'RequestInit' to a mutable reference to 'DeferredRequestInit'.
/// A 'base' that is not a reference to 'DeferredRequestInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DeferredRequestInit::from_mrequest_init_unchecked(base: mut RequestInit) -> mut DeferredRequestInit = "return #var(base);"

pub ext fun DeferredRequestInit::from_js(value: JsValue) -> mut DeferredRequestInit = "
    const r = {};
    r.m_activate_after = #fun(Option::from_js[Float])(#var(value).activateAfter);
    r.m_method = #fun(Option::from_js[String])(#var(value).method);
    r.m_headers = #fun(Option::from_js[JsValue])(#var(value).headers);
    r.m_body = #fun(Option::from_js[JsValue])(#var(value).body);
    r.m_referrer = #fun(Option::from_js[String])(#var(value).referrer);
    r.m_referrer_policy = #fun(Option::from_js[String])(#var(value).referrerPolicy);
    r.m_mode = #fun(Option::from_js[String])(#var(value).mode);
    r.m_credentials = #fun(Option::from_js[String])(#var(value).credentials);
    r.m_cache = #fun(Option::from_js[String])(#var(value).cache);
    r.m_redirect = #fun(Option::from_js[String])(#var(value).redirect);
    r.m_integrity = #fun(Option::from_js[String])(#var(value).integrity);
    r.m_keepalive = #fun(Option::from_js[Bool])(#var(value).keepalive);
    r.m_priority = #fun(Option::from_js[String])(#var(value).priority);
    r.m_browsing_topics = #fun(Option::from_js[Bool])(#var(value).browsingTopics);
    r.m_ad_auction_headers = #fun(Option::from_js[Bool])(#var(value).adAuctionHeaders);
    r.m_shared_storage_writable = #fun(Option::from_js[Bool])(#var(value).sharedStorageWritable);
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    r.m_duplex = #fun(Option::from_js[String])(#var(value).duplex);
    r.m_target_address_space = #fun(Option::from_js[String])(#var(value).targetAddressSpace);
    r.m_private_token = #fun(Option::from_js[mut PrivateToken])(#var(value).privateToken);
    r.m_attribution_reporting = #fun(Option::from_js[mut AttributionReportingRequestOptions])(#var(value).attributionReporting);
    r.m_retry_options = #fun(Option::from_js[mut RetryOptions])(#var(value).retryOptions);
    return r;
"

pub ext fun DeferredRequestInit::as_js(self: DeferredRequestInit) -> JsValue = "
    const r = {};
    r.activateAfter = #fun(Option::as_js_undef[Float])(#var(self).m_activate_after);
    r.method = #fun(Option::as_js_undef[String])(#var(self).m_method);
    r.headers = #fun(Option::as_js_undef[JsValue])(#var(self).m_headers);
    r.body = #fun(Option::as_js_undef[JsValue])(#var(self).m_body);
    r.referrer = #fun(Option::as_js_undef[String])(#var(self).m_referrer);
    r.referrerPolicy = #fun(Option::as_js_undef[String])(#var(self).m_referrer_policy);
    r.mode = #fun(Option::as_js_undef[String])(#var(self).m_mode);
    r.credentials = #fun(Option::as_js_undef[String])(#var(self).m_credentials);
    r.cache = #fun(Option::as_js_undef[String])(#var(self).m_cache);
    r.redirect = #fun(Option::as_js_undef[String])(#var(self).m_redirect);
    r.integrity = #fun(Option::as_js_undef[String])(#var(self).m_integrity);
    r.keepalive = #fun(Option::as_js_undef[Bool])(#var(self).m_keepalive);
    r.priority = #fun(Option::as_js_undef[String])(#var(self).m_priority);
    r.browsingTopics = #fun(Option::as_js_undef[Bool])(#var(self).m_browsing_topics);
    r.adAuctionHeaders = #fun(Option::as_js_undef[Bool])(#var(self).m_ad_auction_headers);
    r.sharedStorageWritable = #fun(Option::as_js_undef[Bool])(#var(self).m_shared_storage_writable);
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    r.duplex = #fun(Option::as_js_undef[String])(#var(self).m_duplex);
    r.targetAddressSpace = #fun(Option::as_js_undef[String])(#var(self).m_target_address_space);
    r.privateToken = #fun(Option::as_js_undef[mut PrivateToken])(#var(self).m_private_token);
    r.attributionReporting = #fun(Option::as_js_undef[mut AttributionReportingRequestOptions])(#var(self).m_attribution_reporting);
    r.retryOptions = #fun(Option::as_js_undef[mut RetryOptions])(#var(self).m_retry_options);
    return r;
"

struct FetchLaterResult()

pub ext fun FetchLaterResult::activated(self: FetchLaterResult) -> Bool
    = "return #fun(Bool::from_js)(#var(self).activated);"

pub fun FetchLaterResult::as_js(self: FetchLaterResult) -> JsValue = JsValue::unsafe_from[FetchLaterResult](self)

pub fun FetchLaterResult::from_js(v: JsValue) -> mut FetchLaterResult = JsValue::unsafe_as[mut FetchLaterResult](v)

struct Window()

pub ext fun Window::onabort(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun Window::set_onabort(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onbeforeinput(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeinput);"

pub ext fun Window::set_onbeforeinput(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeinput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onbeforematch(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforematch);"

pub ext fun Window::set_onbeforematch(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforematch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onbeforetoggle(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforetoggle);"

pub ext fun Window::set_onbeforetoggle(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforetoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onblur(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun Window::set_onblur(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncancel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun Window::set_oncancel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncanplay(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplay);"

pub ext fun Window::set_oncanplay(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncanplaythrough(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplaythrough);"

pub ext fun Window::set_oncanplaythrough(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplaythrough = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun Window::set_onchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onclick(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclick);"

pub ext fun Window::set_onclick(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onclose(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun Window::set_onclose(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncommand(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncommand);"

pub ext fun Window::set_oncommand(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncommand = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncontentvisibilityautostatechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontentvisibilityautostatechange);"

pub ext fun Window::set_oncontentvisibilityautostatechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontentvisibilityautostatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncontextlost(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun Window::set_oncontextlost(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncontextmenu(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextmenu);"

pub ext fun Window::set_oncontextmenu(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextmenu = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncontextrestored(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun Window::set_oncontextrestored(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oncuechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun Window::set_oncuechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondblclick(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondblclick);"

pub ext fun Window::set_ondblclick(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondblclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondrag(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrag);"

pub ext fun Window::set_ondrag(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrag = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondragend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragend);"

pub ext fun Window::set_ondragend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondragenter(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragenter);"

pub ext fun Window::set_ondragenter(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondragleave(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragleave);"

pub ext fun Window::set_ondragleave(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondragover(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragover);"

pub ext fun Window::set_ondragover(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondragstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragstart);"

pub ext fun Window::set_ondragstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondrop(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrop);"

pub ext fun Window::set_ondrop(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrop = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ondurationchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondurationchange);"

pub ext fun Window::set_ondurationchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondurationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onemptied(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onemptied);"

pub ext fun Window::set_onemptied(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onemptied = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onended(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onended);"

pub ext fun Window::set_onended(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onended = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onerror(self: Window) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun Window::set_onerror(self: mut Window, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onfencedtreeclick(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfencedtreeclick);"

pub ext fun Window::set_onfencedtreeclick(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfencedtreeclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onfocus(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun Window::set_onfocus(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onformdata(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onformdata);"

pub ext fun Window::set_onformdata(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onformdata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oninput(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninput);"

pub ext fun Window::set_oninput(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::oninvalid(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninvalid);"

pub ext fun Window::set_oninvalid(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninvalid = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onkeydown(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeydown);"

pub ext fun Window::set_onkeydown(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeydown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onkeypress(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeypress);"

pub ext fun Window::set_onkeypress(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeypress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onkeyup(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeyup);"

pub ext fun Window::set_onkeyup(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeyup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onload(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun Window::set_onload(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onloadeddata(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadeddata);"

pub ext fun Window::set_onloadeddata(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadeddata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onloadedmetadata(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadedmetadata);"

pub ext fun Window::set_onloadedmetadata(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadedmetadata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onloadstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun Window::set_onloadstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmousedown(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousedown);"

pub ext fun Window::set_onmousedown(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousedown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmouseenter(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseenter);"

pub ext fun Window::set_onmouseenter(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmouseleave(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseleave);"

pub ext fun Window::set_onmouseleave(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmousemove(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousemove);"

pub ext fun Window::set_onmousemove(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousemove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmouseout(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseout);"

pub ext fun Window::set_onmouseout(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmouseover(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseover);"

pub ext fun Window::set_onmouseover(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmouseup(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseup);"

pub ext fun Window::set_onmouseup(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmousewheel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousewheel);"

pub ext fun Window::set_onmousewheel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousewheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onoverscroll(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoverscroll);"

pub ext fun Window::set_onoverscroll(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoverscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpause(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpause);"

pub ext fun Window::set_onpause(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpause = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onplay(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplay);"

pub ext fun Window::set_onplay(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onplaying(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplaying);"

pub ext fun Window::set_onplaying(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplaying = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onprogress(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun Window::set_onprogress(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onratechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onratechange);"

pub ext fun Window::set_onratechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onratechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onreset(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreset);"

pub ext fun Window::set_onreset(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreset = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onresize(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun Window::set_onresize(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onscroll(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun Window::set_onscroll(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onscrollend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun Window::set_onscrollend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onsecuritypolicyviolation(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsecuritypolicyviolation);"

pub ext fun Window::set_onsecuritypolicyviolation(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsecuritypolicyviolation = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onseeked(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeked);"

pub ext fun Window::set_onseeked(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeked = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onseeking(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeking);"

pub ext fun Window::set_onseeking(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeking = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onselect(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselect);"

pub ext fun Window::set_onselect(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onslotchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun Window::set_onslotchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onscrollsnapchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchange);"

pub ext fun Window::set_onscrollsnapchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onscrollsnapchanging(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchanging);"

pub ext fun Window::set_onscrollsnapchanging(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchanging = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onstalled(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstalled);"

pub ext fun Window::set_onstalled(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstalled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onsubmit(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsubmit);"

pub ext fun Window::set_onsubmit(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsubmit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onsuspend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsuspend);"

pub ext fun Window::set_onsuspend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsuspend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontimeupdate(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeupdate);"

pub ext fun Window::set_ontimeupdate(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontoggle(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontoggle);"

pub ext fun Window::set_ontoggle(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onvolumechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvolumechange);"

pub ext fun Window::set_onvolumechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvolumechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwaiting(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwaiting);"

pub ext fun Window::set_onwaiting(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwaiting = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwebkitanimationend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationend);"

pub ext fun Window::set_onwebkitanimationend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwebkitanimationiteration(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationiteration);"

pub ext fun Window::set_onwebkitanimationiteration(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwebkitanimationstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationstart);"

pub ext fun Window::set_onwebkitanimationstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwebkittransitionend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkittransitionend);"

pub ext fun Window::set_onwebkittransitionend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkittransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onwheel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwheel);"

pub ext fun Window::set_onwheel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onauxclick(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onauxclick);"

pub ext fun Window::set_onauxclick(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onauxclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ongotpointercapture(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ongotpointercapture);"

pub ext fun Window::set_ongotpointercapture(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ongotpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onlostpointercapture(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlostpointercapture);"

pub ext fun Window::set_onlostpointercapture(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlostpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerdown(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerdown);"

pub ext fun Window::set_onpointerdown(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerdown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointermove(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointermove);"

pub ext fun Window::set_onpointermove(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointermove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerrawupdate(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerrawupdate);"

pub ext fun Window::set_onpointerrawupdate(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerrawupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerup(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerup);"

pub ext fun Window::set_onpointerup(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointercancel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointercancel);"

pub ext fun Window::set_onpointercancel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointercancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerover(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerover);"

pub ext fun Window::set_onpointerover(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerout(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerout);"

pub ext fun Window::set_onpointerout(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerenter(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerenter);"

pub ext fun Window::set_onpointerenter(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpointerleave(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerleave);"

pub ext fun Window::set_onpointerleave(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontouchcancel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchcancel);"

pub ext fun Window::set_ontouchcancel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchcancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontouchend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchend);"

pub ext fun Window::set_ontouchend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontouchmove(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchmove);"

pub ext fun Window::set_ontouchmove(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontouchstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchstart);"

pub ext fun Window::set_ontouchstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onselectstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectstart);"

pub ext fun Window::set_onselectstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onselectionchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectionchange);"

pub ext fun Window::set_onselectionchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectionchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onanimationend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationend);"

pub ext fun Window::set_onanimationend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onanimationiteration(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationiteration);"

pub ext fun Window::set_onanimationiteration(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onanimationstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationstart);"

pub ext fun Window::set_onanimationstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontransitionrun(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionrun);"

pub ext fun Window::set_ontransitionrun(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionrun = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontransitionstart(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionstart);"

pub ext fun Window::set_ontransitionstart(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontransitionend(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionend);"

pub ext fun Window::set_ontransitionend(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontransitioncancel(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitioncancel);"

pub ext fun Window::set_ontransitioncancel(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitioncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onafterprint(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onafterprint);"

pub ext fun Window::set_onafterprint(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onafterprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onbeforeprint(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeprint);"

pub ext fun Window::set_onbeforeprint(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onbeforeunload(self: Window) -> Option[Fun(mut Event) -> Option[String]]
    = "return #fun(Option::from_js[Fun(mut Event) -> Option[String]])(#var(self).onbeforeunload);"

pub ext fun Window::set_onbeforeunload(self: mut Window, value: Option[Fun(mut Event) -> Option[String]])
    = "#var(self).onbeforeunload = #fun(Option::as_js[Fun(mut Event) -> Option[String]])(#var(value));"

pub ext fun Window::onhashchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onhashchange);"

pub ext fun Window::set_onhashchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onhashchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onlanguagechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun Window::set_onlanguagechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmessage(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun Window::set_onmessage(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmessageerror(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessageerror);"

pub ext fun Window::set_onmessageerror(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessageerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onmove(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmove);"

pub ext fun Window::set_onmove(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onoffline(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoffline);"

pub ext fun Window::set_onoffline(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoffline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ononline(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ononline);"

pub ext fun Window::set_ononline(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ononline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpagehide(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpagehide);"

pub ext fun Window::set_onpagehide(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpagehide = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpageshow(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpageshow);"

pub ext fun Window::set_onpageshow(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpageshow = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpopstate(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpopstate);"

pub ext fun Window::set_onpopstate(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpopstate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onrejectionhandled(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun Window::set_onrejectionhandled(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onstorage(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstorage);"

pub ext fun Window::set_onstorage(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstorage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::ontimezonechange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun Window::set_ontimezonechange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onunhandledrejection(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun Window::set_onunhandledrejection(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onunload(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunload);"

pub ext fun Window::set_onunload(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::is_secure_context(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isSecureContext);"

pub ext fun Window::scheduler(self: Window) -> mut Scheduler
    = "return #fun(Scheduler::from_js)(#var(self).scheduler);"

pub ext fun Window::fetch_later(__self: mut Window, input: JsValue, init: mut DeferredRequestInit) -> mut FetchLaterResult = "
    const r = #var(__self).fetchLater(#var(input), #fun(DeferredRequestInit::as_js)(#var(init)));
    return #fun(FetchLaterResult::from_js)(r);
"

pub ext fun Window::report_error(__self: mut Window, e: JsValue) -> Unit = "
    const r = #var(__self).reportError(#var(e));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::btoa(__self: mut Window, btoa: String) -> String = "
    const r = #var(__self).btoa(#fun(String::as_js)(#var(btoa)));
    return #fun(String::from_js)(r);
"

pub ext fun Window::atob(__self: mut Window, atob: String) -> String = "
    const r = #var(__self).atob(#fun(String::as_js)(#var(atob)));
    return #fun(String::from_js)(r);
"

pub ext fun Window::queue_microtask(__self: mut Window, callback: Fun() -> Unit) -> Unit = "
    const r = #var(__self).queueMicrotask((() => { const r = #var(callback)(); return #fun(Unit::as_js)(r); }));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::structured_clone(__self: mut Window, value: JsValue, options: mut StructuredSerializeOptions) -> JsValue = "
    const r = #var(__self).structuredClone(#var(value), #fun(StructuredSerializeOptions::as_js)(#var(options)));
    return r;
"

pub fun Window::as_js(self: Window) -> JsValue = JsValue::unsafe_from[Window](self)

pub fun Window::from_js(v: JsValue) -> mut Window = JsValue::unsafe_as[mut Window](v)

struct Headers()

pub ext fun Headers::from_any(init: JsValue) -> mut Headers
    = "return new Headers(#var(init));"

pub ext fun Headers::append(__self: mut Headers, name: String, value: String) -> Unit = "
    const r = #var(__self).append(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Headers::delete(__self: mut Headers, key: String) -> Unit = "
    const r = #var(__self).delete(#fun(String::as_js)(#var(key)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Headers::get(__self: mut Headers, key: String) -> Option[String] = "
    const r = #var(__self).get(#fun(String::as_js)(#var(key)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Headers::get_set_cookie(__self: mut Headers) -> List[String] = "
    const r = #var(__self).getSetCookie();
    return #fun(List::from_js[String])(r);
"

pub ext fun Headers::has(__self: mut Headers, key: String) -> Bool = "
    const r = #var(__self).has(#fun(String::as_js)(#var(key)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Headers::set(__self: mut Headers, key: String, value: String) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(key)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub fun Headers::as_js(self: Headers) -> JsValue = JsValue::unsafe_from[Headers](self)

pub fun Headers::from_js(v: JsValue) -> mut Headers = JsValue::unsafe_as[mut Headers](v)

pub val PrivateTokenVersion::_1: String = "1"

pub val RefreshPolicy::None: String = "none"
pub val RefreshPolicy::Refresh: String = "refresh"

pub val OperationType::TokenRequest: String = "token-request"
pub val OperationType::SendRedemptionRecord: String = "send-redemption-record"
pub val OperationType::TokenRedemption: String = "token-redemption"

pub val SignRequestData::Omit: String = "omit"
pub val SignRequestData::Include: String = "include"
pub val SignRequestData::HeadersOnly: String = "headers-only"

pub struct PrivateToken(
    version: String,
    operation: String,
    refresh_policy: Option[String],
    issuers: Option[List[String]]
)

pub fun PrivateToken::default(version: String, operation: String) -> mut PrivateToken
    = PrivateToken(version, operation, Option::Some("none"), Option::None)

pub ext fun PrivateToken::from_js(value: JsValue) -> mut PrivateToken = "
    const r = {};
    r.m_version = #fun(String::from_js)(#var(value).version);
    r.m_operation = #fun(String::from_js)(#var(value).operation);
    r.m_refresh_policy = #fun(Option::from_js[String])(#var(value).refreshPolicy);
    r.m_issuers = #fun(Option::from_js[List[String]])(#var(value).issuers);
    return r;
"

pub ext fun PrivateToken::as_js(self: PrivateToken) -> JsValue = "
    const r = {};
    r.version = #var(self).m_version;
    r.operation = #var(self).m_operation;
    r.refreshPolicy = #fun(Option::as_js_undef[String])(#var(self).m_refresh_policy);
    r.issuers = #fun(Option::as_js_undef[List[String]])(#var(self).m_issuers);
    return r;
"

pub val RequestDestination::Audio: String = "audio"
pub val RequestDestination::Audioworklet: String = "audioworklet"
pub val RequestDestination::Document: String = "document"
pub val RequestDestination::Embed: String = "embed"
pub val RequestDestination::Font: String = "font"
pub val RequestDestination::Frame: String = "frame"
pub val RequestDestination::Iframe: String = "iframe"
pub val RequestDestination::Image: String = "image"
pub val RequestDestination::Json: String = "json"
pub val RequestDestination::Manifest: String = "manifest"
pub val RequestDestination::Object: String = "object"
pub val RequestDestination::Paintworklet: String = "paintworklet"
pub val RequestDestination::Report: String = "report"
pub val RequestDestination::Script: String = "script"
pub val RequestDestination::Serviceworker: String = "serviceworker"
pub val RequestDestination::Sharedworker: String = "sharedworker"
pub val RequestDestination::Style: String = "style"
pub val RequestDestination::Track: String = "track"
pub val RequestDestination::Video: String = "video"
pub val RequestDestination::Worker: String = "worker"
pub val RequestDestination::Xslt: String = "xslt"
pub val RequestDestination::Fencedframe: String = "fencedframe"
pub val RequestDestination::Dictionary: String = "dictionary"
pub val RequestDestination::Speculationrules: String = "speculationrules"
pub val RequestDestination::Sharedstorageworklet: String = "sharedstorageworklet"
pub val RequestDestination::Webidentity: String = "webidentity"
pub val RequestDestination::Webbundle: String = "webbundle"

pub val RequestMode::Navigate: String = "navigate"
pub val RequestMode::SameOrigin: String = "same-origin"
pub val RequestMode::NoCors: String = "no-cors"
pub val RequestMode::Cors: String = "cors"

pub val RequestCredentials::Omit: String = "omit"
pub val RequestCredentials::SameOrigin: String = "same-origin"
pub val RequestCredentials::Include: String = "include"

pub val RequestRedirect::Follow: String = "follow"
pub val RequestRedirect::Error: String = "error"
pub val RequestRedirect::Manual: String = "manual"

pub val RequestCache::Default: String = "default"
pub val RequestCache::NoStore: String = "no-store"
pub val RequestCache::Reload: String = "reload"
pub val RequestCache::NoCache: String = "no-cache"
pub val RequestCache::ForceCache: String = "force-cache"
pub val RequestCache::OnlyIfCached: String = "only-if-cached"

pub val FetchPriority::Low: String = "low"
pub val FetchPriority::Auto: String = "auto"
pub val FetchPriority::High: String = "high"

pub val RequestDuplex::Half: String = "half"

pub val IPAddressSpace::Loopback: String = "loopback"
pub val IPAddressSpace::Local: String = "local"
pub val IPAddressSpace::Private: String = "private"
pub val IPAddressSpace::Public: String = "public"
pub val IPAddressSpace::Unknown: String = "unknown"

pub val ReferrerPolicy::NoReferrer: String = "no-referrer"
pub val ReferrerPolicy::NoReferrerWhenDowngrade: String = "no-referrer-when-downgrade"
pub val ReferrerPolicy::SameOrigin: String = "same-origin"
pub val ReferrerPolicy::Origin: String = "origin"
pub val ReferrerPolicy::StrictOrigin: String = "strict-origin"
pub val ReferrerPolicy::OriginWhenCrossOrigin: String = "origin-when-cross-origin"
pub val ReferrerPolicy::StrictOriginWhenCrossOrigin: String = "strict-origin-when-cross-origin"
pub val ReferrerPolicy::UnsafeUrl: String = "unsafe-url"

struct Request()

pub ext fun Request::from_any_mrequest_init(input: JsValue, init: mut RequestInit) -> mut Request
    = "return new Request(#var(input), #fun(RequestInit::as_js)(#var(init)));"

pub ext fun Request::method(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).method);"

pub ext fun Request::url(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun Request::headers(self: Request) -> mut Headers
    = "return #fun(Headers::from_js)(#var(self).headers);"

pub ext fun Request::destination(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).destination);"

pub ext fun Request::referrer(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).referrer);"

pub ext fun Request::referrer_policy(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun Request::mode(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).mode);"

pub ext fun Request::credentials(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).credentials);"

pub ext fun Request::cache(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).cache);"

pub ext fun Request::redirect(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).redirect);"

pub ext fun Request::integrity(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).integrity);"

pub ext fun Request::keepalive(self: Request) -> Bool
    = "return #fun(Bool::from_js)(#var(self).keepalive);"

pub ext fun Request::signal(self: Request) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun Request::duplex(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).duplex);"

pub ext fun Request::target_address_space(self: Request) -> String
    = "return #fun(String::from_js)(#var(self).targetAddressSpace);"

pub ext fun Request::is_history_navigation(self: Request) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isHistoryNavigation);"

pub ext fun Request::body(self: Request) -> Option[mut ReadableStream]
    = "return #fun(Option::from_js[mut ReadableStream])(#var(self).body);"

pub ext fun Request::body_used(self: Request) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bodyUsed);"

pub ext fun Request::clone(__self: mut Request) -> mut Request = "
    const r = #var(__self).clone();
    return #fun(Request::from_js)(r);
"

pub ext fun Request::array_buffer(__self: mut Request) -> Promise[JsValue] = "
    const r = #var(__self).arrayBuffer();
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Request::blob(__self: mut Request) -> Promise[mut Blob] = "
    const r = #var(__self).blob();
    return #fun(Promise::from_js[mut Blob])(r);
"

pub ext fun Request::bytes(__self: mut Request) -> Promise[JsValue] = "
    const r = #var(__self).bytes();
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Request::form_data(__self: mut Request) -> Promise[mut FormData] = "
    const r = #var(__self).formData();
    return #fun(Promise::from_js[mut FormData])(r);
"

pub ext fun Request::json(__self: mut Request) -> Promise[JsValue] = "
    const r = #var(__self).json();
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Request::text(__self: mut Request) -> Promise[String] = "
    const r = #var(__self).text();
    return #fun(Promise::from_js[String])(r);
"

pub fun Request::as_js(self: Request) -> JsValue = JsValue::unsafe_from[Request](self)

pub fun Request::from_js(v: JsValue) -> mut Request = JsValue::unsafe_as[mut Request](v)

pub struct RequestInit(
    method: Option[String],
    headers: Option[JsValue],
    body: Option[JsValue],
    referrer: Option[String],
    referrer_policy: Option[String],
    mode: Option[String],
    credentials: Option[String],
    cache: Option[String],
    redirect: Option[String],
    integrity: Option[String],
    keepalive: Option[Bool],
    priority: Option[String],
    browsing_topics: Option[Bool],
    ad_auction_headers: Option[Bool],
    shared_storage_writable: Option[Bool],
    signal: Option[mut AbortSignal],
    duplex: Option[String],
    target_address_space: Option[String],
    private_token: Option[mut PrivateToken],
    attribution_reporting: Option[mut AttributionReportingRequestOptions],
    retry_options: Option[mut RetryOptions]
)

pub fun RequestInit::default() -> mut RequestInit
    = RequestInit(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun RequestInit::from_js(value: JsValue) -> mut RequestInit = "
    const r = {};
    r.m_method = #fun(Option::from_js[String])(#var(value).method);
    r.m_headers = #fun(Option::from_js[JsValue])(#var(value).headers);
    r.m_body = #fun(Option::from_js[JsValue])(#var(value).body);
    r.m_referrer = #fun(Option::from_js[String])(#var(value).referrer);
    r.m_referrer_policy = #fun(Option::from_js[String])(#var(value).referrerPolicy);
    r.m_mode = #fun(Option::from_js[String])(#var(value).mode);
    r.m_credentials = #fun(Option::from_js[String])(#var(value).credentials);
    r.m_cache = #fun(Option::from_js[String])(#var(value).cache);
    r.m_redirect = #fun(Option::from_js[String])(#var(value).redirect);
    r.m_integrity = #fun(Option::from_js[String])(#var(value).integrity);
    r.m_keepalive = #fun(Option::from_js[Bool])(#var(value).keepalive);
    r.m_priority = #fun(Option::from_js[String])(#var(value).priority);
    r.m_browsing_topics = #fun(Option::from_js[Bool])(#var(value).browsingTopics);
    r.m_ad_auction_headers = #fun(Option::from_js[Bool])(#var(value).adAuctionHeaders);
    r.m_shared_storage_writable = #fun(Option::from_js[Bool])(#var(value).sharedStorageWritable);
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    r.m_duplex = #fun(Option::from_js[String])(#var(value).duplex);
    r.m_target_address_space = #fun(Option::from_js[String])(#var(value).targetAddressSpace);
    r.m_private_token = #fun(Option::from_js[mut PrivateToken])(#var(value).privateToken);
    r.m_attribution_reporting = #fun(Option::from_js[mut AttributionReportingRequestOptions])(#var(value).attributionReporting);
    r.m_retry_options = #fun(Option::from_js[mut RetryOptions])(#var(value).retryOptions);
    return r;
"

pub ext fun RequestInit::as_js(self: RequestInit) -> JsValue = "
    const r = {};
    r.method = #fun(Option::as_js_undef[String])(#var(self).m_method);
    r.headers = #fun(Option::as_js_undef[JsValue])(#var(self).m_headers);
    r.body = #fun(Option::as_js_undef[JsValue])(#var(self).m_body);
    r.referrer = #fun(Option::as_js_undef[String])(#var(self).m_referrer);
    r.referrerPolicy = #fun(Option::as_js_undef[String])(#var(self).m_referrer_policy);
    r.mode = #fun(Option::as_js_undef[String])(#var(self).m_mode);
    r.credentials = #fun(Option::as_js_undef[String])(#var(self).m_credentials);
    r.cache = #fun(Option::as_js_undef[String])(#var(self).m_cache);
    r.redirect = #fun(Option::as_js_undef[String])(#var(self).m_redirect);
    r.integrity = #fun(Option::as_js_undef[String])(#var(self).m_integrity);
    r.keepalive = #fun(Option::as_js_undef[Bool])(#var(self).m_keepalive);
    r.priority = #fun(Option::as_js_undef[String])(#var(self).m_priority);
    r.browsingTopics = #fun(Option::as_js_undef[Bool])(#var(self).m_browsing_topics);
    r.adAuctionHeaders = #fun(Option::as_js_undef[Bool])(#var(self).m_ad_auction_headers);
    r.sharedStorageWritable = #fun(Option::as_js_undef[Bool])(#var(self).m_shared_storage_writable);
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    r.duplex = #fun(Option::as_js_undef[String])(#var(self).m_duplex);
    r.targetAddressSpace = #fun(Option::as_js_undef[String])(#var(self).m_target_address_space);
    r.privateToken = #fun(Option::as_js_undef[mut PrivateToken])(#var(self).m_private_token);
    r.attributionReporting = #fun(Option::as_js_undef[mut AttributionReportingRequestOptions])(#var(self).m_attribution_reporting);
    r.retryOptions = #fun(Option::as_js_undef[mut RetryOptions])(#var(self).m_retry_options);
    return r;
"

pub val ResponseType::Basic: String = "basic"
pub val ResponseType::Cors: String = "cors"
pub val ResponseType::Default: String = "default"
pub val ResponseType::Error: String = "error"
pub val ResponseType::Opaque: String = "opaque"
pub val ResponseType::Opaqueredirect: String = "opaqueredirect"

struct Response()

pub ext fun Response::from_any_mresponse_init(body: JsValue, init: mut ResponseInit) -> mut Response
    = "return new Response(#var(body), #fun(ResponseInit::as_js)(#var(init)));"

pub ext fun Response::type(self: Response) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Response::url(self: Response) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun Response::redirected(self: Response) -> Bool
    = "return #fun(Bool::from_js)(#var(self).redirected);"

pub ext fun Response::status(self: Response) -> Int
    = "return #fun(Int::from_js)(#var(self).status);"

pub ext fun Response::ok(self: Response) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ok);"

pub ext fun Response::status_text(self: Response) -> String
    = "return #fun(String::from_js)(#var(self).statusText);"

pub ext fun Response::headers(self: Response) -> mut Headers
    = "return #fun(Headers::from_js)(#var(self).headers);"

pub ext fun Response::body(self: Response) -> Option[mut ReadableStream]
    = "return #fun(Option::from_js[mut ReadableStream])(#var(self).body);"

pub ext fun Response::body_used(self: Response) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bodyUsed);"

pub ext fun Response::error() -> mut Response = "
    const r = Response.error();
    return #fun(Response::from_js)(r);
"

pub ext fun Response::redirect(url: String, status: Int) -> mut Response = "
    const r = Response.redirect(#fun(String::as_js)(#var(url)), #fun(Int::as_js)(#var(status)));
    return #fun(Response::from_js)(r);
"

pub ext fun Response::json(data: JsValue, init: mut ResponseInit) -> mut Response = "
    const r = Response.json(#var(data), #fun(ResponseInit::as_js)(#var(init)));
    return #fun(Response::from_js)(r);
"

pub ext fun Response::clone(__self: mut Response) -> mut Response = "
    const r = #var(__self).clone();
    return #fun(Response::from_js)(r);
"

pub ext fun Response::array_buffer(__self: mut Response) -> Promise[JsValue] = "
    const r = #var(__self).arrayBuffer();
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Response::blob(__self: mut Response) -> Promise[mut Blob] = "
    const r = #var(__self).blob();
    return #fun(Promise::from_js[mut Blob])(r);
"

pub ext fun Response::bytes(__self: mut Response) -> Promise[JsValue] = "
    const r = #var(__self).bytes();
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Response::form_data(__self: mut Response) -> Promise[mut FormData] = "
    const r = #var(__self).formData();
    return #fun(Promise::from_js[mut FormData])(r);
"

pub ext fun Response::text(__self: mut Response) -> Promise[String] = "
    const r = #var(__self).text();
    return #fun(Promise::from_js[String])(r);
"

pub fun Response::as_js(self: Response) -> JsValue = JsValue::unsafe_from[Response](self)

pub fun Response::from_js(v: JsValue) -> mut Response = JsValue::unsafe_as[mut Response](v)

pub struct ResponseInit(
    status: Option[Int],
    status_text: Option[String],
    headers: Option[JsValue]
)

pub fun ResponseInit::default() -> mut ResponseInit
    = ResponseInit(Option::Some(200), Option::Some(""), Option::None)

pub ext fun ResponseInit::from_js(value: JsValue) -> mut ResponseInit = "
    const r = {};
    r.m_status = #fun(Option::from_js[Int])(#var(value).status);
    r.m_status_text = #fun(Option::from_js[String])(#var(value).statusText);
    r.m_headers = #fun(Option::from_js[JsValue])(#var(value).headers);
    return r;
"

pub ext fun ResponseInit::as_js(self: ResponseInit) -> JsValue = "
    const r = {};
    r.status = #fun(Option::as_js_undef[Int])(#var(self).m_status);
    r.statusText = #fun(Option::as_js_undef[String])(#var(self).m_status_text);
    r.headers = #fun(Option::as_js_undef[JsValue])(#var(self).m_headers);
    return r;
"

pub struct RetryOptions(
    max_attempts: Int,
    initial_delay: Option[Int],
    backoff_factor: Option[Float],
    max_age: Option[Int],
    retry_after_unload: Option[Bool],
    retry_non_idempotent: Option[Bool],
    retry_only_if_server_unreached: Option[Bool]
)

pub fun RetryOptions::default(max_attempts: Int) -> mut RetryOptions
    = RetryOptions(max_attempts, Option::None, Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun RetryOptions::from_js(value: JsValue) -> mut RetryOptions = "
    const r = {};
    r.m_max_attempts = #fun(Int::from_js)(#var(value).maxAttempts);
    r.m_initial_delay = #fun(Option::from_js[Int])(#var(value).initialDelay);
    r.m_backoff_factor = #fun(Option::from_js[Float])(#var(value).backoffFactor);
    r.m_max_age = #fun(Option::from_js[Int])(#var(value).maxAge);
    r.m_retry_after_unload = #fun(Option::from_js[Bool])(#var(value).retryAfterUnload);
    r.m_retry_non_idempotent = #fun(Option::from_js[Bool])(#var(value).retryNonIdempotent);
    r.m_retry_only_if_server_unreached = #fun(Option::from_js[Bool])(#var(value).retryOnlyIfServerUnreached);
    return r;
"

pub ext fun RetryOptions::as_js(self: RetryOptions) -> JsValue = "
    const r = {};
    r.maxAttempts = #fun(Int::as_js)(#var(self).m_max_attempts);
    r.initialDelay = #fun(Option::as_js_undef[Int])(#var(self).m_initial_delay);
    r.backoffFactor = #fun(Option::as_js_undef[Float])(#var(self).m_backoff_factor);
    r.maxAge = #fun(Option::as_js_undef[Int])(#var(self).m_max_age);
    r.retryAfterUnload = #fun(Option::as_js_undef[Bool])(#var(self).m_retry_after_unload);
    r.retryNonIdempotent = #fun(Option::as_js_undef[Bool])(#var(self).m_retry_non_idempotent);
    r.retryOnlyIfServerUnreached = #fun(Option::as_js_undef[Bool])(#var(self).m_retry_only_if_server_unreached);
    return r;
"

pub ext fun Internals::get_internal_response_url_list(__self: mut Internals, response: mut Response) -> List[String] = "
    const r = #var(__self).getInternalResponseURLList(#fun(Response::as_js)(#var(response)));
    return #fun(List::from_js[String])(r);
"

struct WorkerInternals()

pub ext fun WorkerInternals::get_internal_response_url_list(__self: mut WorkerInternals, response: mut Response) -> List[String] = "
    const r = #var(__self).getInternalResponseURLList(#fun(Response::as_js)(#var(response)));
    return #fun(List::from_js[String])(r);
"

pub ext fun WorkerInternals::get_initial_resource_priority(__self: mut WorkerInternals, url: String, worker__global: mut WorkerGlobalScope) -> Promise[Int] = "
    const r = #var(__self).getInitialResourcePriority(#fun(String::as_js)(#var(url)), #fun(WorkerGlobalScope::as_js)(#var(worker__global)));
    return #fun(Promise::from_js[Int])(r);
"

pub fun WorkerInternals::as_js(self: WorkerInternals) -> JsValue = JsValue::unsafe_from[WorkerInternals](self)

pub fun WorkerInternals::from_js(v: JsValue) -> mut WorkerInternals = JsValue::unsafe_as[mut WorkerInternals](v)

pub ext fun Window::fetch(__self: mut Window, input: JsValue, init: mut RequestInit) -> Promise[mut Response] = "
    const r = #var(__self).fetch(#var(input), #fun(RequestInit::as_js)(#var(init)));
    return #fun(Promise::from_js[mut Response])(r);
"

struct WorkerGlobalScope()

pub ext fun WorkerGlobalScope::is_secure_context(self: WorkerGlobalScope) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isSecureContext);"

pub ext fun WorkerGlobalScope::scheduler(self: WorkerGlobalScope) -> mut Scheduler
    = "return #fun(Scheduler::from_js)(#var(self).scheduler);"

pub ext fun WorkerGlobalScope::fonts(self: WorkerGlobalScope) -> mut FontFaceSet
    = "return #fun(FontFaceSet::from_js)(#var(self).fonts);"

pub ext fun WorkerGlobalScope::fetch(__self: mut WorkerGlobalScope, input: JsValue, init: mut RequestInit) -> Promise[mut Response] = "
    const r = #var(__self).fetch(#var(input), #fun(RequestInit::as_js)(#var(init)));
    return #fun(Promise::from_js[mut Response])(r);
"

pub ext fun WorkerGlobalScope::report_error(__self: mut WorkerGlobalScope, e: JsValue) -> Unit = "
    const r = #var(__self).reportError(#var(e));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerGlobalScope::btoa(__self: mut WorkerGlobalScope, btoa: String) -> String = "
    const r = #var(__self).btoa(#fun(String::as_js)(#var(btoa)));
    return #fun(String::from_js)(r);
"

pub ext fun WorkerGlobalScope::atob(__self: mut WorkerGlobalScope, atob: String) -> String = "
    const r = #var(__self).atob(#fun(String::as_js)(#var(atob)));
    return #fun(String::from_js)(r);
"

pub ext fun WorkerGlobalScope::queue_microtask(__self: mut WorkerGlobalScope, callback: Fun() -> Unit) -> Unit = "
    const r = #var(__self).queueMicrotask((() => { const r = #var(callback)(); return #fun(Unit::as_js)(r); }));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerGlobalScope::structured_clone(__self: mut WorkerGlobalScope, value: JsValue, options: mut StructuredSerializeOptions) -> JsValue = "
    const r = #var(__self).structuredClone(#var(value), #fun(StructuredSerializeOptions::as_js)(#var(options)));
    return r;
"

pub fun WorkerGlobalScope::as_js(self: WorkerGlobalScope) -> JsValue = JsValue::unsafe_from[WorkerGlobalScope](self)

pub fun WorkerGlobalScope::from_js(v: JsValue) -> mut WorkerGlobalScope = JsValue::unsafe_as[mut WorkerGlobalScope](v)

struct Blob()

pub ext fun Blob::from_list_any_mblob_property_bag(blob_parts: List[JsValue], options: mut BlobPropertyBag) -> mut Blob
    = "return new Blob(#fun(List::as_js[JsValue])(#var(blob_parts)), #fun(BlobPropertyBag::as_js)(#var(options)));"

pub ext fun Blob::size(self: Blob) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun Blob::type(self: Blob) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Blob::slice(__self: mut Blob, start: Int, end: Int, content_type: String) -> mut Blob = "
    const r = #var(__self).slice(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(String::as_js)(#var(content_type)));
    return #fun(Blob::from_js)(r);
"

pub ext fun Blob::stream(__self: mut Blob) -> mut ReadableStream = "
    const r = #var(__self).stream();
    return #fun(ReadableStream::from_js)(r);
"

pub ext fun Blob::text(__self: mut Blob) -> Promise[String] = "
    const r = #var(__self).text();
    return #fun(Promise::from_js[String])(r);
"

pub ext fun Blob::array_buffer(__self: mut Blob) -> Promise[JsValue] = "
    const r = #var(__self).arrayBuffer();
    return #fun(Promise::from_js[JsValue])(r);
"

pub fun Blob::as_js(self: Blob) -> JsValue = JsValue::unsafe_from[Blob](self)

pub fun Blob::from_js(v: JsValue) -> mut Blob = JsValue::unsafe_as[mut Blob](v)

pub val EndingType::Transparent: String = "transparent"
pub val EndingType::Native: String = "native"

pub struct BlobPropertyBag(
    type: Option[String],
    endings: Option[String]
)

pub fun BlobPropertyBag::default() -> mut BlobPropertyBag
    = BlobPropertyBag(Option::Some(""), Option::Some("transparent"))

pub ext fun BlobPropertyBag::from_js(value: JsValue) -> mut BlobPropertyBag = "
    const r = {};
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_endings = #fun(Option::from_js[String])(#var(value).endings);
    return r;
"

pub ext fun BlobPropertyBag::as_js(self: BlobPropertyBag) -> JsValue = "
    const r = {};
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.endings = #fun(Option::as_js_undef[String])(#var(self).m_endings);
    return r;
"

struct File()

/// Converts a reference to 'File' to a reference to 'Blob'.
/// This does not involve manipulating the object or reference.
pub ext fun File::as_blob(self: File) -> Blob = "return #var(self);"

/// Converts a mutable reference to 'File' to a mutable reference to 'Blob'.
/// This does not involve manipulating the object or reference.
pub ext fun File::as_mblob(self: mut File) -> mut Blob = "return #var(self);"

/// Attempts to convert a reference to 'Blob' to a reference to 'File'.
/// The conversion may fail and panic if 'base' is not a reference to 'File' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun File::from_blob(base: Blob) -> File = "
    if(#var(base) instanceof File) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Blob' to 'File'!\");
"

/// Attempts to convert a mutable reference to 'Blob' to a mutable reference to 'File'.
/// The conversion may fail and panic if 'base' is not a reference to 'File' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun File::from_mblob(base: mut Blob) -> mut File = "
    if(#var(base) instanceof File) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Blob' to 'File'!\");
"

pub ext fun File::from_list_any_str_mfile_property_bag(file_bits: List[JsValue], file_name: String, options: mut FilePropertyBag) -> mut File
    = "return new File(#fun(List::as_js[JsValue])(#var(file_bits)), #fun(String::as_js)(#var(file_name)), #fun(FilePropertyBag::as_js)(#var(options)));"

pub ext fun File::name(self: File) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun File::last_modified(self: File) -> Int
    = "return #fun(Int::from_js)(#var(self).lastModified);"

pub ext fun File::last_modified_date(self: File) -> Option[JsObject]
    = "return #fun(Option::from_js[JsObject])(#var(self).lastModifiedDate);"

pub ext fun File::webkit_relative_path(self: File) -> String
    = "return #fun(String::from_js)(#var(self).webkitRelativePath);"

pub ext fun File::size(self: File) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun File::type(self: File) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun File::slice(__self: mut File, start: Int, end: Int, content_type: String) -> mut Blob = "
    const r = #var(__self).slice(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(String::as_js)(#var(content_type)));
    return #fun(Blob::from_js)(r);
"

pub ext fun File::stream(__self: mut File) -> mut ReadableStream = "
    const r = #var(__self).stream();
    return #fun(ReadableStream::from_js)(r);
"

pub ext fun File::text(__self: mut File) -> Promise[String] = "
    const r = #var(__self).text();
    return #fun(Promise::from_js[String])(r);
"

pub ext fun File::array_buffer(__self: mut File) -> Promise[JsValue] = "
    const r = #var(__self).arrayBuffer();
    return #fun(Promise::from_js[JsValue])(r);
"

pub fun File::as_js(self: File) -> JsValue = JsValue::unsafe_from[File](self)

pub fun File::from_js(v: JsValue) -> mut File = JsValue::unsafe_as[mut File](v)

struct FileList()

pub ext fun FileList::length(self: FileList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun FileList::item(__self: mut FileList, index: Int) -> Option[mut File] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut File])(r);
"

pub fun FileList::as_js(self: FileList) -> JsValue = JsValue::unsafe_from[FileList](self)

pub fun FileList::from_js(v: JsValue) -> mut FileList = JsValue::unsafe_as[mut FileList](v)

pub struct FilePropertyBag(
    last_modified: Option[Int],
    type: Option[String],
    endings: Option[String]
)

pub fun FilePropertyBag::default() -> mut FilePropertyBag
    = FilePropertyBag(Option::None, Option::Some(""), Option::Some("transparent"))

/// Converts a reference to 'FilePropertyBag' to a reference to 'BlobPropertyBag'.
/// This does not involve manipulating the object or reference.
pub ext fun FilePropertyBag::as_blob_property_bag(self: FilePropertyBag) -> BlobPropertyBag = "return #var(self);"

/// Converts a mutable reference to 'FilePropertyBag' to a mutable reference to 'BlobPropertyBag'.
/// This does not involve manipulating the object or reference.
pub ext fun FilePropertyBag::as_mblob_property_bag(self: mut FilePropertyBag) -> mut BlobPropertyBag = "return #var(self);"

/// Attempts to convert a reference to 'BlobPropertyBag' to a reference to 'FilePropertyBag'.
/// A 'base' that is not a reference to 'FilePropertyBag' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FilePropertyBag::from_blob_property_bag_unchecked(base: BlobPropertyBag) -> FilePropertyBag = "return #var(base);"

/// Attempts to convert a mutable reference to 'BlobPropertyBag' to a mutable reference to 'FilePropertyBag'.
/// A 'base' that is not a reference to 'FilePropertyBag' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FilePropertyBag::from_mblob_property_bag_unchecked(base: mut BlobPropertyBag) -> mut FilePropertyBag = "return #var(base);"

pub ext fun FilePropertyBag::from_js(value: JsValue) -> mut FilePropertyBag = "
    const r = {};
    r.m_last_modified = #fun(Option::from_js[Int])(#var(value).lastModified);
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_endings = #fun(Option::from_js[String])(#var(value).endings);
    return r;
"

pub ext fun FilePropertyBag::as_js(self: FilePropertyBag) -> JsValue = "
    const r = {};
    r.lastModified = #fun(Option::as_js_undef[Int])(#var(self).m_last_modified);
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.endings = #fun(Option::as_js_undef[String])(#var(self).m_endings);
    return r;
"

struct FileReader()

/// Converts a reference to 'FileReader' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun FileReader::as_event_target(self: FileReader) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'FileReader' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun FileReader::as_mevent_target(self: mut FileReader) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'FileReader'.
/// The conversion may fail and panic if 'base' is not a reference to 'FileReader' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FileReader::from_event_target(base: EventTarget) -> FileReader = "
    if(#var(base) instanceof FileReader) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'FileReader'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'FileReader'.
/// The conversion may fail and panic if 'base' is not a reference to 'FileReader' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FileReader::from_mevent_target(base: mut EventTarget) -> mut FileReader = "
    if(#var(base) instanceof FileReader) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'FileReader'!\");
"

pub ext fun FileReader::new() -> mut FileReader
    = "return new FileReader();"

pub ext fun FileReader::ready_state(self: FileReader) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun FileReader::result(self: FileReader) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).result);"

pub ext fun FileReader::error(self: FileReader) -> Option[mut DOMException]
    = "return #fun(Option::from_js[mut DOMException])(#var(self).error);"

pub ext fun FileReader::onloadstart(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun FileReader::set_onloadstart(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::onprogress(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun FileReader::set_onprogress(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::onload(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun FileReader::set_onload(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::onabort(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun FileReader::set_onabort(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::onerror(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun FileReader::set_onerror(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::onloadend(self: FileReader) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadend);"

pub ext fun FileReader::set_onloadend(self: mut FileReader, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun FileReader::read_as_array_buffer(__self: mut FileReader, blob: mut Blob) -> Unit = "
    const r = #var(__self).readAsArrayBuffer(#fun(Blob::as_js)(#var(blob)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::read_as_binary_string(__self: mut FileReader, blob: mut Blob) -> Unit = "
    const r = #var(__self).readAsBinaryString(#fun(Blob::as_js)(#var(blob)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::read_as_text(__self: mut FileReader, blob: mut Blob, label: String) -> Unit = "
    const r = #var(__self).readAsText(#fun(Blob::as_js)(#var(blob)), #fun(String::as_js)(#var(label)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::read_as_data_url(__self: mut FileReader, blob: mut Blob) -> Unit = "
    const r = #var(__self).readAsDataURL(#fun(Blob::as_js)(#var(blob)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::abort(__self: mut FileReader) -> Unit = "
    const r = #var(__self).abort();
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::add_event_listener(__self: mut FileReader, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::remove_event_listener(__self: mut FileReader, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun FileReader::dispatch_event(__self: mut FileReader, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun FileReader::when(__self: mut FileReader, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun FileReader::as_js(self: FileReader) -> JsValue = JsValue::unsafe_from[FileReader](self)

pub fun FileReader::from_js(v: JsValue) -> mut FileReader = JsValue::unsafe_as[mut FileReader](v)

pub val FileReader::empty: Int = 0
pub val FileReader::loading: Int = 1
pub val FileReader::done: Int = 2

struct FileReaderSync()

pub ext fun FileReaderSync::new() -> mut FileReaderSync
    = "return new FileReaderSync();"

pub ext fun FileReaderSync::read_as_array_buffer(__self: mut FileReaderSync, blob: mut Blob) -> JsValue = "
    const r = #var(__self).readAsArrayBuffer(#fun(Blob::as_js)(#var(blob)));
    return r;
"

pub ext fun FileReaderSync::read_as_binary_string(__self: mut FileReaderSync, blob: mut Blob) -> String = "
    const r = #var(__self).readAsBinaryString(#fun(Blob::as_js)(#var(blob)));
    return #fun(String::from_js)(r);
"

pub ext fun FileReaderSync::read_as_text(__self: mut FileReaderSync, blob: mut Blob, label: String) -> String = "
    const r = #var(__self).readAsText(#fun(Blob::as_js)(#var(blob)), #fun(String::as_js)(#var(label)));
    return #fun(String::from_js)(r);
"

pub ext fun FileReaderSync::read_as_data_url(__self: mut FileReaderSync, blob: mut Blob) -> String = "
    const r = #var(__self).readAsDataURL(#fun(Blob::as_js)(#var(blob)));
    return #fun(String::from_js)(r);
"

pub fun FileReaderSync::as_js(self: FileReaderSync) -> JsValue = JsValue::unsafe_from[FileReaderSync](self)

pub fun FileReaderSync::from_js(v: JsValue) -> mut FileReaderSync = JsValue::unsafe_as[mut FileReaderSync](v)

struct URL()

pub ext fun URL::create_object_url(blob: mut Blob) -> String = "
    const r = URL.createObjectURL(#fun(Blob::as_js)(#var(blob)));
    return #fun(String::from_js)(r);
"

pub ext fun URL::revoke_object_url(url: String) -> Unit = "
    const r = URL.revokeObjectURL(#fun(String::as_js)(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub fun URL::as_js(self: URL) -> JsValue = JsValue::unsafe_from[URL](self)

pub fun URL::from_js(v: JsValue) -> mut URL = JsValue::unsafe_as[mut URL](v)

struct FragmentDirective()

pub ext fun FragmentDirective::items(self: FragmentDirective) -> JsValue
    = "return #var(self).items;"

pub ext fun FragmentDirective::create_selector_directive(__self: mut FragmentDirective, arg: JsValue) -> Promise[mut SelectorDirective] = "
    const r = #var(__self).createSelectorDirective(#var(arg));
    return #fun(Promise::from_js[mut SelectorDirective])(r);
"

pub fun FragmentDirective::as_js(self: FragmentDirective) -> JsValue = JsValue::unsafe_from[FragmentDirective](self)

pub fun FragmentDirective::from_js(v: JsValue) -> mut FragmentDirective = JsValue::unsafe_as[mut FragmentDirective](v)

struct TextDirective()

/// Converts a reference to 'TextDirective' to a reference to 'SelectorDirective'.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::as_selector_directive(self: TextDirective) -> SelectorDirective = "return #var(self);"

/// Converts a mutable reference to 'TextDirective' to a mutable reference to 'SelectorDirective'.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::as_mselector_directive(self: mut TextDirective) -> mut SelectorDirective = "return #var(self);"

/// Attempts to convert a reference to 'SelectorDirective' to a reference to 'TextDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::from_selector_directive(base: SelectorDirective) -> TextDirective = "
    if(#var(base) instanceof TextDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SelectorDirective' to 'TextDirective'!\");
"

/// Attempts to convert a mutable reference to 'SelectorDirective' to a mutable reference to 'TextDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::from_mselector_directive(base: mut SelectorDirective) -> mut TextDirective = "
    if(#var(base) instanceof TextDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SelectorDirective' to 'TextDirective'!\");
"

/// Converts a reference to 'TextDirective' to a reference to 'Directive'.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::as_directive(self: TextDirective) -> Directive = "return #var(self);"

/// Converts a mutable reference to 'TextDirective' to a mutable reference to 'Directive'.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::as_mdirective(self: mut TextDirective) -> mut Directive = "return #var(self);"

/// Attempts to convert a reference to 'Directive' to a reference to 'TextDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::from_directive(base: Directive) -> TextDirective = "
    if(#var(base) instanceof TextDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Directive' to 'TextDirective'!\");
"

/// Attempts to convert a mutable reference to 'Directive' to a mutable reference to 'TextDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextDirective::from_mdirective(base: mut Directive) -> mut TextDirective = "
    if(#var(base) instanceof TextDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Directive' to 'TextDirective'!\");
"

pub ext fun TextDirective::from_mtext_directive_options(options: mut TextDirectiveOptions) -> mut TextDirective
    = "return new TextDirective(#fun(TextDirectiveOptions::as_js)(#var(options)));"

pub ext fun TextDirective::prefix(self: TextDirective) -> String
    = "return #fun(String::from_js)(#var(self).prefix);"

pub ext fun TextDirective::text_start(self: TextDirective) -> String
    = "return #fun(String::from_js)(#var(self).textStart);"

pub ext fun TextDirective::text_end(self: TextDirective) -> String
    = "return #fun(String::from_js)(#var(self).textEnd);"

pub ext fun TextDirective::suffix(self: TextDirective) -> String
    = "return #fun(String::from_js)(#var(self).suffix);"

pub ext fun TextDirective::type(self: TextDirective) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TextDirective::get_matching_range(__self: mut TextDirective) -> Promise[mut Range] = "
    const r = #var(__self).getMatchingRange();
    return #fun(Promise::from_js[mut Range])(r);
"

pub fun TextDirective::as_js(self: TextDirective) -> JsValue = JsValue::unsafe_from[TextDirective](self)

pub fun TextDirective::from_js(v: JsValue) -> mut TextDirective = JsValue::unsafe_as[mut TextDirective](v)

pub struct TextDirectiveOptions(
    prefix: Option[String],
    text_start: Option[String],
    text_end: Option[String],
    suffix: Option[String]
)

pub fun TextDirectiveOptions::default() -> mut TextDirectiveOptions
    = TextDirectiveOptions(Option::None, Option::None, Option::None, Option::None)

pub ext fun TextDirectiveOptions::from_js(value: JsValue) -> mut TextDirectiveOptions = "
    const r = {};
    r.m_prefix = #fun(Option::from_js[String])(#var(value).prefix);
    r.m_text_start = #fun(Option::from_js[String])(#var(value).textStart);
    r.m_text_end = #fun(Option::from_js[String])(#var(value).textEnd);
    r.m_suffix = #fun(Option::from_js[String])(#var(value).suffix);
    return r;
"

pub ext fun TextDirectiveOptions::as_js(self: TextDirectiveOptions) -> JsValue = "
    const r = {};
    r.prefix = #fun(Option::as_js_undef[String])(#var(self).m_prefix);
    r.textStart = #fun(Option::as_js_undef[String])(#var(self).m_text_start);
    r.textEnd = #fun(Option::as_js_undef[String])(#var(self).m_text_end);
    r.suffix = #fun(Option::as_js_undef[String])(#var(self).m_suffix);
    return r;
"

struct BarProp()

pub ext fun BarProp::visible(self: BarProp) -> Bool
    = "return #fun(Bool::from_js)(#var(self).visible);"

pub fun BarProp::as_js(self: BarProp) -> JsValue = JsValue::unsafe_from[BarProp](self)

pub fun BarProp::from_js(v: JsValue) -> mut BarProp = JsValue::unsafe_as[mut BarProp](v)

struct CoopAccessViolationReportBody()

/// Converts a reference to 'CoopAccessViolationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun CoopAccessViolationReportBody::as_report_body(self: CoopAccessViolationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'CoopAccessViolationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun CoopAccessViolationReportBody::as_mreport_body(self: mut CoopAccessViolationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'CoopAccessViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'CoopAccessViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CoopAccessViolationReportBody::from_report_body(base: ReportBody) -> CoopAccessViolationReportBody = "
    if(#var(base) instanceof CoopAccessViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'CoopAccessViolationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'CoopAccessViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'CoopAccessViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CoopAccessViolationReportBody::from_mreport_body(base: mut ReportBody) -> mut CoopAccessViolationReportBody = "
    if(#var(base) instanceof CoopAccessViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'CoopAccessViolationReportBody'!\");
"

pub ext fun CoopAccessViolationReportBody::source_file(self: CoopAccessViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun CoopAccessViolationReportBody::line_number(self: CoopAccessViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun CoopAccessViolationReportBody::column_number(self: CoopAccessViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun CoopAccessViolationReportBody::type(self: CoopAccessViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CoopAccessViolationReportBody::property(self: CoopAccessViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).property);"

pub ext fun CoopAccessViolationReportBody::openee_url(self: CoopAccessViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).openeeURL);"

pub ext fun CoopAccessViolationReportBody::opener_url(self: CoopAccessViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).openerURL);"

pub ext fun CoopAccessViolationReportBody::other_document_url(self: CoopAccessViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).otherDocumentURL);"

pub ext fun CoopAccessViolationReportBody::to_json(__self: mut CoopAccessViolationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun CoopAccessViolationReportBody::as_js(self: CoopAccessViolationReportBody) -> JsValue = JsValue::unsafe_from[CoopAccessViolationReportBody](self)

pub fun CoopAccessViolationReportBody::from_js(v: JsValue) -> mut CoopAccessViolationReportBody = JsValue::unsafe_as[mut CoopAccessViolationReportBody](v)

struct CSPViolationReportBody()

/// Converts a reference to 'CSPViolationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun CSPViolationReportBody::as_report_body(self: CSPViolationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'CSPViolationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun CSPViolationReportBody::as_mreport_body(self: mut CSPViolationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'CSPViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSPViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSPViolationReportBody::from_report_body(base: ReportBody) -> CSPViolationReportBody = "
    if(#var(base) instanceof CSPViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'CSPViolationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'CSPViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'CSPViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CSPViolationReportBody::from_mreport_body(base: mut ReportBody) -> mut CSPViolationReportBody = "
    if(#var(base) instanceof CSPViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'CSPViolationReportBody'!\");
"

pub ext fun CSPViolationReportBody::document_url(self: CSPViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).documentURL);"

pub ext fun CSPViolationReportBody::referrer(self: CSPViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).referrer);"

pub ext fun CSPViolationReportBody::blocked_url(self: CSPViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).blockedURL);"

pub ext fun CSPViolationReportBody::effective_directive(self: CSPViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).effectiveDirective);"

pub ext fun CSPViolationReportBody::original_policy(self: CSPViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).originalPolicy);"

pub ext fun CSPViolationReportBody::source_file(self: CSPViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun CSPViolationReportBody::sample(self: CSPViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sample);"

pub ext fun CSPViolationReportBody::disposition(self: CSPViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).disposition);"

pub ext fun CSPViolationReportBody::status_code(self: CSPViolationReportBody) -> Int
    = "return #fun(Int::from_js)(#var(self).statusCode);"

pub ext fun CSPViolationReportBody::line_number(self: CSPViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun CSPViolationReportBody::column_number(self: CSPViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun CSPViolationReportBody::to_json(__self: mut CSPViolationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun CSPViolationReportBody::as_js(self: CSPViolationReportBody) -> JsValue = JsValue::unsafe_from[CSPViolationReportBody](self)

pub fun CSPViolationReportBody::from_js(v: JsValue) -> mut CSPViolationReportBody = JsValue::unsafe_as[mut CSPViolationReportBody](v)

struct DeprecationReportBody()

/// Converts a reference to 'DeprecationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun DeprecationReportBody::as_report_body(self: DeprecationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'DeprecationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun DeprecationReportBody::as_mreport_body(self: mut DeprecationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'DeprecationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'DeprecationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DeprecationReportBody::from_report_body(base: ReportBody) -> DeprecationReportBody = "
    if(#var(base) instanceof DeprecationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'DeprecationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'DeprecationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'DeprecationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DeprecationReportBody::from_mreport_body(base: mut ReportBody) -> mut DeprecationReportBody = "
    if(#var(base) instanceof DeprecationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'DeprecationReportBody'!\");
"

pub ext fun DeprecationReportBody::id(self: DeprecationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun DeprecationReportBody::anticipated_removal(self: DeprecationReportBody) -> Option[JsObject]
    = "return #fun(Option::from_js[JsObject])(#var(self).anticipatedRemoval);"

pub ext fun DeprecationReportBody::message(self: DeprecationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub ext fun DeprecationReportBody::source_file(self: DeprecationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun DeprecationReportBody::line_number(self: DeprecationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun DeprecationReportBody::column_number(self: DeprecationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun DeprecationReportBody::to_json(__self: mut DeprecationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DeprecationReportBody::as_js(self: DeprecationReportBody) -> JsValue = JsValue::unsafe_from[DeprecationReportBody](self)

pub fun DeprecationReportBody::from_js(v: JsValue) -> mut DeprecationReportBody = JsValue::unsafe_as[mut DeprecationReportBody](v)

pub val DirectiveType::Text: String = "text"
pub val DirectiveType::Selector: String = "selector"

struct Directive()

pub ext fun Directive::type(self: Directive) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub fun Directive::as_js(self: Directive) -> JsValue = JsValue::unsafe_from[Directive](self)

pub fun Directive::from_js(v: JsValue) -> mut Directive = JsValue::unsafe_as[mut Directive](v)

struct DocumentPolicyViolationReportBody()

/// Converts a reference to 'DocumentPolicyViolationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentPolicyViolationReportBody::as_report_body(self: DocumentPolicyViolationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'DocumentPolicyViolationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentPolicyViolationReportBody::as_mreport_body(self: mut DocumentPolicyViolationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'DocumentPolicyViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentPolicyViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentPolicyViolationReportBody::from_report_body(base: ReportBody) -> DocumentPolicyViolationReportBody = "
    if(#var(base) instanceof DocumentPolicyViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'DocumentPolicyViolationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'DocumentPolicyViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentPolicyViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentPolicyViolationReportBody::from_mreport_body(base: mut ReportBody) -> mut DocumentPolicyViolationReportBody = "
    if(#var(base) instanceof DocumentPolicyViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'DocumentPolicyViolationReportBody'!\");
"

pub ext fun DocumentPolicyViolationReportBody::feature_id(self: DocumentPolicyViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).featureId);"

pub ext fun DocumentPolicyViolationReportBody::source_file(self: DocumentPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun DocumentPolicyViolationReportBody::line_number(self: DocumentPolicyViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun DocumentPolicyViolationReportBody::column_number(self: DocumentPolicyViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun DocumentPolicyViolationReportBody::disposition(self: DocumentPolicyViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).disposition);"

pub ext fun DocumentPolicyViolationReportBody::message(self: DocumentPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).message);"

pub ext fun DocumentPolicyViolationReportBody::to_json(__self: mut DocumentPolicyViolationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DocumentPolicyViolationReportBody::as_js(self: DocumentPolicyViolationReportBody) -> JsValue = JsValue::unsafe_from[DocumentPolicyViolationReportBody](self)

pub fun DocumentPolicyViolationReportBody::from_js(v: JsValue) -> mut DocumentPolicyViolationReportBody = JsValue::unsafe_as[mut DocumentPolicyViolationReportBody](v)

struct External()

pub ext fun External::add_search_provider(__self: mut External) -> Unit = "
    const r = #var(__self).AddSearchProvider();
    return #fun(Unit::from_js)(r);
"

pub ext fun External::is_search_provider_installed(__self: mut External) -> Unit = "
    const r = #var(__self).IsSearchProviderInstalled();
    return #fun(Unit::from_js)(r);
"

pub fun External::as_js(self: External) -> JsValue = JsValue::unsafe_from[External](self)

pub fun External::from_js(v: JsValue) -> mut External = JsValue::unsafe_as[mut External](v)

pub val ScrollRestoration::Auto: String = "auto"
pub val ScrollRestoration::Manual: String = "manual"

struct History()

pub ext fun History::length(self: History) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun History::scroll_restoration(self: History) -> String
    = "return #fun(String::from_js)(#var(self).scrollRestoration);"

pub ext fun History::set_scroll_restoration(self: mut History, value: String)
    = "#var(self).scrollRestoration = #var(value);"

pub ext fun History::state(self: History) -> JsValue
    = "return #var(self).state;"

pub ext fun History::go(__self: mut History, delta: Int) -> Unit = "
    const r = #var(__self).go(#fun(Int::as_js)(#var(delta)));
    return #fun(Unit::from_js)(r);
"

pub ext fun History::back(__self: mut History) -> Unit = "
    const r = #var(__self).back();
    return #fun(Unit::from_js)(r);
"

pub ext fun History::forward(__self: mut History) -> Unit = "
    const r = #var(__self).forward();
    return #fun(Unit::from_js)(r);
"

pub ext fun History::push_state(__self: mut History, data: JsValue, title: String, url: Option[String]) -> Unit = "
    const r = #var(__self).pushState(#var(data), #fun(String::as_js)(#var(title)), #fun(Option::as_js[String])(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub ext fun History::replace_state(__self: mut History, data: JsValue, title: String, url: Option[String]) -> Unit = "
    const r = #var(__self).replaceState(#var(data), #fun(String::as_js)(#var(title)), #fun(Option::as_js[String])(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub fun History::as_js(self: History) -> JsValue = JsValue::unsafe_from[History](self)

pub fun History::from_js(v: JsValue) -> mut History = JsValue::unsafe_as[mut History](v)

struct IntegrityViolationReportBody()

/// Converts a reference to 'IntegrityViolationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun IntegrityViolationReportBody::as_report_body(self: IntegrityViolationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'IntegrityViolationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun IntegrityViolationReportBody::as_mreport_body(self: mut IntegrityViolationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'IntegrityViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'IntegrityViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun IntegrityViolationReportBody::from_report_body(base: ReportBody) -> IntegrityViolationReportBody = "
    if(#var(base) instanceof IntegrityViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'IntegrityViolationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'IntegrityViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'IntegrityViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun IntegrityViolationReportBody::from_mreport_body(base: mut ReportBody) -> mut IntegrityViolationReportBody = "
    if(#var(base) instanceof IntegrityViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'IntegrityViolationReportBody'!\");
"

pub ext fun IntegrityViolationReportBody::document_url(self: IntegrityViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).documentURL);"

pub ext fun IntegrityViolationReportBody::blocked_url(self: IntegrityViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).blockedURL);"

pub ext fun IntegrityViolationReportBody::destination(self: IntegrityViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).destination);"

pub ext fun IntegrityViolationReportBody::report_only(self: IntegrityViolationReportBody) -> Bool
    = "return #fun(Bool::from_js)(#var(self).reportOnly);"

pub ext fun IntegrityViolationReportBody::to_json(__self: mut IntegrityViolationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun IntegrityViolationReportBody::as_js(self: IntegrityViolationReportBody) -> JsValue = JsValue::unsafe_from[IntegrityViolationReportBody](self)

pub fun IntegrityViolationReportBody::from_js(v: JsValue) -> mut IntegrityViolationReportBody = JsValue::unsafe_as[mut IntegrityViolationReportBody](v)

struct InterventionReportBody()

/// Converts a reference to 'InterventionReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun InterventionReportBody::as_report_body(self: InterventionReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'InterventionReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun InterventionReportBody::as_mreport_body(self: mut InterventionReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'InterventionReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'InterventionReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InterventionReportBody::from_report_body(base: ReportBody) -> InterventionReportBody = "
    if(#var(base) instanceof InterventionReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'InterventionReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'InterventionReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'InterventionReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InterventionReportBody::from_mreport_body(base: mut ReportBody) -> mut InterventionReportBody = "
    if(#var(base) instanceof InterventionReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'InterventionReportBody'!\");
"

pub ext fun InterventionReportBody::id(self: InterventionReportBody) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun InterventionReportBody::message(self: InterventionReportBody) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub ext fun InterventionReportBody::source_file(self: InterventionReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun InterventionReportBody::line_number(self: InterventionReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun InterventionReportBody::column_number(self: InterventionReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun InterventionReportBody::to_json(__self: mut InterventionReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun InterventionReportBody::as_js(self: InterventionReportBody) -> JsValue = JsValue::unsafe_from[InterventionReportBody](self)

pub fun InterventionReportBody::from_js(v: JsValue) -> mut InterventionReportBody = JsValue::unsafe_as[mut InterventionReportBody](v)

pub struct IsInputPendingOptions(
    include_continuous: Option[Bool]
)

pub fun IsInputPendingOptions::default() -> mut IsInputPendingOptions
    = IsInputPendingOptions(Option::Some(false))

pub ext fun IsInputPendingOptions::from_js(value: JsValue) -> mut IsInputPendingOptions = "
    const r = {};
    r.m_include_continuous = #fun(Option::from_js[Bool])(#var(value).includeContinuous);
    return r;
"

pub ext fun IsInputPendingOptions::as_js(self: IsInputPendingOptions) -> JsValue = "
    const r = {};
    r.includeContinuous = #fun(Option::as_js_undef[Bool])(#var(self).m_include_continuous);
    return r;
"

struct Location()

pub ext fun Location::ancestor_origins(self: Location) -> mut DOMStringList
    = "return #fun(DOMStringList::from_js)(#var(self).ancestorOrigins);"

pub ext fun Location::href(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun Location::set_href(self: mut Location, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun Location::origin(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun Location::protocol(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun Location::set_protocol(self: mut Location, value: String)
    = "#var(self).protocol = #fun(String::as_js)(#var(value));"

pub ext fun Location::host(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).host);"

pub ext fun Location::set_host(self: mut Location, value: String)
    = "#var(self).host = #fun(String::as_js)(#var(value));"

pub ext fun Location::hostname(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun Location::set_hostname(self: mut Location, value: String)
    = "#var(self).hostname = #fun(String::as_js)(#var(value));"

pub ext fun Location::port(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun Location::set_port(self: mut Location, value: String)
    = "#var(self).port = #fun(String::as_js)(#var(value));"

pub ext fun Location::pathname(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun Location::set_pathname(self: mut Location, value: String)
    = "#var(self).pathname = #fun(String::as_js)(#var(value));"

pub ext fun Location::search(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun Location::set_search(self: mut Location, value: String)
    = "#var(self).search = #fun(String::as_js)(#var(value));"

pub ext fun Location::hash(self: Location) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub ext fun Location::set_hash(self: mut Location, value: String)
    = "#var(self).hash = #fun(String::as_js)(#var(value));"

pub ext fun Location::assign(__self: mut Location, url: String) -> Unit = "
    const r = #var(__self).assign(#fun(String::as_js)(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Location::replace(__self: mut Location, url: String) -> Unit = "
    const r = #var(__self).replace(#fun(String::as_js)(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Location::reload(__self: mut Location) -> Unit = "
    const r = #var(__self).reload();
    return #fun(Unit::from_js)(r);
"

pub fun Location::as_js(self: Location) -> JsValue = JsValue::unsafe_from[Location](self)

pub fun Location::from_js(v: JsValue) -> mut Location = JsValue::unsafe_as[mut Location](v)

pub ext fun Navigator::vendor_sub(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).vendorSub);"

pub ext fun Navigator::product_sub(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).productSub);"

pub ext fun Navigator::vendor(self: Navigator) -> String
    = "return #fun(String::from_js)(#var(self).vendor);"

pub ext fun Navigator::scheduling(self: Navigator) -> mut Scheduling
    = "return #fun(Scheduling::from_js)(#var(self).scheduling);"

pub struct NavigatorUABrandVersion(
    brand: Option[String],
    version: Option[String]
)

pub fun NavigatorUABrandVersion::default() -> mut NavigatorUABrandVersion
    = NavigatorUABrandVersion(Option::None, Option::None)

pub ext fun NavigatorUABrandVersion::from_js(value: JsValue) -> mut NavigatorUABrandVersion = "
    const r = {};
    r.m_brand = #fun(Option::from_js[String])(#var(value).brand);
    r.m_version = #fun(Option::from_js[String])(#var(value).version);
    return r;
"

pub ext fun NavigatorUABrandVersion::as_js(self: NavigatorUABrandVersion) -> JsValue = "
    const r = {};
    r.brand = #fun(Option::as_js_undef[String])(#var(self).m_brand);
    r.version = #fun(Option::as_js_undef[String])(#var(self).m_version);
    return r;
"

struct NavigatorUAData()

pub ext fun NavigatorUAData::brands(self: NavigatorUAData) -> JsValue
    = "return #var(self).brands;"

pub ext fun NavigatorUAData::mobile(self: NavigatorUAData) -> Bool
    = "return #fun(Bool::from_js)(#var(self).mobile);"

pub ext fun NavigatorUAData::platform(self: NavigatorUAData) -> String
    = "return #fun(String::from_js)(#var(self).platform);"

pub ext fun NavigatorUAData::get_high_entropy_values(__self: mut NavigatorUAData, hints: List[String]) -> Promise[mut UADataValues] = "
    const r = #var(__self).getHighEntropyValues(#fun(List::as_js[String])(#var(hints)));
    return #fun(Promise::from_js[mut UADataValues])(r);
"

pub ext fun NavigatorUAData::to_json(__self: mut NavigatorUAData) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun NavigatorUAData::as_js(self: NavigatorUAData) -> JsValue = JsValue::unsafe_from[NavigatorUAData](self)

pub fun NavigatorUAData::from_js(v: JsValue) -> mut NavigatorUAData = JsValue::unsafe_as[mut NavigatorUAData](v)

pub ext fun Navigator::user_activation(self: Navigator) -> mut UserActivation
    = "return #fun(UserActivation::from_js)(#var(self).userActivation);"

struct PermissionsPolicyViolationReportBody()

/// Converts a reference to 'PermissionsPolicyViolationReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun PermissionsPolicyViolationReportBody::as_report_body(self: PermissionsPolicyViolationReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'PermissionsPolicyViolationReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun PermissionsPolicyViolationReportBody::as_mreport_body(self: mut PermissionsPolicyViolationReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'PermissionsPolicyViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'PermissionsPolicyViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PermissionsPolicyViolationReportBody::from_report_body(base: ReportBody) -> PermissionsPolicyViolationReportBody = "
    if(#var(base) instanceof PermissionsPolicyViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'PermissionsPolicyViolationReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'PermissionsPolicyViolationReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'PermissionsPolicyViolationReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PermissionsPolicyViolationReportBody::from_mreport_body(base: mut ReportBody) -> mut PermissionsPolicyViolationReportBody = "
    if(#var(base) instanceof PermissionsPolicyViolationReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'PermissionsPolicyViolationReportBody'!\");
"

pub ext fun PermissionsPolicyViolationReportBody::feature_id(self: PermissionsPolicyViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).featureId);"

pub ext fun PermissionsPolicyViolationReportBody::source_file(self: PermissionsPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).sourceFile);"

pub ext fun PermissionsPolicyViolationReportBody::line_number(self: PermissionsPolicyViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).lineNumber);"

pub ext fun PermissionsPolicyViolationReportBody::column_number(self: PermissionsPolicyViolationReportBody) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).columnNumber);"

pub ext fun PermissionsPolicyViolationReportBody::disposition(self: PermissionsPolicyViolationReportBody) -> String
    = "return #fun(String::from_js)(#var(self).disposition);"

pub ext fun PermissionsPolicyViolationReportBody::message(self: PermissionsPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).message);"

pub ext fun PermissionsPolicyViolationReportBody::allow_attribute(self: PermissionsPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).allowAttribute);"

pub ext fun PermissionsPolicyViolationReportBody::src_attribute(self: PermissionsPolicyViolationReportBody) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).srcAttribute);"

pub ext fun PermissionsPolicyViolationReportBody::to_json(__self: mut PermissionsPolicyViolationReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PermissionsPolicyViolationReportBody::as_js(self: PermissionsPolicyViolationReportBody) -> JsValue = JsValue::unsafe_from[PermissionsPolicyViolationReportBody](self)

pub fun PermissionsPolicyViolationReportBody::from_js(v: JsValue) -> mut PermissionsPolicyViolationReportBody = JsValue::unsafe_as[mut PermissionsPolicyViolationReportBody](v)

struct Report()

pub ext fun Report::type(self: Report) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Report::url(self: Report) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun Report::body(self: Report) -> Option[mut ReportBody]
    = "return #fun(Option::from_js[mut ReportBody])(#var(self).body);"

pub ext fun Report::to_json(__self: mut Report) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun Report::as_js(self: Report) -> JsValue = JsValue::unsafe_from[Report](self)

pub fun Report::from_js(v: JsValue) -> mut Report = JsValue::unsafe_as[mut Report](v)

struct ReportBody()

pub ext fun ReportBody::to_json(__self: mut ReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun ReportBody::as_js(self: ReportBody) -> JsValue = JsValue::unsafe_from[ReportBody](self)

pub fun ReportBody::from_js(v: JsValue) -> mut ReportBody = JsValue::unsafe_as[mut ReportBody](v)

struct ReportingObserver()

pub ext fun ReportingObserver::from_f_list_mreport_mreporting_observer_unit_mreporting_observer_options(callback: Fun(List[mut Report], mut ReportingObserver) -> Unit, options: mut ReportingObserverOptions) -> mut ReportingObserver
    = "return new ReportingObserver(((p0, p1) => { const r = #var(callback)(#fun(List::from_js[mut Report])(p0), #fun(ReportingObserver::from_js)(p1)); return #fun(Unit::as_js)(r); }), #fun(ReportingObserverOptions::as_js)(#var(options)));"

pub ext fun ReportingObserver::observe(__self: mut ReportingObserver) -> Unit = "
    const r = #var(__self).observe();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReportingObserver::disconnect(__self: mut ReportingObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReportingObserver::take_records(__self: mut ReportingObserver) -> List[mut Report] = "
    const r = #var(__self).takeRecords();
    return #fun(List::from_js[mut Report])(r);
"

pub fun ReportingObserver::as_js(self: ReportingObserver) -> JsValue = JsValue::unsafe_from[ReportingObserver](self)

pub fun ReportingObserver::from_js(v: JsValue) -> mut ReportingObserver = JsValue::unsafe_as[mut ReportingObserver](v)

pub struct ReportingObserverOptions(
    types: Option[List[String]],
    buffered: Option[Bool]
)

pub fun ReportingObserverOptions::default() -> mut ReportingObserverOptions
    = ReportingObserverOptions(Option::None, Option::Some(false))

pub ext fun ReportingObserverOptions::from_js(value: JsValue) -> mut ReportingObserverOptions = "
    const r = {};
    r.m_types = #fun(Option::from_js[List[String]])(#var(value).types);
    r.m_buffered = #fun(Option::from_js[Bool])(#var(value).buffered);
    return r;
"

pub ext fun ReportingObserverOptions::as_js(self: ReportingObserverOptions) -> JsValue = "
    const r = {};
    r.types = #fun(Option::as_js_undef[List[String]])(#var(self).m_types);
    r.buffered = #fun(Option::as_js_undef[Bool])(#var(self).m_buffered);
    return r;
"

struct Scheduling()

pub ext fun Scheduling::is_input_pending(__self: mut Scheduling, options: mut IsInputPendingOptions) -> Bool = "
    const r = #var(__self).isInputPending(#fun(IsInputPendingOptions::as_js)(#var(options)));
    return #fun(Bool::from_js)(r);
"

pub fun Scheduling::as_js(self: Scheduling) -> JsValue = JsValue::unsafe_from[Scheduling](self)

pub fun Scheduling::from_js(v: JsValue) -> mut Scheduling = JsValue::unsafe_as[mut Scheduling](v)

struct Screen()

/// Converts a reference to 'Screen' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Screen::as_event_target(self: Screen) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Screen' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Screen::as_mevent_target(self: mut Screen) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Screen'.
/// The conversion may fail and panic if 'base' is not a reference to 'Screen' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Screen::from_event_target(base: EventTarget) -> Screen = "
    if(#var(base) instanceof Screen) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Screen'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Screen'.
/// The conversion may fail and panic if 'base' is not a reference to 'Screen' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Screen::from_mevent_target(base: mut EventTarget) -> mut Screen = "
    if(#var(base) instanceof Screen) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Screen'!\");
"

pub ext fun Screen::avail_width(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).availWidth);"

pub ext fun Screen::avail_height(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).availHeight);"

pub ext fun Screen::width(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun Screen::height(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun Screen::color_depth(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).colorDepth);"

pub ext fun Screen::pixel_depth(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).pixelDepth);"

pub ext fun Screen::avail_left(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).availLeft);"

pub ext fun Screen::avail_top(self: Screen) -> Int
    = "return #fun(Int::from_js)(#var(self).availTop);"

pub ext fun Screen::onchange(self: Screen) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun Screen::set_onchange(self: mut Screen, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Screen::is_extended(self: Screen) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isExtended);"

pub ext fun Screen::add_event_listener(__self: mut Screen, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Screen::remove_event_listener(__self: mut Screen, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Screen::dispatch_event(__self: mut Screen, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Screen::when(__self: mut Screen, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Screen::as_js(self: Screen) -> JsValue = JsValue::unsafe_from[Screen](self)

pub fun Screen::from_js(v: JsValue) -> mut Screen = JsValue::unsafe_as[mut Screen](v)

pub val ScrollLogicalPosition::Start: String = "start"
pub val ScrollLogicalPosition::Center: String = "center"
pub val ScrollLogicalPosition::End: String = "end"
pub val ScrollLogicalPosition::Nearest: String = "nearest"

pub val ScrollContainer::All: String = "all"
pub val ScrollContainer::Nearest: String = "nearest"

pub struct ScrollIntoViewOptions(
    block: Option[String],
    inline: Option[String],
    container: Option[String],
    behavior: Option[String]
)

pub fun ScrollIntoViewOptions::default() -> mut ScrollIntoViewOptions
    = ScrollIntoViewOptions(Option::Some("start"), Option::Some("nearest"), Option::Some("all"), Option::Some("auto"))

/// Converts a reference to 'ScrollIntoViewOptions' to a reference to 'ScrollOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollIntoViewOptions::as_scroll_options(self: ScrollIntoViewOptions) -> ScrollOptions = "return #var(self);"

/// Converts a mutable reference to 'ScrollIntoViewOptions' to a mutable reference to 'ScrollOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollIntoViewOptions::as_mscroll_options(self: mut ScrollIntoViewOptions) -> mut ScrollOptions = "return #var(self);"

/// Attempts to convert a reference to 'ScrollOptions' to a reference to 'ScrollIntoViewOptions'.
/// A 'base' that is not a reference to 'ScrollIntoViewOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollIntoViewOptions::from_scroll_options_unchecked(base: ScrollOptions) -> ScrollIntoViewOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'ScrollOptions' to a mutable reference to 'ScrollIntoViewOptions'.
/// A 'base' that is not a reference to 'ScrollIntoViewOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollIntoViewOptions::from_mscroll_options_unchecked(base: mut ScrollOptions) -> mut ScrollIntoViewOptions = "return #var(base);"

pub ext fun ScrollIntoViewOptions::from_js(value: JsValue) -> mut ScrollIntoViewOptions = "
    const r = {};
    r.m_block = #fun(Option::from_js[String])(#var(value).block);
    r.m_inline = #fun(Option::from_js[String])(#var(value).inline);
    r.m_container = #fun(Option::from_js[String])(#var(value).container);
    r.m_behavior = #fun(Option::from_js[String])(#var(value).behavior);
    return r;
"

pub ext fun ScrollIntoViewOptions::as_js(self: ScrollIntoViewOptions) -> JsValue = "
    const r = {};
    r.block = #fun(Option::as_js_undef[String])(#var(self).m_block);
    r.inline = #fun(Option::as_js_undef[String])(#var(self).m_inline);
    r.container = #fun(Option::as_js_undef[String])(#var(self).m_container);
    r.behavior = #fun(Option::as_js_undef[String])(#var(self).m_behavior);
    return r;
"

pub val ScrollBehavior::Auto: String = "auto"
pub val ScrollBehavior::Instant: String = "instant"
pub val ScrollBehavior::Smooth: String = "smooth"

pub struct ScrollOptions(
    behavior: Option[String]
)

pub fun ScrollOptions::default() -> mut ScrollOptions
    = ScrollOptions(Option::Some("auto"))

pub ext fun ScrollOptions::from_js(value: JsValue) -> mut ScrollOptions = "
    const r = {};
    r.m_behavior = #fun(Option::from_js[String])(#var(value).behavior);
    return r;
"

pub ext fun ScrollOptions::as_js(self: ScrollOptions) -> JsValue = "
    const r = {};
    r.behavior = #fun(Option::as_js_undef[String])(#var(self).m_behavior);
    return r;
"

pub struct ScrollToOptions(
    left: Option[Float],
    top: Option[Float],
    behavior: Option[String]
)

pub fun ScrollToOptions::default() -> mut ScrollToOptions
    = ScrollToOptions(Option::None, Option::None, Option::Some("auto"))

/// Converts a reference to 'ScrollToOptions' to a reference to 'ScrollOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollToOptions::as_scroll_options(self: ScrollToOptions) -> ScrollOptions = "return #var(self);"

/// Converts a mutable reference to 'ScrollToOptions' to a mutable reference to 'ScrollOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollToOptions::as_mscroll_options(self: mut ScrollToOptions) -> mut ScrollOptions = "return #var(self);"

/// Attempts to convert a reference to 'ScrollOptions' to a reference to 'ScrollToOptions'.
/// A 'base' that is not a reference to 'ScrollToOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollToOptions::from_scroll_options_unchecked(base: ScrollOptions) -> ScrollToOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'ScrollOptions' to a mutable reference to 'ScrollToOptions'.
/// A 'base' that is not a reference to 'ScrollToOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun ScrollToOptions::from_mscroll_options_unchecked(base: mut ScrollOptions) -> mut ScrollToOptions = "return #var(base);"

pub ext fun ScrollToOptions::from_js(value: JsValue) -> mut ScrollToOptions = "
    const r = {};
    r.m_left = #fun(Option::from_js[Float])(#var(value).left);
    r.m_top = #fun(Option::from_js[Float])(#var(value).top);
    r.m_behavior = #fun(Option::from_js[String])(#var(value).behavior);
    return r;
"

pub ext fun ScrollToOptions::as_js(self: ScrollToOptions) -> JsValue = "
    const r = {};
    r.left = #fun(Option::as_js_undef[Float])(#var(self).m_left);
    r.top = #fun(Option::as_js_undef[Float])(#var(self).m_top);
    r.behavior = #fun(Option::as_js_undef[String])(#var(self).m_behavior);
    return r;
"

struct SelectorDirective()

/// Converts a reference to 'SelectorDirective' to a reference to 'Directive'.
/// This does not involve manipulating the object or reference.
pub ext fun SelectorDirective::as_directive(self: SelectorDirective) -> Directive = "return #var(self);"

/// Converts a mutable reference to 'SelectorDirective' to a mutable reference to 'Directive'.
/// This does not involve manipulating the object or reference.
pub ext fun SelectorDirective::as_mdirective(self: mut SelectorDirective) -> mut Directive = "return #var(self);"

/// Attempts to convert a reference to 'Directive' to a reference to 'SelectorDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'SelectorDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SelectorDirective::from_directive(base: Directive) -> SelectorDirective = "
    if(#var(base) instanceof SelectorDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Directive' to 'SelectorDirective'!\");
"

/// Attempts to convert a mutable reference to 'Directive' to a mutable reference to 'SelectorDirective'.
/// The conversion may fail and panic if 'base' is not a reference to 'SelectorDirective' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SelectorDirective::from_mdirective(base: mut Directive) -> mut SelectorDirective = "
    if(#var(base) instanceof SelectorDirective) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Directive' to 'SelectorDirective'!\");
"

pub ext fun SelectorDirective::type(self: SelectorDirective) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SelectorDirective::get_matching_range(__self: mut SelectorDirective) -> Promise[mut Range] = "
    const r = #var(__self).getMatchingRange();
    return #fun(Promise::from_js[mut Range])(r);
"

pub fun SelectorDirective::as_js(self: SelectorDirective) -> JsValue = JsValue::unsafe_from[SelectorDirective](self)

pub fun SelectorDirective::from_js(v: JsValue) -> mut SelectorDirective = JsValue::unsafe_as[mut SelectorDirective](v)

struct TestReportBody()

/// Converts a reference to 'TestReportBody' to a reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun TestReportBody::as_report_body(self: TestReportBody) -> ReportBody = "return #var(self);"

/// Converts a mutable reference to 'TestReportBody' to a mutable reference to 'ReportBody'.
/// This does not involve manipulating the object or reference.
pub ext fun TestReportBody::as_mreport_body(self: mut TestReportBody) -> mut ReportBody = "return #var(self);"

/// Attempts to convert a reference to 'ReportBody' to a reference to 'TestReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'TestReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TestReportBody::from_report_body(base: ReportBody) -> TestReportBody = "
    if(#var(base) instanceof TestReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'TestReportBody'!\");
"

/// Attempts to convert a mutable reference to 'ReportBody' to a mutable reference to 'TestReportBody'.
/// The conversion may fail and panic if 'base' is not a reference to 'TestReportBody' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TestReportBody::from_mreport_body(base: mut ReportBody) -> mut TestReportBody = "
    if(#var(base) instanceof TestReportBody) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'ReportBody' to 'TestReportBody'!\");
"

pub ext fun TestReportBody::message(self: TestReportBody) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub ext fun TestReportBody::to_json(__self: mut TestReportBody) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun TestReportBody::as_js(self: TestReportBody) -> JsValue = JsValue::unsafe_from[TestReportBody](self)

pub fun TestReportBody::from_js(v: JsValue) -> mut TestReportBody = JsValue::unsafe_as[mut TestReportBody](v)

pub struct UADataValues(
    brands: Option[List[mut NavigatorUABrandVersion]],
    mobile: Option[Bool],
    platform: Option[String],
    platform_version: Option[String],
    architecture: Option[String],
    model: Option[String],
    ua_full_version: Option[String],
    bitness: Option[String],
    full_version_list: Option[List[mut NavigatorUABrandVersion]],
    wow_64: Option[Bool],
    form_factors: Option[List[String]]
)

pub fun UADataValues::default() -> mut UADataValues
    = UADataValues(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun UADataValues::from_js(value: JsValue) -> mut UADataValues = "
    const r = {};
    r.m_brands = #fun(Option::from_js[List[mut NavigatorUABrandVersion]])(#var(value).brands);
    r.m_mobile = #fun(Option::from_js[Bool])(#var(value).mobile);
    r.m_platform = #fun(Option::from_js[String])(#var(value).platform);
    r.m_platform_version = #fun(Option::from_js[String])(#var(value).platformVersion);
    r.m_architecture = #fun(Option::from_js[String])(#var(value).architecture);
    r.m_model = #fun(Option::from_js[String])(#var(value).model);
    r.m_ua_full_version = #fun(Option::from_js[String])(#var(value).uaFullVersion);
    r.m_bitness = #fun(Option::from_js[String])(#var(value).bitness);
    r.m_full_version_list = #fun(Option::from_js[List[mut NavigatorUABrandVersion]])(#var(value).fullVersionList);
    r.m_wow_64 = #fun(Option::from_js[Bool])(#var(value).wow64);
    r.m_form_factors = #fun(Option::from_js[List[String]])(#var(value).formFactors);
    return r;
"

pub ext fun UADataValues::as_js(self: UADataValues) -> JsValue = "
    const r = {};
    r.brands = #fun(Option::as_js_undef[List[mut NavigatorUABrandVersion]])(#var(self).m_brands);
    r.mobile = #fun(Option::as_js_undef[Bool])(#var(self).m_mobile);
    r.platform = #fun(Option::as_js_undef[String])(#var(self).m_platform);
    r.platformVersion = #fun(Option::as_js_undef[String])(#var(self).m_platform_version);
    r.architecture = #fun(Option::as_js_undef[String])(#var(self).m_architecture);
    r.model = #fun(Option::as_js_undef[String])(#var(self).m_model);
    r.uaFullVersion = #fun(Option::as_js_undef[String])(#var(self).m_ua_full_version);
    r.bitness = #fun(Option::as_js_undef[String])(#var(self).m_bitness);
    r.fullVersionList = #fun(Option::as_js_undef[List[mut NavigatorUABrandVersion]])(#var(self).m_full_version_list);
    r.wow64 = #fun(Option::as_js_undef[Bool])(#var(self).m_wow_64);
    r.formFactors = #fun(Option::as_js_undef[List[String]])(#var(self).m_form_factors);
    return r;
"

struct UserActivation()

pub ext fun UserActivation::has_been_active(self: UserActivation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hasBeenActive);"

pub ext fun UserActivation::is_active(self: UserActivation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isActive);"

pub fun UserActivation::as_js(self: UserActivation) -> JsValue = JsValue::unsafe_from[UserActivation](self)

pub fun UserActivation::from_js(v: JsValue) -> mut UserActivation = JsValue::unsafe_as[mut UserActivation](v)

struct Viewport()

pub ext fun Viewport::segments(self: Viewport) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).segments);"

pub fun Viewport::as_js(self: Viewport) -> JsValue = JsValue::unsafe_from[Viewport](self)

pub fun Viewport::from_js(v: JsValue) -> mut Viewport = JsValue::unsafe_as[mut Viewport](v)

struct VisualViewport()

/// Converts a reference to 'VisualViewport' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VisualViewport::as_event_target(self: VisualViewport) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'VisualViewport' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VisualViewport::as_mevent_target(self: mut VisualViewport) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'VisualViewport'.
/// The conversion may fail and panic if 'base' is not a reference to 'VisualViewport' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VisualViewport::from_event_target(base: EventTarget) -> VisualViewport = "
    if(#var(base) instanceof VisualViewport) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VisualViewport'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'VisualViewport'.
/// The conversion may fail and panic if 'base' is not a reference to 'VisualViewport' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VisualViewport::from_mevent_target(base: mut EventTarget) -> mut VisualViewport = "
    if(#var(base) instanceof VisualViewport) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VisualViewport'!\");
"

pub ext fun VisualViewport::offset_left(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetLeft);"

pub ext fun VisualViewport::offset_top(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetTop);"

pub ext fun VisualViewport::page_left(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).pageLeft);"

pub ext fun VisualViewport::page_top(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).pageTop);"

pub ext fun VisualViewport::width(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun VisualViewport::height(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun VisualViewport::scale(self: VisualViewport) -> Float
    = "return #fun(Float::from_js)(#var(self).scale);"

pub ext fun VisualViewport::onresize(self: VisualViewport) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun VisualViewport::set_onresize(self: mut VisualViewport, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VisualViewport::onscroll(self: VisualViewport) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun VisualViewport::set_onscroll(self: mut VisualViewport, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VisualViewport::onscrollend(self: VisualViewport) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun VisualViewport::set_onscrollend(self: mut VisualViewport, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VisualViewport::add_event_listener(__self: mut VisualViewport, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VisualViewport::remove_event_listener(__self: mut VisualViewport, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VisualViewport::dispatch_event(__self: mut VisualViewport, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun VisualViewport::when(__self: mut VisualViewport, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun VisualViewport::as_js(self: VisualViewport) -> JsValue = JsValue::unsafe_from[VisualViewport](self)

pub fun VisualViewport::from_js(v: JsValue) -> mut VisualViewport = JsValue::unsafe_as[mut VisualViewport](v)

/// Converts a reference to 'Window' to a reference to 'WindowProperties'.
/// This does not involve manipulating the object or reference.
pub ext fun Window::as_window_properties(self: Window) -> WindowProperties = "return #var(self);"

/// Converts a mutable reference to 'Window' to a mutable reference to 'WindowProperties'.
/// This does not involve manipulating the object or reference.
pub ext fun Window::as_mwindow_properties(self: mut Window) -> mut WindowProperties = "return #var(self);"

/// Attempts to convert a reference to 'WindowProperties' to a reference to 'Window'.
/// The conversion may fail and panic if 'base' is not a reference to 'Window' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Window::from_window_properties(base: WindowProperties) -> Window = "
    if(#var(base) instanceof Window) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WindowProperties' to 'Window'!\");
"

/// Attempts to convert a mutable reference to 'WindowProperties' to a mutable reference to 'Window'.
/// The conversion may fail and panic if 'base' is not a reference to 'Window' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Window::from_mwindow_properties(base: mut WindowProperties) -> mut Window = "
    if(#var(base) instanceof Window) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WindowProperties' to 'Window'!\");
"

/// Converts a reference to 'Window' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Window::as_event_target(self: Window) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Window' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Window::as_mevent_target(self: mut Window) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Window'.
/// The conversion may fail and panic if 'base' is not a reference to 'Window' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Window::from_event_target(base: EventTarget) -> Window = "
    if(#var(base) instanceof Window) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Window'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Window'.
/// The conversion may fail and panic if 'base' is not a reference to 'Window' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Window::from_mevent_target(base: mut EventTarget) -> mut Window = "
    if(#var(base) instanceof Window) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Window'!\");
"

pub ext fun Window::window(self: Window) -> mut Window
    = "return #fun(Window::from_js)(#var(self).window);"

pub ext fun Window::self(self: Window) -> mut Window
    = "return #fun(Window::from_js)(#var(self).self);"

pub ext fun Window::document(self: Window) -> mut Document
    = "return #fun(Document::from_js)(#var(self).document);"

pub ext fun Window::name(self: Window) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun Window::set_name(self: mut Window, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun Window::location(self: Window) -> mut Location
    = "return #fun(Location::from_js)(#var(self).location);"

pub ext fun Window::custom_elements(self: Window) -> mut CustomElementRegistry
    = "return #fun(CustomElementRegistry::from_js)(#var(self).customElements);"

pub ext fun Window::history(self: Window) -> mut History
    = "return #fun(History::from_js)(#var(self).history);"

pub ext fun Window::navigation(self: Window) -> mut Navigation
    = "return #fun(Navigation::from_js)(#var(self).navigation);"

pub ext fun Window::locationbar(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).locationbar);"

pub ext fun Window::menubar(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).menubar);"

pub ext fun Window::personalbar(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).personalbar);"

pub ext fun Window::scrollbars(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).scrollbars);"

pub ext fun Window::statusbar(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).statusbar);"

pub ext fun Window::toolbar(self: Window) -> mut BarProp
    = "return #fun(BarProp::from_js)(#var(self).toolbar);"

pub ext fun Window::status(self: Window) -> String
    = "return #fun(String::from_js)(#var(self).status);"

pub ext fun Window::set_status(self: mut Window, value: String)
    = "#var(self).status = #fun(String::as_js)(#var(value));"

pub ext fun Window::closed(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).closed);"

pub ext fun Window::frames(self: Window) -> mut Window
    = "return #fun(Window::from_js)(#var(self).frames);"

pub ext fun Window::length(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Window::top(self: Window) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).top);"

pub ext fun Window::opener(self: Window) -> JsValue
    = "return #var(self).opener;"

pub ext fun Window::set_opener(self: mut Window, value: JsValue)
    = "#var(self).opener = #var(value);"

pub ext fun Window::parent(self: Window) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).parent);"

pub ext fun Window::frame_element(self: Window) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).frameElement);"

pub ext fun Window::navigator(self: Window) -> mut Navigator
    = "return #fun(Navigator::from_js)(#var(self).navigator);"

pub ext fun Window::origin_agent_cluster(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).originAgentCluster);"

pub ext fun Window::origin(self: Window) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun Window::external(self: Window) -> mut External
    = "return #fun(External::from_js)(#var(self).external);"

pub ext fun Window::screen(self: Window) -> mut Screen
    = "return #fun(Screen::from_js)(#var(self).screen);"

pub ext fun Window::inner_width(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).innerWidth);"

pub ext fun Window::inner_height(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).innerHeight);"

pub ext fun Window::scroll_x(self: Window) -> Float
    = "return #fun(Float::from_js)(#var(self).scrollX);"

pub ext fun Window::page_x_offset(self: Window) -> Float
    = "return #fun(Float::from_js)(#var(self).pageXOffset);"

pub ext fun Window::scroll_y(self: Window) -> Float
    = "return #fun(Float::from_js)(#var(self).scrollY);"

pub ext fun Window::page_y_offset(self: Window) -> Float
    = "return #fun(Float::from_js)(#var(self).pageYOffset);"

pub ext fun Window::visual_viewport(self: Window) -> mut VisualViewport
    = "return #fun(VisualViewport::from_js)(#var(self).visualViewport);"

pub ext fun Window::viewport(self: Window) -> mut Viewport
    = "return #fun(Viewport::from_js)(#var(self).viewport);"

pub ext fun Window::screen_x(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).screenX);"

pub ext fun Window::screen_y(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).screenY);"

pub ext fun Window::outer_width(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).outerWidth);"

pub ext fun Window::outer_height(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).outerHeight);"

pub ext fun Window::device_pixel_ratio(self: Window) -> Float
    = "return #fun(Float::from_js)(#var(self).devicePixelRatio);"

pub ext fun Window::onorientationchange(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onorientationchange);"

pub ext fun Window::set_onorientationchange(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onorientationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::orientation(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).orientation);"

pub ext fun Window::onpageswap(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpageswap);"

pub ext fun Window::set_onpageswap(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpageswap = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::onpagereveal(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpagereveal);"

pub ext fun Window::set_onpagereveal(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpagereveal = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::event(self: Window) -> JsValue
    = "return #var(self).event;"

pub ext fun Window::client_information(self: Window) -> mut Navigator
    = "return #fun(Navigator::from_js)(#var(self).clientInformation);"

pub ext fun Window::offscreen_buffering(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).offscreenBuffering);"

pub ext fun Window::screen_left(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).screenLeft);"

pub ext fun Window::screen_top(self: Window) -> Int
    = "return #fun(Int::from_js)(#var(self).screenTop);"

pub ext fun Window::default_status(self: Window) -> String
    = "return #fun(String::from_js)(#var(self).defaultStatus);"

pub ext fun Window::set_default_status(self: mut Window, value: String)
    = "#var(self).defaultStatus = #fun(String::as_js)(#var(value));"

pub ext fun Window::defaultstatus(self: Window) -> String
    = "return #fun(String::from_js)(#var(self).defaultstatus);"

pub ext fun Window::set_defaultstatus(self: mut Window, value: String)
    = "#var(self).defaultstatus = #fun(String::as_js)(#var(value));"

pub ext fun Window::style_media(self: Window) -> mut StyleMedia
    = "return #fun(StyleMedia::from_js)(#var(self).styleMedia);"

pub ext fun Window::onsearch(self: Window) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsearch);"

pub ext fun Window::set_onsearch(self: mut Window, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsearch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Window::trusted_types(self: Window) -> mut TrustedTypePolicyFactory
    = "return #fun(TrustedTypePolicyFactory::from_js)(#var(self).trustedTypes);"

pub ext fun Window::credentialless(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).credentialless);"

pub ext fun Window::fence(self: Window) -> Option[mut Fence]
    = "return #fun(Option::from_js[mut Fence])(#var(self).fence);"

pub ext fun Window::close(__self: mut Window) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::stop(__self: mut Window) -> Unit = "
    const r = #var(__self).stop();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::focus(__self: mut Window) -> Unit = "
    const r = #var(__self).focus();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::blur(__self: mut Window) -> Unit = "
    const r = #var(__self).blur();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::open(__self: mut Window, url: String, target: String, features: String) -> Option[mut Window] = "
    const r = #var(__self).open(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(target)), #fun(String::as_js)(#var(features)));
    return #fun(Option::from_js[mut Window])(r);
"

pub ext fun Window::get_int(__self: Window, index: Int) -> mut Window = "
    const r = Window[#fun(Int::as_js)(#var(index))];
    return #fun(Window::from_js)(r);
"

pub ext fun Window::alert(__self: mut Window) -> Unit = "
    const r = #var(__self).alert();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::alert_str(__self: mut Window, message: String) -> Unit = "
    const r = #var(__self).alert(#fun(String::as_js)(#var(message)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::confirm(__self: mut Window, message: String) -> Bool = "
    const r = #var(__self).confirm(#fun(String::as_js)(#var(message)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Window::prompt(__self: mut Window, message: String, default_value: String) -> Option[String] = "
    const r = #var(__self).prompt(#fun(String::as_js)(#var(message)), #fun(String::as_js)(#var(default_value)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Window::print(__self: mut Window) -> Unit = "
    const r = #var(__self).print();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::post_message_any_str_list_obj(__self: mut Window, message: JsValue, target_origin: String, transfer: List[JsObject]) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(String::as_js)(#var(target_origin)), #fun(List::as_js[JsObject])(#var(transfer)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::post_message_any_mwindow_post_message_options(__self: mut Window, message: JsValue, options: mut WindowPostMessageOptions) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(WindowPostMessageOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::request_animation_frame(__self: mut Window, callback: Fun(Float) -> Unit) -> Int = "
    const r = #var(__self).requestAnimationFrame(((p0) => { const r = #var(callback)(#fun(Float::from_js)(p0)); return #fun(Unit::as_js)(r); }));
    return #fun(Int::from_js)(r);
"

pub ext fun Window::cancel_animation_frame(__self: mut Window, handle: Int) -> Unit = "
    const r = #var(__self).cancelAnimationFrame(#fun(Int::as_js)(#var(handle)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::capture_events(__self: mut Window) -> Unit = "
    const r = #var(__self).captureEvents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::release_events(__self: mut Window) -> Unit = "
    const r = #var(__self).releaseEvents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::get_computed_style(__self: mut Window, elt: mut Element, pseudo_elt: Option[String]) -> mut CSSStyleDeclaration = "
    const r = #var(__self).getComputedStyle(#fun(Element::as_js)(#var(elt)), #fun(Option::as_js[String])(#var(pseudo_elt)));
    return #fun(CSSStyleDeclaration::from_js)(r);
"

pub ext fun Window::match_media(__self: mut Window, query: String) -> mut MediaQueryList = "
    const r = #var(__self).matchMedia(#fun(String::as_js)(#var(query)));
    return #fun(MediaQueryList::from_js)(r);
"

pub ext fun Window::move_to(__self: mut Window, x: Int, y: Int) -> Unit = "
    const r = #var(__self).moveTo(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::move_by(__self: mut Window, x: Int, y: Int) -> Unit = "
    const r = #var(__self).moveBy(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::resize_to(__self: mut Window, x: Int, y: Int) -> Unit = "
    const r = #var(__self).resizeTo(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::resize_by(__self: mut Window, x: Int, y: Int) -> Unit = "
    const r = #var(__self).resizeBy(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_mscroll_to_options(__self: mut Window, options: mut ScrollToOptions) -> Unit = "
    const r = #var(__self).scroll(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_flt_flt(__self: mut Window, x: Float, y: Float) -> Unit = "
    const r = #var(__self).scroll(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_to_mscroll_to_options(__self: mut Window, options: mut ScrollToOptions) -> Unit = "
    const r = #var(__self).scrollTo(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_to_flt_flt(__self: mut Window, x: Float, y: Float) -> Unit = "
    const r = #var(__self).scrollTo(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_by_mscroll_to_options(__self: mut Window, options: mut ScrollToOptions) -> Unit = "
    const r = #var(__self).scrollBy(#fun(ScrollToOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::scroll_by_flt_flt(__self: mut Window, x: Float, y: Float) -> Unit = "
    const r = #var(__self).scrollBy(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::get_selection(__self: mut Window) -> Option[mut Selection] = "
    const r = #var(__self).getSelection();
    return #fun(Option::from_js[mut Selection])(r);
"

pub ext fun Window::find(__self: mut Window, string: String, case_sensitive: Bool, backwards: Bool, wrap: Bool, whole_word: Bool, search_in_frames: Bool, show_dialog: Bool) -> Bool = "
    const r = #var(__self).find(#fun(String::as_js)(#var(string)), #fun(Bool::as_js)(#var(case_sensitive)), #fun(Bool::as_js)(#var(backwards)), #fun(Bool::as_js)(#var(wrap)), #fun(Bool::as_js)(#var(whole_word)), #fun(Bool::as_js)(#var(search_in_frames)), #fun(Bool::as_js)(#var(show_dialog)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Window::webkit_request_animation_frame(__self: mut Window, callback: Fun(Float) -> Unit) -> Int = "
    const r = #var(__self).webkitRequestAnimationFrame(((p0) => { const r = #var(callback)(#fun(Float::from_js)(p0)); return #fun(Unit::as_js)(r); }));
    return #fun(Int::from_js)(r);
"

pub ext fun Window::webkit_cancel_animation_frame(__self: mut Window, id: Int) -> Unit = "
    const r = #var(__self).webkitCancelAnimationFrame(#fun(Int::as_js)(#var(id)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::get_str(__self: Window, name: String) -> JsObject = "
    const r = Window[#fun(String::as_js)(#var(name))];
    return r;
"

pub ext fun Window::add_event_listener(__self: mut Window, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::remove_event_listener(__self: mut Window, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Window::dispatch_event(__self: mut Window, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Window::when(__self: mut Window, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub val PopinContextType::Partitioned: String = "partitioned"

pub ext fun Window::popin_context_types_supported(__self: mut Window) -> List[String] = "
    const r = #var(__self).popinContextTypesSupported();
    return #fun(List::from_js[String])(r);
"

pub ext fun Window::popin_context_type(__self: mut Window) -> Option[String] = "
    const r = #var(__self).popinContextType();
    return #fun(Option::from_js[String])(r);
"

pub struct WindowPostMessageOptions(
    target_origin: Option[String],
    delegate: Option[String],
    include_user_activation: Option[Bool],
    transfer: Option[List[JsObject]]
)

pub fun WindowPostMessageOptions::default() -> mut WindowPostMessageOptions
    = WindowPostMessageOptions(Option::Some("/"), Option::None, Option::Some(false), Option::Some(List::empty()))

/// Converts a reference to 'WindowPostMessageOptions' to a reference to 'PostMessageOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun WindowPostMessageOptions::as_post_message_options(self: WindowPostMessageOptions) -> PostMessageOptions = "return #var(self);"

/// Converts a mutable reference to 'WindowPostMessageOptions' to a mutable reference to 'PostMessageOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun WindowPostMessageOptions::as_mpost_message_options(self: mut WindowPostMessageOptions) -> mut PostMessageOptions = "return #var(self);"

/// Attempts to convert a reference to 'PostMessageOptions' to a reference to 'WindowPostMessageOptions'.
/// A 'base' that is not a reference to 'WindowPostMessageOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun WindowPostMessageOptions::from_post_message_options_unchecked(base: PostMessageOptions) -> WindowPostMessageOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'PostMessageOptions' to a mutable reference to 'WindowPostMessageOptions'.
/// A 'base' that is not a reference to 'WindowPostMessageOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun WindowPostMessageOptions::from_mpost_message_options_unchecked(base: mut PostMessageOptions) -> mut WindowPostMessageOptions = "return #var(base);"

pub ext fun WindowPostMessageOptions::from_js(value: JsValue) -> mut WindowPostMessageOptions = "
    const r = {};
    r.m_target_origin = #fun(Option::from_js[String])(#var(value).targetOrigin);
    r.m_delegate = #fun(Option::from_js[String])(#var(value).delegate);
    r.m_include_user_activation = #fun(Option::from_js[Bool])(#var(value).includeUserActivation);
    r.m_transfer = #fun(Option::from_js[List[JsObject]])(#var(value).transfer);
    return r;
"

pub ext fun WindowPostMessageOptions::as_js(self: WindowPostMessageOptions) -> JsValue = "
    const r = {};
    r.targetOrigin = #fun(Option::as_js_undef[String])(#var(self).m_target_origin);
    r.delegate = #fun(Option::as_js_undef[String])(#var(self).m_delegate);
    r.includeUserActivation = #fun(Option::as_js_undef[Bool])(#var(self).m_include_user_activation);
    r.transfer = #fun(Option::as_js_undef[List[JsObject]])(#var(self).m_transfer);
    return r;
"

struct WindowProperties()

/// Converts a reference to 'WindowProperties' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun WindowProperties::as_event_target(self: WindowProperties) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'WindowProperties' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun WindowProperties::as_mevent_target(self: mut WindowProperties) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'WindowProperties'.
/// The conversion may fail and panic if 'base' is not a reference to 'WindowProperties' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WindowProperties::from_event_target(base: EventTarget) -> WindowProperties = "
    if(#var(base) instanceof WindowProperties) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'WindowProperties'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'WindowProperties'.
/// The conversion may fail and panic if 'base' is not a reference to 'WindowProperties' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WindowProperties::from_mevent_target(base: mut EventTarget) -> mut WindowProperties = "
    if(#var(base) instanceof WindowProperties) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'WindowProperties'!\");
"

pub ext fun WindowProperties::get(__self: WindowProperties, name: String) -> JsObject = "
    const r = WindowProperties[#fun(String::as_js)(#var(name))];
    return r;
"

pub ext fun WindowProperties::add_event_listener(__self: mut WindowProperties, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun WindowProperties::remove_event_listener(__self: mut WindowProperties, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun WindowProperties::dispatch_event(__self: mut WindowProperties, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun WindowProperties::when(__self: mut WindowProperties, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun WindowProperties::as_js(self: WindowProperties) -> JsValue = JsValue::unsafe_from[WindowProperties](self)

pub fun WindowProperties::from_js(v: JsValue) -> mut WindowProperties = JsValue::unsafe_as[mut WindowProperties](v)

pub ext fun Document::fullscreen_enabled(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).fullscreenEnabled);"

pub ext fun Document::fullscreen(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).fullscreen);"

pub ext fun Document::onfullscreenchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfullscreenchange);"

pub ext fun Document::set_onfullscreenchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfullscreenchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onfullscreenerror(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfullscreenerror);"

pub ext fun Document::set_onfullscreenerror(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfullscreenerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::webkit_is_full_screen(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).webkitIsFullScreen);"

pub ext fun Document::webkit_current_full_screen_element(self: Document) -> mut Element
    = "return #fun(Element::from_js)(#var(self).webkitCurrentFullScreenElement);"

pub ext fun Document::webkit_fullscreen_enabled(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).webkitFullscreenEnabled);"

pub ext fun Document::webkit_fullscreen_element(self: Document) -> mut Element
    = "return #fun(Element::from_js)(#var(self).webkitFullscreenElement);"

pub ext fun Document::onwebkitfullscreenchange(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitfullscreenchange);"

pub ext fun Document::set_onwebkitfullscreenchange(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitfullscreenchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::onwebkitfullscreenerror(self: Document) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitfullscreenerror);"

pub ext fun Document::set_onwebkitfullscreenerror(self: mut Document, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitfullscreenerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Document::exit_fullscreen(__self: mut Document) -> Promise[Unit] = "
    const r = #var(__self).exitFullscreen();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Document::webkit_cancel_full_screen(__self: mut Document) -> Unit = "
    const r = #var(__self).webkitCancelFullScreen();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::webkit_exit_fullscreen(__self: mut Document) -> Unit = "
    const r = #var(__self).webkitExitFullscreen();
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::onfullscreenchange(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfullscreenchange);"

pub ext fun Element::set_onfullscreenchange(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfullscreenchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onfullscreenerror(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfullscreenerror);"

pub ext fun Element::set_onfullscreenerror(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfullscreenerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onwebkitfullscreenchange(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitfullscreenchange);"

pub ext fun Element::set_onwebkitfullscreenchange(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitfullscreenchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::onwebkitfullscreenerror(self: Element) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitfullscreenerror);"

pub ext fun Element::set_onwebkitfullscreenerror(self: mut Element, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitfullscreenerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Element::request_fullscreen(__self: mut Element, options: mut FullscreenOptions) -> Promise[Unit] = "
    const r = #var(__self).requestFullscreen(#fun(FullscreenOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Element::webkit_request_full_screen(__self: mut Element, options: mut FullscreenOptions) -> Unit = "
    const r = #var(__self).webkitRequestFullScreen(#fun(FullscreenOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::webkit_request_fullscreen(__self: mut Element, options: mut FullscreenOptions) -> Unit = "
    const r = #var(__self).webkitRequestFullscreen(#fun(FullscreenOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub val FullscreenNavigationUI::Auto: String = "auto"
pub val FullscreenNavigationUI::Show: String = "show"
pub val FullscreenNavigationUI::Hide: String = "hide"

pub struct FullscreenOptions(
    navigation_ui: Option[String],
    screen: Option[mut Screen]
)

pub fun FullscreenOptions::default() -> mut FullscreenOptions
    = FullscreenOptions(Option::Some("auto"), Option::None)

pub ext fun FullscreenOptions::from_js(value: JsValue) -> mut FullscreenOptions = "
    const r = {};
    r.m_navigation_ui = #fun(Option::from_js[String])(#var(value).navigationUI);
    r.m_screen = #fun(Option::from_js[mut Screen])(#var(value).screen);
    return r;
"

pub ext fun FullscreenOptions::as_js(self: FullscreenOptions) -> JsValue = "
    const r = {};
    r.navigationUI = #fun(Option::as_js_undef[String])(#var(self).m_navigation_ui);
    r.screen = #fun(Option::as_js_undef[mut Screen])(#var(self).m_screen);
    return r;
"

struct DOMMatrix()

/// Converts a reference to 'DOMMatrix' to a reference to 'DOMMatrixReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrix::as_dom_matrix_read_only(self: DOMMatrix) -> DOMMatrixReadOnly = "return #var(self);"

/// Converts a mutable reference to 'DOMMatrix' to a mutable reference to 'DOMMatrixReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrix::as_mdom_matrix_read_only(self: mut DOMMatrix) -> mut DOMMatrixReadOnly = "return #var(self);"

/// Attempts to convert a reference to 'DOMMatrixReadOnly' to a reference to 'DOMMatrix'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMMatrix' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrix::from_dom_matrix_read_only(base: DOMMatrixReadOnly) -> DOMMatrix = "
    if(#var(base) instanceof DOMMatrix) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMMatrixReadOnly' to 'DOMMatrix'!\");
"

/// Attempts to convert a mutable reference to 'DOMMatrixReadOnly' to a mutable reference to 'DOMMatrix'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMMatrix' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrix::from_mdom_matrix_read_only(base: mut DOMMatrixReadOnly) -> mut DOMMatrix = "
    if(#var(base) instanceof DOMMatrix) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMMatrixReadOnly' to 'DOMMatrix'!\");
"

pub ext fun DOMMatrix::from_any(init: JsValue) -> mut DOMMatrix
    = "return new DOMMatrix(#var(init));"

pub ext fun DOMMatrix::a(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).a);"

pub ext fun DOMMatrix::set_a(self: mut DOMMatrix, value: Float)
    = "#var(self).a = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::b(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).b);"

pub ext fun DOMMatrix::set_b(self: mut DOMMatrix, value: Float)
    = "#var(self).b = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::c(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).c);"

pub ext fun DOMMatrix::set_c(self: mut DOMMatrix, value: Float)
    = "#var(self).c = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::d(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).d);"

pub ext fun DOMMatrix::set_d(self: mut DOMMatrix, value: Float)
    = "#var(self).d = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::e(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).e);"

pub ext fun DOMMatrix::set_e(self: mut DOMMatrix, value: Float)
    = "#var(self).e = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::f(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).f);"

pub ext fun DOMMatrix::set_f(self: mut DOMMatrix, value: Float)
    = "#var(self).f = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_11(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m11);"

pub ext fun DOMMatrix::set_m_11(self: mut DOMMatrix, value: Float)
    = "#var(self).m11 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_12(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m12);"

pub ext fun DOMMatrix::set_m_12(self: mut DOMMatrix, value: Float)
    = "#var(self).m12 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_13(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m13);"

pub ext fun DOMMatrix::set_m_13(self: mut DOMMatrix, value: Float)
    = "#var(self).m13 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_14(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m14);"

pub ext fun DOMMatrix::set_m_14(self: mut DOMMatrix, value: Float)
    = "#var(self).m14 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_21(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m21);"

pub ext fun DOMMatrix::set_m_21(self: mut DOMMatrix, value: Float)
    = "#var(self).m21 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_22(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m22);"

pub ext fun DOMMatrix::set_m_22(self: mut DOMMatrix, value: Float)
    = "#var(self).m22 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_23(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m23);"

pub ext fun DOMMatrix::set_m_23(self: mut DOMMatrix, value: Float)
    = "#var(self).m23 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_24(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m24);"

pub ext fun DOMMatrix::set_m_24(self: mut DOMMatrix, value: Float)
    = "#var(self).m24 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_31(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m31);"

pub ext fun DOMMatrix::set_m_31(self: mut DOMMatrix, value: Float)
    = "#var(self).m31 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_32(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m32);"

pub ext fun DOMMatrix::set_m_32(self: mut DOMMatrix, value: Float)
    = "#var(self).m32 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_33(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m33);"

pub ext fun DOMMatrix::set_m_33(self: mut DOMMatrix, value: Float)
    = "#var(self).m33 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_34(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m34);"

pub ext fun DOMMatrix::set_m_34(self: mut DOMMatrix, value: Float)
    = "#var(self).m34 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_41(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m41);"

pub ext fun DOMMatrix::set_m_41(self: mut DOMMatrix, value: Float)
    = "#var(self).m41 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_42(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m42);"

pub ext fun DOMMatrix::set_m_42(self: mut DOMMatrix, value: Float)
    = "#var(self).m42 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_43(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m43);"

pub ext fun DOMMatrix::set_m_43(self: mut DOMMatrix, value: Float)
    = "#var(self).m43 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::m_44(self: DOMMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).m44);"

pub ext fun DOMMatrix::set_m_44(self: mut DOMMatrix, value: Float)
    = "#var(self).m44 = #fun(Float::as_js)(#var(value));"

pub ext fun DOMMatrix::is_2d(self: DOMMatrix) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun DOMMatrix::is_identity(self: DOMMatrix) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isIdentity);"

pub ext fun DOMMatrix::from_matrix_mdom_matrix_init(other: mut DOMMatrixInit) -> mut DOMMatrix = "
    const r = DOMMatrix.fromMatrix(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::from_float_32_array_any(array_32: JsValue) -> mut DOMMatrix = "
    const r = DOMMatrix.fromFloat32Array(#var(array_32));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::from_float_64_array_any(array_64: JsValue) -> mut DOMMatrix = "
    const r = DOMMatrix.fromFloat64Array(#var(array_64));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::multiply_self(__self: mut DOMMatrix, other: mut DOMMatrixInit) -> mut DOMMatrix = "
    const r = #var(__self).multiplySelf(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::pre_multiply_self(__self: mut DOMMatrix, other: mut DOMMatrixInit) -> mut DOMMatrix = "
    const r = #var(__self).preMultiplySelf(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::translate_self(__self: mut DOMMatrix, tx: Float, ty: Float, tz: Float) -> mut DOMMatrix = "
    const r = #var(__self).translateSelf(#fun(Float::as_js)(#var(tx)), #fun(Float::as_js)(#var(ty)), #fun(Float::as_js)(#var(tz)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::scale_self(__self: mut DOMMatrix, scale_x: Float, scale_y: Float, scale_z: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scaleSelf(#fun(Float::as_js)(#var(scale_x)), #fun(Float::as_js)(#var(scale_y)), #fun(Float::as_js)(#var(scale_z)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::scale_3d_self(__self: mut DOMMatrix, scale: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scale3dSelf(#fun(Float::as_js)(#var(scale)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate_self(__self: mut DOMMatrix, rot_x: Float, rot_y: Float, rot_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateSelf(#fun(Float::as_js)(#var(rot_x)), #fun(Float::as_js)(#var(rot_y)), #fun(Float::as_js)(#var(rot_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate_from_vector_self(__self: mut DOMMatrix, x: Float, y: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateFromVectorSelf(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate_axis_angle_self(__self: mut DOMMatrix, x: Float, y: Float, z: Float, angle: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateAxisAngleSelf(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(z)), #fun(Float::as_js)(#var(angle)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::skew_x_self(__self: mut DOMMatrix, sx: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewXSelf(#fun(Float::as_js)(#var(sx)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::skew_y_self(__self: mut DOMMatrix, sy: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewYSelf(#fun(Float::as_js)(#var(sy)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::invert_self(__self: mut DOMMatrix) -> mut DOMMatrix = "
    const r = #var(__self).invertSelf();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::set_matrix_value(__self: mut DOMMatrix, transform_list: String) -> mut DOMMatrix = "
    const r = #var(__self).setMatrixValue(#fun(String::as_js)(#var(transform_list)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::translate(__self: mut DOMMatrix, tx: Float, ty: Float, tz: Float) -> mut DOMMatrix = "
    const r = #var(__self).translate(#fun(Float::as_js)(#var(tx)), #fun(Float::as_js)(#var(ty)), #fun(Float::as_js)(#var(tz)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::scale(__self: mut DOMMatrix, scale_x: Float, scale_y: Float, scale_z: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scale(#fun(Float::as_js)(#var(scale_x)), #fun(Float::as_js)(#var(scale_y)), #fun(Float::as_js)(#var(scale_z)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::scale_non_uniform(__self: mut DOMMatrix, scale_x: Float, scale_y: Float) -> mut DOMMatrix = "
    const r = #var(__self).scaleNonUniform(#fun(Float::as_js)(#var(scale_x)), #fun(Float::as_js)(#var(scale_y)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::scale_3d(__self: mut DOMMatrix, scale: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scale3d(#fun(Float::as_js)(#var(scale)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate(__self: mut DOMMatrix, rot_x: Float, rot_y: Float, rot_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotate(#fun(Float::as_js)(#var(rot_x)), #fun(Float::as_js)(#var(rot_y)), #fun(Float::as_js)(#var(rot_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate_from_vector(__self: mut DOMMatrix, x: Float, y: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateFromVector(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::rotate_axis_angle(__self: mut DOMMatrix, x: Float, y: Float, z: Float, angle: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateAxisAngle(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(z)), #fun(Float::as_js)(#var(angle)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::skew_x(__self: mut DOMMatrix, sx: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewX(#fun(Float::as_js)(#var(sx)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::skew_y(__self: mut DOMMatrix, sy: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewY(#fun(Float::as_js)(#var(sy)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::multiply(__self: mut DOMMatrix, other: mut DOMMatrixInit) -> mut DOMMatrix = "
    const r = #var(__self).multiply(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::flip_x(__self: mut DOMMatrix) -> mut DOMMatrix = "
    const r = #var(__self).flipX();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::flip_y(__self: mut DOMMatrix) -> mut DOMMatrix = "
    const r = #var(__self).flipY();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::inverse(__self: mut DOMMatrix) -> mut DOMMatrix = "
    const r = #var(__self).inverse();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrix::transform_point(__self: mut DOMMatrix, point: mut DOMPointInit) -> mut DOMPoint = "
    const r = #var(__self).transformPoint(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun DOMMatrix::to_float_32_array(__self: mut DOMMatrix) -> JsValue = "
    const r = #var(__self).toFloat32Array();
    return r;
"

pub ext fun DOMMatrix::to_float_64_array(__self: mut DOMMatrix) -> JsValue = "
    const r = #var(__self).toFloat64Array();
    return r;
"

pub ext fun DOMMatrix::as_string(__self: mut DOMMatrix) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun DOMMatrix::to_json(__self: mut DOMMatrix) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMMatrix::as_js(self: DOMMatrix) -> JsValue = JsValue::unsafe_from[DOMMatrix](self)

pub fun DOMMatrix::from_js(v: JsValue) -> mut DOMMatrix = JsValue::unsafe_as[mut DOMMatrix](v)

pub struct DOMMatrix2DInit(
    a: Option[Float],
    b: Option[Float],
    c: Option[Float],
    d: Option[Float],
    e: Option[Float],
    f: Option[Float],
    m_11: Option[Float],
    m_12: Option[Float],
    m_21: Option[Float],
    m_22: Option[Float],
    m_41: Option[Float],
    m_42: Option[Float]
)

pub fun DOMMatrix2DInit::default() -> mut DOMMatrix2DInit
    = DOMMatrix2DInit(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun DOMMatrix2DInit::from_js(value: JsValue) -> mut DOMMatrix2DInit = "
    const r = {};
    r.m_a = #fun(Option::from_js[Float])(#var(value).a);
    r.m_b = #fun(Option::from_js[Float])(#var(value).b);
    r.m_c = #fun(Option::from_js[Float])(#var(value).c);
    r.m_d = #fun(Option::from_js[Float])(#var(value).d);
    r.m_e = #fun(Option::from_js[Float])(#var(value).e);
    r.m_f = #fun(Option::from_js[Float])(#var(value).f);
    r.m_m_11 = #fun(Option::from_js[Float])(#var(value).m11);
    r.m_m_12 = #fun(Option::from_js[Float])(#var(value).m12);
    r.m_m_21 = #fun(Option::from_js[Float])(#var(value).m21);
    r.m_m_22 = #fun(Option::from_js[Float])(#var(value).m22);
    r.m_m_41 = #fun(Option::from_js[Float])(#var(value).m41);
    r.m_m_42 = #fun(Option::from_js[Float])(#var(value).m42);
    return r;
"

pub ext fun DOMMatrix2DInit::as_js(self: DOMMatrix2DInit) -> JsValue = "
    const r = {};
    r.a = #fun(Option::as_js_undef[Float])(#var(self).m_a);
    r.b = #fun(Option::as_js_undef[Float])(#var(self).m_b);
    r.c = #fun(Option::as_js_undef[Float])(#var(self).m_c);
    r.d = #fun(Option::as_js_undef[Float])(#var(self).m_d);
    r.e = #fun(Option::as_js_undef[Float])(#var(self).m_e);
    r.f = #fun(Option::as_js_undef[Float])(#var(self).m_f);
    r.m11 = #fun(Option::as_js_undef[Float])(#var(self).m_m_11);
    r.m12 = #fun(Option::as_js_undef[Float])(#var(self).m_m_12);
    r.m21 = #fun(Option::as_js_undef[Float])(#var(self).m_m_21);
    r.m22 = #fun(Option::as_js_undef[Float])(#var(self).m_m_22);
    r.m41 = #fun(Option::as_js_undef[Float])(#var(self).m_m_41);
    r.m42 = #fun(Option::as_js_undef[Float])(#var(self).m_m_42);
    return r;
"

pub struct DOMMatrixInit(
    m_13: Option[Float],
    m_14: Option[Float],
    m_23: Option[Float],
    m_24: Option[Float],
    m_31: Option[Float],
    m_32: Option[Float],
    m_33: Option[Float],
    m_34: Option[Float],
    m_43: Option[Float],
    m_44: Option[Float],
    is_2d: Option[Bool],
    a: Option[Float],
    b: Option[Float],
    c: Option[Float],
    d: Option[Float],
    e: Option[Float],
    f: Option[Float],
    m_11: Option[Float],
    m_12: Option[Float],
    m_21: Option[Float],
    m_22: Option[Float],
    m_41: Option[Float],
    m_42: Option[Float]
)

pub fun DOMMatrixInit::default() -> mut DOMMatrixInit
    = DOMMatrixInit(Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(1.0), Option::Some(0.0), Option::Some(0.0), Option::Some(1.0), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

/// Converts a reference to 'DOMMatrixInit' to a reference to 'DOMMatrix2DInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrixInit::as_dom_matrix_2d_init(self: DOMMatrixInit) -> DOMMatrix2DInit = "return #var(self);"

/// Converts a mutable reference to 'DOMMatrixInit' to a mutable reference to 'DOMMatrix2DInit'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrixInit::as_mdom_matrix_2d_init(self: mut DOMMatrixInit) -> mut DOMMatrix2DInit = "return #var(self);"

/// Attempts to convert a reference to 'DOMMatrix2DInit' to a reference to 'DOMMatrixInit'.
/// A 'base' that is not a reference to 'DOMMatrixInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrixInit::from_dom_matrix_2d_init_unchecked(base: DOMMatrix2DInit) -> DOMMatrixInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'DOMMatrix2DInit' to a mutable reference to 'DOMMatrixInit'.
/// A 'base' that is not a reference to 'DOMMatrixInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun DOMMatrixInit::from_mdom_matrix_2d_init_unchecked(base: mut DOMMatrix2DInit) -> mut DOMMatrixInit = "return #var(base);"

pub ext fun DOMMatrixInit::from_js(value: JsValue) -> mut DOMMatrixInit = "
    const r = {};
    r.m_m_13 = #fun(Option::from_js[Float])(#var(value).m13);
    r.m_m_14 = #fun(Option::from_js[Float])(#var(value).m14);
    r.m_m_23 = #fun(Option::from_js[Float])(#var(value).m23);
    r.m_m_24 = #fun(Option::from_js[Float])(#var(value).m24);
    r.m_m_31 = #fun(Option::from_js[Float])(#var(value).m31);
    r.m_m_32 = #fun(Option::from_js[Float])(#var(value).m32);
    r.m_m_33 = #fun(Option::from_js[Float])(#var(value).m33);
    r.m_m_34 = #fun(Option::from_js[Float])(#var(value).m34);
    r.m_m_43 = #fun(Option::from_js[Float])(#var(value).m43);
    r.m_m_44 = #fun(Option::from_js[Float])(#var(value).m44);
    r.m_is_2d = #fun(Option::from_js[Bool])(#var(value).is2D);
    r.m_a = #fun(Option::from_js[Float])(#var(value).a);
    r.m_b = #fun(Option::from_js[Float])(#var(value).b);
    r.m_c = #fun(Option::from_js[Float])(#var(value).c);
    r.m_d = #fun(Option::from_js[Float])(#var(value).d);
    r.m_e = #fun(Option::from_js[Float])(#var(value).e);
    r.m_f = #fun(Option::from_js[Float])(#var(value).f);
    r.m_m_11 = #fun(Option::from_js[Float])(#var(value).m11);
    r.m_m_12 = #fun(Option::from_js[Float])(#var(value).m12);
    r.m_m_21 = #fun(Option::from_js[Float])(#var(value).m21);
    r.m_m_22 = #fun(Option::from_js[Float])(#var(value).m22);
    r.m_m_41 = #fun(Option::from_js[Float])(#var(value).m41);
    r.m_m_42 = #fun(Option::from_js[Float])(#var(value).m42);
    return r;
"

pub ext fun DOMMatrixInit::as_js(self: DOMMatrixInit) -> JsValue = "
    const r = {};
    r.m13 = #fun(Option::as_js_undef[Float])(#var(self).m_m_13);
    r.m14 = #fun(Option::as_js_undef[Float])(#var(self).m_m_14);
    r.m23 = #fun(Option::as_js_undef[Float])(#var(self).m_m_23);
    r.m24 = #fun(Option::as_js_undef[Float])(#var(self).m_m_24);
    r.m31 = #fun(Option::as_js_undef[Float])(#var(self).m_m_31);
    r.m32 = #fun(Option::as_js_undef[Float])(#var(self).m_m_32);
    r.m33 = #fun(Option::as_js_undef[Float])(#var(self).m_m_33);
    r.m34 = #fun(Option::as_js_undef[Float])(#var(self).m_m_34);
    r.m43 = #fun(Option::as_js_undef[Float])(#var(self).m_m_43);
    r.m44 = #fun(Option::as_js_undef[Float])(#var(self).m_m_44);
    r.is2D = #fun(Option::as_js_undef[Bool])(#var(self).m_is_2d);
    r.a = #fun(Option::as_js_undef[Float])(#var(self).m_a);
    r.b = #fun(Option::as_js_undef[Float])(#var(self).m_b);
    r.c = #fun(Option::as_js_undef[Float])(#var(self).m_c);
    r.d = #fun(Option::as_js_undef[Float])(#var(self).m_d);
    r.e = #fun(Option::as_js_undef[Float])(#var(self).m_e);
    r.f = #fun(Option::as_js_undef[Float])(#var(self).m_f);
    r.m11 = #fun(Option::as_js_undef[Float])(#var(self).m_m_11);
    r.m12 = #fun(Option::as_js_undef[Float])(#var(self).m_m_12);
    r.m21 = #fun(Option::as_js_undef[Float])(#var(self).m_m_21);
    r.m22 = #fun(Option::as_js_undef[Float])(#var(self).m_m_22);
    r.m41 = #fun(Option::as_js_undef[Float])(#var(self).m_m_41);
    r.m42 = #fun(Option::as_js_undef[Float])(#var(self).m_m_42);
    return r;
"

struct DOMMatrixReadOnly()

pub ext fun DOMMatrixReadOnly::from_any(init: JsValue) -> mut DOMMatrixReadOnly
    = "return new DOMMatrixReadOnly(#var(init));"

pub ext fun DOMMatrixReadOnly::a(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).a);"

pub ext fun DOMMatrixReadOnly::b(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).b);"

pub ext fun DOMMatrixReadOnly::c(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).c);"

pub ext fun DOMMatrixReadOnly::d(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).d);"

pub ext fun DOMMatrixReadOnly::e(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).e);"

pub ext fun DOMMatrixReadOnly::f(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).f);"

pub ext fun DOMMatrixReadOnly::m_11(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m11);"

pub ext fun DOMMatrixReadOnly::m_12(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m12);"

pub ext fun DOMMatrixReadOnly::m_13(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m13);"

pub ext fun DOMMatrixReadOnly::m_14(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m14);"

pub ext fun DOMMatrixReadOnly::m_21(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m21);"

pub ext fun DOMMatrixReadOnly::m_22(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m22);"

pub ext fun DOMMatrixReadOnly::m_23(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m23);"

pub ext fun DOMMatrixReadOnly::m_24(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m24);"

pub ext fun DOMMatrixReadOnly::m_31(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m31);"

pub ext fun DOMMatrixReadOnly::m_32(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m32);"

pub ext fun DOMMatrixReadOnly::m_33(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m33);"

pub ext fun DOMMatrixReadOnly::m_34(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m34);"

pub ext fun DOMMatrixReadOnly::m_41(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m41);"

pub ext fun DOMMatrixReadOnly::m_42(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m42);"

pub ext fun DOMMatrixReadOnly::m_43(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m43);"

pub ext fun DOMMatrixReadOnly::m_44(self: DOMMatrixReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).m44);"

pub ext fun DOMMatrixReadOnly::is_2d(self: DOMMatrixReadOnly) -> Bool
    = "return #fun(Bool::from_js)(#var(self).is2D);"

pub ext fun DOMMatrixReadOnly::is_identity(self: DOMMatrixReadOnly) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isIdentity);"

pub ext fun DOMMatrixReadOnly::from_matrix(other: mut DOMMatrixInit) -> mut DOMMatrixReadOnly = "
    const r = DOMMatrixReadOnly.fromMatrix(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrixReadOnly::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::from_float_32_array(array_32: JsValue) -> mut DOMMatrixReadOnly = "
    const r = DOMMatrixReadOnly.fromFloat32Array(#var(array_32));
    return #fun(DOMMatrixReadOnly::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::from_float_64_array(array_64: JsValue) -> mut DOMMatrixReadOnly = "
    const r = DOMMatrixReadOnly.fromFloat64Array(#var(array_64));
    return #fun(DOMMatrixReadOnly::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::translate(__self: mut DOMMatrixReadOnly, tx: Float, ty: Float, tz: Float) -> mut DOMMatrix = "
    const r = #var(__self).translate(#fun(Float::as_js)(#var(tx)), #fun(Float::as_js)(#var(ty)), #fun(Float::as_js)(#var(tz)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::scale(__self: mut DOMMatrixReadOnly, scale_x: Float, scale_y: Float, scale_z: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scale(#fun(Float::as_js)(#var(scale_x)), #fun(Float::as_js)(#var(scale_y)), #fun(Float::as_js)(#var(scale_z)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::scale_non_uniform(__self: mut DOMMatrixReadOnly, scale_x: Float, scale_y: Float) -> mut DOMMatrix = "
    const r = #var(__self).scaleNonUniform(#fun(Float::as_js)(#var(scale_x)), #fun(Float::as_js)(#var(scale_y)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::scale_3d(__self: mut DOMMatrixReadOnly, scale: Float, origin_x: Float, origin_y: Float, origin_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).scale3d(#fun(Float::as_js)(#var(scale)), #fun(Float::as_js)(#var(origin_x)), #fun(Float::as_js)(#var(origin_y)), #fun(Float::as_js)(#var(origin_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::rotate(__self: mut DOMMatrixReadOnly, rot_x: Float, rot_y: Float, rot_z: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotate(#fun(Float::as_js)(#var(rot_x)), #fun(Float::as_js)(#var(rot_y)), #fun(Float::as_js)(#var(rot_z)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::rotate_from_vector(__self: mut DOMMatrixReadOnly, x: Float, y: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateFromVector(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::rotate_axis_angle(__self: mut DOMMatrixReadOnly, x: Float, y: Float, z: Float, angle: Float) -> mut DOMMatrix = "
    const r = #var(__self).rotateAxisAngle(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(z)), #fun(Float::as_js)(#var(angle)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::skew_x(__self: mut DOMMatrixReadOnly, sx: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewX(#fun(Float::as_js)(#var(sx)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::skew_y(__self: mut DOMMatrixReadOnly, sy: Float) -> mut DOMMatrix = "
    const r = #var(__self).skewY(#fun(Float::as_js)(#var(sy)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::multiply(__self: mut DOMMatrixReadOnly, other: mut DOMMatrixInit) -> mut DOMMatrix = "
    const r = #var(__self).multiply(#fun(DOMMatrixInit::as_js)(#var(other)));
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::flip_x(__self: mut DOMMatrixReadOnly) -> mut DOMMatrix = "
    const r = #var(__self).flipX();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::flip_y(__self: mut DOMMatrixReadOnly) -> mut DOMMatrix = "
    const r = #var(__self).flipY();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::inverse(__self: mut DOMMatrixReadOnly) -> mut DOMMatrix = "
    const r = #var(__self).inverse();
    return #fun(DOMMatrix::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::transform_point(__self: mut DOMMatrixReadOnly, point: mut DOMPointInit) -> mut DOMPoint = "
    const r = #var(__self).transformPoint(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun DOMMatrixReadOnly::to_float_32_array(__self: mut DOMMatrixReadOnly) -> JsValue = "
    const r = #var(__self).toFloat32Array();
    return r;
"

pub ext fun DOMMatrixReadOnly::to_float_64_array(__self: mut DOMMatrixReadOnly) -> JsValue = "
    const r = #var(__self).toFloat64Array();
    return r;
"

pub ext fun DOMMatrixReadOnly::as_string(__self: mut DOMMatrixReadOnly) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun DOMMatrixReadOnly::to_json(__self: mut DOMMatrixReadOnly) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMMatrixReadOnly::as_js(self: DOMMatrixReadOnly) -> JsValue = JsValue::unsafe_from[DOMMatrixReadOnly](self)

pub fun DOMMatrixReadOnly::from_js(v: JsValue) -> mut DOMMatrixReadOnly = JsValue::unsafe_as[mut DOMMatrixReadOnly](v)

struct DOMPoint()

/// Converts a reference to 'DOMPoint' to a reference to 'DOMPointReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMPoint::as_dom_point_read_only(self: DOMPoint) -> DOMPointReadOnly = "return #var(self);"

/// Converts a mutable reference to 'DOMPoint' to a mutable reference to 'DOMPointReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMPoint::as_mdom_point_read_only(self: mut DOMPoint) -> mut DOMPointReadOnly = "return #var(self);"

/// Attempts to convert a reference to 'DOMPointReadOnly' to a reference to 'DOMPoint'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMPoint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMPoint::from_dom_point_read_only(base: DOMPointReadOnly) -> DOMPoint = "
    if(#var(base) instanceof DOMPoint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMPointReadOnly' to 'DOMPoint'!\");
"

/// Attempts to convert a mutable reference to 'DOMPointReadOnly' to a mutable reference to 'DOMPoint'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMPoint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMPoint::from_mdom_point_read_only(base: mut DOMPointReadOnly) -> mut DOMPoint = "
    if(#var(base) instanceof DOMPoint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMPointReadOnly' to 'DOMPoint'!\");
"

pub ext fun DOMPoint::from_flt_flt_flt_flt(x: Float, y: Float, z: Float, w: Float) -> mut DOMPoint
    = "return new DOMPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(z)), #fun(Float::as_js)(#var(w)));"

pub ext fun DOMPoint::x(self: DOMPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun DOMPoint::set_x(self: mut DOMPoint, value: Float)
    = "#var(self).x = #fun(Float::as_js)(#var(value));"

pub ext fun DOMPoint::y(self: DOMPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun DOMPoint::set_y(self: mut DOMPoint, value: Float)
    = "#var(self).y = #fun(Float::as_js)(#var(value));"

pub ext fun DOMPoint::z(self: DOMPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).z);"

pub ext fun DOMPoint::set_z(self: mut DOMPoint, value: Float)
    = "#var(self).z = #fun(Float::as_js)(#var(value));"

pub ext fun DOMPoint::w(self: DOMPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).w);"

pub ext fun DOMPoint::set_w(self: mut DOMPoint, value: Float)
    = "#var(self).w = #fun(Float::as_js)(#var(value));"

pub ext fun DOMPoint::from_point_mdom_point_init(other: mut DOMPointInit) -> mut DOMPoint = "
    const r = DOMPoint.fromPoint(#fun(DOMPointInit::as_js)(#var(other)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun DOMPoint::matrix_transform(__self: mut DOMPoint, matrix: mut DOMMatrixInit) -> mut DOMPoint = "
    const r = #var(__self).matrixTransform(#fun(DOMMatrixInit::as_js)(#var(matrix)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun DOMPoint::to_json(__self: mut DOMPoint) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMPoint::as_js(self: DOMPoint) -> JsValue = JsValue::unsafe_from[DOMPoint](self)

pub fun DOMPoint::from_js(v: JsValue) -> mut DOMPoint = JsValue::unsafe_as[mut DOMPoint](v)

pub struct DOMPointInit(
    x: Option[Float],
    y: Option[Float],
    z: Option[Float],
    w: Option[Float]
)

pub fun DOMPointInit::default() -> mut DOMPointInit
    = DOMPointInit(Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(1.0))

pub ext fun DOMPointInit::from_js(value: JsValue) -> mut DOMPointInit = "
    const r = {};
    r.m_x = #fun(Option::from_js[Float])(#var(value).x);
    r.m_y = #fun(Option::from_js[Float])(#var(value).y);
    r.m_z = #fun(Option::from_js[Float])(#var(value).z);
    r.m_w = #fun(Option::from_js[Float])(#var(value).w);
    return r;
"

pub ext fun DOMPointInit::as_js(self: DOMPointInit) -> JsValue = "
    const r = {};
    r.x = #fun(Option::as_js_undef[Float])(#var(self).m_x);
    r.y = #fun(Option::as_js_undef[Float])(#var(self).m_y);
    r.z = #fun(Option::as_js_undef[Float])(#var(self).m_z);
    r.w = #fun(Option::as_js_undef[Float])(#var(self).m_w);
    return r;
"

struct DOMPointReadOnly()

pub ext fun DOMPointReadOnly::from_flt_flt_flt_flt(x: Float, y: Float, z: Float, w: Float) -> mut DOMPointReadOnly
    = "return new DOMPointReadOnly(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(z)), #fun(Float::as_js)(#var(w)));"

pub ext fun DOMPointReadOnly::x(self: DOMPointReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun DOMPointReadOnly::y(self: DOMPointReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun DOMPointReadOnly::z(self: DOMPointReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).z);"

pub ext fun DOMPointReadOnly::w(self: DOMPointReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).w);"

pub ext fun DOMPointReadOnly::from_point(other: mut DOMPointInit) -> mut DOMPointReadOnly = "
    const r = DOMPointReadOnly.fromPoint(#fun(DOMPointInit::as_js)(#var(other)));
    return #fun(DOMPointReadOnly::from_js)(r);
"

pub ext fun DOMPointReadOnly::matrix_transform(__self: mut DOMPointReadOnly, matrix: mut DOMMatrixInit) -> mut DOMPoint = "
    const r = #var(__self).matrixTransform(#fun(DOMMatrixInit::as_js)(#var(matrix)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun DOMPointReadOnly::to_json(__self: mut DOMPointReadOnly) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMPointReadOnly::as_js(self: DOMPointReadOnly) -> JsValue = JsValue::unsafe_from[DOMPointReadOnly](self)

pub fun DOMPointReadOnly::from_js(v: JsValue) -> mut DOMPointReadOnly = JsValue::unsafe_as[mut DOMPointReadOnly](v)

struct DOMQuad()

pub ext fun DOMQuad::from_mdom_point_init_mdom_point_init_mdom_point_init_mdom_point_init(p_1: mut DOMPointInit, p_2: mut DOMPointInit, p_3: mut DOMPointInit, p_4: mut DOMPointInit) -> mut DOMQuad
    = "return new DOMQuad(#fun(DOMPointInit::as_js)(#var(p_1)), #fun(DOMPointInit::as_js)(#var(p_2)), #fun(DOMPointInit::as_js)(#var(p_3)), #fun(DOMPointInit::as_js)(#var(p_4)));"

pub ext fun DOMQuad::p_1(self: DOMQuad) -> mut DOMPoint
    = "return #fun(DOMPoint::from_js)(#var(self).p1);"

pub ext fun DOMQuad::p_2(self: DOMQuad) -> mut DOMPoint
    = "return #fun(DOMPoint::from_js)(#var(self).p2);"

pub ext fun DOMQuad::p_3(self: DOMQuad) -> mut DOMPoint
    = "return #fun(DOMPoint::from_js)(#var(self).p3);"

pub ext fun DOMQuad::p_4(self: DOMQuad) -> mut DOMPoint
    = "return #fun(DOMPoint::from_js)(#var(self).p4);"

pub ext fun DOMQuad::from_rect(other: mut DOMRectInit) -> mut DOMQuad = "
    const r = DOMQuad.fromRect(#fun(DOMRectInit::as_js)(#var(other)));
    return #fun(DOMQuad::from_js)(r);
"

pub ext fun DOMQuad::from_quad(other: mut DOMQuadInit) -> mut DOMQuad = "
    const r = DOMQuad.fromQuad(#fun(DOMQuadInit::as_js)(#var(other)));
    return #fun(DOMQuad::from_js)(r);
"

pub ext fun DOMQuad::get_bounds(__self: mut DOMQuad) -> mut DOMRect = "
    const r = #var(__self).getBounds();
    return #fun(DOMRect::from_js)(r);
"

pub ext fun DOMQuad::to_json(__self: mut DOMQuad) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMQuad::as_js(self: DOMQuad) -> JsValue = JsValue::unsafe_from[DOMQuad](self)

pub fun DOMQuad::from_js(v: JsValue) -> mut DOMQuad = JsValue::unsafe_as[mut DOMQuad](v)

pub struct DOMQuadInit(
    p_1: Option[mut DOMPointInit],
    p_2: Option[mut DOMPointInit],
    p_3: Option[mut DOMPointInit],
    p_4: Option[mut DOMPointInit]
)

pub fun DOMQuadInit::default() -> mut DOMQuadInit
    = DOMQuadInit(Option::None, Option::None, Option::None, Option::None)

pub ext fun DOMQuadInit::from_js(value: JsValue) -> mut DOMQuadInit = "
    const r = {};
    r.m_p_1 = #fun(Option::from_js[mut DOMPointInit])(#var(value).p1);
    r.m_p_2 = #fun(Option::from_js[mut DOMPointInit])(#var(value).p2);
    r.m_p_3 = #fun(Option::from_js[mut DOMPointInit])(#var(value).p3);
    r.m_p_4 = #fun(Option::from_js[mut DOMPointInit])(#var(value).p4);
    return r;
"

pub ext fun DOMQuadInit::as_js(self: DOMQuadInit) -> JsValue = "
    const r = {};
    r.p1 = #fun(Option::as_js_undef[mut DOMPointInit])(#var(self).m_p_1);
    r.p2 = #fun(Option::as_js_undef[mut DOMPointInit])(#var(self).m_p_2);
    r.p3 = #fun(Option::as_js_undef[mut DOMPointInit])(#var(self).m_p_3);
    r.p4 = #fun(Option::as_js_undef[mut DOMPointInit])(#var(self).m_p_4);
    return r;
"

struct DOMRect()

/// Converts a reference to 'DOMRect' to a reference to 'DOMRectReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMRect::as_dom_rect_read_only(self: DOMRect) -> DOMRectReadOnly = "return #var(self);"

/// Converts a mutable reference to 'DOMRect' to a mutable reference to 'DOMRectReadOnly'.
/// This does not involve manipulating the object or reference.
pub ext fun DOMRect::as_mdom_rect_read_only(self: mut DOMRect) -> mut DOMRectReadOnly = "return #var(self);"

/// Attempts to convert a reference to 'DOMRectReadOnly' to a reference to 'DOMRect'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMRect' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMRect::from_dom_rect_read_only(base: DOMRectReadOnly) -> DOMRect = "
    if(#var(base) instanceof DOMRect) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMRectReadOnly' to 'DOMRect'!\");
"

/// Attempts to convert a mutable reference to 'DOMRectReadOnly' to a mutable reference to 'DOMRect'.
/// The conversion may fail and panic if 'base' is not a reference to 'DOMRect' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DOMRect::from_mdom_rect_read_only(base: mut DOMRectReadOnly) -> mut DOMRect = "
    if(#var(base) instanceof DOMRect) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DOMRectReadOnly' to 'DOMRect'!\");
"

pub ext fun DOMRect::from_flt_flt_flt_flt(x: Float, y: Float, width: Float, height: Float) -> mut DOMRect
    = "return new DOMRect(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(width)), #fun(Float::as_js)(#var(height)));"

pub ext fun DOMRect::x(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun DOMRect::set_x(self: mut DOMRect, value: Float)
    = "#var(self).x = #fun(Float::as_js)(#var(value));"

pub ext fun DOMRect::y(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun DOMRect::set_y(self: mut DOMRect, value: Float)
    = "#var(self).y = #fun(Float::as_js)(#var(value));"

pub ext fun DOMRect::width(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun DOMRect::set_width(self: mut DOMRect, value: Float)
    = "#var(self).width = #fun(Float::as_js)(#var(value));"

pub ext fun DOMRect::height(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun DOMRect::set_height(self: mut DOMRect, value: Float)
    = "#var(self).height = #fun(Float::as_js)(#var(value));"

pub ext fun DOMRect::top(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).top);"

pub ext fun DOMRect::right(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).right);"

pub ext fun DOMRect::bottom(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).bottom);"

pub ext fun DOMRect::left(self: DOMRect) -> Float
    = "return #fun(Float::from_js)(#var(self).left);"

pub ext fun DOMRect::from_rect_mdom_rect_init(other: mut DOMRectInit) -> mut DOMRect = "
    const r = DOMRect.fromRect(#fun(DOMRectInit::as_js)(#var(other)));
    return #fun(DOMRect::from_js)(r);
"

pub ext fun DOMRect::to_json(__self: mut DOMRect) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMRect::as_js(self: DOMRect) -> JsValue = JsValue::unsafe_from[DOMRect](self)

pub fun DOMRect::from_js(v: JsValue) -> mut DOMRect = JsValue::unsafe_as[mut DOMRect](v)

pub struct DOMRectInit(
    x: Option[Float],
    y: Option[Float],
    width: Option[Float],
    height: Option[Float]
)

pub fun DOMRectInit::default() -> mut DOMRectInit
    = DOMRectInit(Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0))

pub ext fun DOMRectInit::from_js(value: JsValue) -> mut DOMRectInit = "
    const r = {};
    r.m_x = #fun(Option::from_js[Float])(#var(value).x);
    r.m_y = #fun(Option::from_js[Float])(#var(value).y);
    r.m_width = #fun(Option::from_js[Float])(#var(value).width);
    r.m_height = #fun(Option::from_js[Float])(#var(value).height);
    return r;
"

pub ext fun DOMRectInit::as_js(self: DOMRectInit) -> JsValue = "
    const r = {};
    r.x = #fun(Option::as_js_undef[Float])(#var(self).m_x);
    r.y = #fun(Option::as_js_undef[Float])(#var(self).m_y);
    r.width = #fun(Option::as_js_undef[Float])(#var(self).m_width);
    r.height = #fun(Option::as_js_undef[Float])(#var(self).m_height);
    return r;
"

struct DOMRectList()

pub ext fun DOMRectList::length(self: DOMRectList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun DOMRectList::item(__self: mut DOMRectList, index: Int) -> Option[mut DOMRect] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut DOMRect])(r);
"

pub fun DOMRectList::as_js(self: DOMRectList) -> JsValue = JsValue::unsafe_from[DOMRectList](self)

pub fun DOMRectList::from_js(v: JsValue) -> mut DOMRectList = JsValue::unsafe_as[mut DOMRectList](v)

struct DOMRectReadOnly()

pub ext fun DOMRectReadOnly::from_flt_flt_flt_flt(x: Float, y: Float, width: Float, height: Float) -> mut DOMRectReadOnly
    = "return new DOMRectReadOnly(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Float::as_js)(#var(width)), #fun(Float::as_js)(#var(height)));"

pub ext fun DOMRectReadOnly::x(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun DOMRectReadOnly::y(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun DOMRectReadOnly::width(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun DOMRectReadOnly::height(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun DOMRectReadOnly::top(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).top);"

pub ext fun DOMRectReadOnly::right(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).right);"

pub ext fun DOMRectReadOnly::bottom(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).bottom);"

pub ext fun DOMRectReadOnly::left(self: DOMRectReadOnly) -> Float
    = "return #fun(Float::from_js)(#var(self).left);"

pub ext fun DOMRectReadOnly::from_rect(other: mut DOMRectInit) -> mut DOMRectReadOnly = "
    const r = DOMRectReadOnly.fromRect(#fun(DOMRectInit::as_js)(#var(other)));
    return #fun(DOMRectReadOnly::from_js)(r);
"

pub ext fun DOMRectReadOnly::to_json(__self: mut DOMRectReadOnly) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun DOMRectReadOnly::as_js(self: DOMRectReadOnly) -> JsValue = JsValue::unsafe_from[DOMRectReadOnly](self)

pub fun DOMRectReadOnly::from_js(v: JsValue) -> mut DOMRectReadOnly = JsValue::unsafe_as[mut DOMRectReadOnly](v)

// TODO: Definitions of type 'namespace'

pub val HighlightType::Highlight: String = "highlight"
pub val HighlightType::SpellingError: String = "spelling-error"
pub val HighlightType::GrammarError: String = "grammar-error"

struct Highlight()

pub ext fun Highlight::from_mabstract_range(...init_ranges: List[mut AbstractRange]) -> mut Highlight
    = "return new Highlight(...((#var(init_ranges)).map(v => #fun(AbstractRange::as_js)(v))));"

pub ext fun Highlight::priority(self: Highlight) -> Int
    = "return #fun(Int::from_js)(#var(self).priority);"

pub ext fun Highlight::set_priority(self: mut Highlight, value: Int)
    = "#var(self).priority = #fun(Int::as_js)(#var(value));"

pub ext fun Highlight::type(self: Highlight) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Highlight::set_type(self: mut Highlight, value: String)
    = "#var(self).type = #var(value);"

pub ext fun Highlight::add_event_listener(__self: mut Highlight, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Highlight::remove_event_listener(__self: mut Highlight, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Highlight::dispatch_event(__self: mut Highlight, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun Highlight::as_js(self: Highlight) -> JsValue = JsValue::unsafe_from[Highlight](self)

pub fun Highlight::from_js(v: JsValue) -> mut Highlight = JsValue::unsafe_as[mut Highlight](v)

pub struct HighlightHitResult(
    highlight: Option[mut Highlight],
    ranges: Option[List[mut AbstractRange]]
)

pub fun HighlightHitResult::default() -> mut HighlightHitResult
    = HighlightHitResult(Option::None, Option::None)

pub ext fun HighlightHitResult::from_js(value: JsValue) -> mut HighlightHitResult = "
    const r = {};
    r.m_highlight = #fun(Option::from_js[mut Highlight])(#var(value).highlight);
    r.m_ranges = #fun(Option::from_js[List[mut AbstractRange]])(#var(value).ranges);
    return r;
"

pub ext fun HighlightHitResult::as_js(self: HighlightHitResult) -> JsValue = "
    const r = {};
    r.highlight = #fun(Option::as_js_undef[mut Highlight])(#var(self).m_highlight);
    r.ranges = #fun(Option::as_js_undef[List[mut AbstractRange]])(#var(self).m_ranges);
    return r;
"

pub struct HighlightPointerEventInit(
    range: Option[mut Range],
    pointer_id: Option[Int],
    width: Option[Float],
    height: Option[Float],
    pressure: Option[Float],
    tilt_x: Option[Int],
    tilt_y: Option[Int],
    azimuth_angle: Option[Float],
    altitude_angle: Option[Float],
    tangential_pressure: Option[Float],
    twist: Option[Int],
    pointer_type: Option[String],
    is_primary: Option[Bool],
    persistent_device_id: Option[Int],
    coalesced_events: Option[List[mut PointerEvent]],
    predicted_events: Option[List[mut PointerEvent]],
    screen_x: Option[Float],
    screen_y: Option[Float],
    client_x: Option[Float],
    client_y: Option[Float],
    button: Option[Int],
    buttons: Option[Int],
    related_target: Option[mut EventTarget],
    movement_x: Option[Int],
    movement_y: Option[Int],
    region: Option[String],
    ctrl_key: Option[Bool],
    shift_key: Option[Bool],
    alt_key: Option[Bool],
    meta_key: Option[Bool],
    modifier_alt_graph: Option[Bool],
    modifier_caps_lock: Option[Bool],
    modifier_fn: Option[Bool],
    modifier_num_lock: Option[Bool],
    modifier_scroll_lock: Option[Bool],
    modifier_symbol: Option[Bool],
    view: Option[mut Window],
    detail: Option[Int],
    source_capabilities: Option[mut InputDeviceCapabilities],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun HighlightPointerEventInit::default() -> mut HighlightPointerEventInit
    = HighlightPointerEventInit(Option::None, Option::Some(0), Option::Some(1.0), Option::Some(1.0), Option::Some(0.0), Option::None, Option::None, Option::None, Option::None, Option::Some(0.0), Option::Some(0), Option::Some(""), Option::Some(false), Option::Some(0), Option::Some(List::empty()), Option::Some(List::empty()), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0), Option::Some(0), Option::None, Option::Some(0), Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::None, Option::Some(0), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'HighlightPointerEventInit' to a reference to 'PointerEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEventInit::as_pointer_event_init(self: HighlightPointerEventInit) -> PointerEventInit = "return #var(self);"

/// Converts a mutable reference to 'HighlightPointerEventInit' to a mutable reference to 'PointerEventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEventInit::as_mpointer_event_init(self: mut HighlightPointerEventInit) -> mut PointerEventInit = "return #var(self);"

/// Attempts to convert a reference to 'PointerEventInit' to a reference to 'HighlightPointerEventInit'.
/// A 'base' that is not a reference to 'HighlightPointerEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEventInit::from_pointer_event_init_unchecked(base: PointerEventInit) -> HighlightPointerEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'PointerEventInit' to a mutable reference to 'HighlightPointerEventInit'.
/// A 'base' that is not a reference to 'HighlightPointerEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEventInit::from_mpointer_event_init_unchecked(base: mut PointerEventInit) -> mut HighlightPointerEventInit = "return #var(base);"

pub ext fun HighlightPointerEventInit::from_js(value: JsValue) -> mut HighlightPointerEventInit = "
    const r = {};
    r.m_range = #fun(Option::from_js[mut Range])(#var(value).range);
    r.m_pointer_id = #fun(Option::from_js[Int])(#var(value).pointerId);
    r.m_width = #fun(Option::from_js[Float])(#var(value).width);
    r.m_height = #fun(Option::from_js[Float])(#var(value).height);
    r.m_pressure = #fun(Option::from_js[Float])(#var(value).pressure);
    r.m_tilt_x = #fun(Option::from_js[Int])(#var(value).tiltX);
    r.m_tilt_y = #fun(Option::from_js[Int])(#var(value).tiltY);
    r.m_azimuth_angle = #fun(Option::from_js[Float])(#var(value).azimuthAngle);
    r.m_altitude_angle = #fun(Option::from_js[Float])(#var(value).altitudeAngle);
    r.m_tangential_pressure = #fun(Option::from_js[Float])(#var(value).tangentialPressure);
    r.m_twist = #fun(Option::from_js[Int])(#var(value).twist);
    r.m_pointer_type = #fun(Option::from_js[String])(#var(value).pointerType);
    r.m_is_primary = #fun(Option::from_js[Bool])(#var(value).isPrimary);
    r.m_persistent_device_id = #fun(Option::from_js[Int])(#var(value).persistentDeviceId);
    r.m_coalesced_events = #fun(Option::from_js[List[mut PointerEvent]])(#var(value).coalescedEvents);
    r.m_predicted_events = #fun(Option::from_js[List[mut PointerEvent]])(#var(value).predictedEvents);
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_button = #fun(Option::from_js[Int])(#var(value).button);
    r.m_buttons = #fun(Option::from_js[Int])(#var(value).buttons);
    r.m_related_target = #fun(Option::from_js[mut EventTarget])(#var(value).relatedTarget);
    r.m_movement_x = #fun(Option::from_js[Int])(#var(value).movementX);
    r.m_movement_y = #fun(Option::from_js[Int])(#var(value).movementY);
    r.m_region = #fun(Option::from_js[String])(#var(value).region);
    r.m_ctrl_key = #fun(Option::from_js[Bool])(#var(value).ctrlKey);
    r.m_shift_key = #fun(Option::from_js[Bool])(#var(value).shiftKey);
    r.m_alt_key = #fun(Option::from_js[Bool])(#var(value).altKey);
    r.m_meta_key = #fun(Option::from_js[Bool])(#var(value).metaKey);
    r.m_modifier_alt_graph = #fun(Option::from_js[Bool])(#var(value).modifierAltGraph);
    r.m_modifier_caps_lock = #fun(Option::from_js[Bool])(#var(value).modifierCapsLock);
    r.m_modifier_fn = #fun(Option::from_js[Bool])(#var(value).modifierFn);
    r.m_modifier_num_lock = #fun(Option::from_js[Bool])(#var(value).modifierNumLock);
    r.m_modifier_scroll_lock = #fun(Option::from_js[Bool])(#var(value).modifierScrollLock);
    r.m_modifier_symbol = #fun(Option::from_js[Bool])(#var(value).modifierSymbol);
    r.m_view = #fun(Option::from_js[mut Window])(#var(value).view);
    r.m_detail = #fun(Option::from_js[Int])(#var(value).detail);
    r.m_source_capabilities = #fun(Option::from_js[mut InputDeviceCapabilities])(#var(value).sourceCapabilities);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun HighlightPointerEventInit::as_js(self: HighlightPointerEventInit) -> JsValue = "
    const r = {};
    r.range = #fun(Option::as_js_undef[mut Range])(#var(self).m_range);
    r.pointerId = #fun(Option::as_js_undef[Int])(#var(self).m_pointer_id);
    r.width = #fun(Option::as_js_undef[Float])(#var(self).m_width);
    r.height = #fun(Option::as_js_undef[Float])(#var(self).m_height);
    r.pressure = #fun(Option::as_js_undef[Float])(#var(self).m_pressure);
    r.tiltX = #fun(Option::as_js_undef[Int])(#var(self).m_tilt_x);
    r.tiltY = #fun(Option::as_js_undef[Int])(#var(self).m_tilt_y);
    r.azimuthAngle = #fun(Option::as_js_undef[Float])(#var(self).m_azimuth_angle);
    r.altitudeAngle = #fun(Option::as_js_undef[Float])(#var(self).m_altitude_angle);
    r.tangentialPressure = #fun(Option::as_js_undef[Float])(#var(self).m_tangential_pressure);
    r.twist = #fun(Option::as_js_undef[Int])(#var(self).m_twist);
    r.pointerType = #fun(Option::as_js_undef[String])(#var(self).m_pointer_type);
    r.isPrimary = #fun(Option::as_js_undef[Bool])(#var(self).m_is_primary);
    r.persistentDeviceId = #fun(Option::as_js_undef[Int])(#var(self).m_persistent_device_id);
    r.coalescedEvents = #fun(Option::as_js_undef[List[mut PointerEvent]])(#var(self).m_coalesced_events);
    r.predictedEvents = #fun(Option::as_js_undef[List[mut PointerEvent]])(#var(self).m_predicted_events);
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.button = #fun(Option::as_js_undef[Int])(#var(self).m_button);
    r.buttons = #fun(Option::as_js_undef[Int])(#var(self).m_buttons);
    r.relatedTarget = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_related_target);
    r.movementX = #fun(Option::as_js_undef[Int])(#var(self).m_movement_x);
    r.movementY = #fun(Option::as_js_undef[Int])(#var(self).m_movement_y);
    r.region = #fun(Option::as_js_undef[String])(#var(self).m_region);
    r.ctrlKey = #fun(Option::as_js_undef[Bool])(#var(self).m_ctrl_key);
    r.shiftKey = #fun(Option::as_js_undef[Bool])(#var(self).m_shift_key);
    r.altKey = #fun(Option::as_js_undef[Bool])(#var(self).m_alt_key);
    r.metaKey = #fun(Option::as_js_undef[Bool])(#var(self).m_meta_key);
    r.modifierAltGraph = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_alt_graph);
    r.modifierCapsLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_caps_lock);
    r.modifierFn = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_fn);
    r.modifierNumLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_num_lock);
    r.modifierScrollLock = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_scroll_lock);
    r.modifierSymbol = #fun(Option::as_js_undef[Bool])(#var(self).m_modifier_symbol);
    r.view = #fun(Option::as_js_undef[mut Window])(#var(self).m_view);
    r.detail = #fun(Option::as_js_undef[Int])(#var(self).m_detail);
    r.sourceCapabilities = #fun(Option::as_js_undef[mut InputDeviceCapabilities])(#var(self).m_source_capabilities);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct HighlightPointerEvent()

/// Converts a reference to 'HighlightPointerEvent' to a reference to 'PointerEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_pointer_event(self: HighlightPointerEvent) -> PointerEvent = "return #var(self);"

/// Converts a mutable reference to 'HighlightPointerEvent' to a mutable reference to 'PointerEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_mpointer_event(self: mut HighlightPointerEvent) -> mut PointerEvent = "return #var(self);"

/// Attempts to convert a reference to 'PointerEvent' to a reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_pointer_event(base: PointerEvent) -> HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PointerEvent' to 'HighlightPointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'PointerEvent' to a mutable reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_mpointer_event(base: mut PointerEvent) -> mut HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PointerEvent' to 'HighlightPointerEvent'!\");
"

/// Converts a reference to 'HighlightPointerEvent' to a reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_mouse_event(self: HighlightPointerEvent) -> MouseEvent = "return #var(self);"

/// Converts a mutable reference to 'HighlightPointerEvent' to a mutable reference to 'MouseEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_mmouse_event(self: mut HighlightPointerEvent) -> mut MouseEvent = "return #var(self);"

/// Attempts to convert a reference to 'MouseEvent' to a reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_mouse_event(base: MouseEvent) -> HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'HighlightPointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'MouseEvent' to a mutable reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_mmouse_event(base: mut MouseEvent) -> mut HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'MouseEvent' to 'HighlightPointerEvent'!\");
"

/// Converts a reference to 'HighlightPointerEvent' to a reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_ui_event(self: HighlightPointerEvent) -> UIEvent = "return #var(self);"

/// Converts a mutable reference to 'HighlightPointerEvent' to a mutable reference to 'UIEvent'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_mui_event(self: mut HighlightPointerEvent) -> mut UIEvent = "return #var(self);"

/// Attempts to convert a reference to 'UIEvent' to a reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_ui_event(base: UIEvent) -> HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'HighlightPointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'UIEvent' to a mutable reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_mui_event(base: mut UIEvent) -> mut HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'UIEvent' to 'HighlightPointerEvent'!\");
"

/// Converts a reference to 'HighlightPointerEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_event(self: HighlightPointerEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'HighlightPointerEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::as_mevent(self: mut HighlightPointerEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_event(base: Event) -> HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'HighlightPointerEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'HighlightPointerEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'HighlightPointerEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HighlightPointerEvent::from_mevent(base: mut Event) -> mut HighlightPointerEvent = "
    if(#var(base) instanceof HighlightPointerEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'HighlightPointerEvent'!\");
"

pub ext fun HighlightPointerEvent::range(self: HighlightPointerEvent) -> Option[mut Range]
    = "return #fun(Option::from_js[mut Range])(#var(self).range);"

pub ext fun HighlightPointerEvent::pointer_id(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).pointerId);"

pub ext fun HighlightPointerEvent::width(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun HighlightPointerEvent::height(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun HighlightPointerEvent::pressure(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pressure);"

pub ext fun HighlightPointerEvent::tilt_x(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).tiltX);"

pub ext fun HighlightPointerEvent::tilt_y(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).tiltY);"

pub ext fun HighlightPointerEvent::azimuth_angle(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).azimuthAngle);"

pub ext fun HighlightPointerEvent::altitude_angle(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).altitudeAngle);"

pub ext fun HighlightPointerEvent::tangential_pressure(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).tangentialPressure);"

pub ext fun HighlightPointerEvent::twist(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).twist);"

pub ext fun HighlightPointerEvent::pointer_type(self: HighlightPointerEvent) -> String
    = "return #fun(String::from_js)(#var(self).pointerType);"

pub ext fun HighlightPointerEvent::is_primary(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isPrimary);"

pub ext fun HighlightPointerEvent::persistent_device_id(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).persistentDeviceId);"

pub ext fun HighlightPointerEvent::screen_x(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun HighlightPointerEvent::screen_y(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun HighlightPointerEvent::client_x(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun HighlightPointerEvent::client_y(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun HighlightPointerEvent::ctrl_key(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ctrlKey);"

pub ext fun HighlightPointerEvent::shift_key(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shiftKey);"

pub ext fun HighlightPointerEvent::alt_key(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).altKey);"

pub ext fun HighlightPointerEvent::meta_key(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).metaKey);"

pub ext fun HighlightPointerEvent::button(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).button);"

pub ext fun HighlightPointerEvent::buttons(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).buttons);"

pub ext fun HighlightPointerEvent::related_target(self: HighlightPointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).relatedTarget);"

pub ext fun HighlightPointerEvent::page_x(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun HighlightPointerEvent::page_y(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun HighlightPointerEvent::x(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun HighlightPointerEvent::y(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun HighlightPointerEvent::offset_x(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetX);"

pub ext fun HighlightPointerEvent::offset_y(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).offsetY);"

pub ext fun HighlightPointerEvent::movement_x(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementX);"

pub ext fun HighlightPointerEvent::movement_y(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).movementY);"

pub ext fun HighlightPointerEvent::from_element(self: HighlightPointerEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).fromElement);"

pub ext fun HighlightPointerEvent::to_element(self: HighlightPointerEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).toElement);"

pub ext fun HighlightPointerEvent::layer_x(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerX);"

pub ext fun HighlightPointerEvent::layer_y(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).layerY);"

pub ext fun HighlightPointerEvent::view(self: HighlightPointerEvent) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).view);"

pub ext fun HighlightPointerEvent::detail(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).detail);"

pub ext fun HighlightPointerEvent::source_capabilities(self: HighlightPointerEvent) -> Option[mut InputDeviceCapabilities]
    = "return #fun(Option::from_js[mut InputDeviceCapabilities])(#var(self).sourceCapabilities);"

pub ext fun HighlightPointerEvent::which(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).which);"

pub ext fun HighlightPointerEvent::type(self: HighlightPointerEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HighlightPointerEvent::target(self: HighlightPointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun HighlightPointerEvent::current_target(self: HighlightPointerEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun HighlightPointerEvent::event_phase(self: HighlightPointerEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun HighlightPointerEvent::bubbles(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun HighlightPointerEvent::cancelable(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun HighlightPointerEvent::default_prevented(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun HighlightPointerEvent::composed(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun HighlightPointerEvent::is_trusted(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun HighlightPointerEvent::time_stamp(self: HighlightPointerEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun HighlightPointerEvent::src_element(self: HighlightPointerEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun HighlightPointerEvent::return_value(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun HighlightPointerEvent::set_return_value(self: mut HighlightPointerEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun HighlightPointerEvent::cancel_bubble(self: HighlightPointerEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun HighlightPointerEvent::set_cancel_bubble(self: mut HighlightPointerEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun HighlightPointerEvent::get_coalesced_events(__self: mut HighlightPointerEvent) -> List[mut PointerEvent] = "
    const r = #var(__self).getCoalescedEvents();
    return #fun(List::from_js[mut PointerEvent])(r);
"

pub ext fun HighlightPointerEvent::get_predicted_events(__self: mut HighlightPointerEvent) -> List[mut PointerEvent] = "
    const r = #var(__self).getPredictedEvents();
    return #fun(List::from_js[mut PointerEvent])(r);
"

pub ext fun HighlightPointerEvent::get_modifier_state(__self: mut HighlightPointerEvent, key_arg: String) -> Bool = "
    const r = #var(__self).getModifierState(#fun(String::as_js)(#var(key_arg)));
    return #fun(Bool::from_js)(r);
"

pub ext fun HighlightPointerEvent::init_mouse_event(__self: mut HighlightPointerEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int, screen_x: Int, screen_y: Int, client_x: Int, client_y: Int, ctrl_key: Bool, alt_key: Bool, shift_key: Bool, meta_key: Bool, button: Int, related_target: Option[mut EventTarget]) -> Unit = "
    const r = #var(__self).initMouseEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)), #fun(Int::as_js)(#var(screen_x)), #fun(Int::as_js)(#var(screen_y)), #fun(Int::as_js)(#var(client_x)), #fun(Int::as_js)(#var(client_y)), #fun(Bool::as_js)(#var(ctrl_key)), #fun(Bool::as_js)(#var(alt_key)), #fun(Bool::as_js)(#var(shift_key)), #fun(Bool::as_js)(#var(meta_key)), #fun(Int::as_js)(#var(button)), #fun(Option::as_js[mut EventTarget])(#var(related_target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HighlightPointerEvent::init_ui_event(__self: mut HighlightPointerEvent, type: String, bubbles: Bool, cancelable: Bool, view: Option[mut Window], detail: Int) -> Unit = "
    const r = #var(__self).initUIEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #fun(Option::as_js[mut Window])(#var(view)), #fun(Int::as_js)(#var(detail)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HighlightPointerEvent::composed_path(__self: mut HighlightPointerEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun HighlightPointerEvent::stop_propagation(__self: mut HighlightPointerEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun HighlightPointerEvent::stop_immediate_propagation(__self: mut HighlightPointerEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun HighlightPointerEvent::prevent_default(__self: mut HighlightPointerEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun HighlightPointerEvent::init_event(__self: mut HighlightPointerEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun HighlightPointerEvent::as_js(self: HighlightPointerEvent) -> JsValue = JsValue::unsafe_from[HighlightPointerEvent](self)

pub fun HighlightPointerEvent::from_js(v: JsValue) -> mut HighlightPointerEvent = JsValue::unsafe_as[mut HighlightPointerEvent](v)

pub val HighlightPointerEvent::none: Int = 0
pub val HighlightPointerEvent::capturing_phase: Int = 1
pub val HighlightPointerEvent::at_target: Int = 2
pub val HighlightPointerEvent::bubbling_phase: Int = 3

struct HighlightRegistry()

pub ext fun HighlightRegistry::highlights_from_point(__self: mut HighlightRegistry, x: Float, y: Float, options: mut HighlightsFromPointOptions) -> List[mut HighlightHitResult] = "
    const r = #var(__self).highlightsFromPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(HighlightsFromPointOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut HighlightHitResult])(r);
"

pub fun HighlightRegistry::as_js(self: HighlightRegistry) -> JsValue = JsValue::unsafe_from[HighlightRegistry](self)

pub fun HighlightRegistry::from_js(v: JsValue) -> mut HighlightRegistry = JsValue::unsafe_as[mut HighlightRegistry](v)

pub struct HighlightsFromPointOptions(
    shadow_roots: Option[List[mut ShadowRoot]]
)

pub fun HighlightsFromPointOptions::default() -> mut HighlightsFromPointOptions
    = HighlightsFromPointOptions(Option::Some(List::empty()))

pub ext fun HighlightsFromPointOptions::from_js(value: JsValue) -> mut HighlightsFromPointOptions = "
    const r = {};
    r.m_shadow_roots = #fun(Option::from_js[List[mut ShadowRoot]])(#var(value).shadowRoots);
    return r;
"

pub ext fun HighlightsFromPointOptions::as_js(self: HighlightsFromPointOptions) -> JsValue = "
    const r = {};
    r.shadowRoots = #fun(Option::as_js_undef[List[mut ShadowRoot]])(#var(self).m_shadow_roots);
    return r;
"

pub struct AssignedNodesOptions(
    flatten: Option[Bool]
)

pub fun AssignedNodesOptions::default() -> mut AssignedNodesOptions
    = AssignedNodesOptions(Option::Some(false))

pub ext fun AssignedNodesOptions::from_js(value: JsValue) -> mut AssignedNodesOptions = "
    const r = {};
    r.m_flatten = #fun(Option::from_js[Bool])(#var(value).flatten);
    return r;
"

pub ext fun AssignedNodesOptions::as_js(self: AssignedNodesOptions) -> JsValue = "
    const r = {};
    r.flatten = #fun(Option::as_js_undef[Bool])(#var(self).m_flatten);
    return r;
"

pub struct Baselines(
    alphabetic: Option[Float],
    hanging: Option[Float],
    ideographic: Option[Float]
)

pub fun Baselines::default() -> mut Baselines
    = Baselines(Option::None, Option::None, Option::None)

pub ext fun Baselines::from_js(value: JsValue) -> mut Baselines = "
    const r = {};
    r.m_alphabetic = #fun(Option::from_js[Float])(#var(value).alphabetic);
    r.m_hanging = #fun(Option::from_js[Float])(#var(value).hanging);
    r.m_ideographic = #fun(Option::from_js[Float])(#var(value).ideographic);
    return r;
"

pub ext fun Baselines::as_js(self: Baselines) -> JsValue = "
    const r = {};
    r.alphabetic = #fun(Option::as_js_undef[Float])(#var(self).m_alphabetic);
    r.hanging = #fun(Option::as_js_undef[Float])(#var(self).m_hanging);
    r.ideographic = #fun(Option::as_js_undef[Float])(#var(self).m_ideographic);
    return r;
"

pub val CanvasHighDynamicRangeMode::Default: String = "default"
pub val CanvasHighDynamicRangeMode::Extended: String = "extended"

pub struct CanvasSmpteSt2086Metadata(
    red_primary_x: Float,
    red_primary_y: Float,
    green_primary_x: Float,
    green_primary_y: Float,
    blue_primary_x: Float,
    blue_primary_y: Float,
    white_point_x: Float,
    white_point_y: Float,
    minimum_luminance: Float,
    maximum_luminance: Float
)

pub fun CanvasSmpteSt2086Metadata::default(red_primary_x: Float, red_primary_y: Float, green_primary_x: Float, green_primary_y: Float, blue_primary_x: Float, blue_primary_y: Float, white_point_x: Float, white_point_y: Float, minimum_luminance: Float, maximum_luminance: Float) -> mut CanvasSmpteSt2086Metadata
    = CanvasSmpteSt2086Metadata(red_primary_x, red_primary_y, green_primary_x, green_primary_y, blue_primary_x, blue_primary_y, white_point_x, white_point_y, minimum_luminance, maximum_luminance)

pub ext fun CanvasSmpteSt2086Metadata::from_js(value: JsValue) -> mut CanvasSmpteSt2086Metadata = "
    const r = {};
    r.m_red_primary_x = #fun(Float::from_js)(#var(value).redPrimaryX);
    r.m_red_primary_y = #fun(Float::from_js)(#var(value).redPrimaryY);
    r.m_green_primary_x = #fun(Float::from_js)(#var(value).greenPrimaryX);
    r.m_green_primary_y = #fun(Float::from_js)(#var(value).greenPrimaryY);
    r.m_blue_primary_x = #fun(Float::from_js)(#var(value).bluePrimaryX);
    r.m_blue_primary_y = #fun(Float::from_js)(#var(value).bluePrimaryY);
    r.m_white_point_x = #fun(Float::from_js)(#var(value).whitePointX);
    r.m_white_point_y = #fun(Float::from_js)(#var(value).whitePointY);
    r.m_minimum_luminance = #fun(Float::from_js)(#var(value).minimumLuminance);
    r.m_maximum_luminance = #fun(Float::from_js)(#var(value).maximumLuminance);
    return r;
"

pub ext fun CanvasSmpteSt2086Metadata::as_js(self: CanvasSmpteSt2086Metadata) -> JsValue = "
    const r = {};
    r.redPrimaryX = #fun(Float::as_js)(#var(self).m_red_primary_x);
    r.redPrimaryY = #fun(Float::as_js)(#var(self).m_red_primary_y);
    r.greenPrimaryX = #fun(Float::as_js)(#var(self).m_green_primary_x);
    r.greenPrimaryY = #fun(Float::as_js)(#var(self).m_green_primary_y);
    r.bluePrimaryX = #fun(Float::as_js)(#var(self).m_blue_primary_x);
    r.bluePrimaryY = #fun(Float::as_js)(#var(self).m_blue_primary_y);
    r.whitePointX = #fun(Float::as_js)(#var(self).m_white_point_x);
    r.whitePointY = #fun(Float::as_js)(#var(self).m_white_point_y);
    r.minimumLuminance = #fun(Float::as_js)(#var(self).m_minimum_luminance);
    r.maximumLuminance = #fun(Float::as_js)(#var(self).m_maximum_luminance);
    return r;
"

pub struct CanvasHighDynamicRangeOptions(
    mode: Option[String],
    agtm: Option[String],
    smpte_st_2086_metadata: Option[mut CanvasSmpteSt2086Metadata]
)

pub fun CanvasHighDynamicRangeOptions::default() -> mut CanvasHighDynamicRangeOptions
    = CanvasHighDynamicRangeOptions(Option::Some("default"), Option::None, Option::None)

pub ext fun CanvasHighDynamicRangeOptions::from_js(value: JsValue) -> mut CanvasHighDynamicRangeOptions = "
    const r = {};
    r.m_mode = #fun(Option::from_js[String])(#var(value).mode);
    r.m_agtm = #fun(Option::from_js[String])(#var(value).agtm);
    r.m_smpte_st_2086_metadata = #fun(Option::from_js[mut CanvasSmpteSt2086Metadata])(#var(value).smpteSt2086Metadata);
    return r;
"

pub ext fun CanvasHighDynamicRangeOptions::as_js(self: CanvasHighDynamicRangeOptions) -> JsValue = "
    const r = {};
    r.mode = #fun(Option::as_js_undef[String])(#var(self).m_mode);
    r.agtm = #fun(Option::as_js_undef[String])(#var(self).m_agtm);
    r.smpteSt2086Metadata = #fun(Option::as_js_undef[mut CanvasSmpteSt2086Metadata])(#var(self).m_smpte_st_2086_metadata);
    return r;
"

pub struct CanvasHitTestRect(
    x: Option[Float],
    y: Option[Float],
    width: Option[Float],
    height: Option[Float]
)

pub fun CanvasHitTestRect::default() -> mut CanvasHitTestRect
    = CanvasHitTestRect(Option::None, Option::None, Option::None, Option::None)

pub ext fun CanvasHitTestRect::from_js(value: JsValue) -> mut CanvasHitTestRect = "
    const r = {};
    r.m_x = #fun(Option::from_js[Float])(#var(value).x);
    r.m_y = #fun(Option::from_js[Float])(#var(value).y);
    r.m_width = #fun(Option::from_js[Float])(#var(value).width);
    r.m_height = #fun(Option::from_js[Float])(#var(value).height);
    return r;
"

pub ext fun CanvasHitTestRect::as_js(self: CanvasHitTestRect) -> JsValue = "
    const r = {};
    r.x = #fun(Option::as_js_undef[Float])(#var(self).m_x);
    r.y = #fun(Option::as_js_undef[Float])(#var(self).m_y);
    r.width = #fun(Option::as_js_undef[Float])(#var(self).m_width);
    r.height = #fun(Option::as_js_undef[Float])(#var(self).m_height);
    return r;
"

pub struct CanvasElementHitTestRegion(
    element: Option[mut Element],
    rect: Option[mut CanvasHitTestRect]
)

pub fun CanvasElementHitTestRegion::default() -> mut CanvasElementHitTestRegion
    = CanvasElementHitTestRegion(Option::None, Option::None)

pub ext fun CanvasElementHitTestRegion::from_js(value: JsValue) -> mut CanvasElementHitTestRegion = "
    const r = {};
    r.m_element = #fun(Option::from_js[mut Element])(#var(value).element);
    r.m_rect = #fun(Option::from_js[mut CanvasHitTestRect])(#var(value).rect);
    return r;
"

pub ext fun CanvasElementHitTestRegion::as_js(self: CanvasElementHitTestRegion) -> JsValue = "
    const r = {};
    r.element = #fun(Option::as_js_undef[mut Element])(#var(self).m_element);
    r.rect = #fun(Option::as_js_undef[mut CanvasHitTestRect])(#var(self).m_rect);
    return r;
"

struct HTMLCanvasElement()

/// Converts a reference to 'HTMLCanvasElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::as_html_element(self: HTMLCanvasElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLCanvasElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::as_mhtml_element(self: mut HTMLCanvasElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLCanvasElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLCanvasElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::from_html_element(base: HTMLElement) -> HTMLCanvasElement = "
    if(#var(base) instanceof HTMLCanvasElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLCanvasElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLCanvasElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLCanvasElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLCanvasElement = "
    if(#var(base) instanceof HTMLCanvasElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLCanvasElement'!\");
"

/// Converts a reference to 'HTMLCanvasElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::as_element(self: HTMLCanvasElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLCanvasElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::as_melement(self: mut HTMLCanvasElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLCanvasElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLCanvasElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::from_element(base: Element) -> HTMLCanvasElement = "
    if(#var(base) instanceof HTMLCanvasElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLCanvasElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLCanvasElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLCanvasElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLCanvasElement::from_melement(base: mut Element) -> mut HTMLCanvasElement = "
    if(#var(base) instanceof HTMLCanvasElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLCanvasElement'!\");
"

pub ext fun HTMLCanvasElement::width(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLCanvasElement::set_width(self: mut HTMLCanvasElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::height(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun HTMLCanvasElement::set_height(self: mut HTMLCanvasElement, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::layout_subtree(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).layoutSubtree);"

pub ext fun HTMLCanvasElement::set_layout_subtree(self: mut HTMLCanvasElement, value: Bool)
    = "#var(self).layoutSubtree = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::title(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLCanvasElement::set_title(self: mut HTMLCanvasElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::lang(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLCanvasElement::set_lang(self: mut HTMLCanvasElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::translate(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLCanvasElement::set_translate(self: mut HTMLCanvasElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::dir(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLCanvasElement::set_dir(self: mut HTMLCanvasElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::hidden(self: HTMLCanvasElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLCanvasElement::set_hidden(self: mut HTMLCanvasElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLCanvasElement::inert(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLCanvasElement::set_inert(self: mut HTMLCanvasElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::access_key(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLCanvasElement::set_access_key(self: mut HTMLCanvasElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::draggable(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLCanvasElement::set_draggable(self: mut HTMLCanvasElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::spellcheck(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLCanvasElement::set_spellcheck(self: mut HTMLCanvasElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::autocapitalize(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLCanvasElement::set_autocapitalize(self: mut HTMLCanvasElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::edit_context(self: HTMLCanvasElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLCanvasElement::set_edit_context(self: mut HTMLCanvasElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLCanvasElement::content_editable(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLCanvasElement::set_content_editable(self: mut HTMLCanvasElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::enter_key_hint(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLCanvasElement::set_enter_key_hint(self: mut HTMLCanvasElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::is_content_editable(self: HTMLCanvasElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLCanvasElement::input_mode(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLCanvasElement::set_input_mode(self: mut HTMLCanvasElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::virtual_keyboard_policy(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLCanvasElement::set_virtual_keyboard_policy(self: mut HTMLCanvasElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::scroll_parent(self: HTMLCanvasElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLCanvasElement::offset_parent(self: HTMLCanvasElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLCanvasElement::offset_top(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLCanvasElement::offset_left(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLCanvasElement::offset_width(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLCanvasElement::offset_height(self: HTMLCanvasElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLCanvasElement::popover(self: HTMLCanvasElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLCanvasElement::set_popover(self: mut HTMLCanvasElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLCanvasElement::inner_text(self: HTMLCanvasElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLCanvasElement::set_inner_text(self: mut HTMLCanvasElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLCanvasElement::outer_text(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLCanvasElement::set_outer_text(self: mut HTMLCanvasElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::writing_suggestions(self: HTMLCanvasElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLCanvasElement::set_writing_suggestions(self: mut HTMLCanvasElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLCanvasElement::to_data_url(__self: mut HTMLCanvasElement, type: String, quality: JsValue) -> String = "
    const r = #var(__self).toDataURL(#fun(String::as_js)(#var(type)), #var(quality));
    return #fun(String::from_js)(r);
"

pub ext fun HTMLCanvasElement::to_blob(__self: mut HTMLCanvasElement, callback: Fun(Option[mut Blob]) -> Unit, type: String, quality: JsValue) -> Unit = "
    const r = #var(__self).toBlob(((p0) => { const r = #var(callback)(#fun(Option::from_js[mut Blob])(p0)); return #fun(Unit::as_js)(r); }), #fun(String::as_js)(#var(type)), #var(quality));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLCanvasElement::configure_high_dynamic_range(__self: mut HTMLCanvasElement, options: mut CanvasHighDynamicRangeOptions) -> Unit = "
    const r = #var(__self).configureHighDynamicRange(#fun(CanvasHighDynamicRangeOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLCanvasElement::click(__self: mut HTMLCanvasElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLCanvasElement::attach_internals(__self: mut HTMLCanvasElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLCanvasElement::toggle_popover(__self: mut HTMLCanvasElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLCanvasElement::show_popover(__self: mut HTMLCanvasElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLCanvasElement::hide_popover(__self: mut HTMLCanvasElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLCanvasElement::start_view_transition(__self: mut HTMLCanvasElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLCanvasElement::start_view_transition_f_prom_unit(__self: mut HTMLCanvasElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLCanvasElement::start_view_transition_mview_transition_options(__self: mut HTMLCanvasElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLCanvasElement::as_js(self: HTMLCanvasElement) -> JsValue = JsValue::unsafe_from[HTMLCanvasElement](self)

pub fun HTMLCanvasElement::from_js(v: JsValue) -> mut HTMLCanvasElement = JsValue::unsafe_as[mut HTMLCanvasElement](v)

struct ImageData()

pub ext fun ImageData::from_int_int(sw: Int, sh: Int) -> mut ImageData
    = "return new ImageData(#fun(Int::as_js)(#var(sw)), #fun(Int::as_js)(#var(sh)));"

pub ext fun ImageData::from_int_int_mimage_data_settings(sw: Int, sh: Int, settings: mut ImageDataSettings) -> mut ImageData
    = "return new ImageData(#fun(Int::as_js)(#var(sw)), #fun(Int::as_js)(#var(sh)), #fun(ImageDataSettings::as_js)(#var(settings)));"

pub ext fun ImageData::from_any_int_int_mimage_data_settings(data: JsValue, sw: Int, sh: Int, settings: mut ImageDataSettings) -> mut ImageData
    = "return new ImageData(#var(data), #fun(Int::as_js)(#var(sw)), #fun(Int::as_js)(#var(sh)), #fun(ImageDataSettings::as_js)(#var(settings)));"

pub ext fun ImageData::width(self: ImageData) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun ImageData::height(self: ImageData) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun ImageData::color_space(self: ImageData) -> String
    = "return #fun(String::from_js)(#var(self).colorSpace);"

pub ext fun ImageData::pixel_format(self: ImageData) -> String
    = "return #fun(String::from_js)(#var(self).pixelFormat);"

pub ext fun ImageData::data(self: ImageData) -> JsValue
    = "return #var(self).data;"

pub fun ImageData::as_js(self: ImageData) -> JsValue = JsValue::unsafe_from[ImageData](self)

pub fun ImageData::from_js(v: JsValue) -> mut ImageData = JsValue::unsafe_as[mut ImageData](v)

pub val PredefinedColorSpace::Srgb: String = "srgb"
pub val PredefinedColorSpace::Rec2020: String = "rec2020"
pub val PredefinedColorSpace::DisplayP3: String = "display-p3"
pub val PredefinedColorSpace::Rec2100Hlg: String = "rec2100-hlg"
pub val PredefinedColorSpace::Rec2100Pq: String = "rec2100-pq"
pub val PredefinedColorSpace::SrgbLinear: String = "srgb-linear"

pub val ImageDataPixelFormat::RgbaUnorm8: String = "rgba-unorm8"
pub val ImageDataPixelFormat::RgbaFloat16: String = "rgba-float16"
pub val ImageDataPixelFormat::RgbaFloat32: String = "rgba-float32"

pub struct ImageDataSettings(
    color_space: Option[String],
    pixel_format: Option[String]
)

pub fun ImageDataSettings::default() -> mut ImageDataSettings
    = ImageDataSettings(Option::None, Option::Some("rgba-unorm8"))

pub ext fun ImageDataSettings::from_js(value: JsValue) -> mut ImageDataSettings = "
    const r = {};
    r.m_color_space = #fun(Option::from_js[String])(#var(value).colorSpace);
    r.m_pixel_format = #fun(Option::from_js[String])(#var(value).pixelFormat);
    return r;
"

pub ext fun ImageDataSettings::as_js(self: ImageDataSettings) -> JsValue = "
    const r = {};
    r.colorSpace = #fun(Option::as_js_undef[String])(#var(self).m_color_space);
    r.pixelFormat = #fun(Option::as_js_undef[String])(#var(self).m_pixel_format);
    return r;
"

pub struct ImageEncodeOptions(
    type: Option[String],
    quality: Option[Float]
)

pub fun ImageEncodeOptions::default() -> mut ImageEncodeOptions
    = ImageEncodeOptions(Option::Some("image/png"), Option::Some(1.0))

pub ext fun ImageEncodeOptions::from_js(value: JsValue) -> mut ImageEncodeOptions = "
    const r = {};
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_quality = #fun(Option::from_js[Float])(#var(value).quality);
    return r;
"

pub ext fun ImageEncodeOptions::as_js(self: ImageEncodeOptions) -> JsValue = "
    const r = {};
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.quality = #fun(Option::as_js_undef[Float])(#var(self).m_quality);
    return r;
"

struct TextCluster()

pub ext fun TextCluster::x(self: TextCluster) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun TextCluster::y(self: TextCluster) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun TextCluster::start(self: TextCluster) -> Int
    = "return #fun(Int::from_js)(#var(self).start);"

pub ext fun TextCluster::end(self: TextCluster) -> Int
    = "return #fun(Int::from_js)(#var(self).end);"

pub ext fun TextCluster::align(self: TextCluster) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun TextCluster::baseline(self: TextCluster) -> String
    = "return #fun(String::from_js)(#var(self).baseline);"

pub fun TextCluster::as_js(self: TextCluster) -> JsValue = JsValue::unsafe_from[TextCluster](self)

pub fun TextCluster::from_js(v: JsValue) -> mut TextCluster = JsValue::unsafe_as[mut TextCluster](v)

pub val CanvasTextAlign::Start: String = "start"
pub val CanvasTextAlign::End: String = "end"
pub val CanvasTextAlign::Left: String = "left"
pub val CanvasTextAlign::Right: String = "right"
pub val CanvasTextAlign::Center: String = "center"

pub val CanvasTextBaseline::Top: String = "top"
pub val CanvasTextBaseline::Hanging: String = "hanging"
pub val CanvasTextBaseline::Middle: String = "middle"
pub val CanvasTextBaseline::Alphabetic: String = "alphabetic"
pub val CanvasTextBaseline::Ideographic: String = "ideographic"
pub val CanvasTextBaseline::Bottom: String = "bottom"

pub struct TextClusterOptions(
    align: Option[String],
    baseline: Option[String],
    x: Option[Float],
    y: Option[Float]
)

pub fun TextClusterOptions::default() -> mut TextClusterOptions
    = TextClusterOptions(Option::None, Option::None, Option::None, Option::None)

pub ext fun TextClusterOptions::from_js(value: JsValue) -> mut TextClusterOptions = "
    const r = {};
    r.m_align = #fun(Option::from_js[String])(#var(value).align);
    r.m_baseline = #fun(Option::from_js[String])(#var(value).baseline);
    r.m_x = #fun(Option::from_js[Float])(#var(value).x);
    r.m_y = #fun(Option::from_js[Float])(#var(value).y);
    return r;
"

pub ext fun TextClusterOptions::as_js(self: TextClusterOptions) -> JsValue = "
    const r = {};
    r.align = #fun(Option::as_js_undef[String])(#var(self).m_align);
    r.baseline = #fun(Option::as_js_undef[String])(#var(self).m_baseline);
    r.x = #fun(Option::as_js_undef[Float])(#var(self).m_x);
    r.y = #fun(Option::as_js_undef[Float])(#var(self).m_y);
    return r;
"

struct TextMetrics()

pub ext fun TextMetrics::width(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun TextMetrics::actual_bounding_box_left(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).actualBoundingBoxLeft);"

pub ext fun TextMetrics::actual_bounding_box_right(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).actualBoundingBoxRight);"

pub ext fun TextMetrics::font_bounding_box_ascent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).fontBoundingBoxAscent);"

pub ext fun TextMetrics::font_bounding_box_descent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).fontBoundingBoxDescent);"

pub ext fun TextMetrics::actual_bounding_box_ascent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).actualBoundingBoxAscent);"

pub ext fun TextMetrics::actual_bounding_box_descent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).actualBoundingBoxDescent);"

pub ext fun TextMetrics::hanging_baseline(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).hangingBaseline);"

pub ext fun TextMetrics::alphabetic_baseline(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).alphabeticBaseline);"

pub ext fun TextMetrics::ideographic_baseline(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).ideographicBaseline);"

pub ext fun TextMetrics::em_height_ascent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).emHeightAscent);"

pub ext fun TextMetrics::em_height_descent(self: TextMetrics) -> Float
    = "return #fun(Float::from_js)(#var(self).emHeightDescent);"

pub ext fun TextMetrics::get_index_from_offset(__self: mut TextMetrics, x: Float) -> Int = "
    const r = #var(__self).getIndexFromOffset(#fun(Float::as_js)(#var(x)));
    return #fun(Int::from_js)(r);
"

pub ext fun TextMetrics::get_selection_rects(__self: mut TextMetrics, start: Int, end: Int) -> List[mut DOMRectReadOnly] = "
    const r = #var(__self).getSelectionRects(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)));
    return #fun(List::from_js[mut DOMRectReadOnly])(r);
"

pub ext fun TextMetrics::get_actual_bounding_box(__self: mut TextMetrics, start: Int, end: Int) -> mut DOMRectReadOnly = "
    const r = #var(__self).getActualBoundingBox(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)));
    return #fun(DOMRectReadOnly::from_js)(r);
"

pub ext fun TextMetrics::get_text_clusters_int_int_mtext_cluster_options(__self: mut TextMetrics, start: Int, end: Int, options: mut TextClusterOptions) -> List[mut TextCluster] = "
    const r = #var(__self).getTextClusters(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(TextClusterOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut TextCluster])(r);
"

pub ext fun TextMetrics::get_text_clusters_mtext_cluster_options(__self: mut TextMetrics, options: mut TextClusterOptions) -> List[mut TextCluster] = "
    const r = #var(__self).getTextClusters(#fun(TextClusterOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut TextCluster])(r);
"

pub fun TextMetrics::as_js(self: TextMetrics) -> JsValue = JsValue::unsafe_from[TextMetrics](self)

pub fun TextMetrics::from_js(v: JsValue) -> mut TextMetrics = JsValue::unsafe_as[mut TextMetrics](v)

struct CloseWatcher()

/// Converts a reference to 'CloseWatcher' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CloseWatcher::as_event_target(self: CloseWatcher) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CloseWatcher' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CloseWatcher::as_mevent_target(self: mut CloseWatcher) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CloseWatcher'.
/// The conversion may fail and panic if 'base' is not a reference to 'CloseWatcher' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CloseWatcher::from_event_target(base: EventTarget) -> CloseWatcher = "
    if(#var(base) instanceof CloseWatcher) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CloseWatcher'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CloseWatcher'.
/// The conversion may fail and panic if 'base' is not a reference to 'CloseWatcher' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CloseWatcher::from_mevent_target(base: mut EventTarget) -> mut CloseWatcher = "
    if(#var(base) instanceof CloseWatcher) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CloseWatcher'!\");
"

pub ext fun CloseWatcher::from_mclose_watcher_options(options: mut CloseWatcherOptions) -> mut CloseWatcher
    = "return new CloseWatcher(#fun(CloseWatcherOptions::as_js)(#var(options)));"

pub ext fun CloseWatcher::oncancel(self: CloseWatcher) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun CloseWatcher::set_oncancel(self: mut CloseWatcher, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CloseWatcher::onclose(self: CloseWatcher) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun CloseWatcher::set_onclose(self: mut CloseWatcher, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun CloseWatcher::request_close(__self: mut CloseWatcher) -> Unit = "
    const r = #var(__self).requestClose();
    return #fun(Unit::from_js)(r);
"

pub ext fun CloseWatcher::close(__self: mut CloseWatcher) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun CloseWatcher::destroy(__self: mut CloseWatcher) -> Unit = "
    const r = #var(__self).destroy();
    return #fun(Unit::from_js)(r);
"

pub ext fun CloseWatcher::add_event_listener(__self: mut CloseWatcher, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CloseWatcher::remove_event_listener(__self: mut CloseWatcher, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CloseWatcher::dispatch_event(__self: mut CloseWatcher, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CloseWatcher::when(__self: mut CloseWatcher, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun CloseWatcher::as_js(self: CloseWatcher) -> JsValue = JsValue::unsafe_from[CloseWatcher](self)

pub fun CloseWatcher::from_js(v: JsValue) -> mut CloseWatcher = JsValue::unsafe_as[mut CloseWatcher](v)

pub struct CloseWatcherOptions(
    signal: Option[mut AbortSignal]
)

pub fun CloseWatcherOptions::default() -> mut CloseWatcherOptions
    = CloseWatcherOptions(Option::None)

pub ext fun CloseWatcherOptions::from_js(value: JsValue) -> mut CloseWatcherOptions = "
    const r = {};
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    return r;
"

pub ext fun CloseWatcherOptions::as_js(self: CloseWatcherOptions) -> JsValue = "
    const r = {};
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    return r;
"

struct CustomElementRegistry()

pub ext fun CustomElementRegistry::new() -> mut CustomElementRegistry
    = "return new CustomElementRegistry();"

pub ext fun CustomElementRegistry::define(__self: mut CustomElementRegistry, name: String, constructor: Fun() -> JsValue, options: mut ElementDefinitionOptions) -> Unit = "
    const r = #var(__self).define(#fun(String::as_js)(#var(name)), (() => { const r = #var(constructor)(); return r; }), #fun(ElementDefinitionOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomElementRegistry::get(__self: mut CustomElementRegistry, name: String) -> JsValue = "
    const r = #var(__self).get(#fun(String::as_js)(#var(name)));
    return r;
"

pub ext fun CustomElementRegistry::get_name(__self: mut CustomElementRegistry, constructor: Fun() -> JsValue) -> Option[String] = "
    const r = #var(__self).getName((() => { const r = #var(constructor)(); return r; }));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CustomElementRegistry::when_defined(__self: mut CustomElementRegistry, name: String) -> Promise[Fun() -> JsValue] = "
    const r = #var(__self).whenDefined(#fun(String::as_js)(#var(name)));
    return #fun(Promise::from_js[Fun() -> JsValue])(r);
"

pub ext fun CustomElementRegistry::upgrade(__self: mut CustomElementRegistry, root: mut Node) -> Unit = "
    const r = #var(__self).upgrade(#fun(Node::as_js)(#var(root)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomElementRegistry::initialize(__self: mut CustomElementRegistry, root: JsValue) -> Unit = "
    const r = #var(__self).initialize(#var(root));
    return #fun(Unit::from_js)(r);
"

pub fun CustomElementRegistry::as_js(self: CustomElementRegistry) -> JsValue = JsValue::unsafe_from[CustomElementRegistry](self)

pub fun CustomElementRegistry::from_js(v: JsValue) -> mut CustomElementRegistry = JsValue::unsafe_as[mut CustomElementRegistry](v)

pub val FormStateRestoreMode::Restore: String = "restore"
pub val FormStateRestoreMode::Autocomplete: String = "autocomplete"

struct CustomStateSet()

pub ext fun CustomStateSet::add(__self: mut CustomStateSet, key: String) -> Unit = "
    const r = #var(__self).add(#fun(String::as_js)(#var(key)));
    return #fun(Unit::from_js)(r);
"

pub fun CustomStateSet::as_js(self: CustomStateSet) -> JsValue = JsValue::unsafe_from[CustomStateSet](self)

pub fun CustomStateSet::from_js(v: JsValue) -> mut CustomStateSet = JsValue::unsafe_as[mut CustomStateSet](v)

struct ElementInternals()

pub ext fun ElementInternals::form(self: ElementInternals) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun ElementInternals::will_validate(self: ElementInternals) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun ElementInternals::validity(self: ElementInternals) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun ElementInternals::validation_message(self: ElementInternals) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun ElementInternals::labels(self: ElementInternals) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun ElementInternals::states(self: ElementInternals) -> mut CustomStateSet
    = "return #fun(CustomStateSet::from_js)(#var(self).states);"

pub ext fun ElementInternals::shadow_root(self: ElementInternals) -> Option[mut ShadowRoot]
    = "return #fun(Option::from_js[mut ShadowRoot])(#var(self).shadowRoot);"

pub ext fun ElementInternals::role(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).role);"

pub ext fun ElementInternals::set_role(self: mut ElementInternals, value: Option[String])
    = "#var(self).role = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_atomic(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaAtomic);"

pub ext fun ElementInternals::set_aria_atomic(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaAtomic = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_auto_complete(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaAutoComplete);"

pub ext fun ElementInternals::set_aria_auto_complete(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaAutoComplete = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_busy(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBusy);"

pub ext fun ElementInternals::set_aria_busy(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaBusy = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_braille_label(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBrailleLabel);"

pub ext fun ElementInternals::set_aria_braille_label(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaBrailleLabel = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_braille_role_description(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaBrailleRoleDescription);"

pub ext fun ElementInternals::set_aria_braille_role_description(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaBrailleRoleDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_checked(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaChecked);"

pub ext fun ElementInternals::set_aria_checked(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaChecked = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_col_count(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColCount);"

pub ext fun ElementInternals::set_aria_col_count(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaColCount = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_col_index(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColIndex);"

pub ext fun ElementInternals::set_aria_col_index(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaColIndex = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_col_index_text(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColIndexText);"

pub ext fun ElementInternals::set_aria_col_index_text(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaColIndexText = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_col_span(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaColSpan);"

pub ext fun ElementInternals::set_aria_col_span(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaColSpan = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_current(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaCurrent);"

pub ext fun ElementInternals::set_aria_current(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaCurrent = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_description(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaDescription);"

pub ext fun ElementInternals::set_aria_description(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_disabled(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaDisabled);"

pub ext fun ElementInternals::set_aria_disabled(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaDisabled = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_expanded(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaExpanded);"

pub ext fun ElementInternals::set_aria_expanded(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaExpanded = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_has_popup(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaHasPopup);"

pub ext fun ElementInternals::set_aria_has_popup(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaHasPopup = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_hidden(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaHidden);"

pub ext fun ElementInternals::set_aria_hidden(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaHidden = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_invalid(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaInvalid);"

pub ext fun ElementInternals::set_aria_invalid(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaInvalid = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_key_shortcuts(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaKeyShortcuts);"

pub ext fun ElementInternals::set_aria_key_shortcuts(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaKeyShortcuts = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_label(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLabel);"

pub ext fun ElementInternals::set_aria_label(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaLabel = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_level(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLevel);"

pub ext fun ElementInternals::set_aria_level(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaLevel = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_live(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaLive);"

pub ext fun ElementInternals::set_aria_live(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaLive = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_modal(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaModal);"

pub ext fun ElementInternals::set_aria_modal(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaModal = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_multi_line(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaMultiLine);"

pub ext fun ElementInternals::set_aria_multi_line(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaMultiLine = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_multi_selectable(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaMultiSelectable);"

pub ext fun ElementInternals::set_aria_multi_selectable(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaMultiSelectable = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_orientation(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaOrientation);"

pub ext fun ElementInternals::set_aria_orientation(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaOrientation = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_placeholder(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPlaceholder);"

pub ext fun ElementInternals::set_aria_placeholder(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaPlaceholder = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_pos_in_set(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPosInSet);"

pub ext fun ElementInternals::set_aria_pos_in_set(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaPosInSet = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_pressed(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaPressed);"

pub ext fun ElementInternals::set_aria_pressed(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaPressed = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_read_only(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaReadOnly);"

pub ext fun ElementInternals::set_aria_read_only(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaReadOnly = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_relevant(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRelevant);"

pub ext fun ElementInternals::set_aria_relevant(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRelevant = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_required(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRequired);"

pub ext fun ElementInternals::set_aria_required(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRequired = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_role_description(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRoleDescription);"

pub ext fun ElementInternals::set_aria_role_description(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRoleDescription = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_row_count(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowCount);"

pub ext fun ElementInternals::set_aria_row_count(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRowCount = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_row_index(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowIndex);"

pub ext fun ElementInternals::set_aria_row_index(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRowIndex = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_row_index_text(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowIndexText);"

pub ext fun ElementInternals::set_aria_row_index_text(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRowIndexText = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_row_span(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaRowSpan);"

pub ext fun ElementInternals::set_aria_row_span(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaRowSpan = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_selected(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSelected);"

pub ext fun ElementInternals::set_aria_selected(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaSelected = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_set_size(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSetSize);"

pub ext fun ElementInternals::set_aria_set_size(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaSetSize = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_sort(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaSort);"

pub ext fun ElementInternals::set_aria_sort(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaSort = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_value_max(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueMax);"

pub ext fun ElementInternals::set_aria_value_max(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaValueMax = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_value_min(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueMin);"

pub ext fun ElementInternals::set_aria_value_min(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaValueMin = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_value_now(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueNow);"

pub ext fun ElementInternals::set_aria_value_now(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaValueNow = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_value_text(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaValueText);"

pub ext fun ElementInternals::set_aria_value_text(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaValueText = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_virtual_content(self: ElementInternals) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).ariaVirtualContent);"

pub ext fun ElementInternals::set_aria_virtual_content(self: mut ElementInternals, value: Option[String])
    = "#var(self).ariaVirtualContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun ElementInternals::aria_active_descendant_element(self: ElementInternals) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).ariaActiveDescendantElement);"

pub ext fun ElementInternals::set_aria_active_descendant_element(self: mut ElementInternals, value: Option[mut Element])
    = "#var(self).ariaActiveDescendantElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun ElementInternals::aria_controls_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaControlsElements);"

pub ext fun ElementInternals::set_aria_controls_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaControlsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_described_by_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaDescribedByElements);"

pub ext fun ElementInternals::set_aria_described_by_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaDescribedByElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_details_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaDetailsElements);"

pub ext fun ElementInternals::set_aria_details_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaDetailsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_error_message_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaErrorMessageElements);"

pub ext fun ElementInternals::set_aria_error_message_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaErrorMessageElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_flow_to_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaFlowToElements);"

pub ext fun ElementInternals::set_aria_flow_to_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaFlowToElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_labelled_by_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaLabelledByElements);"

pub ext fun ElementInternals::set_aria_labelled_by_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaLabelledByElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::aria_owns_elements(self: ElementInternals) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).ariaOwnsElements);"

pub ext fun ElementInternals::set_aria_owns_elements(self: mut ElementInternals, value: Option[JsValue])
    = "#var(self).ariaOwnsElements = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun ElementInternals::set_form_value(__self: mut ElementInternals, value: Option[JsValue], state: Option[JsValue]) -> Unit = "
    const r = #var(__self).setFormValue(#fun(Option::as_js[JsValue])(#var(value)), #fun(Option::as_js[JsValue])(#var(state)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ElementInternals::set_validity(__self: mut ElementInternals, flags: mut ValidityStateFlags, message: String, anchor: mut HTMLElement) -> Unit = "
    const r = #var(__self).setValidity(#fun(ValidityStateFlags::as_js)(#var(flags)), #fun(String::as_js)(#var(message)), #fun(HTMLElement::as_js)(#var(anchor)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ElementInternals::check_validity(__self: mut ElementInternals) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun ElementInternals::report_validity(__self: mut ElementInternals) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub fun ElementInternals::as_js(self: ElementInternals) -> JsValue = JsValue::unsafe_from[ElementInternals](self)

pub fun ElementInternals::from_js(v: JsValue) -> mut ElementInternals = JsValue::unsafe_as[mut ElementInternals](v)

pub struct ValidityStateFlags(
    value_missing: Option[Bool],
    type_mismatch: Option[Bool],
    pattern_mismatch: Option[Bool],
    too_long: Option[Bool],
    too_short: Option[Bool],
    range_underflow: Option[Bool],
    range_overflow: Option[Bool],
    step_mismatch: Option[Bool],
    bad_input: Option[Bool],
    custom_error: Option[Bool]
)

pub fun ValidityStateFlags::default() -> mut ValidityStateFlags
    = ValidityStateFlags(Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun ValidityStateFlags::from_js(value: JsValue) -> mut ValidityStateFlags = "
    const r = {};
    r.m_value_missing = #fun(Option::from_js[Bool])(#var(value).valueMissing);
    r.m_type_mismatch = #fun(Option::from_js[Bool])(#var(value).typeMismatch);
    r.m_pattern_mismatch = #fun(Option::from_js[Bool])(#var(value).patternMismatch);
    r.m_too_long = #fun(Option::from_js[Bool])(#var(value).tooLong);
    r.m_too_short = #fun(Option::from_js[Bool])(#var(value).tooShort);
    r.m_range_underflow = #fun(Option::from_js[Bool])(#var(value).rangeUnderflow);
    r.m_range_overflow = #fun(Option::from_js[Bool])(#var(value).rangeOverflow);
    r.m_step_mismatch = #fun(Option::from_js[Bool])(#var(value).stepMismatch);
    r.m_bad_input = #fun(Option::from_js[Bool])(#var(value).badInput);
    r.m_custom_error = #fun(Option::from_js[Bool])(#var(value).customError);
    return r;
"

pub ext fun ValidityStateFlags::as_js(self: ValidityStateFlags) -> JsValue = "
    const r = {};
    r.valueMissing = #fun(Option::as_js_undef[Bool])(#var(self).m_value_missing);
    r.typeMismatch = #fun(Option::as_js_undef[Bool])(#var(self).m_type_mismatch);
    r.patternMismatch = #fun(Option::as_js_undef[Bool])(#var(self).m_pattern_mismatch);
    r.tooLong = #fun(Option::as_js_undef[Bool])(#var(self).m_too_long);
    r.tooShort = #fun(Option::as_js_undef[Bool])(#var(self).m_too_short);
    r.rangeUnderflow = #fun(Option::as_js_undef[Bool])(#var(self).m_range_underflow);
    r.rangeOverflow = #fun(Option::as_js_undef[Bool])(#var(self).m_range_overflow);
    r.stepMismatch = #fun(Option::as_js_undef[Bool])(#var(self).m_step_mismatch);
    r.badInput = #fun(Option::as_js_undef[Bool])(#var(self).m_bad_input);
    r.customError = #fun(Option::as_js_undef[Bool])(#var(self).m_custom_error);
    return r;
"

struct Fence()

pub ext fun Fence::report_event(__self: mut Fence, event: JsValue) -> Unit = "
    const r = #var(__self).reportEvent(#var(event));
    return #fun(Unit::from_js)(r);
"

pub ext fun Fence::set_report_event_data_for_automatic_beacons(__self: mut Fence, event: mut FenceEvent) -> Unit = "
    const r = #var(__self).setReportEventDataForAutomaticBeacons(#fun(FenceEvent::as_js)(#var(event)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Fence::get_nested_configs(__self: mut Fence) -> List[mut FencedFrameConfig] = "
    const r = #var(__self).getNestedConfigs();
    return #fun(List::from_js[mut FencedFrameConfig])(r);
"

pub ext fun Fence::disable_untrusted_network(__self: mut Fence) -> Promise[Unit] = "
    const r = #var(__self).disableUntrustedNetwork();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Fence::notify_event(__self: mut Fence, triggering__event: mut Event) -> Unit = "
    const r = #var(__self).notifyEvent(#fun(Event::as_js)(#var(triggering__event)));
    return #fun(Unit::from_js)(r);
"

pub fun Fence::as_js(self: Fence) -> JsValue = JsValue::unsafe_from[Fence](self)

pub fun Fence::from_js(v: JsValue) -> mut Fence = JsValue::unsafe_as[mut Fence](v)

pub val FenceReportingDestination::Buyer: String = "buyer"
pub val FenceReportingDestination::Seller: String = "seller"
pub val FenceReportingDestination::ComponentSeller: String = "component-seller"
pub val FenceReportingDestination::DirectSeller: String = "direct-seller"
pub val FenceReportingDestination::SharedStorageSelectUrl: String = "shared-storage-select-url"

pub struct FenceEvent(
    event_type: Option[String],
    event_data: Option[String],
    destination: Option[List[String]],
    cross_origin_exposed: Option[Bool],
    once: Option[Bool],
    destination_url: Option[String]
)

pub fun FenceEvent::default() -> mut FenceEvent
    = FenceEvent(Option::None, Option::None, Option::None, Option::Some(false), Option::Some(false), Option::None)

pub ext fun FenceEvent::from_js(value: JsValue) -> mut FenceEvent = "
    const r = {};
    r.m_event_type = #fun(Option::from_js[String])(#var(value).eventType);
    r.m_event_data = #fun(Option::from_js[String])(#var(value).eventData);
    r.m_destination = #fun(Option::from_js[List[String]])(#var(value).destination);
    r.m_cross_origin_exposed = #fun(Option::from_js[Bool])(#var(value).crossOriginExposed);
    r.m_once = #fun(Option::from_js[Bool])(#var(value).once);
    r.m_destination_url = #fun(Option::from_js[String])(#var(value).destinationURL);
    return r;
"

pub ext fun FenceEvent::as_js(self: FenceEvent) -> JsValue = "
    const r = {};
    r.eventType = #fun(Option::as_js_undef[String])(#var(self).m_event_type);
    r.eventData = #fun(Option::as_js_undef[String])(#var(self).m_event_data);
    r.destination = #fun(Option::as_js_undef[List[String]])(#var(self).m_destination);
    r.crossOriginExposed = #fun(Option::as_js_undef[Bool])(#var(self).m_cross_origin_exposed);
    r.once = #fun(Option::as_js_undef[Bool])(#var(self).m_once);
    r.destinationURL = #fun(Option::as_js_undef[String])(#var(self).m_destination_url);
    return r;
"

pub val OpaqueProperty::Opaque: String = "opaque"

struct FencedFrameConfig()

pub ext fun FencedFrameConfig::from_str(url: String) -> mut FencedFrameConfig
    = "return new FencedFrameConfig(#fun(String::as_js)(#var(url)));"

pub ext fun FencedFrameConfig::set_shared_storage_context(__self: mut FencedFrameConfig, context_string: String) -> Unit = "
    const r = #var(__self).setSharedStorageContext(#fun(String::as_js)(#var(context_string)));
    return #fun(Unit::from_js)(r);
"

pub fun FencedFrameConfig::as_js(self: FencedFrameConfig) -> JsValue = JsValue::unsafe_from[FencedFrameConfig](self)

pub fun FencedFrameConfig::from_js(v: JsValue) -> mut FencedFrameConfig = JsValue::unsafe_as[mut FencedFrameConfig](v)

struct HTMLFencedFrameElement()

/// Converts a reference to 'HTMLFencedFrameElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::as_html_element(self: HTMLFencedFrameElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFencedFrameElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::as_mhtml_element(self: mut HTMLFencedFrameElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFencedFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFencedFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::from_html_element(base: HTMLElement) -> HTMLFencedFrameElement = "
    if(#var(base) instanceof HTMLFencedFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFencedFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFencedFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFencedFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFencedFrameElement = "
    if(#var(base) instanceof HTMLFencedFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFencedFrameElement'!\");
"

/// Converts a reference to 'HTMLFencedFrameElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::as_element(self: HTMLFencedFrameElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFencedFrameElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::as_melement(self: mut HTMLFencedFrameElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFencedFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFencedFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::from_element(base: Element) -> HTMLFencedFrameElement = "
    if(#var(base) instanceof HTMLFencedFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFencedFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFencedFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFencedFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFencedFrameElement::from_melement(base: mut Element) -> mut HTMLFencedFrameElement = "
    if(#var(base) instanceof HTMLFencedFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFencedFrameElement'!\");
"

pub ext fun HTMLFencedFrameElement::config(self: HTMLFencedFrameElement) -> Option[mut FencedFrameConfig]
    = "return #fun(Option::from_js[mut FencedFrameConfig])(#var(self).config);"

pub ext fun HTMLFencedFrameElement::set_config(self: mut HTMLFencedFrameElement, value: Option[mut FencedFrameConfig])
    = "#var(self).config = #fun(Option::as_js[mut FencedFrameConfig])(#var(value));"

pub ext fun HTMLFencedFrameElement::width(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLFencedFrameElement::set_width(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::height(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLFencedFrameElement::set_height(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::allow(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).allow);"

pub ext fun HTMLFencedFrameElement::set_allow(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).allow = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::sandbox(self: HTMLFencedFrameElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).sandbox);"

pub ext fun HTMLFencedFrameElement::title(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFencedFrameElement::set_title(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::lang(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFencedFrameElement::set_lang(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::translate(self: HTMLFencedFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFencedFrameElement::set_translate(self: mut HTMLFencedFrameElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::dir(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFencedFrameElement::set_dir(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::hidden(self: HTMLFencedFrameElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFencedFrameElement::set_hidden(self: mut HTMLFencedFrameElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFencedFrameElement::inert(self: HTMLFencedFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFencedFrameElement::set_inert(self: mut HTMLFencedFrameElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::access_key(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFencedFrameElement::set_access_key(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::draggable(self: HTMLFencedFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFencedFrameElement::set_draggable(self: mut HTMLFencedFrameElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::spellcheck(self: HTMLFencedFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFencedFrameElement::set_spellcheck(self: mut HTMLFencedFrameElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::autocapitalize(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFencedFrameElement::set_autocapitalize(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::edit_context(self: HTMLFencedFrameElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFencedFrameElement::set_edit_context(self: mut HTMLFencedFrameElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFencedFrameElement::content_editable(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFencedFrameElement::set_content_editable(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::enter_key_hint(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFencedFrameElement::set_enter_key_hint(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::is_content_editable(self: HTMLFencedFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFencedFrameElement::input_mode(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFencedFrameElement::set_input_mode(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::virtual_keyboard_policy(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFencedFrameElement::set_virtual_keyboard_policy(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::scroll_parent(self: HTMLFencedFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFencedFrameElement::offset_parent(self: HTMLFencedFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFencedFrameElement::offset_top(self: HTMLFencedFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFencedFrameElement::offset_left(self: HTMLFencedFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFencedFrameElement::offset_width(self: HTMLFencedFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFencedFrameElement::offset_height(self: HTMLFencedFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFencedFrameElement::popover(self: HTMLFencedFrameElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFencedFrameElement::set_popover(self: mut HTMLFencedFrameElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFencedFrameElement::inner_text(self: HTMLFencedFrameElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFencedFrameElement::set_inner_text(self: mut HTMLFencedFrameElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFencedFrameElement::outer_text(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFencedFrameElement::set_outer_text(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::writing_suggestions(self: HTMLFencedFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFencedFrameElement::set_writing_suggestions(self: mut HTMLFencedFrameElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFencedFrameElement::can_load_opaque_url() -> Bool = "
    const r = HTMLFencedFrameElement.canLoadOpaqueURL();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::click(__self: mut HTMLFencedFrameElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::attach_internals(__self: mut HTMLFencedFrameElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::toggle_popover(__self: mut HTMLFencedFrameElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::show_popover(__self: mut HTMLFencedFrameElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::hide_popover(__self: mut HTMLFencedFrameElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::start_view_transition(__self: mut HTMLFencedFrameElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::start_view_transition_f_prom_unit(__self: mut HTMLFencedFrameElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFencedFrameElement::start_view_transition_mview_transition_options(__self: mut HTMLFencedFrameElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFencedFrameElement::as_js(self: HTMLFencedFrameElement) -> JsValue = JsValue::unsafe_from[HTMLFencedFrameElement](self)

pub fun HTMLFencedFrameElement::from_js(v: JsValue) -> mut HTMLFencedFrameElement = JsValue::unsafe_as[mut HTMLFencedFrameElement](v)

pub struct FocusOptions(
    prevent_scroll: Option[Bool]
)

pub fun FocusOptions::default() -> mut FocusOptions
    = FocusOptions(Option::Some(false))

pub ext fun FocusOptions::from_js(value: JsValue) -> mut FocusOptions = "
    const r = {};
    r.m_prevent_scroll = #fun(Option::from_js[Bool])(#var(value).preventScroll);
    return r;
"

pub ext fun FocusOptions::as_js(self: FocusOptions) -> JsValue = "
    const r = {};
    r.preventScroll = #fun(Option::as_js_undef[Bool])(#var(self).m_prevent_scroll);
    return r;
"

struct FormData()

pub ext fun FormData::from_mhtml_form_element_omhtml_element(form: mut HTMLFormElement, submitter: Option[mut HTMLElement]) -> mut FormData
    = "return new FormData(#fun(HTMLFormElement::as_js)(#var(form)), #fun(Option::as_js[mut HTMLElement])(#var(submitter)));"

pub ext fun FormData::append_str_str(__self: mut FormData, name: String, value: String) -> Unit = "
    const r = #var(__self).append(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FormData::append_str_mblob_str(__self: mut FormData, name: String, value: mut Blob, filename: String) -> Unit = "
    const r = #var(__self).append(#fun(String::as_js)(#var(name)), #fun(Blob::as_js)(#var(value)), #fun(String::as_js)(#var(filename)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FormData::delete(__self: mut FormData, name: String) -> Unit = "
    const r = #var(__self).delete(#fun(String::as_js)(#var(name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FormData::get(__self: mut FormData, name: String) -> Option[JsValue] = "
    const r = #var(__self).get(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[JsValue])(r);
"

pub ext fun FormData::get_all(__self: mut FormData, name: String) -> List[JsValue] = "
    const r = #var(__self).getAll(#fun(String::as_js)(#var(name)));
    return #fun(List::from_js[JsValue])(r);
"

pub ext fun FormData::has(__self: mut FormData, name: String) -> Bool = "
    const r = #var(__self).has(#fun(String::as_js)(#var(name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun FormData::set_str_str(__self: mut FormData, name: String, value: String) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun FormData::set_str_mblob_str(__self: mut FormData, name: String, value: mut Blob, filename: String) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(name)), #fun(Blob::as_js)(#var(value)), #fun(String::as_js)(#var(filename)));
    return #fun(Unit::from_js)(r);
"

pub fun FormData::as_js(self: FormData) -> JsValue = JsValue::unsafe_from[FormData](self)

pub fun FormData::from_js(v: JsValue) -> mut FormData = JsValue::unsafe_as[mut FormData](v)

struct FormDataEvent()

/// Converts a reference to 'FormDataEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEvent::as_event(self: FormDataEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'FormDataEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEvent::as_mevent(self: mut FormDataEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'FormDataEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FormDataEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEvent::from_event(base: Event) -> FormDataEvent = "
    if(#var(base) instanceof FormDataEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FormDataEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'FormDataEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'FormDataEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEvent::from_mevent(base: mut Event) -> mut FormDataEvent = "
    if(#var(base) instanceof FormDataEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'FormDataEvent'!\");
"

pub ext fun FormDataEvent::from_str_mform_data_event_init(type: String, event_init_dict: mut FormDataEventInit) -> mut FormDataEvent
    = "return new FormDataEvent(#fun(String::as_js)(#var(type)), #fun(FormDataEventInit::as_js)(#var(event_init_dict)));"

pub ext fun FormDataEvent::form_data(self: FormDataEvent) -> mut FormData
    = "return #fun(FormData::from_js)(#var(self).formData);"

pub ext fun FormDataEvent::type(self: FormDataEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun FormDataEvent::target(self: FormDataEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun FormDataEvent::current_target(self: FormDataEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun FormDataEvent::event_phase(self: FormDataEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun FormDataEvent::bubbles(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun FormDataEvent::cancelable(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun FormDataEvent::default_prevented(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun FormDataEvent::composed(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun FormDataEvent::is_trusted(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun FormDataEvent::time_stamp(self: FormDataEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun FormDataEvent::src_element(self: FormDataEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun FormDataEvent::return_value(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun FormDataEvent::set_return_value(self: mut FormDataEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun FormDataEvent::cancel_bubble(self: FormDataEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun FormDataEvent::set_cancel_bubble(self: mut FormDataEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun FormDataEvent::composed_path(__self: mut FormDataEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun FormDataEvent::stop_propagation(__self: mut FormDataEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FormDataEvent::stop_immediate_propagation(__self: mut FormDataEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun FormDataEvent::prevent_default(__self: mut FormDataEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun FormDataEvent::init_event(__self: mut FormDataEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun FormDataEvent::as_js(self: FormDataEvent) -> JsValue = JsValue::unsafe_from[FormDataEvent](self)

pub fun FormDataEvent::from_js(v: JsValue) -> mut FormDataEvent = JsValue::unsafe_as[mut FormDataEvent](v)

pub val FormDataEvent::none: Int = 0
pub val FormDataEvent::capturing_phase: Int = 1
pub val FormDataEvent::at_target: Int = 2
pub val FormDataEvent::bubbling_phase: Int = 3

pub struct FormDataEventInit(
    form_data: mut FormData,
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun FormDataEventInit::default(form_data: mut FormData) -> mut FormDataEventInit
    = FormDataEventInit(form_data, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'FormDataEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEventInit::as_event_init(self: FormDataEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'FormDataEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEventInit::as_mevent_init(self: mut FormDataEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'FormDataEventInit'.
/// A 'base' that is not a reference to 'FormDataEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEventInit::from_event_init_unchecked(base: EventInit) -> FormDataEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'FormDataEventInit'.
/// A 'base' that is not a reference to 'FormDataEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun FormDataEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut FormDataEventInit = "return #var(base);"

pub ext fun FormDataEventInit::from_js(value: JsValue) -> mut FormDataEventInit = "
    const r = {};
    r.m_form_data = #fun(FormData::from_js)(#var(value).formData);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun FormDataEventInit::as_js(self: FormDataEventInit) -> JsValue = "
    const r = {};
    r.formData = #fun(FormData::as_js)(#var(self).m_form_data);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct HTMLButtonElement()

/// Converts a reference to 'HTMLButtonElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::as_html_element(self: HTMLButtonElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLButtonElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::as_mhtml_element(self: mut HTMLButtonElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLButtonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLButtonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::from_html_element(base: HTMLElement) -> HTMLButtonElement = "
    if(#var(base) instanceof HTMLButtonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLButtonElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLButtonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLButtonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLButtonElement = "
    if(#var(base) instanceof HTMLButtonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLButtonElement'!\");
"

/// Converts a reference to 'HTMLButtonElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::as_element(self: HTMLButtonElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLButtonElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::as_melement(self: mut HTMLButtonElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLButtonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLButtonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::from_element(base: Element) -> HTMLButtonElement = "
    if(#var(base) instanceof HTMLButtonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLButtonElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLButtonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLButtonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLButtonElement::from_melement(base: mut Element) -> mut HTMLButtonElement = "
    if(#var(base) instanceof HTMLButtonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLButtonElement'!\");
"

pub ext fun HTMLButtonElement::disabled(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLButtonElement::set_disabled(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::form(self: HTMLButtonElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLButtonElement::form_action(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).formAction);"

pub ext fun HTMLButtonElement::set_form_action(self: mut HTMLButtonElement, value: String)
    = "#var(self).formAction = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::form_enctype(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).formEnctype);"

pub ext fun HTMLButtonElement::set_form_enctype(self: mut HTMLButtonElement, value: String)
    = "#var(self).formEnctype = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::form_method(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).formMethod);"

pub ext fun HTMLButtonElement::set_form_method(self: mut HTMLButtonElement, value: String)
    = "#var(self).formMethod = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::form_no_validate(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).formNoValidate);"

pub ext fun HTMLButtonElement::set_form_no_validate(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).formNoValidate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::form_target(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).formTarget);"

pub ext fun HTMLButtonElement::set_form_target(self: mut HTMLButtonElement, value: String)
    = "#var(self).formTarget = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::name(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLButtonElement::set_name(self: mut HTMLButtonElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::type(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLButtonElement::set_type(self: mut HTMLButtonElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::value(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLButtonElement::set_value(self: mut HTMLButtonElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::command_for_element(self: HTMLButtonElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).commandForElement);"

pub ext fun HTMLButtonElement::set_command_for_element(self: mut HTMLButtonElement, value: Option[mut Element])
    = "#var(self).commandForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLButtonElement::command(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).command);"

pub ext fun HTMLButtonElement::set_command(self: mut HTMLButtonElement, value: String)
    = "#var(self).command = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::will_validate(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLButtonElement::validity(self: HTMLButtonElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLButtonElement::validation_message(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLButtonElement::labels(self: HTMLButtonElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLButtonElement::title(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLButtonElement::set_title(self: mut HTMLButtonElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::lang(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLButtonElement::set_lang(self: mut HTMLButtonElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::translate(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLButtonElement::set_translate(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::dir(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLButtonElement::set_dir(self: mut HTMLButtonElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::hidden(self: HTMLButtonElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLButtonElement::set_hidden(self: mut HTMLButtonElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLButtonElement::inert(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLButtonElement::set_inert(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::access_key(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLButtonElement::set_access_key(self: mut HTMLButtonElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::draggable(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLButtonElement::set_draggable(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::spellcheck(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLButtonElement::set_spellcheck(self: mut HTMLButtonElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLButtonElement::autocapitalize(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLButtonElement::set_autocapitalize(self: mut HTMLButtonElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::edit_context(self: HTMLButtonElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLButtonElement::set_edit_context(self: mut HTMLButtonElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLButtonElement::content_editable(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLButtonElement::set_content_editable(self: mut HTMLButtonElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::enter_key_hint(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLButtonElement::set_enter_key_hint(self: mut HTMLButtonElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::is_content_editable(self: HTMLButtonElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLButtonElement::input_mode(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLButtonElement::set_input_mode(self: mut HTMLButtonElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::virtual_keyboard_policy(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLButtonElement::set_virtual_keyboard_policy(self: mut HTMLButtonElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::scroll_parent(self: HTMLButtonElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLButtonElement::offset_parent(self: HTMLButtonElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLButtonElement::offset_top(self: HTMLButtonElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLButtonElement::offset_left(self: HTMLButtonElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLButtonElement::offset_width(self: HTMLButtonElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLButtonElement::offset_height(self: HTMLButtonElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLButtonElement::popover(self: HTMLButtonElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLButtonElement::set_popover(self: mut HTMLButtonElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLButtonElement::inner_text(self: HTMLButtonElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLButtonElement::set_inner_text(self: mut HTMLButtonElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLButtonElement::outer_text(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLButtonElement::set_outer_text(self: mut HTMLButtonElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::writing_suggestions(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLButtonElement::set_writing_suggestions(self: mut HTMLButtonElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::popover_target_element(self: HTMLButtonElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).popoverTargetElement);"

pub ext fun HTMLButtonElement::set_popover_target_element(self: mut HTMLButtonElement, value: Option[mut Element])
    = "#var(self).popoverTargetElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLButtonElement::popover_target_action(self: HTMLButtonElement) -> String
    = "return #fun(String::from_js)(#var(self).popoverTargetAction);"

pub ext fun HTMLButtonElement::set_popover_target_action(self: mut HTMLButtonElement, value: String)
    = "#var(self).popoverTargetAction = #fun(String::as_js)(#var(value));"

pub ext fun HTMLButtonElement::interest_for_element(self: HTMLButtonElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).interestForElement);"

pub ext fun HTMLButtonElement::set_interest_for_element(self: mut HTMLButtonElement, value: Option[mut Element])
    = "#var(self).interestForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLButtonElement::check_validity(__self: mut HTMLButtonElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLButtonElement::report_validity(__self: mut HTMLButtonElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLButtonElement::set_custom_validity(__self: mut HTMLButtonElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLButtonElement::click(__self: mut HTMLButtonElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLButtonElement::attach_internals(__self: mut HTMLButtonElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLButtonElement::toggle_popover(__self: mut HTMLButtonElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLButtonElement::show_popover(__self: mut HTMLButtonElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLButtonElement::hide_popover(__self: mut HTMLButtonElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLButtonElement::start_view_transition(__self: mut HTMLButtonElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLButtonElement::start_view_transition_f_prom_unit(__self: mut HTMLButtonElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLButtonElement::start_view_transition_mview_transition_options(__self: mut HTMLButtonElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLButtonElement::as_js(self: HTMLButtonElement) -> JsValue = JsValue::unsafe_from[HTMLButtonElement](self)

pub fun HTMLButtonElement::from_js(v: JsValue) -> mut HTMLButtonElement = JsValue::unsafe_as[mut HTMLButtonElement](v)

struct HTMLDataListElement()

/// Converts a reference to 'HTMLDataListElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::as_html_element(self: HTMLDataListElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDataListElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::as_mhtml_element(self: mut HTMLDataListElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDataListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::from_html_element(base: HTMLElement) -> HTMLDataListElement = "
    if(#var(base) instanceof HTMLDataListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDataListElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDataListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDataListElement = "
    if(#var(base) instanceof HTMLDataListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDataListElement'!\");
"

/// Converts a reference to 'HTMLDataListElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::as_element(self: HTMLDataListElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDataListElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::as_melement(self: mut HTMLDataListElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDataListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::from_element(base: Element) -> HTMLDataListElement = "
    if(#var(base) instanceof HTMLDataListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDataListElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDataListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataListElement::from_melement(base: mut Element) -> mut HTMLDataListElement = "
    if(#var(base) instanceof HTMLDataListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDataListElement'!\");
"

pub ext fun HTMLDataListElement::options(self: HTMLDataListElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).options);"

pub ext fun HTMLDataListElement::title(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDataListElement::set_title(self: mut HTMLDataListElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::lang(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDataListElement::set_lang(self: mut HTMLDataListElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::translate(self: HTMLDataListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDataListElement::set_translate(self: mut HTMLDataListElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataListElement::dir(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDataListElement::set_dir(self: mut HTMLDataListElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::hidden(self: HTMLDataListElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDataListElement::set_hidden(self: mut HTMLDataListElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDataListElement::inert(self: HTMLDataListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDataListElement::set_inert(self: mut HTMLDataListElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataListElement::access_key(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDataListElement::set_access_key(self: mut HTMLDataListElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::draggable(self: HTMLDataListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDataListElement::set_draggable(self: mut HTMLDataListElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataListElement::spellcheck(self: HTMLDataListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDataListElement::set_spellcheck(self: mut HTMLDataListElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataListElement::autocapitalize(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDataListElement::set_autocapitalize(self: mut HTMLDataListElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::edit_context(self: HTMLDataListElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDataListElement::set_edit_context(self: mut HTMLDataListElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDataListElement::content_editable(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDataListElement::set_content_editable(self: mut HTMLDataListElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::enter_key_hint(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDataListElement::set_enter_key_hint(self: mut HTMLDataListElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::is_content_editable(self: HTMLDataListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDataListElement::input_mode(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDataListElement::set_input_mode(self: mut HTMLDataListElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::virtual_keyboard_policy(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDataListElement::set_virtual_keyboard_policy(self: mut HTMLDataListElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::scroll_parent(self: HTMLDataListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDataListElement::offset_parent(self: HTMLDataListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDataListElement::offset_top(self: HTMLDataListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDataListElement::offset_left(self: HTMLDataListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDataListElement::offset_width(self: HTMLDataListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDataListElement::offset_height(self: HTMLDataListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDataListElement::popover(self: HTMLDataListElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDataListElement::set_popover(self: mut HTMLDataListElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDataListElement::inner_text(self: HTMLDataListElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDataListElement::set_inner_text(self: mut HTMLDataListElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDataListElement::outer_text(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDataListElement::set_outer_text(self: mut HTMLDataListElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::writing_suggestions(self: HTMLDataListElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDataListElement::set_writing_suggestions(self: mut HTMLDataListElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataListElement::click(__self: mut HTMLDataListElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataListElement::attach_internals(__self: mut HTMLDataListElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDataListElement::toggle_popover(__self: mut HTMLDataListElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDataListElement::show_popover(__self: mut HTMLDataListElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataListElement::hide_popover(__self: mut HTMLDataListElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataListElement::start_view_transition(__self: mut HTMLDataListElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDataListElement::start_view_transition_f_prom_unit(__self: mut HTMLDataListElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDataListElement::start_view_transition_mview_transition_options(__self: mut HTMLDataListElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDataListElement::as_js(self: HTMLDataListElement) -> JsValue = JsValue::unsafe_from[HTMLDataListElement](self)

pub fun HTMLDataListElement::from_js(v: JsValue) -> mut HTMLDataListElement = JsValue::unsafe_as[mut HTMLDataListElement](v)

struct HTMLFieldSetElement()

/// Converts a reference to 'HTMLFieldSetElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::as_html_element(self: HTMLFieldSetElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFieldSetElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::as_mhtml_element(self: mut HTMLFieldSetElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFieldSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFieldSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::from_html_element(base: HTMLElement) -> HTMLFieldSetElement = "
    if(#var(base) instanceof HTMLFieldSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFieldSetElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFieldSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFieldSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFieldSetElement = "
    if(#var(base) instanceof HTMLFieldSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFieldSetElement'!\");
"

/// Converts a reference to 'HTMLFieldSetElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::as_element(self: HTMLFieldSetElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFieldSetElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::as_melement(self: mut HTMLFieldSetElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFieldSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFieldSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::from_element(base: Element) -> HTMLFieldSetElement = "
    if(#var(base) instanceof HTMLFieldSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFieldSetElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFieldSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFieldSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFieldSetElement::from_melement(base: mut Element) -> mut HTMLFieldSetElement = "
    if(#var(base) instanceof HTMLFieldSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFieldSetElement'!\");
"

pub ext fun HTMLFieldSetElement::disabled(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLFieldSetElement::set_disabled(self: mut HTMLFieldSetElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::form(self: HTMLFieldSetElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLFieldSetElement::name(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLFieldSetElement::set_name(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::type(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLFieldSetElement::elements(self: HTMLFieldSetElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).elements);"

pub ext fun HTMLFieldSetElement::will_validate(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLFieldSetElement::validity(self: HTMLFieldSetElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLFieldSetElement::validation_message(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLFieldSetElement::title(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFieldSetElement::set_title(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::lang(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFieldSetElement::set_lang(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::translate(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFieldSetElement::set_translate(self: mut HTMLFieldSetElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::dir(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFieldSetElement::set_dir(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::hidden(self: HTMLFieldSetElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFieldSetElement::set_hidden(self: mut HTMLFieldSetElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFieldSetElement::inert(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFieldSetElement::set_inert(self: mut HTMLFieldSetElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::access_key(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFieldSetElement::set_access_key(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::draggable(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFieldSetElement::set_draggable(self: mut HTMLFieldSetElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::spellcheck(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFieldSetElement::set_spellcheck(self: mut HTMLFieldSetElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::autocapitalize(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFieldSetElement::set_autocapitalize(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::edit_context(self: HTMLFieldSetElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFieldSetElement::set_edit_context(self: mut HTMLFieldSetElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFieldSetElement::content_editable(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFieldSetElement::set_content_editable(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::enter_key_hint(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFieldSetElement::set_enter_key_hint(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::is_content_editable(self: HTMLFieldSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFieldSetElement::input_mode(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFieldSetElement::set_input_mode(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::virtual_keyboard_policy(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFieldSetElement::set_virtual_keyboard_policy(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::scroll_parent(self: HTMLFieldSetElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFieldSetElement::offset_parent(self: HTMLFieldSetElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFieldSetElement::offset_top(self: HTMLFieldSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFieldSetElement::offset_left(self: HTMLFieldSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFieldSetElement::offset_width(self: HTMLFieldSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFieldSetElement::offset_height(self: HTMLFieldSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFieldSetElement::popover(self: HTMLFieldSetElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFieldSetElement::set_popover(self: mut HTMLFieldSetElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFieldSetElement::inner_text(self: HTMLFieldSetElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFieldSetElement::set_inner_text(self: mut HTMLFieldSetElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFieldSetElement::outer_text(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFieldSetElement::set_outer_text(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::writing_suggestions(self: HTMLFieldSetElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFieldSetElement::set_writing_suggestions(self: mut HTMLFieldSetElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFieldSetElement::check_validity(__self: mut HTMLFieldSetElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFieldSetElement::report_validity(__self: mut HTMLFieldSetElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFieldSetElement::set_custom_validity(__self: mut HTMLFieldSetElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFieldSetElement::click(__self: mut HTMLFieldSetElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFieldSetElement::attach_internals(__self: mut HTMLFieldSetElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFieldSetElement::toggle_popover(__self: mut HTMLFieldSetElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFieldSetElement::show_popover(__self: mut HTMLFieldSetElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFieldSetElement::hide_popover(__self: mut HTMLFieldSetElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFieldSetElement::start_view_transition(__self: mut HTMLFieldSetElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFieldSetElement::start_view_transition_f_prom_unit(__self: mut HTMLFieldSetElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFieldSetElement::start_view_transition_mview_transition_options(__self: mut HTMLFieldSetElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFieldSetElement::as_js(self: HTMLFieldSetElement) -> JsValue = JsValue::unsafe_from[HTMLFieldSetElement](self)

pub fun HTMLFieldSetElement::from_js(v: JsValue) -> mut HTMLFieldSetElement = JsValue::unsafe_as[mut HTMLFieldSetElement](v)

struct HTMLFormControlsCollection()

/// Converts a reference to 'HTMLFormControlsCollection' to a reference to 'HTMLCollection'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormControlsCollection::as_html_collection(self: HTMLFormControlsCollection) -> HTMLCollection = "return #var(self);"

/// Converts a mutable reference to 'HTMLFormControlsCollection' to a mutable reference to 'HTMLCollection'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormControlsCollection::as_mhtml_collection(self: mut HTMLFormControlsCollection) -> mut HTMLCollection = "return #var(self);"

/// Attempts to convert a reference to 'HTMLCollection' to a reference to 'HTMLFormControlsCollection'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormControlsCollection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormControlsCollection::from_html_collection(base: HTMLCollection) -> HTMLFormControlsCollection = "
    if(#var(base) instanceof HTMLFormControlsCollection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLCollection' to 'HTMLFormControlsCollection'!\");
"

/// Attempts to convert a mutable reference to 'HTMLCollection' to a mutable reference to 'HTMLFormControlsCollection'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormControlsCollection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormControlsCollection::from_mhtml_collection(base: mut HTMLCollection) -> mut HTMLFormControlsCollection = "
    if(#var(base) instanceof HTMLFormControlsCollection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLCollection' to 'HTMLFormControlsCollection'!\");
"

pub ext fun HTMLFormControlsCollection::length(self: HTMLFormControlsCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLFormControlsCollection::named_item_str(__self: mut HTMLFormControlsCollection, name: String) -> Option[JsValue] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[JsValue])(r);
"

pub ext fun HTMLFormControlsCollection::get(__self: HTMLFormControlsCollection, index: Int) -> mut Node = "
    const r = HTMLFormControlsCollection[#fun(Int::as_js)(#var(index))];
    return #fun(Node::from_js)(r);
"

pub ext fun HTMLFormControlsCollection::item(__self: mut HTMLFormControlsCollection, index: Int) -> Option[mut Element] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Element])(r);
"

pub fun HTMLFormControlsCollection::as_js(self: HTMLFormControlsCollection) -> JsValue = JsValue::unsafe_from[HTMLFormControlsCollection](self)

pub fun HTMLFormControlsCollection::from_js(v: JsValue) -> mut HTMLFormControlsCollection = JsValue::unsafe_as[mut HTMLFormControlsCollection](v)

struct HTMLFormElement()

/// Converts a reference to 'HTMLFormElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::as_html_element(self: HTMLFormElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFormElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::as_mhtml_element(self: mut HTMLFormElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFormElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::from_html_element(base: HTMLElement) -> HTMLFormElement = "
    if(#var(base) instanceof HTMLFormElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFormElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFormElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFormElement = "
    if(#var(base) instanceof HTMLFormElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFormElement'!\");
"

/// Converts a reference to 'HTMLFormElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::as_element(self: HTMLFormElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFormElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::as_melement(self: mut HTMLFormElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFormElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::from_element(base: Element) -> HTMLFormElement = "
    if(#var(base) instanceof HTMLFormElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFormElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFormElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFormElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFormElement::from_melement(base: mut Element) -> mut HTMLFormElement = "
    if(#var(base) instanceof HTMLFormElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFormElement'!\");
"

pub ext fun HTMLFormElement::accept_charset(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).acceptCharset);"

pub ext fun HTMLFormElement::set_accept_charset(self: mut HTMLFormElement, value: String)
    = "#var(self).acceptCharset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::action(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).action);"

pub ext fun HTMLFormElement::set_action(self: mut HTMLFormElement, value: String)
    = "#var(self).action = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::autocomplete(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).autocomplete);"

pub ext fun HTMLFormElement::set_autocomplete(self: mut HTMLFormElement, value: String)
    = "#var(self).autocomplete = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::enctype(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).enctype);"

pub ext fun HTMLFormElement::set_enctype(self: mut HTMLFormElement, value: String)
    = "#var(self).enctype = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::encoding(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).encoding);"

pub ext fun HTMLFormElement::set_encoding(self: mut HTMLFormElement, value: String)
    = "#var(self).encoding = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::method(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).method);"

pub ext fun HTMLFormElement::set_method(self: mut HTMLFormElement, value: String)
    = "#var(self).method = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::name(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLFormElement::set_name(self: mut HTMLFormElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::no_validate(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noValidate);"

pub ext fun HTMLFormElement::set_no_validate(self: mut HTMLFormElement, value: Bool)
    = "#var(self).noValidate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFormElement::target(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun HTMLFormElement::set_target(self: mut HTMLFormElement, value: String)
    = "#var(self).target = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::rel(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).rel);"

pub ext fun HTMLFormElement::set_rel(self: mut HTMLFormElement, value: String)
    = "#var(self).rel = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::rel_list(self: HTMLFormElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).relList);"

pub ext fun HTMLFormElement::elements(self: HTMLFormElement) -> mut HTMLFormControlsCollection
    = "return #fun(HTMLFormControlsCollection::from_js)(#var(self).elements);"

pub ext fun HTMLFormElement::length(self: HTMLFormElement) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLFormElement::title(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFormElement::set_title(self: mut HTMLFormElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::lang(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFormElement::set_lang(self: mut HTMLFormElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::translate(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFormElement::set_translate(self: mut HTMLFormElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFormElement::dir(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFormElement::set_dir(self: mut HTMLFormElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::hidden(self: HTMLFormElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFormElement::set_hidden(self: mut HTMLFormElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFormElement::inert(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFormElement::set_inert(self: mut HTMLFormElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFormElement::access_key(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFormElement::set_access_key(self: mut HTMLFormElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::draggable(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFormElement::set_draggable(self: mut HTMLFormElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFormElement::spellcheck(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFormElement::set_spellcheck(self: mut HTMLFormElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFormElement::autocapitalize(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFormElement::set_autocapitalize(self: mut HTMLFormElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::edit_context(self: HTMLFormElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFormElement::set_edit_context(self: mut HTMLFormElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFormElement::content_editable(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFormElement::set_content_editable(self: mut HTMLFormElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::enter_key_hint(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFormElement::set_enter_key_hint(self: mut HTMLFormElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::is_content_editable(self: HTMLFormElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFormElement::input_mode(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFormElement::set_input_mode(self: mut HTMLFormElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::virtual_keyboard_policy(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFormElement::set_virtual_keyboard_policy(self: mut HTMLFormElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::scroll_parent(self: HTMLFormElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFormElement::offset_parent(self: HTMLFormElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFormElement::offset_top(self: HTMLFormElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFormElement::offset_left(self: HTMLFormElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFormElement::offset_width(self: HTMLFormElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFormElement::offset_height(self: HTMLFormElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFormElement::popover(self: HTMLFormElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFormElement::set_popover(self: mut HTMLFormElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFormElement::inner_text(self: HTMLFormElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFormElement::set_inner_text(self: mut HTMLFormElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFormElement::outer_text(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFormElement::set_outer_text(self: mut HTMLFormElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::writing_suggestions(self: HTMLFormElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFormElement::set_writing_suggestions(self: mut HTMLFormElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFormElement::get_int(__self: HTMLFormElement, index: Int) -> mut Element = "
    const r = HTMLFormElement[#fun(Int::as_js)(#var(index))];
    return #fun(Element::from_js)(r);
"

pub ext fun HTMLFormElement::get_str(__self: HTMLFormElement, name: String) -> JsValue = "
    const r = HTMLFormElement[#fun(String::as_js)(#var(name))];
    return r;
"

pub ext fun HTMLFormElement::submit(__self: mut HTMLFormElement) -> Unit = "
    const r = #var(__self).submit();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::request_submit(__self: mut HTMLFormElement, submitter: Option[mut HTMLElement]) -> Unit = "
    const r = #var(__self).requestSubmit(#fun(Option::as_js[mut HTMLElement])(#var(submitter)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::reset(__self: mut HTMLFormElement) -> Unit = "
    const r = #var(__self).reset();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::check_validity(__self: mut HTMLFormElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFormElement::report_validity(__self: mut HTMLFormElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFormElement::click(__self: mut HTMLFormElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::attach_internals(__self: mut HTMLFormElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFormElement::toggle_popover(__self: mut HTMLFormElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFormElement::show_popover(__self: mut HTMLFormElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::hide_popover(__self: mut HTMLFormElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFormElement::start_view_transition(__self: mut HTMLFormElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFormElement::start_view_transition_f_prom_unit(__self: mut HTMLFormElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFormElement::start_view_transition_mview_transition_options(__self: mut HTMLFormElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFormElement::as_js(self: HTMLFormElement) -> JsValue = JsValue::unsafe_from[HTMLFormElement](self)

pub fun HTMLFormElement::from_js(v: JsValue) -> mut HTMLFormElement = JsValue::unsafe_as[mut HTMLFormElement](v)

pub val SelectionMode::Select: String = "select"
pub val SelectionMode::Start: String = "start"
pub val SelectionMode::End: String = "end"
pub val SelectionMode::Preserve: String = "preserve"

struct HTMLInputElement()

/// Converts a reference to 'HTMLInputElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::as_html_element(self: HTMLInputElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLInputElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::as_mhtml_element(self: mut HTMLInputElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLInputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLInputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::from_html_element(base: HTMLElement) -> HTMLInputElement = "
    if(#var(base) instanceof HTMLInputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLInputElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLInputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLInputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLInputElement = "
    if(#var(base) instanceof HTMLInputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLInputElement'!\");
"

/// Converts a reference to 'HTMLInputElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::as_element(self: HTMLInputElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLInputElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::as_melement(self: mut HTMLInputElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLInputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLInputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::from_element(base: Element) -> HTMLInputElement = "
    if(#var(base) instanceof HTMLInputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLInputElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLInputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLInputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLInputElement::from_melement(base: mut Element) -> mut HTMLInputElement = "
    if(#var(base) instanceof HTMLInputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLInputElement'!\");
"

pub ext fun HTMLInputElement::accept(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).accept);"

pub ext fun HTMLInputElement::set_accept(self: mut HTMLInputElement, value: String)
    = "#var(self).accept = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::alt(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).alt);"

pub ext fun HTMLInputElement::set_alt(self: mut HTMLInputElement, value: String)
    = "#var(self).alt = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::autocomplete(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).autocomplete);"

pub ext fun HTMLInputElement::set_autocomplete(self: mut HTMLInputElement, value: String)
    = "#var(self).autocomplete = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::default_checked(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultChecked);"

pub ext fun HTMLInputElement::set_default_checked(self: mut HTMLInputElement, value: Bool)
    = "#var(self).defaultChecked = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::checked(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).checked);"

pub ext fun HTMLInputElement::set_checked(self: mut HTMLInputElement, value: Bool)
    = "#var(self).checked = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::dir_name(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).dirName);"

pub ext fun HTMLInputElement::set_dir_name(self: mut HTMLInputElement, value: String)
    = "#var(self).dirName = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::disabled(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLInputElement::set_disabled(self: mut HTMLInputElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::form(self: HTMLInputElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLInputElement::files(self: HTMLInputElement) -> Option[mut FileList]
    = "return #fun(Option::from_js[mut FileList])(#var(self).files);"

pub ext fun HTMLInputElement::set_files(self: mut HTMLInputElement, value: Option[mut FileList])
    = "#var(self).files = #fun(Option::as_js[mut FileList])(#var(value));"

pub ext fun HTMLInputElement::form_action(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).formAction);"

pub ext fun HTMLInputElement::set_form_action(self: mut HTMLInputElement, value: String)
    = "#var(self).formAction = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::form_enctype(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).formEnctype);"

pub ext fun HTMLInputElement::set_form_enctype(self: mut HTMLInputElement, value: String)
    = "#var(self).formEnctype = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::form_method(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).formMethod);"

pub ext fun HTMLInputElement::set_form_method(self: mut HTMLInputElement, value: String)
    = "#var(self).formMethod = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::form_no_validate(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).formNoValidate);"

pub ext fun HTMLInputElement::set_form_no_validate(self: mut HTMLInputElement, value: Bool)
    = "#var(self).formNoValidate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::form_target(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).formTarget);"

pub ext fun HTMLInputElement::set_form_target(self: mut HTMLInputElement, value: String)
    = "#var(self).formTarget = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::height(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun HTMLInputElement::set_height(self: mut HTMLInputElement, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLInputElement::indeterminate(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).indeterminate);"

pub ext fun HTMLInputElement::set_indeterminate(self: mut HTMLInputElement, value: Bool)
    = "#var(self).indeterminate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::list(self: HTMLInputElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).list);"

pub ext fun HTMLInputElement::max(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).max);"

pub ext fun HTMLInputElement::set_max(self: mut HTMLInputElement, value: String)
    = "#var(self).max = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::max_length(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).maxLength);"

pub ext fun HTMLInputElement::set_max_length(self: mut HTMLInputElement, value: Int)
    = "#var(self).maxLength = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLInputElement::min(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).min);"

pub ext fun HTMLInputElement::set_min(self: mut HTMLInputElement, value: String)
    = "#var(self).min = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::min_length(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).minLength);"

pub ext fun HTMLInputElement::set_min_length(self: mut HTMLInputElement, value: Int)
    = "#var(self).minLength = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLInputElement::multiple(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).multiple);"

pub ext fun HTMLInputElement::set_multiple(self: mut HTMLInputElement, value: Bool)
    = "#var(self).multiple = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::name(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLInputElement::set_name(self: mut HTMLInputElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::pattern(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).pattern);"

pub ext fun HTMLInputElement::set_pattern(self: mut HTMLInputElement, value: String)
    = "#var(self).pattern = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::placeholder(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).placeholder);"

pub ext fun HTMLInputElement::set_placeholder(self: mut HTMLInputElement, value: String)
    = "#var(self).placeholder = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::read_only(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).readOnly);"

pub ext fun HTMLInputElement::set_read_only(self: mut HTMLInputElement, value: Bool)
    = "#var(self).readOnly = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::required(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).required);"

pub ext fun HTMLInputElement::set_required(self: mut HTMLInputElement, value: Bool)
    = "#var(self).required = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::size(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun HTMLInputElement::set_size(self: mut HTMLInputElement, value: Int)
    = "#var(self).size = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLInputElement::src(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLInputElement::set_src(self: mut HTMLInputElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::step(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).step);"

pub ext fun HTMLInputElement::set_step(self: mut HTMLInputElement, value: String)
    = "#var(self).step = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::type(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLInputElement::set_type(self: mut HTMLInputElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::default_value(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).defaultValue);"

pub ext fun HTMLInputElement::set_default_value(self: mut HTMLInputElement, value: String)
    = "#var(self).defaultValue = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::value(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLInputElement::set_value(self: mut HTMLInputElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::value_as_date(self: HTMLInputElement) -> Option[JsObject]
    = "return #fun(Option::from_js[JsObject])(#var(self).valueAsDate);"

pub ext fun HTMLInputElement::set_value_as_date(self: mut HTMLInputElement, value: Option[JsObject])
    = "#var(self).valueAsDate = #fun(Option::as_js[JsObject])(#var(value));"

pub ext fun HTMLInputElement::value_as_number(self: HTMLInputElement) -> Float
    = "return #fun(Float::from_js)(#var(self).valueAsNumber);"

pub ext fun HTMLInputElement::set_value_as_number(self: mut HTMLInputElement, value: Float)
    = "#var(self).valueAsNumber = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLInputElement::width(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLInputElement::set_width(self: mut HTMLInputElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLInputElement::will_validate(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLInputElement::validity(self: HTMLInputElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLInputElement::validation_message(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLInputElement::labels(self: HTMLInputElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLInputElement::selection_start(self: HTMLInputElement) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).selectionStart);"

pub ext fun HTMLInputElement::set_selection_start(self: mut HTMLInputElement, value: Option[Int])
    = "#var(self).selectionStart = #fun(Option::as_js[Int])(#var(value));"

pub ext fun HTMLInputElement::selection_end(self: HTMLInputElement) -> Option[Int]
    = "return #fun(Option::from_js[Int])(#var(self).selectionEnd);"

pub ext fun HTMLInputElement::set_selection_end(self: mut HTMLInputElement, value: Option[Int])
    = "#var(self).selectionEnd = #fun(Option::as_js[Int])(#var(value));"

pub ext fun HTMLInputElement::selection_direction(self: HTMLInputElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).selectionDirection);"

pub ext fun HTMLInputElement::set_selection_direction(self: mut HTMLInputElement, value: Option[String])
    = "#var(self).selectionDirection = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLInputElement::align(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLInputElement::set_align(self: mut HTMLInputElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::use_map(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).useMap);"

pub ext fun HTMLInputElement::set_use_map(self: mut HTMLInputElement, value: String)
    = "#var(self).useMap = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::capture(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).capture);"

pub ext fun HTMLInputElement::set_capture(self: mut HTMLInputElement, value: String)
    = "#var(self).capture = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::webkitdirectory(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).webkitdirectory);"

pub ext fun HTMLInputElement::set_webkitdirectory(self: mut HTMLInputElement, value: Bool)
    = "#var(self).webkitdirectory = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::incremental(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).incremental);"

pub ext fun HTMLInputElement::set_incremental(self: mut HTMLInputElement, value: Bool)
    = "#var(self).incremental = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::title(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLInputElement::set_title(self: mut HTMLInputElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::lang(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLInputElement::set_lang(self: mut HTMLInputElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::translate(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLInputElement::set_translate(self: mut HTMLInputElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::dir(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLInputElement::set_dir(self: mut HTMLInputElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::hidden(self: HTMLInputElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLInputElement::set_hidden(self: mut HTMLInputElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLInputElement::inert(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLInputElement::set_inert(self: mut HTMLInputElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::access_key(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLInputElement::set_access_key(self: mut HTMLInputElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::draggable(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLInputElement::set_draggable(self: mut HTMLInputElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::spellcheck(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLInputElement::set_spellcheck(self: mut HTMLInputElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLInputElement::autocapitalize(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLInputElement::set_autocapitalize(self: mut HTMLInputElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::edit_context(self: HTMLInputElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLInputElement::set_edit_context(self: mut HTMLInputElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLInputElement::content_editable(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLInputElement::set_content_editable(self: mut HTMLInputElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::enter_key_hint(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLInputElement::set_enter_key_hint(self: mut HTMLInputElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::is_content_editable(self: HTMLInputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLInputElement::input_mode(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLInputElement::set_input_mode(self: mut HTMLInputElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::virtual_keyboard_policy(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLInputElement::set_virtual_keyboard_policy(self: mut HTMLInputElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::scroll_parent(self: HTMLInputElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLInputElement::offset_parent(self: HTMLInputElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLInputElement::offset_top(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLInputElement::offset_left(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLInputElement::offset_width(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLInputElement::offset_height(self: HTMLInputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLInputElement::popover(self: HTMLInputElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLInputElement::set_popover(self: mut HTMLInputElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLInputElement::inner_text(self: HTMLInputElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLInputElement::set_inner_text(self: mut HTMLInputElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLInputElement::outer_text(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLInputElement::set_outer_text(self: mut HTMLInputElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::writing_suggestions(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLInputElement::set_writing_suggestions(self: mut HTMLInputElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::popover_target_element(self: HTMLInputElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).popoverTargetElement);"

pub ext fun HTMLInputElement::set_popover_target_element(self: mut HTMLInputElement, value: Option[mut Element])
    = "#var(self).popoverTargetElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLInputElement::popover_target_action(self: HTMLInputElement) -> String
    = "return #fun(String::from_js)(#var(self).popoverTargetAction);"

pub ext fun HTMLInputElement::set_popover_target_action(self: mut HTMLInputElement, value: String)
    = "#var(self).popoverTargetAction = #fun(String::as_js)(#var(value));"

pub ext fun HTMLInputElement::step_up(__self: mut HTMLInputElement, n: Int) -> Unit = "
    const r = #var(__self).stepUp(#fun(Int::as_js)(#var(n)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::step_down(__self: mut HTMLInputElement, n: Int) -> Unit = "
    const r = #var(__self).stepDown(#fun(Int::as_js)(#var(n)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::check_validity(__self: mut HTMLInputElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLInputElement::report_validity(__self: mut HTMLInputElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLInputElement::set_custom_validity(__self: mut HTMLInputElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::select(__self: mut HTMLInputElement) -> Unit = "
    const r = #var(__self).select();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::set_range_text_str(__self: mut HTMLInputElement, replacement: String) -> Unit = "
    const r = #var(__self).setRangeText(#fun(String::as_js)(#var(replacement)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::set_range_text_str_int_int_str(__self: mut HTMLInputElement, replacement: String, start: Int, end: Int, selection_mode: String) -> Unit = "
    const r = #var(__self).setRangeText(#fun(String::as_js)(#var(replacement)), #fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #var(selection_mode));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::set_selection_range(__self: mut HTMLInputElement, start: Int, end: Int, direction: String) -> Unit = "
    const r = #var(__self).setSelectionRange(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(String::as_js)(#var(direction)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::show_picker(__self: mut HTMLInputElement) -> Unit = "
    const r = #var(__self).showPicker();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::click(__self: mut HTMLInputElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::attach_internals(__self: mut HTMLInputElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLInputElement::toggle_popover(__self: mut HTMLInputElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLInputElement::show_popover(__self: mut HTMLInputElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::hide_popover(__self: mut HTMLInputElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLInputElement::start_view_transition(__self: mut HTMLInputElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLInputElement::start_view_transition_f_prom_unit(__self: mut HTMLInputElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLInputElement::start_view_transition_mview_transition_options(__self: mut HTMLInputElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLInputElement::as_js(self: HTMLInputElement) -> JsValue = JsValue::unsafe_from[HTMLInputElement](self)

pub fun HTMLInputElement::from_js(v: JsValue) -> mut HTMLInputElement = JsValue::unsafe_as[mut HTMLInputElement](v)

struct HTMLLabelElement()

/// Converts a reference to 'HTMLLabelElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::as_html_element(self: HTMLLabelElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLLabelElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::as_mhtml_element(self: mut HTMLLabelElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLLabelElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLabelElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::from_html_element(base: HTMLElement) -> HTMLLabelElement = "
    if(#var(base) instanceof HTMLLabelElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLabelElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLLabelElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLabelElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLLabelElement = "
    if(#var(base) instanceof HTMLLabelElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLabelElement'!\");
"

/// Converts a reference to 'HTMLLabelElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::as_element(self: HTMLLabelElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLLabelElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::as_melement(self: mut HTMLLabelElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLLabelElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLabelElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::from_element(base: Element) -> HTMLLabelElement = "
    if(#var(base) instanceof HTMLLabelElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLabelElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLLabelElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLabelElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLabelElement::from_melement(base: mut Element) -> mut HTMLLabelElement = "
    if(#var(base) instanceof HTMLLabelElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLabelElement'!\");
"

pub ext fun HTMLLabelElement::form(self: HTMLLabelElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLLabelElement::html_for(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).htmlFor);"

pub ext fun HTMLLabelElement::set_html_for(self: mut HTMLLabelElement, value: String)
    = "#var(self).htmlFor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::control(self: HTMLLabelElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).control);"

pub ext fun HTMLLabelElement::title(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLLabelElement::set_title(self: mut HTMLLabelElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::lang(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLLabelElement::set_lang(self: mut HTMLLabelElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::translate(self: HTMLLabelElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLLabelElement::set_translate(self: mut HTMLLabelElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLabelElement::dir(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLLabelElement::set_dir(self: mut HTMLLabelElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::hidden(self: HTMLLabelElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLLabelElement::set_hidden(self: mut HTMLLabelElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLLabelElement::inert(self: HTMLLabelElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLLabelElement::set_inert(self: mut HTMLLabelElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLabelElement::access_key(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLLabelElement::set_access_key(self: mut HTMLLabelElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::draggable(self: HTMLLabelElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLLabelElement::set_draggable(self: mut HTMLLabelElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLabelElement::spellcheck(self: HTMLLabelElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLLabelElement::set_spellcheck(self: mut HTMLLabelElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLabelElement::autocapitalize(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLLabelElement::set_autocapitalize(self: mut HTMLLabelElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::edit_context(self: HTMLLabelElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLLabelElement::set_edit_context(self: mut HTMLLabelElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLLabelElement::content_editable(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLLabelElement::set_content_editable(self: mut HTMLLabelElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::enter_key_hint(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLLabelElement::set_enter_key_hint(self: mut HTMLLabelElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::is_content_editable(self: HTMLLabelElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLLabelElement::input_mode(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLLabelElement::set_input_mode(self: mut HTMLLabelElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::virtual_keyboard_policy(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLLabelElement::set_virtual_keyboard_policy(self: mut HTMLLabelElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::scroll_parent(self: HTMLLabelElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLLabelElement::offset_parent(self: HTMLLabelElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLLabelElement::offset_top(self: HTMLLabelElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLLabelElement::offset_left(self: HTMLLabelElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLLabelElement::offset_width(self: HTMLLabelElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLLabelElement::offset_height(self: HTMLLabelElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLLabelElement::popover(self: HTMLLabelElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLLabelElement::set_popover(self: mut HTMLLabelElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLLabelElement::inner_text(self: HTMLLabelElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLLabelElement::set_inner_text(self: mut HTMLLabelElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLLabelElement::outer_text(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLLabelElement::set_outer_text(self: mut HTMLLabelElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::writing_suggestions(self: HTMLLabelElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLLabelElement::set_writing_suggestions(self: mut HTMLLabelElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLabelElement::click(__self: mut HTMLLabelElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLabelElement::attach_internals(__self: mut HTMLLabelElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLLabelElement::toggle_popover(__self: mut HTMLLabelElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLLabelElement::show_popover(__self: mut HTMLLabelElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLabelElement::hide_popover(__self: mut HTMLLabelElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLabelElement::start_view_transition(__self: mut HTMLLabelElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLabelElement::start_view_transition_f_prom_unit(__self: mut HTMLLabelElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLabelElement::start_view_transition_mview_transition_options(__self: mut HTMLLabelElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLLabelElement::as_js(self: HTMLLabelElement) -> JsValue = JsValue::unsafe_from[HTMLLabelElement](self)

pub fun HTMLLabelElement::from_js(v: JsValue) -> mut HTMLLabelElement = JsValue::unsafe_as[mut HTMLLabelElement](v)

struct HTMLLegendElement()

/// Converts a reference to 'HTMLLegendElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::as_html_element(self: HTMLLegendElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLLegendElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::as_mhtml_element(self: mut HTMLLegendElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLLegendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLegendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::from_html_element(base: HTMLElement) -> HTMLLegendElement = "
    if(#var(base) instanceof HTMLLegendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLegendElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLLegendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLegendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLLegendElement = "
    if(#var(base) instanceof HTMLLegendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLegendElement'!\");
"

/// Converts a reference to 'HTMLLegendElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::as_element(self: HTMLLegendElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLLegendElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::as_melement(self: mut HTMLLegendElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLLegendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLegendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::from_element(base: Element) -> HTMLLegendElement = "
    if(#var(base) instanceof HTMLLegendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLegendElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLLegendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLegendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLegendElement::from_melement(base: mut Element) -> mut HTMLLegendElement = "
    if(#var(base) instanceof HTMLLegendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLegendElement'!\");
"

pub ext fun HTMLLegendElement::form(self: HTMLLegendElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLLegendElement::align(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLLegendElement::set_align(self: mut HTMLLegendElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::title(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLLegendElement::set_title(self: mut HTMLLegendElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::lang(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLLegendElement::set_lang(self: mut HTMLLegendElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::translate(self: HTMLLegendElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLLegendElement::set_translate(self: mut HTMLLegendElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLegendElement::dir(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLLegendElement::set_dir(self: mut HTMLLegendElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::hidden(self: HTMLLegendElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLLegendElement::set_hidden(self: mut HTMLLegendElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLLegendElement::inert(self: HTMLLegendElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLLegendElement::set_inert(self: mut HTMLLegendElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLegendElement::access_key(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLLegendElement::set_access_key(self: mut HTMLLegendElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::draggable(self: HTMLLegendElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLLegendElement::set_draggable(self: mut HTMLLegendElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLegendElement::spellcheck(self: HTMLLegendElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLLegendElement::set_spellcheck(self: mut HTMLLegendElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLegendElement::autocapitalize(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLLegendElement::set_autocapitalize(self: mut HTMLLegendElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::edit_context(self: HTMLLegendElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLLegendElement::set_edit_context(self: mut HTMLLegendElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLLegendElement::content_editable(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLLegendElement::set_content_editable(self: mut HTMLLegendElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::enter_key_hint(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLLegendElement::set_enter_key_hint(self: mut HTMLLegendElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::is_content_editable(self: HTMLLegendElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLLegendElement::input_mode(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLLegendElement::set_input_mode(self: mut HTMLLegendElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::virtual_keyboard_policy(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLLegendElement::set_virtual_keyboard_policy(self: mut HTMLLegendElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::scroll_parent(self: HTMLLegendElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLLegendElement::offset_parent(self: HTMLLegendElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLLegendElement::offset_top(self: HTMLLegendElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLLegendElement::offset_left(self: HTMLLegendElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLLegendElement::offset_width(self: HTMLLegendElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLLegendElement::offset_height(self: HTMLLegendElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLLegendElement::popover(self: HTMLLegendElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLLegendElement::set_popover(self: mut HTMLLegendElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLLegendElement::inner_text(self: HTMLLegendElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLLegendElement::set_inner_text(self: mut HTMLLegendElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLLegendElement::outer_text(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLLegendElement::set_outer_text(self: mut HTMLLegendElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::writing_suggestions(self: HTMLLegendElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLLegendElement::set_writing_suggestions(self: mut HTMLLegendElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLegendElement::click(__self: mut HTMLLegendElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLegendElement::attach_internals(__self: mut HTMLLegendElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLLegendElement::toggle_popover(__self: mut HTMLLegendElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLLegendElement::show_popover(__self: mut HTMLLegendElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLegendElement::hide_popover(__self: mut HTMLLegendElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLegendElement::start_view_transition(__self: mut HTMLLegendElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLegendElement::start_view_transition_f_prom_unit(__self: mut HTMLLegendElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLegendElement::start_view_transition_mview_transition_options(__self: mut HTMLLegendElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLLegendElement::as_js(self: HTMLLegendElement) -> JsValue = JsValue::unsafe_from[HTMLLegendElement](self)

pub fun HTMLLegendElement::from_js(v: JsValue) -> mut HTMLLegendElement = JsValue::unsafe_as[mut HTMLLegendElement](v)

struct HTMLOptGroupElement()

/// Converts a reference to 'HTMLOptGroupElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::as_html_element(self: HTMLOptGroupElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLOptGroupElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::as_mhtml_element(self: mut HTMLOptGroupElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLOptGroupElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptGroupElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::from_html_element(base: HTMLElement) -> HTMLOptGroupElement = "
    if(#var(base) instanceof HTMLOptGroupElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOptGroupElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLOptGroupElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptGroupElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLOptGroupElement = "
    if(#var(base) instanceof HTMLOptGroupElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOptGroupElement'!\");
"

/// Converts a reference to 'HTMLOptGroupElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::as_element(self: HTMLOptGroupElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLOptGroupElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::as_melement(self: mut HTMLOptGroupElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLOptGroupElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptGroupElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::from_element(base: Element) -> HTMLOptGroupElement = "
    if(#var(base) instanceof HTMLOptGroupElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOptGroupElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLOptGroupElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptGroupElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptGroupElement::from_melement(base: mut Element) -> mut HTMLOptGroupElement = "
    if(#var(base) instanceof HTMLOptGroupElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOptGroupElement'!\");
"

pub ext fun HTMLOptGroupElement::disabled(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLOptGroupElement::set_disabled(self: mut HTMLOptGroupElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::label(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun HTMLOptGroupElement::set_label(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).label = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::title(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLOptGroupElement::set_title(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::lang(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLOptGroupElement::set_lang(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::translate(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLOptGroupElement::set_translate(self: mut HTMLOptGroupElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::dir(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLOptGroupElement::set_dir(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::hidden(self: HTMLOptGroupElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLOptGroupElement::set_hidden(self: mut HTMLOptGroupElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLOptGroupElement::inert(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLOptGroupElement::set_inert(self: mut HTMLOptGroupElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::access_key(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLOptGroupElement::set_access_key(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::draggable(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLOptGroupElement::set_draggable(self: mut HTMLOptGroupElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::spellcheck(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLOptGroupElement::set_spellcheck(self: mut HTMLOptGroupElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::autocapitalize(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLOptGroupElement::set_autocapitalize(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::edit_context(self: HTMLOptGroupElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLOptGroupElement::set_edit_context(self: mut HTMLOptGroupElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLOptGroupElement::content_editable(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLOptGroupElement::set_content_editable(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::enter_key_hint(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLOptGroupElement::set_enter_key_hint(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::is_content_editable(self: HTMLOptGroupElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLOptGroupElement::input_mode(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLOptGroupElement::set_input_mode(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::virtual_keyboard_policy(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLOptGroupElement::set_virtual_keyboard_policy(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::scroll_parent(self: HTMLOptGroupElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLOptGroupElement::offset_parent(self: HTMLOptGroupElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLOptGroupElement::offset_top(self: HTMLOptGroupElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLOptGroupElement::offset_left(self: HTMLOptGroupElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLOptGroupElement::offset_width(self: HTMLOptGroupElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLOptGroupElement::offset_height(self: HTMLOptGroupElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLOptGroupElement::popover(self: HTMLOptGroupElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLOptGroupElement::set_popover(self: mut HTMLOptGroupElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLOptGroupElement::inner_text(self: HTMLOptGroupElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLOptGroupElement::set_inner_text(self: mut HTMLOptGroupElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLOptGroupElement::outer_text(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLOptGroupElement::set_outer_text(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::writing_suggestions(self: HTMLOptGroupElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLOptGroupElement::set_writing_suggestions(self: mut HTMLOptGroupElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptGroupElement::click(__self: mut HTMLOptGroupElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptGroupElement::attach_internals(__self: mut HTMLOptGroupElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLOptGroupElement::toggle_popover(__self: mut HTMLOptGroupElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOptGroupElement::show_popover(__self: mut HTMLOptGroupElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptGroupElement::hide_popover(__self: mut HTMLOptGroupElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptGroupElement::start_view_transition(__self: mut HTMLOptGroupElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOptGroupElement::start_view_transition_f_prom_unit(__self: mut HTMLOptGroupElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOptGroupElement::start_view_transition_mview_transition_options(__self: mut HTMLOptGroupElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLOptGroupElement::as_js(self: HTMLOptGroupElement) -> JsValue = JsValue::unsafe_from[HTMLOptGroupElement](self)

pub fun HTMLOptGroupElement::from_js(v: JsValue) -> mut HTMLOptGroupElement = JsValue::unsafe_as[mut HTMLOptGroupElement](v)

struct HTMLOptionElement()

/// Converts a reference to 'HTMLOptionElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::as_html_element(self: HTMLOptionElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLOptionElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::as_mhtml_element(self: mut HTMLOptionElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLOptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::from_html_element(base: HTMLElement) -> HTMLOptionElement = "
    if(#var(base) instanceof HTMLOptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOptionElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLOptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLOptionElement = "
    if(#var(base) instanceof HTMLOptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOptionElement'!\");
"

/// Converts a reference to 'HTMLOptionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::as_element(self: HTMLOptionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLOptionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::as_melement(self: mut HTMLOptionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLOptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::from_element(base: Element) -> HTMLOptionElement = "
    if(#var(base) instanceof HTMLOptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOptionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLOptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionElement::from_melement(base: mut Element) -> mut HTMLOptionElement = "
    if(#var(base) instanceof HTMLOptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOptionElement'!\");
"

pub ext fun HTMLOptionElement::new() -> mut HTMLOptionElement
    = "return new HTMLOptionElement();"

pub ext fun HTMLOptionElement::disabled(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLOptionElement::set_disabled(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::form(self: HTMLOptionElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLOptionElement::label(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun HTMLOptionElement::set_label(self: mut HTMLOptionElement, value: String)
    = "#var(self).label = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::default_selected(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultSelected);"

pub ext fun HTMLOptionElement::set_default_selected(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).defaultSelected = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::selected(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).selected);"

pub ext fun HTMLOptionElement::set_selected(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).selected = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::value(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLOptionElement::set_value(self: mut HTMLOptionElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::text(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun HTMLOptionElement::set_text(self: mut HTMLOptionElement, value: String)
    = "#var(self).text = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::index(self: HTMLOptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).index);"

pub ext fun HTMLOptionElement::title(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLOptionElement::set_title(self: mut HTMLOptionElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::lang(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLOptionElement::set_lang(self: mut HTMLOptionElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::translate(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLOptionElement::set_translate(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::dir(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLOptionElement::set_dir(self: mut HTMLOptionElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::hidden(self: HTMLOptionElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLOptionElement::set_hidden(self: mut HTMLOptionElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLOptionElement::inert(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLOptionElement::set_inert(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::access_key(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLOptionElement::set_access_key(self: mut HTMLOptionElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::draggable(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLOptionElement::set_draggable(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::spellcheck(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLOptionElement::set_spellcheck(self: mut HTMLOptionElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOptionElement::autocapitalize(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLOptionElement::set_autocapitalize(self: mut HTMLOptionElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::edit_context(self: HTMLOptionElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLOptionElement::set_edit_context(self: mut HTMLOptionElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLOptionElement::content_editable(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLOptionElement::set_content_editable(self: mut HTMLOptionElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::enter_key_hint(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLOptionElement::set_enter_key_hint(self: mut HTMLOptionElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::is_content_editable(self: HTMLOptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLOptionElement::input_mode(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLOptionElement::set_input_mode(self: mut HTMLOptionElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::virtual_keyboard_policy(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLOptionElement::set_virtual_keyboard_policy(self: mut HTMLOptionElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::scroll_parent(self: HTMLOptionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLOptionElement::offset_parent(self: HTMLOptionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLOptionElement::offset_top(self: HTMLOptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLOptionElement::offset_left(self: HTMLOptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLOptionElement::offset_width(self: HTMLOptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLOptionElement::offset_height(self: HTMLOptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLOptionElement::popover(self: HTMLOptionElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLOptionElement::set_popover(self: mut HTMLOptionElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLOptionElement::inner_text(self: HTMLOptionElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLOptionElement::set_inner_text(self: mut HTMLOptionElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLOptionElement::outer_text(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLOptionElement::set_outer_text(self: mut HTMLOptionElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::writing_suggestions(self: HTMLOptionElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLOptionElement::set_writing_suggestions(self: mut HTMLOptionElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOptionElement::click(__self: mut HTMLOptionElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptionElement::attach_internals(__self: mut HTMLOptionElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLOptionElement::toggle_popover(__self: mut HTMLOptionElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOptionElement::show_popover(__self: mut HTMLOptionElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptionElement::hide_popover(__self: mut HTMLOptionElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptionElement::start_view_transition(__self: mut HTMLOptionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOptionElement::start_view_transition_f_prom_unit(__self: mut HTMLOptionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOptionElement::start_view_transition_mview_transition_options(__self: mut HTMLOptionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLOptionElement::as_js(self: HTMLOptionElement) -> JsValue = JsValue::unsafe_from[HTMLOptionElement](self)

pub fun HTMLOptionElement::from_js(v: JsValue) -> mut HTMLOptionElement = JsValue::unsafe_as[mut HTMLOptionElement](v)

struct HTMLOptionsCollection()

/// Converts a reference to 'HTMLOptionsCollection' to a reference to 'HTMLCollection'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionsCollection::as_html_collection(self: HTMLOptionsCollection) -> HTMLCollection = "return #var(self);"

/// Converts a mutable reference to 'HTMLOptionsCollection' to a mutable reference to 'HTMLCollection'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionsCollection::as_mhtml_collection(self: mut HTMLOptionsCollection) -> mut HTMLCollection = "return #var(self);"

/// Attempts to convert a reference to 'HTMLCollection' to a reference to 'HTMLOptionsCollection'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionsCollection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionsCollection::from_html_collection(base: HTMLCollection) -> HTMLOptionsCollection = "
    if(#var(base) instanceof HTMLOptionsCollection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLCollection' to 'HTMLOptionsCollection'!\");
"

/// Attempts to convert a mutable reference to 'HTMLCollection' to a mutable reference to 'HTMLOptionsCollection'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOptionsCollection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOptionsCollection::from_mhtml_collection(base: mut HTMLCollection) -> mut HTMLOptionsCollection = "
    if(#var(base) instanceof HTMLOptionsCollection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLCollection' to 'HTMLOptionsCollection'!\");
"

pub ext fun HTMLOptionsCollection::length(self: HTMLOptionsCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLOptionsCollection::set_length(self: mut HTMLOptionsCollection, value: Int)
    = "#var(self).length = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLOptionsCollection::selected_index(self: HTMLOptionsCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).selectedIndex);"

pub ext fun HTMLOptionsCollection::set_selected_index(self: mut HTMLOptionsCollection, value: Int)
    = "#var(self).selectedIndex = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLOptionsCollection::set(__self: mut HTMLOptionsCollection, index: Int, option: Option[mut HTMLOptionElement]) = "
    HTMLOptionsCollection[#fun(Int::as_js)(#var(index))] = #fun(Option::as_js[mut HTMLOptionElement])(#var(option));
"

pub ext fun HTMLOptionsCollection::add(__self: mut HTMLOptionsCollection, element: JsValue, before: Option[JsValue]) -> Unit = "
    const r = #var(__self).add(#var(element), #fun(Option::as_js[JsValue])(#var(before)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptionsCollection::remove(__self: mut HTMLOptionsCollection, index: Int) -> Unit = "
    const r = #var(__self).remove(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOptionsCollection::get_int(__self: HTMLOptionsCollection, index: Int) -> Option[mut Element] = "
    const r = HTMLOptionsCollection[#fun(Int::as_js)(#var(index))];
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLOptionsCollection::get_str(__self: HTMLOptionsCollection, name: String) -> Option[mut Element] = "
    const r = HTMLOptionsCollection[#fun(String::as_js)(#var(name))];
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLOptionsCollection::item(__self: mut HTMLOptionsCollection, index: Int) -> Option[mut Element] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLOptionsCollection::named_item(__self: mut HTMLOptionsCollection, name: String) -> Option[mut Element] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut Element])(r);
"

pub fun HTMLOptionsCollection::as_js(self: HTMLOptionsCollection) -> JsValue = JsValue::unsafe_from[HTMLOptionsCollection](self)

pub fun HTMLOptionsCollection::from_js(v: JsValue) -> mut HTMLOptionsCollection = JsValue::unsafe_as[mut HTMLOptionsCollection](v)

struct HTMLOutputElement()

/// Converts a reference to 'HTMLOutputElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::as_html_element(self: HTMLOutputElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLOutputElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::as_mhtml_element(self: mut HTMLOutputElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLOutputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOutputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::from_html_element(base: HTMLElement) -> HTMLOutputElement = "
    if(#var(base) instanceof HTMLOutputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOutputElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLOutputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOutputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLOutputElement = "
    if(#var(base) instanceof HTMLOutputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOutputElement'!\");
"

/// Converts a reference to 'HTMLOutputElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::as_element(self: HTMLOutputElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLOutputElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::as_melement(self: mut HTMLOutputElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLOutputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOutputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::from_element(base: Element) -> HTMLOutputElement = "
    if(#var(base) instanceof HTMLOutputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOutputElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLOutputElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOutputElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOutputElement::from_melement(base: mut Element) -> mut HTMLOutputElement = "
    if(#var(base) instanceof HTMLOutputElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOutputElement'!\");
"

pub ext fun HTMLOutputElement::html_for(self: HTMLOutputElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).htmlFor);"

pub ext fun HTMLOutputElement::form(self: HTMLOutputElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLOutputElement::name(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLOutputElement::set_name(self: mut HTMLOutputElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::type(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLOutputElement::default_value(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).defaultValue);"

pub ext fun HTMLOutputElement::set_default_value(self: mut HTMLOutputElement, value: String)
    = "#var(self).defaultValue = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::value(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLOutputElement::set_value(self: mut HTMLOutputElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::will_validate(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLOutputElement::validity(self: HTMLOutputElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLOutputElement::validation_message(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLOutputElement::labels(self: HTMLOutputElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLOutputElement::title(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLOutputElement::set_title(self: mut HTMLOutputElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::lang(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLOutputElement::set_lang(self: mut HTMLOutputElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::translate(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLOutputElement::set_translate(self: mut HTMLOutputElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOutputElement::dir(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLOutputElement::set_dir(self: mut HTMLOutputElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::hidden(self: HTMLOutputElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLOutputElement::set_hidden(self: mut HTMLOutputElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLOutputElement::inert(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLOutputElement::set_inert(self: mut HTMLOutputElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOutputElement::access_key(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLOutputElement::set_access_key(self: mut HTMLOutputElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::draggable(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLOutputElement::set_draggable(self: mut HTMLOutputElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOutputElement::spellcheck(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLOutputElement::set_spellcheck(self: mut HTMLOutputElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOutputElement::autocapitalize(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLOutputElement::set_autocapitalize(self: mut HTMLOutputElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::edit_context(self: HTMLOutputElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLOutputElement::set_edit_context(self: mut HTMLOutputElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLOutputElement::content_editable(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLOutputElement::set_content_editable(self: mut HTMLOutputElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::enter_key_hint(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLOutputElement::set_enter_key_hint(self: mut HTMLOutputElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::is_content_editable(self: HTMLOutputElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLOutputElement::input_mode(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLOutputElement::set_input_mode(self: mut HTMLOutputElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::virtual_keyboard_policy(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLOutputElement::set_virtual_keyboard_policy(self: mut HTMLOutputElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::scroll_parent(self: HTMLOutputElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLOutputElement::offset_parent(self: HTMLOutputElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLOutputElement::offset_top(self: HTMLOutputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLOutputElement::offset_left(self: HTMLOutputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLOutputElement::offset_width(self: HTMLOutputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLOutputElement::offset_height(self: HTMLOutputElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLOutputElement::popover(self: HTMLOutputElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLOutputElement::set_popover(self: mut HTMLOutputElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLOutputElement::inner_text(self: HTMLOutputElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLOutputElement::set_inner_text(self: mut HTMLOutputElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLOutputElement::outer_text(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLOutputElement::set_outer_text(self: mut HTMLOutputElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::writing_suggestions(self: HTMLOutputElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLOutputElement::set_writing_suggestions(self: mut HTMLOutputElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOutputElement::check_validity(__self: mut HTMLOutputElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOutputElement::report_validity(__self: mut HTMLOutputElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOutputElement::set_custom_validity(__self: mut HTMLOutputElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOutputElement::click(__self: mut HTMLOutputElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOutputElement::attach_internals(__self: mut HTMLOutputElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLOutputElement::toggle_popover(__self: mut HTMLOutputElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOutputElement::show_popover(__self: mut HTMLOutputElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOutputElement::hide_popover(__self: mut HTMLOutputElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOutputElement::start_view_transition(__self: mut HTMLOutputElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOutputElement::start_view_transition_f_prom_unit(__self: mut HTMLOutputElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOutputElement::start_view_transition_mview_transition_options(__self: mut HTMLOutputElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLOutputElement::as_js(self: HTMLOutputElement) -> JsValue = JsValue::unsafe_from[HTMLOutputElement](self)

pub fun HTMLOutputElement::from_js(v: JsValue) -> mut HTMLOutputElement = JsValue::unsafe_as[mut HTMLOutputElement](v)

struct HTMLSelectElement()

/// Converts a reference to 'HTMLSelectElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::as_html_element(self: HTMLSelectElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLSelectElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::as_mhtml_element(self: mut HTMLSelectElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLSelectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::from_html_element(base: HTMLElement) -> HTMLSelectElement = "
    if(#var(base) instanceof HTMLSelectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSelectElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLSelectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLSelectElement = "
    if(#var(base) instanceof HTMLSelectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSelectElement'!\");
"

/// Converts a reference to 'HTMLSelectElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::as_element(self: HTMLSelectElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLSelectElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::as_melement(self: mut HTMLSelectElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLSelectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::from_element(base: Element) -> HTMLSelectElement = "
    if(#var(base) instanceof HTMLSelectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSelectElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLSelectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectElement::from_melement(base: mut Element) -> mut HTMLSelectElement = "
    if(#var(base) instanceof HTMLSelectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSelectElement'!\");
"

pub ext fun HTMLSelectElement::autocomplete(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).autocomplete);"

pub ext fun HTMLSelectElement::set_autocomplete(self: mut HTMLSelectElement, value: String)
    = "#var(self).autocomplete = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::disabled(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLSelectElement::set_disabled(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::form(self: HTMLSelectElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLSelectElement::multiple(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).multiple);"

pub ext fun HTMLSelectElement::set_multiple(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).multiple = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::name(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLSelectElement::set_name(self: mut HTMLSelectElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::required(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).required);"

pub ext fun HTMLSelectElement::set_required(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).required = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::size(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun HTMLSelectElement::set_size(self: mut HTMLSelectElement, value: Int)
    = "#var(self).size = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLSelectElement::type(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLSelectElement::options(self: HTMLSelectElement) -> mut HTMLOptionsCollection
    = "return #fun(HTMLOptionsCollection::from_js)(#var(self).options);"

pub ext fun HTMLSelectElement::length(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLSelectElement::set_length(self: mut HTMLSelectElement, value: Int)
    = "#var(self).length = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLSelectElement::selected_options(self: HTMLSelectElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).selectedOptions);"

pub ext fun HTMLSelectElement::selected_index(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).selectedIndex);"

pub ext fun HTMLSelectElement::set_selected_index(self: mut HTMLSelectElement, value: Int)
    = "#var(self).selectedIndex = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLSelectElement::value(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLSelectElement::set_value(self: mut HTMLSelectElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::will_validate(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLSelectElement::validity(self: HTMLSelectElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLSelectElement::validation_message(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLSelectElement::labels(self: HTMLSelectElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLSelectElement::selected_content_element(self: HTMLSelectElement) -> Option[mut HTMLSelectedContentElement]
    = "return #fun(Option::from_js[mut HTMLSelectedContentElement])(#var(self).selectedContentElement);"

pub ext fun HTMLSelectElement::set_selected_content_element(self: mut HTMLSelectElement, value: Option[mut HTMLSelectedContentElement])
    = "#var(self).selectedContentElement = #fun(Option::as_js[mut HTMLSelectedContentElement])(#var(value));"

pub ext fun HTMLSelectElement::title(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLSelectElement::set_title(self: mut HTMLSelectElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::lang(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLSelectElement::set_lang(self: mut HTMLSelectElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::translate(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLSelectElement::set_translate(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::dir(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLSelectElement::set_dir(self: mut HTMLSelectElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::hidden(self: HTMLSelectElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLSelectElement::set_hidden(self: mut HTMLSelectElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLSelectElement::inert(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLSelectElement::set_inert(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::access_key(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLSelectElement::set_access_key(self: mut HTMLSelectElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::draggable(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLSelectElement::set_draggable(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::spellcheck(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLSelectElement::set_spellcheck(self: mut HTMLSelectElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectElement::autocapitalize(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLSelectElement::set_autocapitalize(self: mut HTMLSelectElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::edit_context(self: HTMLSelectElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLSelectElement::set_edit_context(self: mut HTMLSelectElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLSelectElement::content_editable(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLSelectElement::set_content_editable(self: mut HTMLSelectElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::enter_key_hint(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLSelectElement::set_enter_key_hint(self: mut HTMLSelectElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::is_content_editable(self: HTMLSelectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLSelectElement::input_mode(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLSelectElement::set_input_mode(self: mut HTMLSelectElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::virtual_keyboard_policy(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLSelectElement::set_virtual_keyboard_policy(self: mut HTMLSelectElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::scroll_parent(self: HTMLSelectElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLSelectElement::offset_parent(self: HTMLSelectElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLSelectElement::offset_top(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLSelectElement::offset_left(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLSelectElement::offset_width(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLSelectElement::offset_height(self: HTMLSelectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLSelectElement::popover(self: HTMLSelectElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLSelectElement::set_popover(self: mut HTMLSelectElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLSelectElement::inner_text(self: HTMLSelectElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLSelectElement::set_inner_text(self: mut HTMLSelectElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLSelectElement::outer_text(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLSelectElement::set_outer_text(self: mut HTMLSelectElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::writing_suggestions(self: HTMLSelectElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLSelectElement::set_writing_suggestions(self: mut HTMLSelectElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectElement::item(__self: mut HTMLSelectElement, index: Int) -> Option[mut Element] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLSelectElement::named_item(__self: mut HTMLSelectElement, name: String) -> Option[mut HTMLOptionElement] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut HTMLOptionElement])(r);
"

pub ext fun HTMLSelectElement::add(__self: mut HTMLSelectElement, element: JsValue, before: Option[JsValue]) -> Unit = "
    const r = #var(__self).add(#var(element), #fun(Option::as_js[JsValue])(#var(before)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::remove(__self: mut HTMLSelectElement) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::remove_int(__self: mut HTMLSelectElement, index: Int) -> Unit = "
    const r = #var(__self).remove(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::set(__self: mut HTMLSelectElement, index: Int, option: Option[mut HTMLOptionElement]) = "
    HTMLSelectElement[#fun(Int::as_js)(#var(index))] = #fun(Option::as_js[mut HTMLOptionElement])(#var(option));
"

pub ext fun HTMLSelectElement::check_validity(__self: mut HTMLSelectElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSelectElement::report_validity(__self: mut HTMLSelectElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSelectElement::set_custom_validity(__self: mut HTMLSelectElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::show_picker(__self: mut HTMLSelectElement) -> Unit = "
    const r = #var(__self).showPicker();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::click(__self: mut HTMLSelectElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::attach_internals(__self: mut HTMLSelectElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLSelectElement::toggle_popover(__self: mut HTMLSelectElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSelectElement::show_popover(__self: mut HTMLSelectElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::hide_popover(__self: mut HTMLSelectElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectElement::start_view_transition(__self: mut HTMLSelectElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSelectElement::start_view_transition_f_prom_unit(__self: mut HTMLSelectElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSelectElement::start_view_transition_mview_transition_options(__self: mut HTMLSelectElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLSelectElement::as_js(self: HTMLSelectElement) -> JsValue = JsValue::unsafe_from[HTMLSelectElement](self)

pub fun HTMLSelectElement::from_js(v: JsValue) -> mut HTMLSelectElement = JsValue::unsafe_as[mut HTMLSelectElement](v)

struct HTMLSelectedContentElement()

/// Converts a reference to 'HTMLSelectedContentElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::as_html_element(self: HTMLSelectedContentElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLSelectedContentElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::as_mhtml_element(self: mut HTMLSelectedContentElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLSelectedContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectedContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::from_html_element(base: HTMLElement) -> HTMLSelectedContentElement = "
    if(#var(base) instanceof HTMLSelectedContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSelectedContentElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLSelectedContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectedContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLSelectedContentElement = "
    if(#var(base) instanceof HTMLSelectedContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSelectedContentElement'!\");
"

/// Converts a reference to 'HTMLSelectedContentElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::as_element(self: HTMLSelectedContentElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLSelectedContentElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::as_melement(self: mut HTMLSelectedContentElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLSelectedContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectedContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::from_element(base: Element) -> HTMLSelectedContentElement = "
    if(#var(base) instanceof HTMLSelectedContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSelectedContentElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLSelectedContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSelectedContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSelectedContentElement::from_melement(base: mut Element) -> mut HTMLSelectedContentElement = "
    if(#var(base) instanceof HTMLSelectedContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSelectedContentElement'!\");
"

pub ext fun HTMLSelectedContentElement::title(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLSelectedContentElement::set_title(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::lang(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLSelectedContentElement::set_lang(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::translate(self: HTMLSelectedContentElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLSelectedContentElement::set_translate(self: mut HTMLSelectedContentElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::dir(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLSelectedContentElement::set_dir(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::hidden(self: HTMLSelectedContentElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLSelectedContentElement::set_hidden(self: mut HTMLSelectedContentElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLSelectedContentElement::inert(self: HTMLSelectedContentElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLSelectedContentElement::set_inert(self: mut HTMLSelectedContentElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::access_key(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLSelectedContentElement::set_access_key(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::draggable(self: HTMLSelectedContentElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLSelectedContentElement::set_draggable(self: mut HTMLSelectedContentElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::spellcheck(self: HTMLSelectedContentElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLSelectedContentElement::set_spellcheck(self: mut HTMLSelectedContentElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::autocapitalize(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLSelectedContentElement::set_autocapitalize(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::edit_context(self: HTMLSelectedContentElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLSelectedContentElement::set_edit_context(self: mut HTMLSelectedContentElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLSelectedContentElement::content_editable(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLSelectedContentElement::set_content_editable(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::enter_key_hint(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLSelectedContentElement::set_enter_key_hint(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::is_content_editable(self: HTMLSelectedContentElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLSelectedContentElement::input_mode(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLSelectedContentElement::set_input_mode(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::virtual_keyboard_policy(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLSelectedContentElement::set_virtual_keyboard_policy(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::scroll_parent(self: HTMLSelectedContentElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLSelectedContentElement::offset_parent(self: HTMLSelectedContentElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLSelectedContentElement::offset_top(self: HTMLSelectedContentElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLSelectedContentElement::offset_left(self: HTMLSelectedContentElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLSelectedContentElement::offset_width(self: HTMLSelectedContentElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLSelectedContentElement::offset_height(self: HTMLSelectedContentElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLSelectedContentElement::popover(self: HTMLSelectedContentElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLSelectedContentElement::set_popover(self: mut HTMLSelectedContentElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLSelectedContentElement::inner_text(self: HTMLSelectedContentElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLSelectedContentElement::set_inner_text(self: mut HTMLSelectedContentElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLSelectedContentElement::outer_text(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLSelectedContentElement::set_outer_text(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::writing_suggestions(self: HTMLSelectedContentElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLSelectedContentElement::set_writing_suggestions(self: mut HTMLSelectedContentElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSelectedContentElement::click(__self: mut HTMLSelectedContentElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::attach_internals(__self: mut HTMLSelectedContentElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::toggle_popover(__self: mut HTMLSelectedContentElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::show_popover(__self: mut HTMLSelectedContentElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::hide_popover(__self: mut HTMLSelectedContentElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::start_view_transition(__self: mut HTMLSelectedContentElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::start_view_transition_f_prom_unit(__self: mut HTMLSelectedContentElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSelectedContentElement::start_view_transition_mview_transition_options(__self: mut HTMLSelectedContentElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLSelectedContentElement::as_js(self: HTMLSelectedContentElement) -> JsValue = JsValue::unsafe_from[HTMLSelectedContentElement](self)

pub fun HTMLSelectedContentElement::from_js(v: JsValue) -> mut HTMLSelectedContentElement = JsValue::unsafe_as[mut HTMLSelectedContentElement](v)

struct HTMLTextAreaElement()

/// Converts a reference to 'HTMLTextAreaElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::as_html_element(self: HTMLTextAreaElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTextAreaElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::as_mhtml_element(self: mut HTMLTextAreaElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTextAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTextAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::from_html_element(base: HTMLElement) -> HTMLTextAreaElement = "
    if(#var(base) instanceof HTMLTextAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTextAreaElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTextAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTextAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTextAreaElement = "
    if(#var(base) instanceof HTMLTextAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTextAreaElement'!\");
"

/// Converts a reference to 'HTMLTextAreaElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::as_element(self: HTMLTextAreaElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTextAreaElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::as_melement(self: mut HTMLTextAreaElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTextAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTextAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::from_element(base: Element) -> HTMLTextAreaElement = "
    if(#var(base) instanceof HTMLTextAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTextAreaElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTextAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTextAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTextAreaElement::from_melement(base: mut Element) -> mut HTMLTextAreaElement = "
    if(#var(base) instanceof HTMLTextAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTextAreaElement'!\");
"

pub ext fun HTMLTextAreaElement::autocomplete(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).autocomplete);"

pub ext fun HTMLTextAreaElement::set_autocomplete(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).autocomplete = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::cols(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).cols);"

pub ext fun HTMLTextAreaElement::set_cols(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).cols = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::dir_name(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).dirName);"

pub ext fun HTMLTextAreaElement::set_dir_name(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).dirName = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::disabled(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLTextAreaElement::set_disabled(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::form(self: HTMLTextAreaElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLTextAreaElement::max_length(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).maxLength);"

pub ext fun HTMLTextAreaElement::set_max_length(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).maxLength = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::min_length(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).minLength);"

pub ext fun HTMLTextAreaElement::set_min_length(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).minLength = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::name(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLTextAreaElement::set_name(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::placeholder(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).placeholder);"

pub ext fun HTMLTextAreaElement::set_placeholder(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).placeholder = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::read_only(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).readOnly);"

pub ext fun HTMLTextAreaElement::set_read_only(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).readOnly = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::required(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).required);"

pub ext fun HTMLTextAreaElement::set_required(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).required = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::rows(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).rows);"

pub ext fun HTMLTextAreaElement::set_rows(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).rows = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::wrap(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).wrap);"

pub ext fun HTMLTextAreaElement::set_wrap(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).wrap = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::type(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLTextAreaElement::default_value(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).defaultValue);"

pub ext fun HTMLTextAreaElement::set_default_value(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).defaultValue = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::value(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLTextAreaElement::set_value(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::text_length(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).textLength);"

pub ext fun HTMLTextAreaElement::will_validate(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLTextAreaElement::validity(self: HTMLTextAreaElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLTextAreaElement::validation_message(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLTextAreaElement::labels(self: HTMLTextAreaElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLTextAreaElement::selection_start(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionStart);"

pub ext fun HTMLTextAreaElement::set_selection_start(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).selectionStart = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::selection_end(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).selectionEnd);"

pub ext fun HTMLTextAreaElement::set_selection_end(self: mut HTMLTextAreaElement, value: Int)
    = "#var(self).selectionEnd = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::selection_direction(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).selectionDirection);"

pub ext fun HTMLTextAreaElement::set_selection_direction(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).selectionDirection = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::title(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTextAreaElement::set_title(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::lang(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTextAreaElement::set_lang(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::translate(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTextAreaElement::set_translate(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::dir(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTextAreaElement::set_dir(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::hidden(self: HTMLTextAreaElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTextAreaElement::set_hidden(self: mut HTMLTextAreaElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTextAreaElement::inert(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTextAreaElement::set_inert(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::access_key(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTextAreaElement::set_access_key(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::draggable(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTextAreaElement::set_draggable(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::spellcheck(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTextAreaElement::set_spellcheck(self: mut HTMLTextAreaElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::autocapitalize(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTextAreaElement::set_autocapitalize(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::edit_context(self: HTMLTextAreaElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTextAreaElement::set_edit_context(self: mut HTMLTextAreaElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTextAreaElement::content_editable(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTextAreaElement::set_content_editable(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::enter_key_hint(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTextAreaElement::set_enter_key_hint(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::is_content_editable(self: HTMLTextAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTextAreaElement::input_mode(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTextAreaElement::set_input_mode(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::virtual_keyboard_policy(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTextAreaElement::set_virtual_keyboard_policy(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::scroll_parent(self: HTMLTextAreaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTextAreaElement::offset_parent(self: HTMLTextAreaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTextAreaElement::offset_top(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTextAreaElement::offset_left(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTextAreaElement::offset_width(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTextAreaElement::offset_height(self: HTMLTextAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTextAreaElement::popover(self: HTMLTextAreaElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTextAreaElement::set_popover(self: mut HTMLTextAreaElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTextAreaElement::inner_text(self: HTMLTextAreaElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTextAreaElement::set_inner_text(self: mut HTMLTextAreaElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTextAreaElement::outer_text(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTextAreaElement::set_outer_text(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::writing_suggestions(self: HTMLTextAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTextAreaElement::set_writing_suggestions(self: mut HTMLTextAreaElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTextAreaElement::check_validity(__self: mut HTMLTextAreaElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTextAreaElement::report_validity(__self: mut HTMLTextAreaElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTextAreaElement::set_custom_validity(__self: mut HTMLTextAreaElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::select(__self: mut HTMLTextAreaElement) -> Unit = "
    const r = #var(__self).select();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::set_range_text_str(__self: mut HTMLTextAreaElement, replacement: String) -> Unit = "
    const r = #var(__self).setRangeText(#fun(String::as_js)(#var(replacement)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::set_range_text_str_int_int_str(__self: mut HTMLTextAreaElement, replacement: String, start: Int, end: Int, selection_mode: String) -> Unit = "
    const r = #var(__self).setRangeText(#fun(String::as_js)(#var(replacement)), #fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #var(selection_mode));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::set_selection_range(__self: mut HTMLTextAreaElement, start: Int, end: Int, direction: String) -> Unit = "
    const r = #var(__self).setSelectionRange(#fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)), #fun(String::as_js)(#var(direction)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::click(__self: mut HTMLTextAreaElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::attach_internals(__self: mut HTMLTextAreaElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTextAreaElement::toggle_popover(__self: mut HTMLTextAreaElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTextAreaElement::show_popover(__self: mut HTMLTextAreaElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::hide_popover(__self: mut HTMLTextAreaElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTextAreaElement::start_view_transition(__self: mut HTMLTextAreaElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTextAreaElement::start_view_transition_f_prom_unit(__self: mut HTMLTextAreaElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTextAreaElement::start_view_transition_mview_transition_options(__self: mut HTMLTextAreaElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTextAreaElement::as_js(self: HTMLTextAreaElement) -> JsValue = JsValue::unsafe_from[HTMLTextAreaElement](self)

pub fun HTMLTextAreaElement::from_js(v: JsValue) -> mut HTMLTextAreaElement = JsValue::unsafe_as[mut HTMLTextAreaElement](v)

struct RadioNodeList()

/// Converts a reference to 'RadioNodeList' to a reference to 'NodeList'.
/// This does not involve manipulating the object or reference.
pub ext fun RadioNodeList::as_node_list(self: RadioNodeList) -> NodeList = "return #var(self);"

/// Converts a mutable reference to 'RadioNodeList' to a mutable reference to 'NodeList'.
/// This does not involve manipulating the object or reference.
pub ext fun RadioNodeList::as_mnode_list(self: mut RadioNodeList) -> mut NodeList = "return #var(self);"

/// Attempts to convert a reference to 'NodeList' to a reference to 'RadioNodeList'.
/// The conversion may fail and panic if 'base' is not a reference to 'RadioNodeList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun RadioNodeList::from_node_list(base: NodeList) -> RadioNodeList = "
    if(#var(base) instanceof RadioNodeList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'NodeList' to 'RadioNodeList'!\");
"

/// Attempts to convert a mutable reference to 'NodeList' to a mutable reference to 'RadioNodeList'.
/// The conversion may fail and panic if 'base' is not a reference to 'RadioNodeList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun RadioNodeList::from_mnode_list(base: mut NodeList) -> mut RadioNodeList = "
    if(#var(base) instanceof RadioNodeList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'NodeList' to 'RadioNodeList'!\");
"

pub ext fun RadioNodeList::value(self: RadioNodeList) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun RadioNodeList::set_value(self: mut RadioNodeList, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun RadioNodeList::length(self: RadioNodeList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun RadioNodeList::get(__self: RadioNodeList, index: Int) -> Option[mut Node] = "
    const r = RadioNodeList[#fun(Int::as_js)(#var(index))];
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun RadioNodeList::item(__self: mut RadioNodeList, index: Int) -> Option[mut Node] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Node])(r);
"

pub fun RadioNodeList::as_js(self: RadioNodeList) -> JsValue = JsValue::unsafe_from[RadioNodeList](self)

pub fun RadioNodeList::from_js(v: JsValue) -> mut RadioNodeList = JsValue::unsafe_as[mut RadioNodeList](v)

struct SubmitEvent()

/// Converts a reference to 'SubmitEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEvent::as_event(self: SubmitEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'SubmitEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEvent::as_mevent(self: mut SubmitEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'SubmitEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SubmitEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEvent::from_event(base: Event) -> SubmitEvent = "
    if(#var(base) instanceof SubmitEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SubmitEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'SubmitEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SubmitEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEvent::from_mevent(base: mut Event) -> mut SubmitEvent = "
    if(#var(base) instanceof SubmitEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SubmitEvent'!\");
"

pub ext fun SubmitEvent::from_str_msubmit_event_init(type: String, event_init_dict: mut SubmitEventInit) -> mut SubmitEvent
    = "return new SubmitEvent(#fun(String::as_js)(#var(type)), #fun(SubmitEventInit::as_js)(#var(event_init_dict)));"

pub ext fun SubmitEvent::submitter(self: SubmitEvent) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).submitter);"

pub ext fun SubmitEvent::type(self: SubmitEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SubmitEvent::target(self: SubmitEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun SubmitEvent::current_target(self: SubmitEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun SubmitEvent::event_phase(self: SubmitEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun SubmitEvent::bubbles(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun SubmitEvent::cancelable(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun SubmitEvent::default_prevented(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun SubmitEvent::composed(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun SubmitEvent::is_trusted(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun SubmitEvent::time_stamp(self: SubmitEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun SubmitEvent::src_element(self: SubmitEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun SubmitEvent::return_value(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun SubmitEvent::set_return_value(self: mut SubmitEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun SubmitEvent::cancel_bubble(self: SubmitEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun SubmitEvent::set_cancel_bubble(self: mut SubmitEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun SubmitEvent::composed_path(__self: mut SubmitEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun SubmitEvent::stop_propagation(__self: mut SubmitEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SubmitEvent::stop_immediate_propagation(__self: mut SubmitEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SubmitEvent::prevent_default(__self: mut SubmitEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun SubmitEvent::init_event(__self: mut SubmitEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun SubmitEvent::as_js(self: SubmitEvent) -> JsValue = JsValue::unsafe_from[SubmitEvent](self)

pub fun SubmitEvent::from_js(v: JsValue) -> mut SubmitEvent = JsValue::unsafe_as[mut SubmitEvent](v)

pub val SubmitEvent::none: Int = 0
pub val SubmitEvent::capturing_phase: Int = 1
pub val SubmitEvent::at_target: Int = 2
pub val SubmitEvent::bubbling_phase: Int = 3

pub struct SubmitEventInit(
    submitter: Option[mut HTMLElement],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun SubmitEventInit::default() -> mut SubmitEventInit
    = SubmitEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'SubmitEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEventInit::as_event_init(self: SubmitEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'SubmitEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEventInit::as_mevent_init(self: mut SubmitEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'SubmitEventInit'.
/// A 'base' that is not a reference to 'SubmitEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEventInit::from_event_init_unchecked(base: EventInit) -> SubmitEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'SubmitEventInit'.
/// A 'base' that is not a reference to 'SubmitEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SubmitEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut SubmitEventInit = "return #var(base);"

pub ext fun SubmitEventInit::from_js(value: JsValue) -> mut SubmitEventInit = "
    const r = {};
    r.m_submitter = #fun(Option::from_js[mut HTMLElement])(#var(value).submitter);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun SubmitEventInit::as_js(self: SubmitEventInit) -> JsValue = "
    const r = {};
    r.submitter = #fun(Option::as_js_undef[mut HTMLElement])(#var(self).m_submitter);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct ValidityState()

pub ext fun ValidityState::value_missing(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).valueMissing);"

pub ext fun ValidityState::type_mismatch(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).typeMismatch);"

pub ext fun ValidityState::pattern_mismatch(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).patternMismatch);"

pub ext fun ValidityState::too_long(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).tooLong);"

pub ext fun ValidityState::too_short(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).tooShort);"

pub ext fun ValidityState::range_underflow(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).rangeUnderflow);"

pub ext fun ValidityState::range_overflow(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).rangeOverflow);"

pub ext fun ValidityState::step_mismatch(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).stepMismatch);"

pub ext fun ValidityState::bad_input(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).badInput);"

pub ext fun ValidityState::custom_error(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).customError);"

pub ext fun ValidityState::valid(self: ValidityState) -> Bool
    = "return #fun(Bool::from_js)(#var(self).valid);"

pub fun ValidityState::as_js(self: ValidityState) -> JsValue = JsValue::unsafe_from[ValidityState](self)

pub fun ValidityState::from_js(v: JsValue) -> mut ValidityState = JsValue::unsafe_as[mut ValidityState](v)

struct HTMLAllCollection()

pub ext fun HTMLAllCollection::length(self: HTMLAllCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLAllCollection::get(__self: HTMLAllCollection, index: Int) -> Option[mut Element] = "
    const r = HTMLAllCollection[#fun(Int::as_js)(#var(index))];
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLAllCollection::named_item(__self: mut HTMLAllCollection, name: String) -> Option[JsValue] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[JsValue])(r);
"

pub ext fun HTMLAllCollection::item(__self: mut HTMLAllCollection, name_or_index: JsValue) -> Option[JsValue] = "
    const r = #var(__self).item(#var(name_or_index));
    return #fun(Option::from_js[JsValue])(r);
"

pub fun HTMLAllCollection::as_js(self: HTMLAllCollection) -> JsValue = JsValue::unsafe_from[HTMLAllCollection](self)

pub fun HTMLAllCollection::from_js(v: JsValue) -> mut HTMLAllCollection = JsValue::unsafe_as[mut HTMLAllCollection](v)

struct HTMLAnchorElement()

/// Converts a reference to 'HTMLAnchorElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::as_html_element(self: HTMLAnchorElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLAnchorElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::as_mhtml_element(self: mut HTMLAnchorElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLAnchorElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAnchorElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::from_html_element(base: HTMLElement) -> HTMLAnchorElement = "
    if(#var(base) instanceof HTMLAnchorElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAnchorElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLAnchorElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAnchorElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLAnchorElement = "
    if(#var(base) instanceof HTMLAnchorElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAnchorElement'!\");
"

/// Converts a reference to 'HTMLAnchorElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::as_element(self: HTMLAnchorElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLAnchorElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::as_melement(self: mut HTMLAnchorElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLAnchorElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAnchorElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::from_element(base: Element) -> HTMLAnchorElement = "
    if(#var(base) instanceof HTMLAnchorElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAnchorElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLAnchorElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAnchorElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAnchorElement::from_melement(base: mut Element) -> mut HTMLAnchorElement = "
    if(#var(base) instanceof HTMLAnchorElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAnchorElement'!\");
"

pub ext fun HTMLAnchorElement::target(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun HTMLAnchorElement::set_target(self: mut HTMLAnchorElement, value: String)
    = "#var(self).target = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::download(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).download);"

pub ext fun HTMLAnchorElement::set_download(self: mut HTMLAnchorElement, value: String)
    = "#var(self).download = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::ping(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).ping);"

pub ext fun HTMLAnchorElement::set_ping(self: mut HTMLAnchorElement, value: String)
    = "#var(self).ping = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::rel(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).rel);"

pub ext fun HTMLAnchorElement::set_rel(self: mut HTMLAnchorElement, value: String)
    = "#var(self).rel = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::rel_list(self: HTMLAnchorElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).relList);"

pub ext fun HTMLAnchorElement::hreflang(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).hreflang);"

pub ext fun HTMLAnchorElement::set_hreflang(self: mut HTMLAnchorElement, value: String)
    = "#var(self).hreflang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::href_translate(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).hrefTranslate);"

pub ext fun HTMLAnchorElement::set_href_translate(self: mut HTMLAnchorElement, value: String)
    = "#var(self).hrefTranslate = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::type(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLAnchorElement::set_type(self: mut HTMLAnchorElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::referrer_policy(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun HTMLAnchorElement::set_referrer_policy(self: mut HTMLAnchorElement, value: String)
    = "#var(self).referrerPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::text(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun HTMLAnchorElement::set_text(self: mut HTMLAnchorElement, value: String)
    = "#var(self).text = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::coords(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).coords);"

pub ext fun HTMLAnchorElement::set_coords(self: mut HTMLAnchorElement, value: String)
    = "#var(self).coords = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::charset(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun HTMLAnchorElement::set_charset(self: mut HTMLAnchorElement, value: String)
    = "#var(self).charset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::name(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLAnchorElement::set_name(self: mut HTMLAnchorElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::rev(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).rev);"

pub ext fun HTMLAnchorElement::set_rev(self: mut HTMLAnchorElement, value: String)
    = "#var(self).rev = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::shape(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).shape);"

pub ext fun HTMLAnchorElement::set_shape(self: mut HTMLAnchorElement, value: String)
    = "#var(self).shape = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::title(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLAnchorElement::set_title(self: mut HTMLAnchorElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::lang(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLAnchorElement::set_lang(self: mut HTMLAnchorElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::translate(self: HTMLAnchorElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLAnchorElement::set_translate(self: mut HTMLAnchorElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::dir(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLAnchorElement::set_dir(self: mut HTMLAnchorElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::hidden(self: HTMLAnchorElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLAnchorElement::set_hidden(self: mut HTMLAnchorElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLAnchorElement::inert(self: HTMLAnchorElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLAnchorElement::set_inert(self: mut HTMLAnchorElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::access_key(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLAnchorElement::set_access_key(self: mut HTMLAnchorElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::draggable(self: HTMLAnchorElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLAnchorElement::set_draggable(self: mut HTMLAnchorElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::spellcheck(self: HTMLAnchorElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLAnchorElement::set_spellcheck(self: mut HTMLAnchorElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::autocapitalize(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLAnchorElement::set_autocapitalize(self: mut HTMLAnchorElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::edit_context(self: HTMLAnchorElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLAnchorElement::set_edit_context(self: mut HTMLAnchorElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLAnchorElement::content_editable(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLAnchorElement::set_content_editable(self: mut HTMLAnchorElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::enter_key_hint(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLAnchorElement::set_enter_key_hint(self: mut HTMLAnchorElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::is_content_editable(self: HTMLAnchorElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLAnchorElement::input_mode(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLAnchorElement::set_input_mode(self: mut HTMLAnchorElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::virtual_keyboard_policy(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLAnchorElement::set_virtual_keyboard_policy(self: mut HTMLAnchorElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::scroll_parent(self: HTMLAnchorElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLAnchorElement::offset_parent(self: HTMLAnchorElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLAnchorElement::offset_top(self: HTMLAnchorElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLAnchorElement::offset_left(self: HTMLAnchorElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLAnchorElement::offset_width(self: HTMLAnchorElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLAnchorElement::offset_height(self: HTMLAnchorElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLAnchorElement::popover(self: HTMLAnchorElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLAnchorElement::set_popover(self: mut HTMLAnchorElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLAnchorElement::inner_text(self: HTMLAnchorElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLAnchorElement::set_inner_text(self: mut HTMLAnchorElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLAnchorElement::outer_text(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLAnchorElement::set_outer_text(self: mut HTMLAnchorElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::writing_suggestions(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLAnchorElement::set_writing_suggestions(self: mut HTMLAnchorElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::attribution_src(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).attributionSrc);"

pub ext fun HTMLAnchorElement::set_attribution_src(self: mut HTMLAnchorElement, value: String)
    = "#var(self).attributionSrc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::href(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun HTMLAnchorElement::set_href(self: mut HTMLAnchorElement, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::origin(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun HTMLAnchorElement::protocol(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun HTMLAnchorElement::set_protocol(self: mut HTMLAnchorElement, value: String)
    = "#var(self).protocol = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::username(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).username);"

pub ext fun HTMLAnchorElement::set_username(self: mut HTMLAnchorElement, value: String)
    = "#var(self).username = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::password(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).password);"

pub ext fun HTMLAnchorElement::set_password(self: mut HTMLAnchorElement, value: String)
    = "#var(self).password = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::host(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).host);"

pub ext fun HTMLAnchorElement::set_host(self: mut HTMLAnchorElement, value: String)
    = "#var(self).host = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::hostname(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun HTMLAnchorElement::set_hostname(self: mut HTMLAnchorElement, value: String)
    = "#var(self).hostname = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::port(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun HTMLAnchorElement::set_port(self: mut HTMLAnchorElement, value: String)
    = "#var(self).port = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::pathname(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun HTMLAnchorElement::set_pathname(self: mut HTMLAnchorElement, value: String)
    = "#var(self).pathname = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::search(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun HTMLAnchorElement::set_search(self: mut HTMLAnchorElement, value: String)
    = "#var(self).search = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::hash(self: HTMLAnchorElement) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub ext fun HTMLAnchorElement::set_hash(self: mut HTMLAnchorElement, value: String)
    = "#var(self).hash = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAnchorElement::interest_for_element(self: HTMLAnchorElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).interestForElement);"

pub ext fun HTMLAnchorElement::set_interest_for_element(self: mut HTMLAnchorElement, value: Option[mut Element])
    = "#var(self).interestForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLAnchorElement::click(__self: mut HTMLAnchorElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAnchorElement::attach_internals(__self: mut HTMLAnchorElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLAnchorElement::toggle_popover(__self: mut HTMLAnchorElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLAnchorElement::show_popover(__self: mut HTMLAnchorElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAnchorElement::hide_popover(__self: mut HTMLAnchorElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAnchorElement::start_view_transition(__self: mut HTMLAnchorElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAnchorElement::start_view_transition_f_prom_unit(__self: mut HTMLAnchorElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAnchorElement::start_view_transition_mview_transition_options(__self: mut HTMLAnchorElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLAnchorElement::as_js(self: HTMLAnchorElement) -> JsValue = JsValue::unsafe_from[HTMLAnchorElement](self)

pub fun HTMLAnchorElement::from_js(v: JsValue) -> mut HTMLAnchorElement = JsValue::unsafe_as[mut HTMLAnchorElement](v)

struct HTMLAreaElement()

/// Converts a reference to 'HTMLAreaElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::as_html_element(self: HTMLAreaElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLAreaElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::as_mhtml_element(self: mut HTMLAreaElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::from_html_element(base: HTMLElement) -> HTMLAreaElement = "
    if(#var(base) instanceof HTMLAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAreaElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLAreaElement = "
    if(#var(base) instanceof HTMLAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAreaElement'!\");
"

/// Converts a reference to 'HTMLAreaElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::as_element(self: HTMLAreaElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLAreaElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::as_melement(self: mut HTMLAreaElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::from_element(base: Element) -> HTMLAreaElement = "
    if(#var(base) instanceof HTMLAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAreaElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLAreaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAreaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAreaElement::from_melement(base: mut Element) -> mut HTMLAreaElement = "
    if(#var(base) instanceof HTMLAreaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAreaElement'!\");
"

pub ext fun HTMLAreaElement::alt(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).alt);"

pub ext fun HTMLAreaElement::set_alt(self: mut HTMLAreaElement, value: String)
    = "#var(self).alt = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::coords(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).coords);"

pub ext fun HTMLAreaElement::set_coords(self: mut HTMLAreaElement, value: String)
    = "#var(self).coords = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::download(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).download);"

pub ext fun HTMLAreaElement::set_download(self: mut HTMLAreaElement, value: String)
    = "#var(self).download = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::shape(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).shape);"

pub ext fun HTMLAreaElement::set_shape(self: mut HTMLAreaElement, value: String)
    = "#var(self).shape = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::target(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun HTMLAreaElement::set_target(self: mut HTMLAreaElement, value: String)
    = "#var(self).target = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::ping(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).ping);"

pub ext fun HTMLAreaElement::set_ping(self: mut HTMLAreaElement, value: String)
    = "#var(self).ping = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::rel(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).rel);"

pub ext fun HTMLAreaElement::set_rel(self: mut HTMLAreaElement, value: String)
    = "#var(self).rel = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::rel_list(self: HTMLAreaElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).relList);"

pub ext fun HTMLAreaElement::referrer_policy(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun HTMLAreaElement::set_referrer_policy(self: mut HTMLAreaElement, value: String)
    = "#var(self).referrerPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::no_href(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noHref);"

pub ext fun HTMLAreaElement::set_no_href(self: mut HTMLAreaElement, value: Bool)
    = "#var(self).noHref = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAreaElement::title(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLAreaElement::set_title(self: mut HTMLAreaElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::lang(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLAreaElement::set_lang(self: mut HTMLAreaElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::translate(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLAreaElement::set_translate(self: mut HTMLAreaElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAreaElement::dir(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLAreaElement::set_dir(self: mut HTMLAreaElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::hidden(self: HTMLAreaElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLAreaElement::set_hidden(self: mut HTMLAreaElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLAreaElement::inert(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLAreaElement::set_inert(self: mut HTMLAreaElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAreaElement::access_key(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLAreaElement::set_access_key(self: mut HTMLAreaElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::draggable(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLAreaElement::set_draggable(self: mut HTMLAreaElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAreaElement::spellcheck(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLAreaElement::set_spellcheck(self: mut HTMLAreaElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAreaElement::autocapitalize(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLAreaElement::set_autocapitalize(self: mut HTMLAreaElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::edit_context(self: HTMLAreaElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLAreaElement::set_edit_context(self: mut HTMLAreaElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLAreaElement::content_editable(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLAreaElement::set_content_editable(self: mut HTMLAreaElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::enter_key_hint(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLAreaElement::set_enter_key_hint(self: mut HTMLAreaElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::is_content_editable(self: HTMLAreaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLAreaElement::input_mode(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLAreaElement::set_input_mode(self: mut HTMLAreaElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::virtual_keyboard_policy(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLAreaElement::set_virtual_keyboard_policy(self: mut HTMLAreaElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::scroll_parent(self: HTMLAreaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLAreaElement::offset_parent(self: HTMLAreaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLAreaElement::offset_top(self: HTMLAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLAreaElement::offset_left(self: HTMLAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLAreaElement::offset_width(self: HTMLAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLAreaElement::offset_height(self: HTMLAreaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLAreaElement::popover(self: HTMLAreaElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLAreaElement::set_popover(self: mut HTMLAreaElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLAreaElement::inner_text(self: HTMLAreaElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLAreaElement::set_inner_text(self: mut HTMLAreaElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLAreaElement::outer_text(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLAreaElement::set_outer_text(self: mut HTMLAreaElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::writing_suggestions(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLAreaElement::set_writing_suggestions(self: mut HTMLAreaElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::attribution_src(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).attributionSrc);"

pub ext fun HTMLAreaElement::set_attribution_src(self: mut HTMLAreaElement, value: String)
    = "#var(self).attributionSrc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::href(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun HTMLAreaElement::set_href(self: mut HTMLAreaElement, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::origin(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun HTMLAreaElement::protocol(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun HTMLAreaElement::set_protocol(self: mut HTMLAreaElement, value: String)
    = "#var(self).protocol = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::username(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).username);"

pub ext fun HTMLAreaElement::set_username(self: mut HTMLAreaElement, value: String)
    = "#var(self).username = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::password(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).password);"

pub ext fun HTMLAreaElement::set_password(self: mut HTMLAreaElement, value: String)
    = "#var(self).password = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::host(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).host);"

pub ext fun HTMLAreaElement::set_host(self: mut HTMLAreaElement, value: String)
    = "#var(self).host = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::hostname(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun HTMLAreaElement::set_hostname(self: mut HTMLAreaElement, value: String)
    = "#var(self).hostname = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::port(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun HTMLAreaElement::set_port(self: mut HTMLAreaElement, value: String)
    = "#var(self).port = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::pathname(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun HTMLAreaElement::set_pathname(self: mut HTMLAreaElement, value: String)
    = "#var(self).pathname = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::search(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun HTMLAreaElement::set_search(self: mut HTMLAreaElement, value: String)
    = "#var(self).search = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::hash(self: HTMLAreaElement) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub ext fun HTMLAreaElement::set_hash(self: mut HTMLAreaElement, value: String)
    = "#var(self).hash = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAreaElement::interest_for_element(self: HTMLAreaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).interestForElement);"

pub ext fun HTMLAreaElement::set_interest_for_element(self: mut HTMLAreaElement, value: Option[mut Element])
    = "#var(self).interestForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLAreaElement::click(__self: mut HTMLAreaElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAreaElement::attach_internals(__self: mut HTMLAreaElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLAreaElement::toggle_popover(__self: mut HTMLAreaElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLAreaElement::show_popover(__self: mut HTMLAreaElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAreaElement::hide_popover(__self: mut HTMLAreaElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAreaElement::start_view_transition(__self: mut HTMLAreaElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAreaElement::start_view_transition_f_prom_unit(__self: mut HTMLAreaElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAreaElement::start_view_transition_mview_transition_options(__self: mut HTMLAreaElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLAreaElement::as_js(self: HTMLAreaElement) -> JsValue = JsValue::unsafe_from[HTMLAreaElement](self)

pub fun HTMLAreaElement::from_js(v: JsValue) -> mut HTMLAreaElement = JsValue::unsafe_as[mut HTMLAreaElement](v)

struct HTMLBaseElement()

/// Converts a reference to 'HTMLBaseElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::as_html_element(self: HTMLBaseElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLBaseElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::as_mhtml_element(self: mut HTMLBaseElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLBaseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBaseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::from_html_element(base: HTMLElement) -> HTMLBaseElement = "
    if(#var(base) instanceof HTMLBaseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBaseElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLBaseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBaseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLBaseElement = "
    if(#var(base) instanceof HTMLBaseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBaseElement'!\");
"

/// Converts a reference to 'HTMLBaseElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::as_element(self: HTMLBaseElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLBaseElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::as_melement(self: mut HTMLBaseElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLBaseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBaseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::from_element(base: Element) -> HTMLBaseElement = "
    if(#var(base) instanceof HTMLBaseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBaseElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLBaseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBaseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBaseElement::from_melement(base: mut Element) -> mut HTMLBaseElement = "
    if(#var(base) instanceof HTMLBaseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBaseElement'!\");
"

pub ext fun HTMLBaseElement::href(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun HTMLBaseElement::set_href(self: mut HTMLBaseElement, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::target(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun HTMLBaseElement::set_target(self: mut HTMLBaseElement, value: String)
    = "#var(self).target = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::title(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLBaseElement::set_title(self: mut HTMLBaseElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::lang(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLBaseElement::set_lang(self: mut HTMLBaseElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::translate(self: HTMLBaseElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLBaseElement::set_translate(self: mut HTMLBaseElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBaseElement::dir(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLBaseElement::set_dir(self: mut HTMLBaseElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::hidden(self: HTMLBaseElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLBaseElement::set_hidden(self: mut HTMLBaseElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLBaseElement::inert(self: HTMLBaseElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLBaseElement::set_inert(self: mut HTMLBaseElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBaseElement::access_key(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLBaseElement::set_access_key(self: mut HTMLBaseElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::draggable(self: HTMLBaseElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLBaseElement::set_draggable(self: mut HTMLBaseElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBaseElement::spellcheck(self: HTMLBaseElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLBaseElement::set_spellcheck(self: mut HTMLBaseElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBaseElement::autocapitalize(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLBaseElement::set_autocapitalize(self: mut HTMLBaseElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::edit_context(self: HTMLBaseElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLBaseElement::set_edit_context(self: mut HTMLBaseElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLBaseElement::content_editable(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLBaseElement::set_content_editable(self: mut HTMLBaseElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::enter_key_hint(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLBaseElement::set_enter_key_hint(self: mut HTMLBaseElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::is_content_editable(self: HTMLBaseElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLBaseElement::input_mode(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLBaseElement::set_input_mode(self: mut HTMLBaseElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::virtual_keyboard_policy(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLBaseElement::set_virtual_keyboard_policy(self: mut HTMLBaseElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::scroll_parent(self: HTMLBaseElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLBaseElement::offset_parent(self: HTMLBaseElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLBaseElement::offset_top(self: HTMLBaseElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLBaseElement::offset_left(self: HTMLBaseElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLBaseElement::offset_width(self: HTMLBaseElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLBaseElement::offset_height(self: HTMLBaseElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLBaseElement::popover(self: HTMLBaseElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLBaseElement::set_popover(self: mut HTMLBaseElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLBaseElement::inner_text(self: HTMLBaseElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLBaseElement::set_inner_text(self: mut HTMLBaseElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLBaseElement::outer_text(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLBaseElement::set_outer_text(self: mut HTMLBaseElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::writing_suggestions(self: HTMLBaseElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLBaseElement::set_writing_suggestions(self: mut HTMLBaseElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBaseElement::click(__self: mut HTMLBaseElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBaseElement::attach_internals(__self: mut HTMLBaseElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLBaseElement::toggle_popover(__self: mut HTMLBaseElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLBaseElement::show_popover(__self: mut HTMLBaseElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBaseElement::hide_popover(__self: mut HTMLBaseElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBaseElement::start_view_transition(__self: mut HTMLBaseElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBaseElement::start_view_transition_f_prom_unit(__self: mut HTMLBaseElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBaseElement::start_view_transition_mview_transition_options(__self: mut HTMLBaseElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLBaseElement::as_js(self: HTMLBaseElement) -> JsValue = JsValue::unsafe_from[HTMLBaseElement](self)

pub fun HTMLBaseElement::from_js(v: JsValue) -> mut HTMLBaseElement = JsValue::unsafe_as[mut HTMLBaseElement](v)

struct HTMLBodyElement()

/// Converts a reference to 'HTMLBodyElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::as_html_element(self: HTMLBodyElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLBodyElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::as_mhtml_element(self: mut HTMLBodyElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLBodyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBodyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::from_html_element(base: HTMLElement) -> HTMLBodyElement = "
    if(#var(base) instanceof HTMLBodyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBodyElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLBodyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBodyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLBodyElement = "
    if(#var(base) instanceof HTMLBodyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBodyElement'!\");
"

/// Converts a reference to 'HTMLBodyElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::as_element(self: HTMLBodyElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLBodyElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::as_melement(self: mut HTMLBodyElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLBodyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBodyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::from_element(base: Element) -> HTMLBodyElement = "
    if(#var(base) instanceof HTMLBodyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBodyElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLBodyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBodyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBodyElement::from_melement(base: mut Element) -> mut HTMLBodyElement = "
    if(#var(base) instanceof HTMLBodyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBodyElement'!\");
"

pub ext fun HTMLBodyElement::text(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun HTMLBodyElement::set_text(self: mut HTMLBodyElement, value: String)
    = "#var(self).text = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::link(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).link);"

pub ext fun HTMLBodyElement::set_link(self: mut HTMLBodyElement, value: String)
    = "#var(self).link = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::v_link(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).vLink);"

pub ext fun HTMLBodyElement::set_v_link(self: mut HTMLBodyElement, value: String)
    = "#var(self).vLink = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::a_link(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).aLink);"

pub ext fun HTMLBodyElement::set_a_link(self: mut HTMLBodyElement, value: String)
    = "#var(self).aLink = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::bg_color(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun HTMLBodyElement::set_bg_color(self: mut HTMLBodyElement, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::background(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).background);"

pub ext fun HTMLBodyElement::set_background(self: mut HTMLBodyElement, value: String)
    = "#var(self).background = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::onblur(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun HTMLBodyElement::set_onblur(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onerror(self: HTMLBodyElement) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun HTMLBodyElement::set_onerror(self: mut HTMLBodyElement, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onfocus(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun HTMLBodyElement::set_onfocus(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onload(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun HTMLBodyElement::set_onload(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onresize(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun HTMLBodyElement::set_onresize(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onscroll(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun HTMLBodyElement::set_onscroll(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onorientationchange(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onorientationchange);"

pub ext fun HTMLBodyElement::set_onorientationchange(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onorientationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::title(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLBodyElement::set_title(self: mut HTMLBodyElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::lang(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLBodyElement::set_lang(self: mut HTMLBodyElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::translate(self: HTMLBodyElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLBodyElement::set_translate(self: mut HTMLBodyElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBodyElement::dir(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLBodyElement::set_dir(self: mut HTMLBodyElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::hidden(self: HTMLBodyElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLBodyElement::set_hidden(self: mut HTMLBodyElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLBodyElement::inert(self: HTMLBodyElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLBodyElement::set_inert(self: mut HTMLBodyElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBodyElement::access_key(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLBodyElement::set_access_key(self: mut HTMLBodyElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::draggable(self: HTMLBodyElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLBodyElement::set_draggable(self: mut HTMLBodyElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBodyElement::spellcheck(self: HTMLBodyElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLBodyElement::set_spellcheck(self: mut HTMLBodyElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBodyElement::autocapitalize(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLBodyElement::set_autocapitalize(self: mut HTMLBodyElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::edit_context(self: HTMLBodyElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLBodyElement::set_edit_context(self: mut HTMLBodyElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLBodyElement::content_editable(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLBodyElement::set_content_editable(self: mut HTMLBodyElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::enter_key_hint(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLBodyElement::set_enter_key_hint(self: mut HTMLBodyElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::is_content_editable(self: HTMLBodyElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLBodyElement::input_mode(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLBodyElement::set_input_mode(self: mut HTMLBodyElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::virtual_keyboard_policy(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLBodyElement::set_virtual_keyboard_policy(self: mut HTMLBodyElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::scroll_parent(self: HTMLBodyElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLBodyElement::offset_parent(self: HTMLBodyElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLBodyElement::offset_top(self: HTMLBodyElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLBodyElement::offset_left(self: HTMLBodyElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLBodyElement::offset_width(self: HTMLBodyElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLBodyElement::offset_height(self: HTMLBodyElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLBodyElement::popover(self: HTMLBodyElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLBodyElement::set_popover(self: mut HTMLBodyElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLBodyElement::inner_text(self: HTMLBodyElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLBodyElement::set_inner_text(self: mut HTMLBodyElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLBodyElement::outer_text(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLBodyElement::set_outer_text(self: mut HTMLBodyElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::writing_suggestions(self: HTMLBodyElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLBodyElement::set_writing_suggestions(self: mut HTMLBodyElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBodyElement::onafterprint(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onafterprint);"

pub ext fun HTMLBodyElement::set_onafterprint(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onafterprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onbeforeprint(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeprint);"

pub ext fun HTMLBodyElement::set_onbeforeprint(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onbeforeunload(self: HTMLBodyElement) -> Option[Fun(mut Event) -> Option[String]]
    = "return #fun(Option::from_js[Fun(mut Event) -> Option[String]])(#var(self).onbeforeunload);"

pub ext fun HTMLBodyElement::set_onbeforeunload(self: mut HTMLBodyElement, value: Option[Fun(mut Event) -> Option[String]])
    = "#var(self).onbeforeunload = #fun(Option::as_js[Fun(mut Event) -> Option[String]])(#var(value));"

pub ext fun HTMLBodyElement::onhashchange(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onhashchange);"

pub ext fun HTMLBodyElement::set_onhashchange(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onhashchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onlanguagechange(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun HTMLBodyElement::set_onlanguagechange(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onmessage(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun HTMLBodyElement::set_onmessage(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onmessageerror(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessageerror);"

pub ext fun HTMLBodyElement::set_onmessageerror(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessageerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onmove(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmove);"

pub ext fun HTMLBodyElement::set_onmove(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onoffline(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoffline);"

pub ext fun HTMLBodyElement::set_onoffline(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoffline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::ononline(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ononline);"

pub ext fun HTMLBodyElement::set_ononline(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ononline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onpagehide(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpagehide);"

pub ext fun HTMLBodyElement::set_onpagehide(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpagehide = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onpageshow(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpageshow);"

pub ext fun HTMLBodyElement::set_onpageshow(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpageshow = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onpopstate(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpopstate);"

pub ext fun HTMLBodyElement::set_onpopstate(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpopstate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onrejectionhandled(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun HTMLBodyElement::set_onrejectionhandled(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onstorage(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstorage);"

pub ext fun HTMLBodyElement::set_onstorage(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstorage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::ontimezonechange(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun HTMLBodyElement::set_ontimezonechange(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onunhandledrejection(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun HTMLBodyElement::set_onunhandledrejection(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::onunload(self: HTMLBodyElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunload);"

pub ext fun HTMLBodyElement::set_onunload(self: mut HTMLBodyElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLBodyElement::click(__self: mut HTMLBodyElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBodyElement::attach_internals(__self: mut HTMLBodyElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLBodyElement::toggle_popover(__self: mut HTMLBodyElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLBodyElement::show_popover(__self: mut HTMLBodyElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBodyElement::hide_popover(__self: mut HTMLBodyElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBodyElement::start_view_transition(__self: mut HTMLBodyElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBodyElement::start_view_transition_f_prom_unit(__self: mut HTMLBodyElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBodyElement::start_view_transition_mview_transition_options(__self: mut HTMLBodyElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLBodyElement::as_js(self: HTMLBodyElement) -> JsValue = JsValue::unsafe_from[HTMLBodyElement](self)

pub fun HTMLBodyElement::from_js(v: JsValue) -> mut HTMLBodyElement = JsValue::unsafe_as[mut HTMLBodyElement](v)

struct HTMLBRElement()

/// Converts a reference to 'HTMLBRElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::as_html_element(self: HTMLBRElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLBRElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::as_mhtml_element(self: mut HTMLBRElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLBRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::from_html_element(base: HTMLElement) -> HTMLBRElement = "
    if(#var(base) instanceof HTMLBRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBRElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLBRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLBRElement = "
    if(#var(base) instanceof HTMLBRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLBRElement'!\");
"

/// Converts a reference to 'HTMLBRElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::as_element(self: HTMLBRElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLBRElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::as_melement(self: mut HTMLBRElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLBRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::from_element(base: Element) -> HTMLBRElement = "
    if(#var(base) instanceof HTMLBRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBRElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLBRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLBRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLBRElement::from_melement(base: mut Element) -> mut HTMLBRElement = "
    if(#var(base) instanceof HTMLBRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLBRElement'!\");
"

pub ext fun HTMLBRElement::clear(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).clear);"

pub ext fun HTMLBRElement::set_clear(self: mut HTMLBRElement, value: String)
    = "#var(self).clear = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::title(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLBRElement::set_title(self: mut HTMLBRElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::lang(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLBRElement::set_lang(self: mut HTMLBRElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::translate(self: HTMLBRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLBRElement::set_translate(self: mut HTMLBRElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBRElement::dir(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLBRElement::set_dir(self: mut HTMLBRElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::hidden(self: HTMLBRElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLBRElement::set_hidden(self: mut HTMLBRElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLBRElement::inert(self: HTMLBRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLBRElement::set_inert(self: mut HTMLBRElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBRElement::access_key(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLBRElement::set_access_key(self: mut HTMLBRElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::draggable(self: HTMLBRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLBRElement::set_draggable(self: mut HTMLBRElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBRElement::spellcheck(self: HTMLBRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLBRElement::set_spellcheck(self: mut HTMLBRElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLBRElement::autocapitalize(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLBRElement::set_autocapitalize(self: mut HTMLBRElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::edit_context(self: HTMLBRElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLBRElement::set_edit_context(self: mut HTMLBRElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLBRElement::content_editable(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLBRElement::set_content_editable(self: mut HTMLBRElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::enter_key_hint(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLBRElement::set_enter_key_hint(self: mut HTMLBRElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::is_content_editable(self: HTMLBRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLBRElement::input_mode(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLBRElement::set_input_mode(self: mut HTMLBRElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::virtual_keyboard_policy(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLBRElement::set_virtual_keyboard_policy(self: mut HTMLBRElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::scroll_parent(self: HTMLBRElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLBRElement::offset_parent(self: HTMLBRElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLBRElement::offset_top(self: HTMLBRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLBRElement::offset_left(self: HTMLBRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLBRElement::offset_width(self: HTMLBRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLBRElement::offset_height(self: HTMLBRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLBRElement::popover(self: HTMLBRElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLBRElement::set_popover(self: mut HTMLBRElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLBRElement::inner_text(self: HTMLBRElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLBRElement::set_inner_text(self: mut HTMLBRElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLBRElement::outer_text(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLBRElement::set_outer_text(self: mut HTMLBRElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::writing_suggestions(self: HTMLBRElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLBRElement::set_writing_suggestions(self: mut HTMLBRElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLBRElement::click(__self: mut HTMLBRElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBRElement::attach_internals(__self: mut HTMLBRElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLBRElement::toggle_popover(__self: mut HTMLBRElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLBRElement::show_popover(__self: mut HTMLBRElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBRElement::hide_popover(__self: mut HTMLBRElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLBRElement::start_view_transition(__self: mut HTMLBRElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBRElement::start_view_transition_f_prom_unit(__self: mut HTMLBRElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLBRElement::start_view_transition_mview_transition_options(__self: mut HTMLBRElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLBRElement::as_js(self: HTMLBRElement) -> JsValue = JsValue::unsafe_from[HTMLBRElement](self)

pub fun HTMLBRElement::from_js(v: JsValue) -> mut HTMLBRElement = JsValue::unsafe_as[mut HTMLBRElement](v)

struct HTMLCollection()

pub ext fun HTMLCollection::length(self: HTMLCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLCollection::item(__self: mut HTMLCollection, index: Int) -> Option[mut Element] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLCollection::named_item(__self: mut HTMLCollection, name: String) -> Option[mut Element] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut Element])(r);
"

pub fun HTMLCollection::as_js(self: HTMLCollection) -> JsValue = JsValue::unsafe_from[HTMLCollection](self)

pub fun HTMLCollection::from_js(v: JsValue) -> mut HTMLCollection = JsValue::unsafe_as[mut HTMLCollection](v)

struct HTMLDataElement()

/// Converts a reference to 'HTMLDataElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::as_html_element(self: HTMLDataElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDataElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::as_mhtml_element(self: mut HTMLDataElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::from_html_element(base: HTMLElement) -> HTMLDataElement = "
    if(#var(base) instanceof HTMLDataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDataElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDataElement = "
    if(#var(base) instanceof HTMLDataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDataElement'!\");
"

/// Converts a reference to 'HTMLDataElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::as_element(self: HTMLDataElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDataElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::as_melement(self: mut HTMLDataElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::from_element(base: Element) -> HTMLDataElement = "
    if(#var(base) instanceof HTMLDataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDataElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDataElement::from_melement(base: mut Element) -> mut HTMLDataElement = "
    if(#var(base) instanceof HTMLDataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDataElement'!\");
"

pub ext fun HTMLDataElement::value(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLDataElement::set_value(self: mut HTMLDataElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::title(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDataElement::set_title(self: mut HTMLDataElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::lang(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDataElement::set_lang(self: mut HTMLDataElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::translate(self: HTMLDataElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDataElement::set_translate(self: mut HTMLDataElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataElement::dir(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDataElement::set_dir(self: mut HTMLDataElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::hidden(self: HTMLDataElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDataElement::set_hidden(self: mut HTMLDataElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDataElement::inert(self: HTMLDataElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDataElement::set_inert(self: mut HTMLDataElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataElement::access_key(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDataElement::set_access_key(self: mut HTMLDataElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::draggable(self: HTMLDataElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDataElement::set_draggable(self: mut HTMLDataElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataElement::spellcheck(self: HTMLDataElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDataElement::set_spellcheck(self: mut HTMLDataElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDataElement::autocapitalize(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDataElement::set_autocapitalize(self: mut HTMLDataElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::edit_context(self: HTMLDataElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDataElement::set_edit_context(self: mut HTMLDataElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDataElement::content_editable(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDataElement::set_content_editable(self: mut HTMLDataElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::enter_key_hint(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDataElement::set_enter_key_hint(self: mut HTMLDataElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::is_content_editable(self: HTMLDataElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDataElement::input_mode(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDataElement::set_input_mode(self: mut HTMLDataElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::virtual_keyboard_policy(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDataElement::set_virtual_keyboard_policy(self: mut HTMLDataElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::scroll_parent(self: HTMLDataElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDataElement::offset_parent(self: HTMLDataElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDataElement::offset_top(self: HTMLDataElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDataElement::offset_left(self: HTMLDataElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDataElement::offset_width(self: HTMLDataElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDataElement::offset_height(self: HTMLDataElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDataElement::popover(self: HTMLDataElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDataElement::set_popover(self: mut HTMLDataElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDataElement::inner_text(self: HTMLDataElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDataElement::set_inner_text(self: mut HTMLDataElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDataElement::outer_text(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDataElement::set_outer_text(self: mut HTMLDataElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::writing_suggestions(self: HTMLDataElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDataElement::set_writing_suggestions(self: mut HTMLDataElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDataElement::click(__self: mut HTMLDataElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataElement::attach_internals(__self: mut HTMLDataElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDataElement::toggle_popover(__self: mut HTMLDataElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDataElement::show_popover(__self: mut HTMLDataElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataElement::hide_popover(__self: mut HTMLDataElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDataElement::start_view_transition(__self: mut HTMLDataElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDataElement::start_view_transition_f_prom_unit(__self: mut HTMLDataElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDataElement::start_view_transition_mview_transition_options(__self: mut HTMLDataElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDataElement::as_js(self: HTMLDataElement) -> JsValue = JsValue::unsafe_from[HTMLDataElement](self)

pub fun HTMLDataElement::from_js(v: JsValue) -> mut HTMLDataElement = JsValue::unsafe_as[mut HTMLDataElement](v)

struct HTMLDetailsElement()

/// Converts a reference to 'HTMLDetailsElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::as_html_element(self: HTMLDetailsElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDetailsElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::as_mhtml_element(self: mut HTMLDetailsElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDetailsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDetailsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::from_html_element(base: HTMLElement) -> HTMLDetailsElement = "
    if(#var(base) instanceof HTMLDetailsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDetailsElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDetailsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDetailsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDetailsElement = "
    if(#var(base) instanceof HTMLDetailsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDetailsElement'!\");
"

/// Converts a reference to 'HTMLDetailsElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::as_element(self: HTMLDetailsElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDetailsElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::as_melement(self: mut HTMLDetailsElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDetailsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDetailsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::from_element(base: Element) -> HTMLDetailsElement = "
    if(#var(base) instanceof HTMLDetailsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDetailsElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDetailsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDetailsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDetailsElement::from_melement(base: mut Element) -> mut HTMLDetailsElement = "
    if(#var(base) instanceof HTMLDetailsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDetailsElement'!\");
"

pub ext fun HTMLDetailsElement::open(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).open);"

pub ext fun HTMLDetailsElement::set_open(self: mut HTMLDetailsElement, value: Bool)
    = "#var(self).open = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::name(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLDetailsElement::set_name(self: mut HTMLDetailsElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::title(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDetailsElement::set_title(self: mut HTMLDetailsElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::lang(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDetailsElement::set_lang(self: mut HTMLDetailsElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::translate(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDetailsElement::set_translate(self: mut HTMLDetailsElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::dir(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDetailsElement::set_dir(self: mut HTMLDetailsElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::hidden(self: HTMLDetailsElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDetailsElement::set_hidden(self: mut HTMLDetailsElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDetailsElement::inert(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDetailsElement::set_inert(self: mut HTMLDetailsElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::access_key(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDetailsElement::set_access_key(self: mut HTMLDetailsElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::draggable(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDetailsElement::set_draggable(self: mut HTMLDetailsElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::spellcheck(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDetailsElement::set_spellcheck(self: mut HTMLDetailsElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::autocapitalize(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDetailsElement::set_autocapitalize(self: mut HTMLDetailsElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::edit_context(self: HTMLDetailsElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDetailsElement::set_edit_context(self: mut HTMLDetailsElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDetailsElement::content_editable(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDetailsElement::set_content_editable(self: mut HTMLDetailsElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::enter_key_hint(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDetailsElement::set_enter_key_hint(self: mut HTMLDetailsElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::is_content_editable(self: HTMLDetailsElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDetailsElement::input_mode(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDetailsElement::set_input_mode(self: mut HTMLDetailsElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::virtual_keyboard_policy(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDetailsElement::set_virtual_keyboard_policy(self: mut HTMLDetailsElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::scroll_parent(self: HTMLDetailsElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDetailsElement::offset_parent(self: HTMLDetailsElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDetailsElement::offset_top(self: HTMLDetailsElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDetailsElement::offset_left(self: HTMLDetailsElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDetailsElement::offset_width(self: HTMLDetailsElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDetailsElement::offset_height(self: HTMLDetailsElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDetailsElement::popover(self: HTMLDetailsElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDetailsElement::set_popover(self: mut HTMLDetailsElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDetailsElement::inner_text(self: HTMLDetailsElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDetailsElement::set_inner_text(self: mut HTMLDetailsElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDetailsElement::outer_text(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDetailsElement::set_outer_text(self: mut HTMLDetailsElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::writing_suggestions(self: HTMLDetailsElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDetailsElement::set_writing_suggestions(self: mut HTMLDetailsElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDetailsElement::click(__self: mut HTMLDetailsElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDetailsElement::attach_internals(__self: mut HTMLDetailsElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDetailsElement::toggle_popover(__self: mut HTMLDetailsElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDetailsElement::show_popover(__self: mut HTMLDetailsElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDetailsElement::hide_popover(__self: mut HTMLDetailsElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDetailsElement::start_view_transition(__self: mut HTMLDetailsElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDetailsElement::start_view_transition_f_prom_unit(__self: mut HTMLDetailsElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDetailsElement::start_view_transition_mview_transition_options(__self: mut HTMLDetailsElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDetailsElement::as_js(self: HTMLDetailsElement) -> JsValue = JsValue::unsafe_from[HTMLDetailsElement](self)

pub fun HTMLDetailsElement::from_js(v: JsValue) -> mut HTMLDetailsElement = JsValue::unsafe_as[mut HTMLDetailsElement](v)

struct HTMLDialogElement()

/// Converts a reference to 'HTMLDialogElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::as_html_element(self: HTMLDialogElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDialogElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::as_mhtml_element(self: mut HTMLDialogElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDialogElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDialogElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::from_html_element(base: HTMLElement) -> HTMLDialogElement = "
    if(#var(base) instanceof HTMLDialogElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDialogElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDialogElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDialogElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDialogElement = "
    if(#var(base) instanceof HTMLDialogElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDialogElement'!\");
"

/// Converts a reference to 'HTMLDialogElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::as_element(self: HTMLDialogElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDialogElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::as_melement(self: mut HTMLDialogElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDialogElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDialogElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::from_element(base: Element) -> HTMLDialogElement = "
    if(#var(base) instanceof HTMLDialogElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDialogElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDialogElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDialogElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDialogElement::from_melement(base: mut Element) -> mut HTMLDialogElement = "
    if(#var(base) instanceof HTMLDialogElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDialogElement'!\");
"

pub ext fun HTMLDialogElement::open(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).open);"

pub ext fun HTMLDialogElement::set_open(self: mut HTMLDialogElement, value: Bool)
    = "#var(self).open = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDialogElement::return_value(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).returnValue);"

pub ext fun HTMLDialogElement::set_return_value(self: mut HTMLDialogElement, value: String)
    = "#var(self).returnValue = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::closed_by(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).closedBy);"

pub ext fun HTMLDialogElement::set_closed_by(self: mut HTMLDialogElement, value: String)
    = "#var(self).closedBy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::title(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDialogElement::set_title(self: mut HTMLDialogElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::lang(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDialogElement::set_lang(self: mut HTMLDialogElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::translate(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDialogElement::set_translate(self: mut HTMLDialogElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDialogElement::dir(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDialogElement::set_dir(self: mut HTMLDialogElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::hidden(self: HTMLDialogElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDialogElement::set_hidden(self: mut HTMLDialogElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDialogElement::inert(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDialogElement::set_inert(self: mut HTMLDialogElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDialogElement::access_key(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDialogElement::set_access_key(self: mut HTMLDialogElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::draggable(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDialogElement::set_draggable(self: mut HTMLDialogElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDialogElement::spellcheck(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDialogElement::set_spellcheck(self: mut HTMLDialogElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDialogElement::autocapitalize(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDialogElement::set_autocapitalize(self: mut HTMLDialogElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::edit_context(self: HTMLDialogElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDialogElement::set_edit_context(self: mut HTMLDialogElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDialogElement::content_editable(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDialogElement::set_content_editable(self: mut HTMLDialogElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::enter_key_hint(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDialogElement::set_enter_key_hint(self: mut HTMLDialogElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::is_content_editable(self: HTMLDialogElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDialogElement::input_mode(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDialogElement::set_input_mode(self: mut HTMLDialogElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::virtual_keyboard_policy(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDialogElement::set_virtual_keyboard_policy(self: mut HTMLDialogElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::scroll_parent(self: HTMLDialogElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDialogElement::offset_parent(self: HTMLDialogElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDialogElement::offset_top(self: HTMLDialogElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDialogElement::offset_left(self: HTMLDialogElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDialogElement::offset_width(self: HTMLDialogElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDialogElement::offset_height(self: HTMLDialogElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDialogElement::popover(self: HTMLDialogElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDialogElement::set_popover(self: mut HTMLDialogElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDialogElement::inner_text(self: HTMLDialogElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDialogElement::set_inner_text(self: mut HTMLDialogElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDialogElement::outer_text(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDialogElement::set_outer_text(self: mut HTMLDialogElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::writing_suggestions(self: HTMLDialogElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDialogElement::set_writing_suggestions(self: mut HTMLDialogElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDialogElement::show(__self: mut HTMLDialogElement) -> Unit = "
    const r = #var(__self).show();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::show_modal(__self: mut HTMLDialogElement) -> Unit = "
    const r = #var(__self).showModal();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::close(__self: mut HTMLDialogElement, return_value: String) -> Unit = "
    const r = #var(__self).close(#fun(String::as_js)(#var(return_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::request_close(__self: mut HTMLDialogElement, return_value: String) -> Unit = "
    const r = #var(__self).requestClose(#fun(String::as_js)(#var(return_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::click(__self: mut HTMLDialogElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::attach_internals(__self: mut HTMLDialogElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDialogElement::toggle_popover(__self: mut HTMLDialogElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDialogElement::show_popover(__self: mut HTMLDialogElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::hide_popover(__self: mut HTMLDialogElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDialogElement::start_view_transition(__self: mut HTMLDialogElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDialogElement::start_view_transition_f_prom_unit(__self: mut HTMLDialogElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDialogElement::start_view_transition_mview_transition_options(__self: mut HTMLDialogElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDialogElement::as_js(self: HTMLDialogElement) -> JsValue = JsValue::unsafe_from[HTMLDialogElement](self)

pub fun HTMLDialogElement::from_js(v: JsValue) -> mut HTMLDialogElement = JsValue::unsafe_as[mut HTMLDialogElement](v)

struct HTMLDirectoryElement()

/// Converts a reference to 'HTMLDirectoryElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::as_html_element(self: HTMLDirectoryElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDirectoryElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::as_mhtml_element(self: mut HTMLDirectoryElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDirectoryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDirectoryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::from_html_element(base: HTMLElement) -> HTMLDirectoryElement = "
    if(#var(base) instanceof HTMLDirectoryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDirectoryElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDirectoryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDirectoryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDirectoryElement = "
    if(#var(base) instanceof HTMLDirectoryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDirectoryElement'!\");
"

/// Converts a reference to 'HTMLDirectoryElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::as_element(self: HTMLDirectoryElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDirectoryElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::as_melement(self: mut HTMLDirectoryElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDirectoryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDirectoryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::from_element(base: Element) -> HTMLDirectoryElement = "
    if(#var(base) instanceof HTMLDirectoryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDirectoryElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDirectoryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDirectoryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDirectoryElement::from_melement(base: mut Element) -> mut HTMLDirectoryElement = "
    if(#var(base) instanceof HTMLDirectoryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDirectoryElement'!\");
"

pub ext fun HTMLDirectoryElement::compact(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).compact);"

pub ext fun HTMLDirectoryElement::set_compact(self: mut HTMLDirectoryElement, value: Bool)
    = "#var(self).compact = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::title(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDirectoryElement::set_title(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::lang(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDirectoryElement::set_lang(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::translate(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDirectoryElement::set_translate(self: mut HTMLDirectoryElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::dir(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDirectoryElement::set_dir(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::hidden(self: HTMLDirectoryElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDirectoryElement::set_hidden(self: mut HTMLDirectoryElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDirectoryElement::inert(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDirectoryElement::set_inert(self: mut HTMLDirectoryElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::access_key(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDirectoryElement::set_access_key(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::draggable(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDirectoryElement::set_draggable(self: mut HTMLDirectoryElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::spellcheck(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDirectoryElement::set_spellcheck(self: mut HTMLDirectoryElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::autocapitalize(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDirectoryElement::set_autocapitalize(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::edit_context(self: HTMLDirectoryElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDirectoryElement::set_edit_context(self: mut HTMLDirectoryElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDirectoryElement::content_editable(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDirectoryElement::set_content_editable(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::enter_key_hint(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDirectoryElement::set_enter_key_hint(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::is_content_editable(self: HTMLDirectoryElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDirectoryElement::input_mode(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDirectoryElement::set_input_mode(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::virtual_keyboard_policy(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDirectoryElement::set_virtual_keyboard_policy(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::scroll_parent(self: HTMLDirectoryElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDirectoryElement::offset_parent(self: HTMLDirectoryElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDirectoryElement::offset_top(self: HTMLDirectoryElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDirectoryElement::offset_left(self: HTMLDirectoryElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDirectoryElement::offset_width(self: HTMLDirectoryElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDirectoryElement::offset_height(self: HTMLDirectoryElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDirectoryElement::popover(self: HTMLDirectoryElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDirectoryElement::set_popover(self: mut HTMLDirectoryElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDirectoryElement::inner_text(self: HTMLDirectoryElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDirectoryElement::set_inner_text(self: mut HTMLDirectoryElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDirectoryElement::outer_text(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDirectoryElement::set_outer_text(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::writing_suggestions(self: HTMLDirectoryElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDirectoryElement::set_writing_suggestions(self: mut HTMLDirectoryElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDirectoryElement::click(__self: mut HTMLDirectoryElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDirectoryElement::attach_internals(__self: mut HTMLDirectoryElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDirectoryElement::toggle_popover(__self: mut HTMLDirectoryElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDirectoryElement::show_popover(__self: mut HTMLDirectoryElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDirectoryElement::hide_popover(__self: mut HTMLDirectoryElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDirectoryElement::start_view_transition(__self: mut HTMLDirectoryElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDirectoryElement::start_view_transition_f_prom_unit(__self: mut HTMLDirectoryElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDirectoryElement::start_view_transition_mview_transition_options(__self: mut HTMLDirectoryElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDirectoryElement::as_js(self: HTMLDirectoryElement) -> JsValue = JsValue::unsafe_from[HTMLDirectoryElement](self)

pub fun HTMLDirectoryElement::from_js(v: JsValue) -> mut HTMLDirectoryElement = JsValue::unsafe_as[mut HTMLDirectoryElement](v)

struct HTMLDivElement()

/// Converts a reference to 'HTMLDivElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::as_html_element(self: HTMLDivElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDivElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::as_mhtml_element(self: mut HTMLDivElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDivElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDivElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::from_html_element(base: HTMLElement) -> HTMLDivElement = "
    if(#var(base) instanceof HTMLDivElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDivElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDivElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDivElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDivElement = "
    if(#var(base) instanceof HTMLDivElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDivElement'!\");
"

/// Converts a reference to 'HTMLDivElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::as_element(self: HTMLDivElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDivElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::as_melement(self: mut HTMLDivElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDivElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDivElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::from_element(base: Element) -> HTMLDivElement = "
    if(#var(base) instanceof HTMLDivElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDivElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDivElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDivElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDivElement::from_melement(base: mut Element) -> mut HTMLDivElement = "
    if(#var(base) instanceof HTMLDivElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDivElement'!\");
"

pub ext fun HTMLDivElement::align(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLDivElement::set_align(self: mut HTMLDivElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::title(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDivElement::set_title(self: mut HTMLDivElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::lang(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDivElement::set_lang(self: mut HTMLDivElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::translate(self: HTMLDivElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDivElement::set_translate(self: mut HTMLDivElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDivElement::dir(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDivElement::set_dir(self: mut HTMLDivElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::hidden(self: HTMLDivElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDivElement::set_hidden(self: mut HTMLDivElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDivElement::inert(self: HTMLDivElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDivElement::set_inert(self: mut HTMLDivElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDivElement::access_key(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDivElement::set_access_key(self: mut HTMLDivElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::draggable(self: HTMLDivElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDivElement::set_draggable(self: mut HTMLDivElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDivElement::spellcheck(self: HTMLDivElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDivElement::set_spellcheck(self: mut HTMLDivElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDivElement::autocapitalize(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDivElement::set_autocapitalize(self: mut HTMLDivElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::edit_context(self: HTMLDivElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDivElement::set_edit_context(self: mut HTMLDivElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDivElement::content_editable(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDivElement::set_content_editable(self: mut HTMLDivElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::enter_key_hint(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDivElement::set_enter_key_hint(self: mut HTMLDivElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::is_content_editable(self: HTMLDivElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDivElement::input_mode(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDivElement::set_input_mode(self: mut HTMLDivElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::virtual_keyboard_policy(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDivElement::set_virtual_keyboard_policy(self: mut HTMLDivElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::scroll_parent(self: HTMLDivElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDivElement::offset_parent(self: HTMLDivElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDivElement::offset_top(self: HTMLDivElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDivElement::offset_left(self: HTMLDivElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDivElement::offset_width(self: HTMLDivElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDivElement::offset_height(self: HTMLDivElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDivElement::popover(self: HTMLDivElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDivElement::set_popover(self: mut HTMLDivElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDivElement::inner_text(self: HTMLDivElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDivElement::set_inner_text(self: mut HTMLDivElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDivElement::outer_text(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDivElement::set_outer_text(self: mut HTMLDivElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::writing_suggestions(self: HTMLDivElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDivElement::set_writing_suggestions(self: mut HTMLDivElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDivElement::click(__self: mut HTMLDivElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDivElement::attach_internals(__self: mut HTMLDivElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDivElement::toggle_popover(__self: mut HTMLDivElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDivElement::show_popover(__self: mut HTMLDivElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDivElement::hide_popover(__self: mut HTMLDivElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDivElement::start_view_transition(__self: mut HTMLDivElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDivElement::start_view_transition_f_prom_unit(__self: mut HTMLDivElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDivElement::start_view_transition_mview_transition_options(__self: mut HTMLDivElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDivElement::as_js(self: HTMLDivElement) -> JsValue = JsValue::unsafe_from[HTMLDivElement](self)

pub fun HTMLDivElement::from_js(v: JsValue) -> mut HTMLDivElement = JsValue::unsafe_as[mut HTMLDivElement](v)

struct HTMLDListElement()

/// Converts a reference to 'HTMLDListElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::as_html_element(self: HTMLDListElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLDListElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::as_mhtml_element(self: mut HTMLDListElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLDListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::from_html_element(base: HTMLElement) -> HTMLDListElement = "
    if(#var(base) instanceof HTMLDListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDListElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLDListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLDListElement = "
    if(#var(base) instanceof HTMLDListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLDListElement'!\");
"

/// Converts a reference to 'HTMLDListElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::as_element(self: HTMLDListElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLDListElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::as_melement(self: mut HTMLDListElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLDListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::from_element(base: Element) -> HTMLDListElement = "
    if(#var(base) instanceof HTMLDListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDListElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLDListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDListElement::from_melement(base: mut Element) -> mut HTMLDListElement = "
    if(#var(base) instanceof HTMLDListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLDListElement'!\");
"

pub ext fun HTMLDListElement::compact(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).compact);"

pub ext fun HTMLDListElement::set_compact(self: mut HTMLDListElement, value: Bool)
    = "#var(self).compact = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDListElement::title(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLDListElement::set_title(self: mut HTMLDListElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::lang(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLDListElement::set_lang(self: mut HTMLDListElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::translate(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLDListElement::set_translate(self: mut HTMLDListElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDListElement::dir(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLDListElement::set_dir(self: mut HTMLDListElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::hidden(self: HTMLDListElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLDListElement::set_hidden(self: mut HTMLDListElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLDListElement::inert(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLDListElement::set_inert(self: mut HTMLDListElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDListElement::access_key(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLDListElement::set_access_key(self: mut HTMLDListElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::draggable(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLDListElement::set_draggable(self: mut HTMLDListElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDListElement::spellcheck(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLDListElement::set_spellcheck(self: mut HTMLDListElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLDListElement::autocapitalize(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLDListElement::set_autocapitalize(self: mut HTMLDListElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::edit_context(self: HTMLDListElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLDListElement::set_edit_context(self: mut HTMLDListElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLDListElement::content_editable(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLDListElement::set_content_editable(self: mut HTMLDListElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::enter_key_hint(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLDListElement::set_enter_key_hint(self: mut HTMLDListElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::is_content_editable(self: HTMLDListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLDListElement::input_mode(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLDListElement::set_input_mode(self: mut HTMLDListElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::virtual_keyboard_policy(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLDListElement::set_virtual_keyboard_policy(self: mut HTMLDListElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::scroll_parent(self: HTMLDListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLDListElement::offset_parent(self: HTMLDListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLDListElement::offset_top(self: HTMLDListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLDListElement::offset_left(self: HTMLDListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLDListElement::offset_width(self: HTMLDListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLDListElement::offset_height(self: HTMLDListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLDListElement::popover(self: HTMLDListElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLDListElement::set_popover(self: mut HTMLDListElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLDListElement::inner_text(self: HTMLDListElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLDListElement::set_inner_text(self: mut HTMLDListElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLDListElement::outer_text(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLDListElement::set_outer_text(self: mut HTMLDListElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::writing_suggestions(self: HTMLDListElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLDListElement::set_writing_suggestions(self: mut HTMLDListElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLDListElement::click(__self: mut HTMLDListElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDListElement::attach_internals(__self: mut HTMLDListElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLDListElement::toggle_popover(__self: mut HTMLDListElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLDListElement::show_popover(__self: mut HTMLDListElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDListElement::hide_popover(__self: mut HTMLDListElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLDListElement::start_view_transition(__self: mut HTMLDListElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDListElement::start_view_transition_f_prom_unit(__self: mut HTMLDListElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLDListElement::start_view_transition_mview_transition_options(__self: mut HTMLDListElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLDListElement::as_js(self: HTMLDListElement) -> JsValue = JsValue::unsafe_from[HTMLDListElement](self)

pub fun HTMLDListElement::from_js(v: JsValue) -> mut HTMLDListElement = JsValue::unsafe_as[mut HTMLDListElement](v)

struct HTMLDocument()

/// Converts a reference to 'HTMLDocument' to a reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDocument::as_document(self: HTMLDocument) -> Document = "return #var(self);"

/// Converts a mutable reference to 'HTMLDocument' to a mutable reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDocument::as_mdocument(self: mut HTMLDocument) -> mut Document = "return #var(self);"

/// Attempts to convert a reference to 'Document' to a reference to 'HTMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDocument::from_document(base: Document) -> HTMLDocument = "
    if(#var(base) instanceof HTMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'HTMLDocument'!\");
"

/// Attempts to convert a mutable reference to 'Document' to a mutable reference to 'HTMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLDocument::from_mdocument(base: mut Document) -> mut HTMLDocument = "
    if(#var(base) instanceof HTMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'HTMLDocument'!\");
"

pub ext fun HTMLDocument::create_expression(__self: mut HTMLDocument, expression: String, resolver: Option[Fun(String) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun HTMLDocument::create_ns_resolver(__self: mut HTMLDocument, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun HTMLDocument::evaluate(__self: mut HTMLDocument, expression: String, context_node: mut Node, resolver: Option[Fun(String) -> Option[String]], type: Int, in_result: Option[JsObject]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[JsObject])(#var(in_result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun HTMLDocument::as_js(self: HTMLDocument) -> JsValue = JsValue::unsafe_from[HTMLDocument](self)

pub fun HTMLDocument::from_js(v: JsValue) -> mut HTMLDocument = JsValue::unsafe_as[mut HTMLDocument](v)

struct HTMLElement()

/// Converts a reference to 'HTMLElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLElement::as_element(self: HTMLElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLElement::as_melement(self: mut HTMLElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLElement::from_element(base: Element) -> HTMLElement = "
    if(#var(base) instanceof HTMLElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLElement::from_melement(base: mut Element) -> mut HTMLElement = "
    if(#var(base) instanceof HTMLElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLElement'!\");
"

pub ext fun HTMLElement::title(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLElement::set_title(self: mut HTMLElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::lang(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLElement::set_lang(self: mut HTMLElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::translate(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLElement::set_translate(self: mut HTMLElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLElement::dir(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLElement::set_dir(self: mut HTMLElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::hidden(self: HTMLElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLElement::set_hidden(self: mut HTMLElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLElement::inert(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLElement::set_inert(self: mut HTMLElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLElement::access_key(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLElement::set_access_key(self: mut HTMLElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::draggable(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLElement::set_draggable(self: mut HTMLElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLElement::spellcheck(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLElement::set_spellcheck(self: mut HTMLElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLElement::autocapitalize(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLElement::set_autocapitalize(self: mut HTMLElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::edit_context(self: HTMLElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLElement::set_edit_context(self: mut HTMLElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLElement::content_editable(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLElement::set_content_editable(self: mut HTMLElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::enter_key_hint(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLElement::set_enter_key_hint(self: mut HTMLElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::is_content_editable(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLElement::input_mode(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLElement::set_input_mode(self: mut HTMLElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::virtual_keyboard_policy(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLElement::set_virtual_keyboard_policy(self: mut HTMLElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::scroll_parent(self: HTMLElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLElement::offset_parent(self: HTMLElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLElement::offset_top(self: HTMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLElement::offset_left(self: HTMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLElement::offset_width(self: HTMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLElement::offset_height(self: HTMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLElement::popover(self: HTMLElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLElement::set_popover(self: mut HTMLElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLElement::inner_text(self: HTMLElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLElement::set_inner_text(self: mut HTMLElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLElement::outer_text(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLElement::set_outer_text(self: mut HTMLElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::writing_suggestions(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLElement::set_writing_suggestions(self: mut HTMLElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::onabort(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun HTMLElement::set_onabort(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onbeforeinput(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeinput);"

pub ext fun HTMLElement::set_onbeforeinput(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeinput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onbeforematch(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforematch);"

pub ext fun HTMLElement::set_onbeforematch(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforematch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onbeforetoggle(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforetoggle);"

pub ext fun HTMLElement::set_onbeforetoggle(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforetoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onblur(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun HTMLElement::set_onblur(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncancel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun HTMLElement::set_oncancel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncanplay(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplay);"

pub ext fun HTMLElement::set_oncanplay(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncanplaythrough(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplaythrough);"

pub ext fun HTMLElement::set_oncanplaythrough(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplaythrough = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onchange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun HTMLElement::set_onchange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onclick(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclick);"

pub ext fun HTMLElement::set_onclick(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onclose(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun HTMLElement::set_onclose(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncommand(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncommand);"

pub ext fun HTMLElement::set_oncommand(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncommand = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncontentvisibilityautostatechange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontentvisibilityautostatechange);"

pub ext fun HTMLElement::set_oncontentvisibilityautostatechange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontentvisibilityautostatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncontextlost(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun HTMLElement::set_oncontextlost(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncontextmenu(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextmenu);"

pub ext fun HTMLElement::set_oncontextmenu(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextmenu = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncontextrestored(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun HTMLElement::set_oncontextrestored(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncuechange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun HTMLElement::set_oncuechange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondblclick(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondblclick);"

pub ext fun HTMLElement::set_ondblclick(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondblclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondrag(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrag);"

pub ext fun HTMLElement::set_ondrag(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrag = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondragend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragend);"

pub ext fun HTMLElement::set_ondragend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondragenter(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragenter);"

pub ext fun HTMLElement::set_ondragenter(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondragleave(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragleave);"

pub ext fun HTMLElement::set_ondragleave(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondragover(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragover);"

pub ext fun HTMLElement::set_ondragover(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondragstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragstart);"

pub ext fun HTMLElement::set_ondragstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondrop(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrop);"

pub ext fun HTMLElement::set_ondrop(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrop = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ondurationchange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondurationchange);"

pub ext fun HTMLElement::set_ondurationchange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondurationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onemptied(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onemptied);"

pub ext fun HTMLElement::set_onemptied(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onemptied = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onended(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onended);"

pub ext fun HTMLElement::set_onended(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onended = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onerror(self: HTMLElement) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun HTMLElement::set_onerror(self: mut HTMLElement, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onfencedtreeclick(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfencedtreeclick);"

pub ext fun HTMLElement::set_onfencedtreeclick(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfencedtreeclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onfocus(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun HTMLElement::set_onfocus(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onformdata(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onformdata);"

pub ext fun HTMLElement::set_onformdata(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onformdata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oninput(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninput);"

pub ext fun HTMLElement::set_oninput(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oninvalid(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninvalid);"

pub ext fun HTMLElement::set_oninvalid(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninvalid = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onkeydown(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeydown);"

pub ext fun HTMLElement::set_onkeydown(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeydown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onkeypress(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeypress);"

pub ext fun HTMLElement::set_onkeypress(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeypress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onkeyup(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeyup);"

pub ext fun HTMLElement::set_onkeyup(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeyup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onload(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun HTMLElement::set_onload(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onloadeddata(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadeddata);"

pub ext fun HTMLElement::set_onloadeddata(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadeddata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onloadedmetadata(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadedmetadata);"

pub ext fun HTMLElement::set_onloadedmetadata(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadedmetadata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onloadstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun HTMLElement::set_onloadstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmousedown(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousedown);"

pub ext fun HTMLElement::set_onmousedown(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousedown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmouseenter(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseenter);"

pub ext fun HTMLElement::set_onmouseenter(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmouseleave(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseleave);"

pub ext fun HTMLElement::set_onmouseleave(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmousemove(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousemove);"

pub ext fun HTMLElement::set_onmousemove(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousemove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmouseout(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseout);"

pub ext fun HTMLElement::set_onmouseout(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmouseover(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseover);"

pub ext fun HTMLElement::set_onmouseover(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmouseup(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseup);"

pub ext fun HTMLElement::set_onmouseup(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onmousewheel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousewheel);"

pub ext fun HTMLElement::set_onmousewheel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousewheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onoverscroll(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoverscroll);"

pub ext fun HTMLElement::set_onoverscroll(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoverscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpause(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpause);"

pub ext fun HTMLElement::set_onpause(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpause = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onplay(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplay);"

pub ext fun HTMLElement::set_onplay(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onplaying(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplaying);"

pub ext fun HTMLElement::set_onplaying(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplaying = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onprogress(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun HTMLElement::set_onprogress(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onratechange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onratechange);"

pub ext fun HTMLElement::set_onratechange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onratechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onreset(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreset);"

pub ext fun HTMLElement::set_onreset(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreset = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onresize(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun HTMLElement::set_onresize(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onscroll(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun HTMLElement::set_onscroll(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onscrollend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun HTMLElement::set_onscrollend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onsecuritypolicyviolation(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsecuritypolicyviolation);"

pub ext fun HTMLElement::set_onsecuritypolicyviolation(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsecuritypolicyviolation = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onseeked(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeked);"

pub ext fun HTMLElement::set_onseeked(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeked = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onseeking(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeking);"

pub ext fun HTMLElement::set_onseeking(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeking = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onselect(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselect);"

pub ext fun HTMLElement::set_onselect(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onslotchange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun HTMLElement::set_onslotchange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onscrollsnapchange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchange);"

pub ext fun HTMLElement::set_onscrollsnapchange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onscrollsnapchanging(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchanging);"

pub ext fun HTMLElement::set_onscrollsnapchanging(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchanging = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onstalled(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstalled);"

pub ext fun HTMLElement::set_onstalled(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstalled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onsubmit(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsubmit);"

pub ext fun HTMLElement::set_onsubmit(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsubmit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onsuspend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsuspend);"

pub ext fun HTMLElement::set_onsuspend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsuspend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontimeupdate(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeupdate);"

pub ext fun HTMLElement::set_ontimeupdate(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontoggle(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontoggle);"

pub ext fun HTMLElement::set_ontoggle(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onvolumechange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvolumechange);"

pub ext fun HTMLElement::set_onvolumechange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvolumechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwaiting(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwaiting);"

pub ext fun HTMLElement::set_onwaiting(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwaiting = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwebkitanimationend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationend);"

pub ext fun HTMLElement::set_onwebkitanimationend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwebkitanimationiteration(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationiteration);"

pub ext fun HTMLElement::set_onwebkitanimationiteration(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwebkitanimationstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationstart);"

pub ext fun HTMLElement::set_onwebkitanimationstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwebkittransitionend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkittransitionend);"

pub ext fun HTMLElement::set_onwebkittransitionend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkittransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onwheel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwheel);"

pub ext fun HTMLElement::set_onwheel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onauxclick(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onauxclick);"

pub ext fun HTMLElement::set_onauxclick(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onauxclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ongotpointercapture(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ongotpointercapture);"

pub ext fun HTMLElement::set_ongotpointercapture(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ongotpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onlostpointercapture(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlostpointercapture);"

pub ext fun HTMLElement::set_onlostpointercapture(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlostpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerdown(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerdown);"

pub ext fun HTMLElement::set_onpointerdown(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerdown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointermove(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointermove);"

pub ext fun HTMLElement::set_onpointermove(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointermove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerrawupdate(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerrawupdate);"

pub ext fun HTMLElement::set_onpointerrawupdate(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerrawupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerup(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerup);"

pub ext fun HTMLElement::set_onpointerup(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointercancel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointercancel);"

pub ext fun HTMLElement::set_onpointercancel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointercancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerover(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerover);"

pub ext fun HTMLElement::set_onpointerover(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerout(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerout);"

pub ext fun HTMLElement::set_onpointerout(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerenter(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerenter);"

pub ext fun HTMLElement::set_onpointerenter(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpointerleave(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerleave);"

pub ext fun HTMLElement::set_onpointerleave(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontouchcancel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchcancel);"

pub ext fun HTMLElement::set_ontouchcancel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchcancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontouchend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchend);"

pub ext fun HTMLElement::set_ontouchend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontouchmove(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchmove);"

pub ext fun HTMLElement::set_ontouchmove(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontouchstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchstart);"

pub ext fun HTMLElement::set_ontouchstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onselectstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectstart);"

pub ext fun HTMLElement::set_onselectstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onselectionchange(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectionchange);"

pub ext fun HTMLElement::set_onselectionchange(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectionchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onanimationend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationend);"

pub ext fun HTMLElement::set_onanimationend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onanimationiteration(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationiteration);"

pub ext fun HTMLElement::set_onanimationiteration(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onanimationstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationstart);"

pub ext fun HTMLElement::set_onanimationstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontransitionrun(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionrun);"

pub ext fun HTMLElement::set_ontransitionrun(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionrun = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontransitionstart(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionstart);"

pub ext fun HTMLElement::set_ontransitionstart(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontransitionend(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionend);"

pub ext fun HTMLElement::set_ontransitionend(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::ontransitioncancel(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitioncancel);"

pub ext fun HTMLElement::set_ontransitioncancel(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitioncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncopy(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncopy);"

pub ext fun HTMLElement::set_oncopy(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::oncut(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncut);"

pub ext fun HTMLElement::set_oncut(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::onpaste(self: HTMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpaste);"

pub ext fun HTMLElement::set_onpaste(self: mut HTMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLElement::dataset(self: HTMLElement) -> mut DOMStringMap
    = "return #fun(DOMStringMap::from_js)(#var(self).dataset);"

pub ext fun HTMLElement::nonce(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).nonce);"

pub ext fun HTMLElement::set_nonce(self: mut HTMLElement, value: String)
    = "#var(self).nonce = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::autofocus(self: HTMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autofocus);"

pub ext fun HTMLElement::set_autofocus(self: mut HTMLElement, value: Bool)
    = "#var(self).autofocus = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLElement::tab_index(self: HTMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).tabIndex);"

pub ext fun HTMLElement::set_tab_index(self: mut HTMLElement, value: Int)
    = "#var(self).tabIndex = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLElement::focusgroup(self: HTMLElement) -> String
    = "return #fun(String::from_js)(#var(self).focusgroup);"

pub ext fun HTMLElement::set_focusgroup(self: mut HTMLElement, value: String)
    = "#var(self).focusgroup = #fun(String::as_js)(#var(value));"

pub ext fun HTMLElement::style(self: HTMLElement) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun HTMLElement::attribute_style_map(self: HTMLElement) -> mut StylePropertyMap
    = "return #fun(StylePropertyMap::from_js)(#var(self).attributeStyleMap);"

pub ext fun HTMLElement::click(__self: mut HTMLElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLElement::attach_internals(__self: mut HTMLElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLElement::toggle_popover(__self: mut HTMLElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLElement::show_popover(__self: mut HTMLElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLElement::hide_popover(__self: mut HTMLElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLElement::start_view_transition(__self: mut HTMLElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLElement::start_view_transition_f_prom_unit(__self: mut HTMLElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLElement::start_view_transition_mview_transition_options(__self: mut HTMLElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLElement::focus(__self: mut HTMLElement, options: mut FocusOptions) -> Unit = "
    const r = #var(__self).focus(#fun(FocusOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLElement::blur(__self: mut HTMLElement) -> Unit = "
    const r = #var(__self).blur();
    return #fun(Unit::from_js)(r);
"

pub fun HTMLElement::as_js(self: HTMLElement) -> JsValue = JsValue::unsafe_from[HTMLElement](self)

pub fun HTMLElement::from_js(v: JsValue) -> mut HTMLElement = JsValue::unsafe_as[mut HTMLElement](v)

struct HTMLEmbedElement()

/// Converts a reference to 'HTMLEmbedElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::as_html_element(self: HTMLEmbedElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLEmbedElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::as_mhtml_element(self: mut HTMLEmbedElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLEmbedElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLEmbedElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::from_html_element(base: HTMLElement) -> HTMLEmbedElement = "
    if(#var(base) instanceof HTMLEmbedElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLEmbedElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLEmbedElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLEmbedElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLEmbedElement = "
    if(#var(base) instanceof HTMLEmbedElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLEmbedElement'!\");
"

/// Converts a reference to 'HTMLEmbedElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::as_element(self: HTMLEmbedElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLEmbedElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::as_melement(self: mut HTMLEmbedElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLEmbedElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLEmbedElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::from_element(base: Element) -> HTMLEmbedElement = "
    if(#var(base) instanceof HTMLEmbedElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLEmbedElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLEmbedElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLEmbedElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLEmbedElement::from_melement(base: mut Element) -> mut HTMLEmbedElement = "
    if(#var(base) instanceof HTMLEmbedElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLEmbedElement'!\");
"

pub ext fun HTMLEmbedElement::src(self: HTMLEmbedElement) -> JsValue
    = "return #var(self).src;"

pub ext fun HTMLEmbedElement::set_src(self: mut HTMLEmbedElement, value: JsValue)
    = "#var(self).src = #var(value);"

pub ext fun HTMLEmbedElement::type(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLEmbedElement::set_type(self: mut HTMLEmbedElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::width(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLEmbedElement::set_width(self: mut HTMLEmbedElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::height(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLEmbedElement::set_height(self: mut HTMLEmbedElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::align(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLEmbedElement::set_align(self: mut HTMLEmbedElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::name(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLEmbedElement::set_name(self: mut HTMLEmbedElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::title(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLEmbedElement::set_title(self: mut HTMLEmbedElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::lang(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLEmbedElement::set_lang(self: mut HTMLEmbedElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::translate(self: HTMLEmbedElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLEmbedElement::set_translate(self: mut HTMLEmbedElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::dir(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLEmbedElement::set_dir(self: mut HTMLEmbedElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::hidden(self: HTMLEmbedElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLEmbedElement::set_hidden(self: mut HTMLEmbedElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLEmbedElement::inert(self: HTMLEmbedElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLEmbedElement::set_inert(self: mut HTMLEmbedElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::access_key(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLEmbedElement::set_access_key(self: mut HTMLEmbedElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::draggable(self: HTMLEmbedElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLEmbedElement::set_draggable(self: mut HTMLEmbedElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::spellcheck(self: HTMLEmbedElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLEmbedElement::set_spellcheck(self: mut HTMLEmbedElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::autocapitalize(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLEmbedElement::set_autocapitalize(self: mut HTMLEmbedElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::edit_context(self: HTMLEmbedElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLEmbedElement::set_edit_context(self: mut HTMLEmbedElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLEmbedElement::content_editable(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLEmbedElement::set_content_editable(self: mut HTMLEmbedElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::enter_key_hint(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLEmbedElement::set_enter_key_hint(self: mut HTMLEmbedElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::is_content_editable(self: HTMLEmbedElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLEmbedElement::input_mode(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLEmbedElement::set_input_mode(self: mut HTMLEmbedElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::virtual_keyboard_policy(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLEmbedElement::set_virtual_keyboard_policy(self: mut HTMLEmbedElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::scroll_parent(self: HTMLEmbedElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLEmbedElement::offset_parent(self: HTMLEmbedElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLEmbedElement::offset_top(self: HTMLEmbedElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLEmbedElement::offset_left(self: HTMLEmbedElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLEmbedElement::offset_width(self: HTMLEmbedElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLEmbedElement::offset_height(self: HTMLEmbedElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLEmbedElement::popover(self: HTMLEmbedElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLEmbedElement::set_popover(self: mut HTMLEmbedElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLEmbedElement::inner_text(self: HTMLEmbedElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLEmbedElement::set_inner_text(self: mut HTMLEmbedElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLEmbedElement::outer_text(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLEmbedElement::set_outer_text(self: mut HTMLEmbedElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::writing_suggestions(self: HTMLEmbedElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLEmbedElement::set_writing_suggestions(self: mut HTMLEmbedElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLEmbedElement::get_svg_document(__self: mut HTMLEmbedElement) -> Option[mut Document] = "
    const r = #var(__self).getSVGDocument();
    return #fun(Option::from_js[mut Document])(r);
"

pub ext fun HTMLEmbedElement::get(__self: HTMLEmbedElement, name: String) -> JsValue = "
    const r = HTMLEmbedElement[#fun(String::as_js)(#var(name))];
    return r;
"

pub ext fun HTMLEmbedElement::set(__self: mut HTMLEmbedElement, name: String, value: JsValue) = "
    HTMLEmbedElement[#fun(String::as_js)(#var(name))] = #var(value);
"

pub ext fun HTMLEmbedElement::click(__self: mut HTMLEmbedElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLEmbedElement::attach_internals(__self: mut HTMLEmbedElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLEmbedElement::toggle_popover(__self: mut HTMLEmbedElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLEmbedElement::show_popover(__self: mut HTMLEmbedElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLEmbedElement::hide_popover(__self: mut HTMLEmbedElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLEmbedElement::start_view_transition(__self: mut HTMLEmbedElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLEmbedElement::start_view_transition_f_prom_unit(__self: mut HTMLEmbedElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLEmbedElement::start_view_transition_mview_transition_options(__self: mut HTMLEmbedElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLEmbedElement::as_js(self: HTMLEmbedElement) -> JsValue = JsValue::unsafe_from[HTMLEmbedElement](self)

pub fun HTMLEmbedElement::from_js(v: JsValue) -> mut HTMLEmbedElement = JsValue::unsafe_as[mut HTMLEmbedElement](v)

struct HTMLFontElement()

/// Converts a reference to 'HTMLFontElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::as_html_element(self: HTMLFontElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFontElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::as_mhtml_element(self: mut HTMLFontElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFontElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFontElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::from_html_element(base: HTMLElement) -> HTMLFontElement = "
    if(#var(base) instanceof HTMLFontElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFontElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFontElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFontElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFontElement = "
    if(#var(base) instanceof HTMLFontElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFontElement'!\");
"

/// Converts a reference to 'HTMLFontElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::as_element(self: HTMLFontElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFontElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::as_melement(self: mut HTMLFontElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFontElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFontElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::from_element(base: Element) -> HTMLFontElement = "
    if(#var(base) instanceof HTMLFontElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFontElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFontElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFontElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFontElement::from_melement(base: mut Element) -> mut HTMLFontElement = "
    if(#var(base) instanceof HTMLFontElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFontElement'!\");
"

pub ext fun HTMLFontElement::color(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).color);"

pub ext fun HTMLFontElement::set_color(self: mut HTMLFontElement, value: String)
    = "#var(self).color = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::face(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).face);"

pub ext fun HTMLFontElement::set_face(self: mut HTMLFontElement, value: String)
    = "#var(self).face = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::size(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).size);"

pub ext fun HTMLFontElement::set_size(self: mut HTMLFontElement, value: String)
    = "#var(self).size = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::title(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFontElement::set_title(self: mut HTMLFontElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::lang(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFontElement::set_lang(self: mut HTMLFontElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::translate(self: HTMLFontElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFontElement::set_translate(self: mut HTMLFontElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFontElement::dir(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFontElement::set_dir(self: mut HTMLFontElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::hidden(self: HTMLFontElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFontElement::set_hidden(self: mut HTMLFontElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFontElement::inert(self: HTMLFontElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFontElement::set_inert(self: mut HTMLFontElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFontElement::access_key(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFontElement::set_access_key(self: mut HTMLFontElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::draggable(self: HTMLFontElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFontElement::set_draggable(self: mut HTMLFontElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFontElement::spellcheck(self: HTMLFontElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFontElement::set_spellcheck(self: mut HTMLFontElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFontElement::autocapitalize(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFontElement::set_autocapitalize(self: mut HTMLFontElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::edit_context(self: HTMLFontElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFontElement::set_edit_context(self: mut HTMLFontElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFontElement::content_editable(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFontElement::set_content_editable(self: mut HTMLFontElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::enter_key_hint(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFontElement::set_enter_key_hint(self: mut HTMLFontElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::is_content_editable(self: HTMLFontElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFontElement::input_mode(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFontElement::set_input_mode(self: mut HTMLFontElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::virtual_keyboard_policy(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFontElement::set_virtual_keyboard_policy(self: mut HTMLFontElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::scroll_parent(self: HTMLFontElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFontElement::offset_parent(self: HTMLFontElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFontElement::offset_top(self: HTMLFontElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFontElement::offset_left(self: HTMLFontElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFontElement::offset_width(self: HTMLFontElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFontElement::offset_height(self: HTMLFontElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFontElement::popover(self: HTMLFontElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFontElement::set_popover(self: mut HTMLFontElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFontElement::inner_text(self: HTMLFontElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFontElement::set_inner_text(self: mut HTMLFontElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFontElement::outer_text(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFontElement::set_outer_text(self: mut HTMLFontElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::writing_suggestions(self: HTMLFontElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFontElement::set_writing_suggestions(self: mut HTMLFontElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFontElement::click(__self: mut HTMLFontElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFontElement::attach_internals(__self: mut HTMLFontElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFontElement::toggle_popover(__self: mut HTMLFontElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFontElement::show_popover(__self: mut HTMLFontElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFontElement::hide_popover(__self: mut HTMLFontElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFontElement::start_view_transition(__self: mut HTMLFontElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFontElement::start_view_transition_f_prom_unit(__self: mut HTMLFontElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFontElement::start_view_transition_mview_transition_options(__self: mut HTMLFontElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFontElement::as_js(self: HTMLFontElement) -> JsValue = JsValue::unsafe_from[HTMLFontElement](self)

pub fun HTMLFontElement::from_js(v: JsValue) -> mut HTMLFontElement = JsValue::unsafe_as[mut HTMLFontElement](v)

struct HTMLFrameElement()

/// Converts a reference to 'HTMLFrameElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::as_html_element(self: HTMLFrameElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFrameElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::as_mhtml_element(self: mut HTMLFrameElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::from_html_element(base: HTMLElement) -> HTMLFrameElement = "
    if(#var(base) instanceof HTMLFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFrameElement = "
    if(#var(base) instanceof HTMLFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFrameElement'!\");
"

/// Converts a reference to 'HTMLFrameElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::as_element(self: HTMLFrameElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFrameElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::as_melement(self: mut HTMLFrameElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::from_element(base: Element) -> HTMLFrameElement = "
    if(#var(base) instanceof HTMLFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameElement::from_melement(base: mut Element) -> mut HTMLFrameElement = "
    if(#var(base) instanceof HTMLFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFrameElement'!\");
"

pub ext fun HTMLFrameElement::name(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLFrameElement::set_name(self: mut HTMLFrameElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::scrolling(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).scrolling);"

pub ext fun HTMLFrameElement::set_scrolling(self: mut HTMLFrameElement, value: String)
    = "#var(self).scrolling = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::src(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLFrameElement::set_src(self: mut HTMLFrameElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::frame_border(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).frameBorder);"

pub ext fun HTMLFrameElement::set_frame_border(self: mut HTMLFrameElement, value: String)
    = "#var(self).frameBorder = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::long_desc(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).longDesc);"

pub ext fun HTMLFrameElement::set_long_desc(self: mut HTMLFrameElement, value: String)
    = "#var(self).longDesc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::no_resize(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noResize);"

pub ext fun HTMLFrameElement::set_no_resize(self: mut HTMLFrameElement, value: Bool)
    = "#var(self).noResize = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameElement::content_document(self: HTMLFrameElement) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).contentDocument);"

pub ext fun HTMLFrameElement::content_window(self: HTMLFrameElement) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).contentWindow);"

pub ext fun HTMLFrameElement::margin_height(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).marginHeight);"

pub ext fun HTMLFrameElement::set_margin_height(self: mut HTMLFrameElement, value: String)
    = "#var(self).marginHeight = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::margin_width(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).marginWidth);"

pub ext fun HTMLFrameElement::set_margin_width(self: mut HTMLFrameElement, value: String)
    = "#var(self).marginWidth = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::title(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFrameElement::set_title(self: mut HTMLFrameElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::lang(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFrameElement::set_lang(self: mut HTMLFrameElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::translate(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFrameElement::set_translate(self: mut HTMLFrameElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameElement::dir(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFrameElement::set_dir(self: mut HTMLFrameElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::hidden(self: HTMLFrameElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFrameElement::set_hidden(self: mut HTMLFrameElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFrameElement::inert(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFrameElement::set_inert(self: mut HTMLFrameElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameElement::access_key(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFrameElement::set_access_key(self: mut HTMLFrameElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::draggable(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFrameElement::set_draggable(self: mut HTMLFrameElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameElement::spellcheck(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFrameElement::set_spellcheck(self: mut HTMLFrameElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameElement::autocapitalize(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFrameElement::set_autocapitalize(self: mut HTMLFrameElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::edit_context(self: HTMLFrameElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFrameElement::set_edit_context(self: mut HTMLFrameElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFrameElement::content_editable(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFrameElement::set_content_editable(self: mut HTMLFrameElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::enter_key_hint(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFrameElement::set_enter_key_hint(self: mut HTMLFrameElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::is_content_editable(self: HTMLFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFrameElement::input_mode(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFrameElement::set_input_mode(self: mut HTMLFrameElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::virtual_keyboard_policy(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFrameElement::set_virtual_keyboard_policy(self: mut HTMLFrameElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::scroll_parent(self: HTMLFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFrameElement::offset_parent(self: HTMLFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFrameElement::offset_top(self: HTMLFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFrameElement::offset_left(self: HTMLFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFrameElement::offset_width(self: HTMLFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFrameElement::offset_height(self: HTMLFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFrameElement::popover(self: HTMLFrameElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFrameElement::set_popover(self: mut HTMLFrameElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFrameElement::inner_text(self: HTMLFrameElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFrameElement::set_inner_text(self: mut HTMLFrameElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFrameElement::outer_text(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFrameElement::set_outer_text(self: mut HTMLFrameElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::writing_suggestions(self: HTMLFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFrameElement::set_writing_suggestions(self: mut HTMLFrameElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameElement::click(__self: mut HTMLFrameElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameElement::attach_internals(__self: mut HTMLFrameElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFrameElement::toggle_popover(__self: mut HTMLFrameElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFrameElement::show_popover(__self: mut HTMLFrameElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameElement::hide_popover(__self: mut HTMLFrameElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameElement::start_view_transition(__self: mut HTMLFrameElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFrameElement::start_view_transition_f_prom_unit(__self: mut HTMLFrameElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFrameElement::start_view_transition_mview_transition_options(__self: mut HTMLFrameElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFrameElement::as_js(self: HTMLFrameElement) -> JsValue = JsValue::unsafe_from[HTMLFrameElement](self)

pub fun HTMLFrameElement::from_js(v: JsValue) -> mut HTMLFrameElement = JsValue::unsafe_as[mut HTMLFrameElement](v)

struct HTMLFrameSetElement()

/// Converts a reference to 'HTMLFrameSetElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::as_html_element(self: HTMLFrameSetElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLFrameSetElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::as_mhtml_element(self: mut HTMLFrameSetElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLFrameSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::from_html_element(base: HTMLElement) -> HTMLFrameSetElement = "
    if(#var(base) instanceof HTMLFrameSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFrameSetElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLFrameSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLFrameSetElement = "
    if(#var(base) instanceof HTMLFrameSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLFrameSetElement'!\");
"

/// Converts a reference to 'HTMLFrameSetElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::as_element(self: HTMLFrameSetElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLFrameSetElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::as_melement(self: mut HTMLFrameSetElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLFrameSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::from_element(base: Element) -> HTMLFrameSetElement = "
    if(#var(base) instanceof HTMLFrameSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFrameSetElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLFrameSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLFrameSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLFrameSetElement::from_melement(base: mut Element) -> mut HTMLFrameSetElement = "
    if(#var(base) instanceof HTMLFrameSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLFrameSetElement'!\");
"

pub ext fun HTMLFrameSetElement::cols(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).cols);"

pub ext fun HTMLFrameSetElement::set_cols(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).cols = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::rows(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).rows);"

pub ext fun HTMLFrameSetElement::set_rows(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).rows = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::onblur(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun HTMLFrameSetElement::set_onblur(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onerror(self: HTMLFrameSetElement) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun HTMLFrameSetElement::set_onerror(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onfocus(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun HTMLFrameSetElement::set_onfocus(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onload(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun HTMLFrameSetElement::set_onload(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onresize(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun HTMLFrameSetElement::set_onresize(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onscroll(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun HTMLFrameSetElement::set_onscroll(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onorientationchange(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onorientationchange);"

pub ext fun HTMLFrameSetElement::set_onorientationchange(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onorientationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::title(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLFrameSetElement::set_title(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::lang(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLFrameSetElement::set_lang(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::translate(self: HTMLFrameSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLFrameSetElement::set_translate(self: mut HTMLFrameSetElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::dir(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLFrameSetElement::set_dir(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::hidden(self: HTMLFrameSetElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLFrameSetElement::set_hidden(self: mut HTMLFrameSetElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::inert(self: HTMLFrameSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLFrameSetElement::set_inert(self: mut HTMLFrameSetElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::access_key(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLFrameSetElement::set_access_key(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::draggable(self: HTMLFrameSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLFrameSetElement::set_draggable(self: mut HTMLFrameSetElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::spellcheck(self: HTMLFrameSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLFrameSetElement::set_spellcheck(self: mut HTMLFrameSetElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::autocapitalize(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLFrameSetElement::set_autocapitalize(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::edit_context(self: HTMLFrameSetElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLFrameSetElement::set_edit_context(self: mut HTMLFrameSetElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLFrameSetElement::content_editable(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLFrameSetElement::set_content_editable(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::enter_key_hint(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLFrameSetElement::set_enter_key_hint(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::is_content_editable(self: HTMLFrameSetElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLFrameSetElement::input_mode(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLFrameSetElement::set_input_mode(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::virtual_keyboard_policy(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLFrameSetElement::set_virtual_keyboard_policy(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::scroll_parent(self: HTMLFrameSetElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLFrameSetElement::offset_parent(self: HTMLFrameSetElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLFrameSetElement::offset_top(self: HTMLFrameSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLFrameSetElement::offset_left(self: HTMLFrameSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLFrameSetElement::offset_width(self: HTMLFrameSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLFrameSetElement::offset_height(self: HTMLFrameSetElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLFrameSetElement::popover(self: HTMLFrameSetElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLFrameSetElement::set_popover(self: mut HTMLFrameSetElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLFrameSetElement::inner_text(self: HTMLFrameSetElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLFrameSetElement::set_inner_text(self: mut HTMLFrameSetElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLFrameSetElement::outer_text(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLFrameSetElement::set_outer_text(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::writing_suggestions(self: HTMLFrameSetElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLFrameSetElement::set_writing_suggestions(self: mut HTMLFrameSetElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLFrameSetElement::onafterprint(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onafterprint);"

pub ext fun HTMLFrameSetElement::set_onafterprint(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onafterprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onbeforeprint(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeprint);"

pub ext fun HTMLFrameSetElement::set_onbeforeprint(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeprint = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onbeforeunload(self: HTMLFrameSetElement) -> Option[Fun(mut Event) -> Option[String]]
    = "return #fun(Option::from_js[Fun(mut Event) -> Option[String]])(#var(self).onbeforeunload);"

pub ext fun HTMLFrameSetElement::set_onbeforeunload(self: mut HTMLFrameSetElement, value: Option[Fun(mut Event) -> Option[String]])
    = "#var(self).onbeforeunload = #fun(Option::as_js[Fun(mut Event) -> Option[String]])(#var(value));"

pub ext fun HTMLFrameSetElement::onhashchange(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onhashchange);"

pub ext fun HTMLFrameSetElement::set_onhashchange(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onhashchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onlanguagechange(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun HTMLFrameSetElement::set_onlanguagechange(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onmessage(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun HTMLFrameSetElement::set_onmessage(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onmessageerror(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessageerror);"

pub ext fun HTMLFrameSetElement::set_onmessageerror(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessageerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onmove(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmove);"

pub ext fun HTMLFrameSetElement::set_onmove(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onoffline(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoffline);"

pub ext fun HTMLFrameSetElement::set_onoffline(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoffline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::ononline(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ononline);"

pub ext fun HTMLFrameSetElement::set_ononline(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ononline = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onpagehide(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpagehide);"

pub ext fun HTMLFrameSetElement::set_onpagehide(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpagehide = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onpageshow(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpageshow);"

pub ext fun HTMLFrameSetElement::set_onpageshow(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpageshow = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onpopstate(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpopstate);"

pub ext fun HTMLFrameSetElement::set_onpopstate(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpopstate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onrejectionhandled(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun HTMLFrameSetElement::set_onrejectionhandled(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onstorage(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstorage);"

pub ext fun HTMLFrameSetElement::set_onstorage(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstorage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::ontimezonechange(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun HTMLFrameSetElement::set_ontimezonechange(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onunhandledrejection(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun HTMLFrameSetElement::set_onunhandledrejection(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::onunload(self: HTMLFrameSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunload);"

pub ext fun HTMLFrameSetElement::set_onunload(self: mut HTMLFrameSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLFrameSetElement::click(__self: mut HTMLFrameSetElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameSetElement::attach_internals(__self: mut HTMLFrameSetElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLFrameSetElement::toggle_popover(__self: mut HTMLFrameSetElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLFrameSetElement::show_popover(__self: mut HTMLFrameSetElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameSetElement::hide_popover(__self: mut HTMLFrameSetElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLFrameSetElement::start_view_transition(__self: mut HTMLFrameSetElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFrameSetElement::start_view_transition_f_prom_unit(__self: mut HTMLFrameSetElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLFrameSetElement::start_view_transition_mview_transition_options(__self: mut HTMLFrameSetElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLFrameSetElement::as_js(self: HTMLFrameSetElement) -> JsValue = JsValue::unsafe_from[HTMLFrameSetElement](self)

pub fun HTMLFrameSetElement::from_js(v: JsValue) -> mut HTMLFrameSetElement = JsValue::unsafe_as[mut HTMLFrameSetElement](v)

struct HTMLHeadElement()

/// Converts a reference to 'HTMLHeadElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::as_html_element(self: HTMLHeadElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLHeadElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::as_mhtml_element(self: mut HTMLHeadElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLHeadElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::from_html_element(base: HTMLElement) -> HTMLHeadElement = "
    if(#var(base) instanceof HTMLHeadElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHeadElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLHeadElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLHeadElement = "
    if(#var(base) instanceof HTMLHeadElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHeadElement'!\");
"

/// Converts a reference to 'HTMLHeadElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::as_element(self: HTMLHeadElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLHeadElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::as_melement(self: mut HTMLHeadElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLHeadElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::from_element(base: Element) -> HTMLHeadElement = "
    if(#var(base) instanceof HTMLHeadElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHeadElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLHeadElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadElement::from_melement(base: mut Element) -> mut HTMLHeadElement = "
    if(#var(base) instanceof HTMLHeadElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHeadElement'!\");
"

pub ext fun HTMLHeadElement::title(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLHeadElement::set_title(self: mut HTMLHeadElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::lang(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLHeadElement::set_lang(self: mut HTMLHeadElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::translate(self: HTMLHeadElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLHeadElement::set_translate(self: mut HTMLHeadElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadElement::dir(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLHeadElement::set_dir(self: mut HTMLHeadElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::hidden(self: HTMLHeadElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLHeadElement::set_hidden(self: mut HTMLHeadElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLHeadElement::inert(self: HTMLHeadElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLHeadElement::set_inert(self: mut HTMLHeadElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadElement::access_key(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLHeadElement::set_access_key(self: mut HTMLHeadElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::draggable(self: HTMLHeadElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLHeadElement::set_draggable(self: mut HTMLHeadElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadElement::spellcheck(self: HTMLHeadElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLHeadElement::set_spellcheck(self: mut HTMLHeadElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadElement::autocapitalize(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLHeadElement::set_autocapitalize(self: mut HTMLHeadElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::edit_context(self: HTMLHeadElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLHeadElement::set_edit_context(self: mut HTMLHeadElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLHeadElement::content_editable(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLHeadElement::set_content_editable(self: mut HTMLHeadElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::enter_key_hint(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLHeadElement::set_enter_key_hint(self: mut HTMLHeadElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::is_content_editable(self: HTMLHeadElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLHeadElement::input_mode(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLHeadElement::set_input_mode(self: mut HTMLHeadElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::virtual_keyboard_policy(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLHeadElement::set_virtual_keyboard_policy(self: mut HTMLHeadElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::scroll_parent(self: HTMLHeadElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLHeadElement::offset_parent(self: HTMLHeadElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLHeadElement::offset_top(self: HTMLHeadElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLHeadElement::offset_left(self: HTMLHeadElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLHeadElement::offset_width(self: HTMLHeadElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLHeadElement::offset_height(self: HTMLHeadElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLHeadElement::popover(self: HTMLHeadElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLHeadElement::set_popover(self: mut HTMLHeadElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLHeadElement::inner_text(self: HTMLHeadElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLHeadElement::set_inner_text(self: mut HTMLHeadElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLHeadElement::outer_text(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLHeadElement::set_outer_text(self: mut HTMLHeadElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::writing_suggestions(self: HTMLHeadElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLHeadElement::set_writing_suggestions(self: mut HTMLHeadElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadElement::click(__self: mut HTMLHeadElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadElement::attach_internals(__self: mut HTMLHeadElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLHeadElement::toggle_popover(__self: mut HTMLHeadElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLHeadElement::show_popover(__self: mut HTMLHeadElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadElement::hide_popover(__self: mut HTMLHeadElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadElement::start_view_transition(__self: mut HTMLHeadElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHeadElement::start_view_transition_f_prom_unit(__self: mut HTMLHeadElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHeadElement::start_view_transition_mview_transition_options(__self: mut HTMLHeadElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLHeadElement::as_js(self: HTMLHeadElement) -> JsValue = JsValue::unsafe_from[HTMLHeadElement](self)

pub fun HTMLHeadElement::from_js(v: JsValue) -> mut HTMLHeadElement = JsValue::unsafe_as[mut HTMLHeadElement](v)

struct HTMLHeadingElement()

/// Converts a reference to 'HTMLHeadingElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::as_html_element(self: HTMLHeadingElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLHeadingElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::as_mhtml_element(self: mut HTMLHeadingElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLHeadingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::from_html_element(base: HTMLElement) -> HTMLHeadingElement = "
    if(#var(base) instanceof HTMLHeadingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHeadingElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLHeadingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLHeadingElement = "
    if(#var(base) instanceof HTMLHeadingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHeadingElement'!\");
"

/// Converts a reference to 'HTMLHeadingElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::as_element(self: HTMLHeadingElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLHeadingElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::as_melement(self: mut HTMLHeadingElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLHeadingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::from_element(base: Element) -> HTMLHeadingElement = "
    if(#var(base) instanceof HTMLHeadingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHeadingElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLHeadingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHeadingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHeadingElement::from_melement(base: mut Element) -> mut HTMLHeadingElement = "
    if(#var(base) instanceof HTMLHeadingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHeadingElement'!\");
"

pub ext fun HTMLHeadingElement::align(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLHeadingElement::set_align(self: mut HTMLHeadingElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::title(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLHeadingElement::set_title(self: mut HTMLHeadingElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::lang(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLHeadingElement::set_lang(self: mut HTMLHeadingElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::translate(self: HTMLHeadingElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLHeadingElement::set_translate(self: mut HTMLHeadingElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::dir(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLHeadingElement::set_dir(self: mut HTMLHeadingElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::hidden(self: HTMLHeadingElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLHeadingElement::set_hidden(self: mut HTMLHeadingElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLHeadingElement::inert(self: HTMLHeadingElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLHeadingElement::set_inert(self: mut HTMLHeadingElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::access_key(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLHeadingElement::set_access_key(self: mut HTMLHeadingElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::draggable(self: HTMLHeadingElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLHeadingElement::set_draggable(self: mut HTMLHeadingElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::spellcheck(self: HTMLHeadingElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLHeadingElement::set_spellcheck(self: mut HTMLHeadingElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::autocapitalize(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLHeadingElement::set_autocapitalize(self: mut HTMLHeadingElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::edit_context(self: HTMLHeadingElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLHeadingElement::set_edit_context(self: mut HTMLHeadingElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLHeadingElement::content_editable(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLHeadingElement::set_content_editable(self: mut HTMLHeadingElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::enter_key_hint(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLHeadingElement::set_enter_key_hint(self: mut HTMLHeadingElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::is_content_editable(self: HTMLHeadingElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLHeadingElement::input_mode(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLHeadingElement::set_input_mode(self: mut HTMLHeadingElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::virtual_keyboard_policy(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLHeadingElement::set_virtual_keyboard_policy(self: mut HTMLHeadingElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::scroll_parent(self: HTMLHeadingElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLHeadingElement::offset_parent(self: HTMLHeadingElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLHeadingElement::offset_top(self: HTMLHeadingElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLHeadingElement::offset_left(self: HTMLHeadingElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLHeadingElement::offset_width(self: HTMLHeadingElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLHeadingElement::offset_height(self: HTMLHeadingElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLHeadingElement::popover(self: HTMLHeadingElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLHeadingElement::set_popover(self: mut HTMLHeadingElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLHeadingElement::inner_text(self: HTMLHeadingElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLHeadingElement::set_inner_text(self: mut HTMLHeadingElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLHeadingElement::outer_text(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLHeadingElement::set_outer_text(self: mut HTMLHeadingElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::writing_suggestions(self: HTMLHeadingElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLHeadingElement::set_writing_suggestions(self: mut HTMLHeadingElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHeadingElement::click(__self: mut HTMLHeadingElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadingElement::attach_internals(__self: mut HTMLHeadingElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLHeadingElement::toggle_popover(__self: mut HTMLHeadingElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLHeadingElement::show_popover(__self: mut HTMLHeadingElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadingElement::hide_popover(__self: mut HTMLHeadingElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHeadingElement::start_view_transition(__self: mut HTMLHeadingElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHeadingElement::start_view_transition_f_prom_unit(__self: mut HTMLHeadingElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHeadingElement::start_view_transition_mview_transition_options(__self: mut HTMLHeadingElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLHeadingElement::as_js(self: HTMLHeadingElement) -> JsValue = JsValue::unsafe_from[HTMLHeadingElement](self)

pub fun HTMLHeadingElement::from_js(v: JsValue) -> mut HTMLHeadingElement = JsValue::unsafe_as[mut HTMLHeadingElement](v)

struct HTMLHRElement()

/// Converts a reference to 'HTMLHRElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::as_html_element(self: HTMLHRElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLHRElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::as_mhtml_element(self: mut HTMLHRElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLHRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::from_html_element(base: HTMLElement) -> HTMLHRElement = "
    if(#var(base) instanceof HTMLHRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHRElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLHRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLHRElement = "
    if(#var(base) instanceof HTMLHRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHRElement'!\");
"

/// Converts a reference to 'HTMLHRElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::as_element(self: HTMLHRElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLHRElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::as_melement(self: mut HTMLHRElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLHRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::from_element(base: Element) -> HTMLHRElement = "
    if(#var(base) instanceof HTMLHRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHRElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLHRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHRElement::from_melement(base: mut Element) -> mut HTMLHRElement = "
    if(#var(base) instanceof HTMLHRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHRElement'!\");
"

pub ext fun HTMLHRElement::align(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLHRElement::set_align(self: mut HTMLHRElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::color(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).color);"

pub ext fun HTMLHRElement::set_color(self: mut HTMLHRElement, value: String)
    = "#var(self).color = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::no_shade(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noShade);"

pub ext fun HTMLHRElement::set_no_shade(self: mut HTMLHRElement, value: Bool)
    = "#var(self).noShade = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHRElement::size(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).size);"

pub ext fun HTMLHRElement::set_size(self: mut HTMLHRElement, value: String)
    = "#var(self).size = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::width(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLHRElement::set_width(self: mut HTMLHRElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::title(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLHRElement::set_title(self: mut HTMLHRElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::lang(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLHRElement::set_lang(self: mut HTMLHRElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::translate(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLHRElement::set_translate(self: mut HTMLHRElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHRElement::dir(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLHRElement::set_dir(self: mut HTMLHRElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::hidden(self: HTMLHRElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLHRElement::set_hidden(self: mut HTMLHRElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLHRElement::inert(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLHRElement::set_inert(self: mut HTMLHRElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHRElement::access_key(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLHRElement::set_access_key(self: mut HTMLHRElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::draggable(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLHRElement::set_draggable(self: mut HTMLHRElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHRElement::spellcheck(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLHRElement::set_spellcheck(self: mut HTMLHRElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHRElement::autocapitalize(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLHRElement::set_autocapitalize(self: mut HTMLHRElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::edit_context(self: HTMLHRElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLHRElement::set_edit_context(self: mut HTMLHRElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLHRElement::content_editable(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLHRElement::set_content_editable(self: mut HTMLHRElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::enter_key_hint(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLHRElement::set_enter_key_hint(self: mut HTMLHRElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::is_content_editable(self: HTMLHRElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLHRElement::input_mode(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLHRElement::set_input_mode(self: mut HTMLHRElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::virtual_keyboard_policy(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLHRElement::set_virtual_keyboard_policy(self: mut HTMLHRElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::scroll_parent(self: HTMLHRElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLHRElement::offset_parent(self: HTMLHRElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLHRElement::offset_top(self: HTMLHRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLHRElement::offset_left(self: HTMLHRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLHRElement::offset_width(self: HTMLHRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLHRElement::offset_height(self: HTMLHRElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLHRElement::popover(self: HTMLHRElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLHRElement::set_popover(self: mut HTMLHRElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLHRElement::inner_text(self: HTMLHRElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLHRElement::set_inner_text(self: mut HTMLHRElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLHRElement::outer_text(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLHRElement::set_outer_text(self: mut HTMLHRElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::writing_suggestions(self: HTMLHRElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLHRElement::set_writing_suggestions(self: mut HTMLHRElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHRElement::click(__self: mut HTMLHRElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHRElement::attach_internals(__self: mut HTMLHRElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLHRElement::toggle_popover(__self: mut HTMLHRElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLHRElement::show_popover(__self: mut HTMLHRElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHRElement::hide_popover(__self: mut HTMLHRElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHRElement::start_view_transition(__self: mut HTMLHRElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHRElement::start_view_transition_f_prom_unit(__self: mut HTMLHRElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHRElement::start_view_transition_mview_transition_options(__self: mut HTMLHRElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLHRElement::as_js(self: HTMLHRElement) -> JsValue = JsValue::unsafe_from[HTMLHRElement](self)

pub fun HTMLHRElement::from_js(v: JsValue) -> mut HTMLHRElement = JsValue::unsafe_as[mut HTMLHRElement](v)

struct HTMLHtmlElement()

/// Converts a reference to 'HTMLHtmlElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::as_html_element(self: HTMLHtmlElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLHtmlElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::as_mhtml_element(self: mut HTMLHtmlElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLHtmlElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHtmlElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::from_html_element(base: HTMLElement) -> HTMLHtmlElement = "
    if(#var(base) instanceof HTMLHtmlElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHtmlElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLHtmlElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHtmlElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLHtmlElement = "
    if(#var(base) instanceof HTMLHtmlElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLHtmlElement'!\");
"

/// Converts a reference to 'HTMLHtmlElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::as_element(self: HTMLHtmlElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLHtmlElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::as_melement(self: mut HTMLHtmlElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLHtmlElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHtmlElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::from_element(base: Element) -> HTMLHtmlElement = "
    if(#var(base) instanceof HTMLHtmlElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHtmlElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLHtmlElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLHtmlElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLHtmlElement::from_melement(base: mut Element) -> mut HTMLHtmlElement = "
    if(#var(base) instanceof HTMLHtmlElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLHtmlElement'!\");
"

pub ext fun HTMLHtmlElement::version(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).version);"

pub ext fun HTMLHtmlElement::set_version(self: mut HTMLHtmlElement, value: String)
    = "#var(self).version = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::title(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLHtmlElement::set_title(self: mut HTMLHtmlElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::lang(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLHtmlElement::set_lang(self: mut HTMLHtmlElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::translate(self: HTMLHtmlElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLHtmlElement::set_translate(self: mut HTMLHtmlElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::dir(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLHtmlElement::set_dir(self: mut HTMLHtmlElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::hidden(self: HTMLHtmlElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLHtmlElement::set_hidden(self: mut HTMLHtmlElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLHtmlElement::inert(self: HTMLHtmlElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLHtmlElement::set_inert(self: mut HTMLHtmlElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::access_key(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLHtmlElement::set_access_key(self: mut HTMLHtmlElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::draggable(self: HTMLHtmlElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLHtmlElement::set_draggable(self: mut HTMLHtmlElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::spellcheck(self: HTMLHtmlElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLHtmlElement::set_spellcheck(self: mut HTMLHtmlElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::autocapitalize(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLHtmlElement::set_autocapitalize(self: mut HTMLHtmlElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::edit_context(self: HTMLHtmlElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLHtmlElement::set_edit_context(self: mut HTMLHtmlElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLHtmlElement::content_editable(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLHtmlElement::set_content_editable(self: mut HTMLHtmlElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::enter_key_hint(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLHtmlElement::set_enter_key_hint(self: mut HTMLHtmlElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::is_content_editable(self: HTMLHtmlElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLHtmlElement::input_mode(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLHtmlElement::set_input_mode(self: mut HTMLHtmlElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::virtual_keyboard_policy(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLHtmlElement::set_virtual_keyboard_policy(self: mut HTMLHtmlElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::scroll_parent(self: HTMLHtmlElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLHtmlElement::offset_parent(self: HTMLHtmlElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLHtmlElement::offset_top(self: HTMLHtmlElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLHtmlElement::offset_left(self: HTMLHtmlElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLHtmlElement::offset_width(self: HTMLHtmlElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLHtmlElement::offset_height(self: HTMLHtmlElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLHtmlElement::popover(self: HTMLHtmlElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLHtmlElement::set_popover(self: mut HTMLHtmlElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLHtmlElement::inner_text(self: HTMLHtmlElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLHtmlElement::set_inner_text(self: mut HTMLHtmlElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLHtmlElement::outer_text(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLHtmlElement::set_outer_text(self: mut HTMLHtmlElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::writing_suggestions(self: HTMLHtmlElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLHtmlElement::set_writing_suggestions(self: mut HTMLHtmlElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLHtmlElement::click(__self: mut HTMLHtmlElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHtmlElement::attach_internals(__self: mut HTMLHtmlElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLHtmlElement::toggle_popover(__self: mut HTMLHtmlElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLHtmlElement::show_popover(__self: mut HTMLHtmlElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHtmlElement::hide_popover(__self: mut HTMLHtmlElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLHtmlElement::start_view_transition(__self: mut HTMLHtmlElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHtmlElement::start_view_transition_f_prom_unit(__self: mut HTMLHtmlElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLHtmlElement::start_view_transition_mview_transition_options(__self: mut HTMLHtmlElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLHtmlElement::as_js(self: HTMLHtmlElement) -> JsValue = JsValue::unsafe_from[HTMLHtmlElement](self)

pub fun HTMLHtmlElement::from_js(v: JsValue) -> mut HTMLHtmlElement = JsValue::unsafe_as[mut HTMLHtmlElement](v)

struct HTMLIFrameElement()

/// Converts a reference to 'HTMLIFrameElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::as_html_element(self: HTMLIFrameElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLIFrameElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::as_mhtml_element(self: mut HTMLIFrameElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLIFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLIFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::from_html_element(base: HTMLElement) -> HTMLIFrameElement = "
    if(#var(base) instanceof HTMLIFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLIFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLIFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLIFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLIFrameElement = "
    if(#var(base) instanceof HTMLIFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLIFrameElement'!\");
"

/// Converts a reference to 'HTMLIFrameElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::as_element(self: HTMLIFrameElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLIFrameElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::as_melement(self: mut HTMLIFrameElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLIFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLIFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::from_element(base: Element) -> HTMLIFrameElement = "
    if(#var(base) instanceof HTMLIFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLIFrameElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLIFrameElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLIFrameElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLIFrameElement::from_melement(base: mut Element) -> mut HTMLIFrameElement = "
    if(#var(base) instanceof HTMLIFrameElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLIFrameElement'!\");
"

pub ext fun HTMLIFrameElement::src(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLIFrameElement::set_src(self: mut HTMLIFrameElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::srcdoc(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).srcdoc);"

pub ext fun HTMLIFrameElement::set_srcdoc(self: mut HTMLIFrameElement, value: String)
    = "#var(self).srcdoc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::name(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLIFrameElement::set_name(self: mut HTMLIFrameElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::sandbox(self: HTMLIFrameElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).sandbox);"

pub ext fun HTMLIFrameElement::allow_fullscreen(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).allowFullscreen);"

pub ext fun HTMLIFrameElement::set_allow_fullscreen(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).allowFullscreen = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::width(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLIFrameElement::set_width(self: mut HTMLIFrameElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::height(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLIFrameElement::set_height(self: mut HTMLIFrameElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::content_document(self: HTMLIFrameElement) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).contentDocument);"

pub ext fun HTMLIFrameElement::content_window(self: HTMLIFrameElement) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).contentWindow);"

pub ext fun HTMLIFrameElement::referrer_policy(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun HTMLIFrameElement::set_referrer_policy(self: mut HTMLIFrameElement, value: String)
    = "#var(self).referrerPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::csp(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).csp);"

pub ext fun HTMLIFrameElement::set_csp(self: mut HTMLIFrameElement, value: String)
    = "#var(self).csp = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::allow(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).allow);"

pub ext fun HTMLIFrameElement::set_allow(self: mut HTMLIFrameElement, value: String)
    = "#var(self).allow = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::feature_policy(self: HTMLIFrameElement) -> mut FeaturePolicy
    = "return #fun(FeaturePolicy::from_js)(#var(self).featurePolicy);"

pub ext fun HTMLIFrameElement::policy(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).policy);"

pub ext fun HTMLIFrameElement::set_policy(self: mut HTMLIFrameElement, value: String)
    = "#var(self).policy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::loading(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).loading);"

pub ext fun HTMLIFrameElement::set_loading(self: mut HTMLIFrameElement, value: String)
    = "#var(self).loading = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::private_token(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).privateToken);"

pub ext fun HTMLIFrameElement::set_private_token(self: mut HTMLIFrameElement, value: String)
    = "#var(self).privateToken = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::browsing_topics(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).browsingTopics);"

pub ext fun HTMLIFrameElement::set_browsing_topics(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).browsingTopics = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::ad_auction_headers(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).adAuctionHeaders);"

pub ext fun HTMLIFrameElement::set_ad_auction_headers(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).adAuctionHeaders = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::credentialless(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).credentialless);"

pub ext fun HTMLIFrameElement::set_credentialless(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).credentialless = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::align(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLIFrameElement::set_align(self: mut HTMLIFrameElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::scrolling(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).scrolling);"

pub ext fun HTMLIFrameElement::set_scrolling(self: mut HTMLIFrameElement, value: String)
    = "#var(self).scrolling = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::frame_border(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).frameBorder);"

pub ext fun HTMLIFrameElement::set_frame_border(self: mut HTMLIFrameElement, value: String)
    = "#var(self).frameBorder = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::long_desc(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).longDesc);"

pub ext fun HTMLIFrameElement::set_long_desc(self: mut HTMLIFrameElement, value: String)
    = "#var(self).longDesc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::margin_height(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).marginHeight);"

pub ext fun HTMLIFrameElement::set_margin_height(self: mut HTMLIFrameElement, value: String)
    = "#var(self).marginHeight = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::margin_width(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).marginWidth);"

pub ext fun HTMLIFrameElement::set_margin_width(self: mut HTMLIFrameElement, value: String)
    = "#var(self).marginWidth = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::title(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLIFrameElement::set_title(self: mut HTMLIFrameElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::lang(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLIFrameElement::set_lang(self: mut HTMLIFrameElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::translate(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLIFrameElement::set_translate(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::dir(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLIFrameElement::set_dir(self: mut HTMLIFrameElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::hidden(self: HTMLIFrameElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLIFrameElement::set_hidden(self: mut HTMLIFrameElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLIFrameElement::inert(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLIFrameElement::set_inert(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::access_key(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLIFrameElement::set_access_key(self: mut HTMLIFrameElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::draggable(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLIFrameElement::set_draggable(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::spellcheck(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLIFrameElement::set_spellcheck(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::autocapitalize(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLIFrameElement::set_autocapitalize(self: mut HTMLIFrameElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::edit_context(self: HTMLIFrameElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLIFrameElement::set_edit_context(self: mut HTMLIFrameElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLIFrameElement::content_editable(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLIFrameElement::set_content_editable(self: mut HTMLIFrameElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::enter_key_hint(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLIFrameElement::set_enter_key_hint(self: mut HTMLIFrameElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::is_content_editable(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLIFrameElement::input_mode(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLIFrameElement::set_input_mode(self: mut HTMLIFrameElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::virtual_keyboard_policy(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLIFrameElement::set_virtual_keyboard_policy(self: mut HTMLIFrameElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::scroll_parent(self: HTMLIFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLIFrameElement::offset_parent(self: HTMLIFrameElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLIFrameElement::offset_top(self: HTMLIFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLIFrameElement::offset_left(self: HTMLIFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLIFrameElement::offset_width(self: HTMLIFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLIFrameElement::offset_height(self: HTMLIFrameElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLIFrameElement::popover(self: HTMLIFrameElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLIFrameElement::set_popover(self: mut HTMLIFrameElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLIFrameElement::inner_text(self: HTMLIFrameElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLIFrameElement::set_inner_text(self: mut HTMLIFrameElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLIFrameElement::outer_text(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLIFrameElement::set_outer_text(self: mut HTMLIFrameElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::writing_suggestions(self: HTMLIFrameElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLIFrameElement::set_writing_suggestions(self: mut HTMLIFrameElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::shared_storage_writable(self: HTMLIFrameElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).sharedStorageWritable);"

pub ext fun HTMLIFrameElement::set_shared_storage_writable(self: mut HTMLIFrameElement, value: Bool)
    = "#var(self).sharedStorageWritable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLIFrameElement::get_svg_document(__self: mut HTMLIFrameElement) -> Option[mut Document] = "
    const r = #var(__self).getSVGDocument();
    return #fun(Option::from_js[mut Document])(r);
"

pub ext fun HTMLIFrameElement::click(__self: mut HTMLIFrameElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLIFrameElement::attach_internals(__self: mut HTMLIFrameElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLIFrameElement::toggle_popover(__self: mut HTMLIFrameElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLIFrameElement::show_popover(__self: mut HTMLIFrameElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLIFrameElement::hide_popover(__self: mut HTMLIFrameElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLIFrameElement::start_view_transition(__self: mut HTMLIFrameElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLIFrameElement::start_view_transition_f_prom_unit(__self: mut HTMLIFrameElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLIFrameElement::start_view_transition_mview_transition_options(__self: mut HTMLIFrameElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLIFrameElement::as_js(self: HTMLIFrameElement) -> JsValue = JsValue::unsafe_from[HTMLIFrameElement](self)

pub fun HTMLIFrameElement::from_js(v: JsValue) -> mut HTMLIFrameElement = JsValue::unsafe_as[mut HTMLIFrameElement](v)

struct HTMLImageElement()

/// Converts a reference to 'HTMLImageElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::as_html_element(self: HTMLImageElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLImageElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::as_mhtml_element(self: mut HTMLImageElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::from_html_element(base: HTMLElement) -> HTMLImageElement = "
    if(#var(base) instanceof HTMLImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLImageElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLImageElement = "
    if(#var(base) instanceof HTMLImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLImageElement'!\");
"

/// Converts a reference to 'HTMLImageElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::as_element(self: HTMLImageElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLImageElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::as_melement(self: mut HTMLImageElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::from_element(base: Element) -> HTMLImageElement = "
    if(#var(base) instanceof HTMLImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLImageElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLImageElement::from_melement(base: mut Element) -> mut HTMLImageElement = "
    if(#var(base) instanceof HTMLImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLImageElement'!\");
"

pub ext fun HTMLImageElement::new() -> mut HTMLImageElement
    = "return new HTMLImageElement();"

pub ext fun HTMLImageElement::alt(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).alt);"

pub ext fun HTMLImageElement::set_alt(self: mut HTMLImageElement, value: String)
    = "#var(self).alt = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::src(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLImageElement::set_src(self: mut HTMLImageElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::srcset(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).srcset);"

pub ext fun HTMLImageElement::set_srcset(self: mut HTMLImageElement, value: String)
    = "#var(self).srcset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::sizes(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).sizes);"

pub ext fun HTMLImageElement::set_sizes(self: mut HTMLImageElement, value: String)
    = "#var(self).sizes = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::cross_origin(self: HTMLImageElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLImageElement::set_cross_origin(self: mut HTMLImageElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLImageElement::use_map(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).useMap);"

pub ext fun HTMLImageElement::set_use_map(self: mut HTMLImageElement, value: String)
    = "#var(self).useMap = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::is_map(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isMap);"

pub ext fun HTMLImageElement::set_is_map(self: mut HTMLImageElement, value: Bool)
    = "#var(self).isMap = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::width(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLImageElement::set_width(self: mut HTMLImageElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLImageElement::height(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun HTMLImageElement::set_height(self: mut HTMLImageElement, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLImageElement::natural_width(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).naturalWidth);"

pub ext fun HTMLImageElement::natural_height(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).naturalHeight);"

pub ext fun HTMLImageElement::complete(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).complete);"

pub ext fun HTMLImageElement::current_src(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).currentSrc);"

pub ext fun HTMLImageElement::referrer_policy(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun HTMLImageElement::set_referrer_policy(self: mut HTMLImageElement, value: String)
    = "#var(self).referrerPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::decoding(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).decoding);"

pub ext fun HTMLImageElement::set_decoding(self: mut HTMLImageElement, value: String)
    = "#var(self).decoding = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::fetch_priority(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).fetchPriority);"

pub ext fun HTMLImageElement::set_fetch_priority(self: mut HTMLImageElement, value: String)
    = "#var(self).fetchPriority = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::loading(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).loading);"

pub ext fun HTMLImageElement::set_loading(self: mut HTMLImageElement, value: String)
    = "#var(self).loading = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::name(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLImageElement::set_name(self: mut HTMLImageElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::lowsrc(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).lowsrc);"

pub ext fun HTMLImageElement::set_lowsrc(self: mut HTMLImageElement, value: String)
    = "#var(self).lowsrc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::align(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLImageElement::set_align(self: mut HTMLImageElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::hspace(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).hspace);"

pub ext fun HTMLImageElement::set_hspace(self: mut HTMLImageElement, value: Int)
    = "#var(self).hspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLImageElement::vspace(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).vspace);"

pub ext fun HTMLImageElement::set_vspace(self: mut HTMLImageElement, value: Int)
    = "#var(self).vspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLImageElement::long_desc(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).longDesc);"

pub ext fun HTMLImageElement::set_long_desc(self: mut HTMLImageElement, value: String)
    = "#var(self).longDesc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::border(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).border);"

pub ext fun HTMLImageElement::set_border(self: mut HTMLImageElement, value: String)
    = "#var(self).border = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::x(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).x);"

pub ext fun HTMLImageElement::y(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).y);"

pub ext fun HTMLImageElement::browsing_topics(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).browsingTopics);"

pub ext fun HTMLImageElement::set_browsing_topics(self: mut HTMLImageElement, value: Bool)
    = "#var(self).browsingTopics = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::title(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLImageElement::set_title(self: mut HTMLImageElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::lang(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLImageElement::set_lang(self: mut HTMLImageElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::translate(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLImageElement::set_translate(self: mut HTMLImageElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::dir(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLImageElement::set_dir(self: mut HTMLImageElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::hidden(self: HTMLImageElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLImageElement::set_hidden(self: mut HTMLImageElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLImageElement::inert(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLImageElement::set_inert(self: mut HTMLImageElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::access_key(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLImageElement::set_access_key(self: mut HTMLImageElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::draggable(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLImageElement::set_draggable(self: mut HTMLImageElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::spellcheck(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLImageElement::set_spellcheck(self: mut HTMLImageElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::autocapitalize(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLImageElement::set_autocapitalize(self: mut HTMLImageElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::edit_context(self: HTMLImageElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLImageElement::set_edit_context(self: mut HTMLImageElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLImageElement::content_editable(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLImageElement::set_content_editable(self: mut HTMLImageElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::enter_key_hint(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLImageElement::set_enter_key_hint(self: mut HTMLImageElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::is_content_editable(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLImageElement::input_mode(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLImageElement::set_input_mode(self: mut HTMLImageElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::virtual_keyboard_policy(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLImageElement::set_virtual_keyboard_policy(self: mut HTMLImageElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::scroll_parent(self: HTMLImageElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLImageElement::offset_parent(self: HTMLImageElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLImageElement::offset_top(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLImageElement::offset_left(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLImageElement::offset_width(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLImageElement::offset_height(self: HTMLImageElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLImageElement::popover(self: HTMLImageElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLImageElement::set_popover(self: mut HTMLImageElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLImageElement::inner_text(self: HTMLImageElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLImageElement::set_inner_text(self: mut HTMLImageElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLImageElement::outer_text(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLImageElement::set_outer_text(self: mut HTMLImageElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::writing_suggestions(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLImageElement::set_writing_suggestions(self: mut HTMLImageElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::attribution_src(self: HTMLImageElement) -> String
    = "return #fun(String::from_js)(#var(self).attributionSrc);"

pub ext fun HTMLImageElement::set_attribution_src(self: mut HTMLImageElement, value: String)
    = "#var(self).attributionSrc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLImageElement::shared_storage_writable(self: HTMLImageElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).sharedStorageWritable);"

pub ext fun HTMLImageElement::set_shared_storage_writable(self: mut HTMLImageElement, value: Bool)
    = "#var(self).sharedStorageWritable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLImageElement::decode(__self: mut HTMLImageElement) -> Promise[Unit] = "
    const r = #var(__self).decode();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun HTMLImageElement::click(__self: mut HTMLImageElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLImageElement::attach_internals(__self: mut HTMLImageElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLImageElement::toggle_popover(__self: mut HTMLImageElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLImageElement::show_popover(__self: mut HTMLImageElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLImageElement::hide_popover(__self: mut HTMLImageElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLImageElement::start_view_transition(__self: mut HTMLImageElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLImageElement::start_view_transition_f_prom_unit(__self: mut HTMLImageElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLImageElement::start_view_transition_mview_transition_options(__self: mut HTMLImageElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLImageElement::as_js(self: HTMLImageElement) -> JsValue = JsValue::unsafe_from[HTMLImageElement](self)

pub fun HTMLImageElement::from_js(v: JsValue) -> mut HTMLImageElement = JsValue::unsafe_as[mut HTMLImageElement](v)

struct HTMLLIElement()

/// Converts a reference to 'HTMLLIElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::as_html_element(self: HTMLLIElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLLIElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::as_mhtml_element(self: mut HTMLLIElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLLIElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLIElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::from_html_element(base: HTMLElement) -> HTMLLIElement = "
    if(#var(base) instanceof HTMLLIElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLIElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLLIElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLIElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLLIElement = "
    if(#var(base) instanceof HTMLLIElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLIElement'!\");
"

/// Converts a reference to 'HTMLLIElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::as_element(self: HTMLLIElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLLIElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::as_melement(self: mut HTMLLIElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLLIElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLIElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::from_element(base: Element) -> HTMLLIElement = "
    if(#var(base) instanceof HTMLLIElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLIElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLLIElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLIElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLIElement::from_melement(base: mut Element) -> mut HTMLLIElement = "
    if(#var(base) instanceof HTMLLIElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLIElement'!\");
"

pub ext fun HTMLLIElement::value(self: HTMLLIElement) -> Int
    = "return #fun(Int::from_js)(#var(self).value);"

pub ext fun HTMLLIElement::set_value(self: mut HTMLLIElement, value: Int)
    = "#var(self).value = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLLIElement::type(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLLIElement::set_type(self: mut HTMLLIElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::title(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLLIElement::set_title(self: mut HTMLLIElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::lang(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLLIElement::set_lang(self: mut HTMLLIElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::translate(self: HTMLLIElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLLIElement::set_translate(self: mut HTMLLIElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLIElement::dir(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLLIElement::set_dir(self: mut HTMLLIElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::hidden(self: HTMLLIElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLLIElement::set_hidden(self: mut HTMLLIElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLLIElement::inert(self: HTMLLIElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLLIElement::set_inert(self: mut HTMLLIElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLIElement::access_key(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLLIElement::set_access_key(self: mut HTMLLIElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::draggable(self: HTMLLIElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLLIElement::set_draggable(self: mut HTMLLIElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLIElement::spellcheck(self: HTMLLIElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLLIElement::set_spellcheck(self: mut HTMLLIElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLIElement::autocapitalize(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLLIElement::set_autocapitalize(self: mut HTMLLIElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::edit_context(self: HTMLLIElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLLIElement::set_edit_context(self: mut HTMLLIElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLLIElement::content_editable(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLLIElement::set_content_editable(self: mut HTMLLIElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::enter_key_hint(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLLIElement::set_enter_key_hint(self: mut HTMLLIElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::is_content_editable(self: HTMLLIElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLLIElement::input_mode(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLLIElement::set_input_mode(self: mut HTMLLIElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::virtual_keyboard_policy(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLLIElement::set_virtual_keyboard_policy(self: mut HTMLLIElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::scroll_parent(self: HTMLLIElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLLIElement::offset_parent(self: HTMLLIElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLLIElement::offset_top(self: HTMLLIElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLLIElement::offset_left(self: HTMLLIElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLLIElement::offset_width(self: HTMLLIElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLLIElement::offset_height(self: HTMLLIElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLLIElement::popover(self: HTMLLIElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLLIElement::set_popover(self: mut HTMLLIElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLLIElement::inner_text(self: HTMLLIElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLLIElement::set_inner_text(self: mut HTMLLIElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLLIElement::outer_text(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLLIElement::set_outer_text(self: mut HTMLLIElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::writing_suggestions(self: HTMLLIElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLLIElement::set_writing_suggestions(self: mut HTMLLIElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLIElement::click(__self: mut HTMLLIElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLIElement::attach_internals(__self: mut HTMLLIElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLLIElement::toggle_popover(__self: mut HTMLLIElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLLIElement::show_popover(__self: mut HTMLLIElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLIElement::hide_popover(__self: mut HTMLLIElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLIElement::start_view_transition(__self: mut HTMLLIElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLIElement::start_view_transition_f_prom_unit(__self: mut HTMLLIElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLIElement::start_view_transition_mview_transition_options(__self: mut HTMLLIElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLLIElement::as_js(self: HTMLLIElement) -> JsValue = JsValue::unsafe_from[HTMLLIElement](self)

pub fun HTMLLIElement::from_js(v: JsValue) -> mut HTMLLIElement = JsValue::unsafe_as[mut HTMLLIElement](v)

struct HTMLLinkElement()

/// Converts a reference to 'HTMLLinkElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::as_html_element(self: HTMLLinkElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLLinkElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::as_mhtml_element(self: mut HTMLLinkElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLLinkElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLinkElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::from_html_element(base: HTMLElement) -> HTMLLinkElement = "
    if(#var(base) instanceof HTMLLinkElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLinkElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLLinkElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLinkElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLLinkElement = "
    if(#var(base) instanceof HTMLLinkElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLLinkElement'!\");
"

/// Converts a reference to 'HTMLLinkElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::as_element(self: HTMLLinkElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLLinkElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::as_melement(self: mut HTMLLinkElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLLinkElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLinkElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::from_element(base: Element) -> HTMLLinkElement = "
    if(#var(base) instanceof HTMLLinkElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLinkElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLLinkElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLLinkElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLLinkElement::from_melement(base: mut Element) -> mut HTMLLinkElement = "
    if(#var(base) instanceof HTMLLinkElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLLinkElement'!\");
"

pub ext fun HTMLLinkElement::disabled(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLLinkElement::set_disabled(self: mut HTMLLinkElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLinkElement::href(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun HTMLLinkElement::set_href(self: mut HTMLLinkElement, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::cross_origin(self: HTMLLinkElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLLinkElement::set_cross_origin(self: mut HTMLLinkElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLLinkElement::rel(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).rel);"

pub ext fun HTMLLinkElement::set_rel(self: mut HTMLLinkElement, value: String)
    = "#var(self).rel = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::rel_list(self: HTMLLinkElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).relList);"

pub ext fun HTMLLinkElement::media(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun HTMLLinkElement::set_media(self: mut HTMLLinkElement, value: String)
    = "#var(self).media = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::hreflang(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).hreflang);"

pub ext fun HTMLLinkElement::set_hreflang(self: mut HTMLLinkElement, value: String)
    = "#var(self).hreflang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::type(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLLinkElement::set_type(self: mut HTMLLinkElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::as_(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).as);"

pub ext fun HTMLLinkElement::set_as_(self: mut HTMLLinkElement, value: String)
    = "#var(self).as = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::referrer_policy(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).referrerPolicy);"

pub ext fun HTMLLinkElement::set_referrer_policy(self: mut HTMLLinkElement, value: String)
    = "#var(self).referrerPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::sizes(self: HTMLLinkElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).sizes);"

pub ext fun HTMLLinkElement::fetch_priority(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).fetchPriority);"

pub ext fun HTMLLinkElement::set_fetch_priority(self: mut HTMLLinkElement, value: String)
    = "#var(self).fetchPriority = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::image_srcset(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).imageSrcset);"

pub ext fun HTMLLinkElement::set_image_srcset(self: mut HTMLLinkElement, value: String)
    = "#var(self).imageSrcset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::image_sizes(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).imageSizes);"

pub ext fun HTMLLinkElement::set_image_sizes(self: mut HTMLLinkElement, value: String)
    = "#var(self).imageSizes = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::charset(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun HTMLLinkElement::set_charset(self: mut HTMLLinkElement, value: String)
    = "#var(self).charset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::rev(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).rev);"

pub ext fun HTMLLinkElement::set_rev(self: mut HTMLLinkElement, value: String)
    = "#var(self).rev = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::target(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun HTMLLinkElement::set_target(self: mut HTMLLinkElement, value: String)
    = "#var(self).target = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::sheet(self: HTMLLinkElement) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).sheet);"

pub ext fun HTMLLinkElement::integrity(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).integrity);"

pub ext fun HTMLLinkElement::set_integrity(self: mut HTMLLinkElement, value: String)
    = "#var(self).integrity = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::blocking(self: HTMLLinkElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).blocking);"

pub ext fun HTMLLinkElement::title(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLLinkElement::set_title(self: mut HTMLLinkElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::lang(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLLinkElement::set_lang(self: mut HTMLLinkElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::translate(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLLinkElement::set_translate(self: mut HTMLLinkElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLinkElement::dir(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLLinkElement::set_dir(self: mut HTMLLinkElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::hidden(self: HTMLLinkElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLLinkElement::set_hidden(self: mut HTMLLinkElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLLinkElement::inert(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLLinkElement::set_inert(self: mut HTMLLinkElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLinkElement::access_key(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLLinkElement::set_access_key(self: mut HTMLLinkElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::draggable(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLLinkElement::set_draggable(self: mut HTMLLinkElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLinkElement::spellcheck(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLLinkElement::set_spellcheck(self: mut HTMLLinkElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLLinkElement::autocapitalize(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLLinkElement::set_autocapitalize(self: mut HTMLLinkElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::edit_context(self: HTMLLinkElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLLinkElement::set_edit_context(self: mut HTMLLinkElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLLinkElement::content_editable(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLLinkElement::set_content_editable(self: mut HTMLLinkElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::enter_key_hint(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLLinkElement::set_enter_key_hint(self: mut HTMLLinkElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::is_content_editable(self: HTMLLinkElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLLinkElement::input_mode(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLLinkElement::set_input_mode(self: mut HTMLLinkElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::virtual_keyboard_policy(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLLinkElement::set_virtual_keyboard_policy(self: mut HTMLLinkElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::scroll_parent(self: HTMLLinkElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLLinkElement::offset_parent(self: HTMLLinkElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLLinkElement::offset_top(self: HTMLLinkElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLLinkElement::offset_left(self: HTMLLinkElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLLinkElement::offset_width(self: HTMLLinkElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLLinkElement::offset_height(self: HTMLLinkElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLLinkElement::popover(self: HTMLLinkElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLLinkElement::set_popover(self: mut HTMLLinkElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLLinkElement::inner_text(self: HTMLLinkElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLLinkElement::set_inner_text(self: mut HTMLLinkElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLLinkElement::outer_text(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLLinkElement::set_outer_text(self: mut HTMLLinkElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::writing_suggestions(self: HTMLLinkElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLLinkElement::set_writing_suggestions(self: mut HTMLLinkElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLLinkElement::click(__self: mut HTMLLinkElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLinkElement::attach_internals(__self: mut HTMLLinkElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLLinkElement::toggle_popover(__self: mut HTMLLinkElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLLinkElement::show_popover(__self: mut HTMLLinkElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLinkElement::hide_popover(__self: mut HTMLLinkElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLLinkElement::start_view_transition(__self: mut HTMLLinkElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLinkElement::start_view_transition_f_prom_unit(__self: mut HTMLLinkElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLLinkElement::start_view_transition_mview_transition_options(__self: mut HTMLLinkElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLLinkElement::as_js(self: HTMLLinkElement) -> JsValue = JsValue::unsafe_from[HTMLLinkElement](self)

pub fun HTMLLinkElement::from_js(v: JsValue) -> mut HTMLLinkElement = JsValue::unsafe_as[mut HTMLLinkElement](v)

struct HTMLMapElement()

/// Converts a reference to 'HTMLMapElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::as_html_element(self: HTMLMapElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMapElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::as_mhtml_element(self: mut HTMLMapElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::from_html_element(base: HTMLElement) -> HTMLMapElement = "
    if(#var(base) instanceof HTMLMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMapElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMapElement = "
    if(#var(base) instanceof HTMLMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMapElement'!\");
"

/// Converts a reference to 'HTMLMapElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::as_element(self: HTMLMapElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMapElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::as_melement(self: mut HTMLMapElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::from_element(base: Element) -> HTMLMapElement = "
    if(#var(base) instanceof HTMLMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMapElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMapElement::from_melement(base: mut Element) -> mut HTMLMapElement = "
    if(#var(base) instanceof HTMLMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMapElement'!\");
"

pub ext fun HTMLMapElement::name(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLMapElement::set_name(self: mut HTMLMapElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::areas(self: HTMLMapElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).areas);"

pub ext fun HTMLMapElement::title(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMapElement::set_title(self: mut HTMLMapElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::lang(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMapElement::set_lang(self: mut HTMLMapElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::translate(self: HTMLMapElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMapElement::set_translate(self: mut HTMLMapElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMapElement::dir(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMapElement::set_dir(self: mut HTMLMapElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::hidden(self: HTMLMapElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMapElement::set_hidden(self: mut HTMLMapElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMapElement::inert(self: HTMLMapElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMapElement::set_inert(self: mut HTMLMapElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMapElement::access_key(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMapElement::set_access_key(self: mut HTMLMapElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::draggable(self: HTMLMapElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMapElement::set_draggable(self: mut HTMLMapElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMapElement::spellcheck(self: HTMLMapElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMapElement::set_spellcheck(self: mut HTMLMapElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMapElement::autocapitalize(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMapElement::set_autocapitalize(self: mut HTMLMapElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::edit_context(self: HTMLMapElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMapElement::set_edit_context(self: mut HTMLMapElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMapElement::content_editable(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMapElement::set_content_editable(self: mut HTMLMapElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::enter_key_hint(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMapElement::set_enter_key_hint(self: mut HTMLMapElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::is_content_editable(self: HTMLMapElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMapElement::input_mode(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMapElement::set_input_mode(self: mut HTMLMapElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::virtual_keyboard_policy(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMapElement::set_virtual_keyboard_policy(self: mut HTMLMapElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::scroll_parent(self: HTMLMapElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMapElement::offset_parent(self: HTMLMapElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMapElement::offset_top(self: HTMLMapElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMapElement::offset_left(self: HTMLMapElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMapElement::offset_width(self: HTMLMapElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMapElement::offset_height(self: HTMLMapElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMapElement::popover(self: HTMLMapElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMapElement::set_popover(self: mut HTMLMapElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMapElement::inner_text(self: HTMLMapElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMapElement::set_inner_text(self: mut HTMLMapElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMapElement::outer_text(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMapElement::set_outer_text(self: mut HTMLMapElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::writing_suggestions(self: HTMLMapElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMapElement::set_writing_suggestions(self: mut HTMLMapElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMapElement::click(__self: mut HTMLMapElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMapElement::attach_internals(__self: mut HTMLMapElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMapElement::toggle_popover(__self: mut HTMLMapElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMapElement::show_popover(__self: mut HTMLMapElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMapElement::hide_popover(__self: mut HTMLMapElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMapElement::start_view_transition(__self: mut HTMLMapElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMapElement::start_view_transition_f_prom_unit(__self: mut HTMLMapElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMapElement::start_view_transition_mview_transition_options(__self: mut HTMLMapElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMapElement::as_js(self: HTMLMapElement) -> JsValue = JsValue::unsafe_from[HTMLMapElement](self)

pub fun HTMLMapElement::from_js(v: JsValue) -> mut HTMLMapElement = JsValue::unsafe_as[mut HTMLMapElement](v)

struct HTMLMarqueeElement()

/// Converts a reference to 'HTMLMarqueeElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::as_html_element(self: HTMLMarqueeElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMarqueeElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::as_mhtml_element(self: mut HTMLMarqueeElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMarqueeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMarqueeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::from_html_element(base: HTMLElement) -> HTMLMarqueeElement = "
    if(#var(base) instanceof HTMLMarqueeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMarqueeElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMarqueeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMarqueeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMarqueeElement = "
    if(#var(base) instanceof HTMLMarqueeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMarqueeElement'!\");
"

/// Converts a reference to 'HTMLMarqueeElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::as_element(self: HTMLMarqueeElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMarqueeElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::as_melement(self: mut HTMLMarqueeElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMarqueeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMarqueeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::from_element(base: Element) -> HTMLMarqueeElement = "
    if(#var(base) instanceof HTMLMarqueeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMarqueeElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMarqueeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMarqueeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMarqueeElement::from_melement(base: mut Element) -> mut HTMLMarqueeElement = "
    if(#var(base) instanceof HTMLMarqueeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMarqueeElement'!\");
"

pub ext fun HTMLMarqueeElement::behavior(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).behavior);"

pub ext fun HTMLMarqueeElement::set_behavior(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).behavior = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::bg_color(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun HTMLMarqueeElement::set_bg_color(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::direction(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).direction);"

pub ext fun HTMLMarqueeElement::set_direction(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).direction = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::height(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLMarqueeElement::set_height(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::hspace(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).hspace);"

pub ext fun HTMLMarqueeElement::set_hspace(self: mut HTMLMarqueeElement, value: Int)
    = "#var(self).hspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::loop(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).loop);"

pub ext fun HTMLMarqueeElement::set_loop(self: mut HTMLMarqueeElement, value: Int)
    = "#var(self).loop = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::scroll_amount(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).scrollAmount);"

pub ext fun HTMLMarqueeElement::set_scroll_amount(self: mut HTMLMarqueeElement, value: Int)
    = "#var(self).scrollAmount = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::scroll_delay(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).scrollDelay);"

pub ext fun HTMLMarqueeElement::set_scroll_delay(self: mut HTMLMarqueeElement, value: Int)
    = "#var(self).scrollDelay = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::true_speed(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).trueSpeed);"

pub ext fun HTMLMarqueeElement::set_true_speed(self: mut HTMLMarqueeElement, value: Bool)
    = "#var(self).trueSpeed = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::vspace(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).vspace);"

pub ext fun HTMLMarqueeElement::set_vspace(self: mut HTMLMarqueeElement, value: Int)
    = "#var(self).vspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::width(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLMarqueeElement::set_width(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::title(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMarqueeElement::set_title(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::lang(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMarqueeElement::set_lang(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::translate(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMarqueeElement::set_translate(self: mut HTMLMarqueeElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::dir(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMarqueeElement::set_dir(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::hidden(self: HTMLMarqueeElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMarqueeElement::set_hidden(self: mut HTMLMarqueeElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMarqueeElement::inert(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMarqueeElement::set_inert(self: mut HTMLMarqueeElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::access_key(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMarqueeElement::set_access_key(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::draggable(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMarqueeElement::set_draggable(self: mut HTMLMarqueeElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::spellcheck(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMarqueeElement::set_spellcheck(self: mut HTMLMarqueeElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::autocapitalize(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMarqueeElement::set_autocapitalize(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::edit_context(self: HTMLMarqueeElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMarqueeElement::set_edit_context(self: mut HTMLMarqueeElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMarqueeElement::content_editable(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMarqueeElement::set_content_editable(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::enter_key_hint(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMarqueeElement::set_enter_key_hint(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::is_content_editable(self: HTMLMarqueeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMarqueeElement::input_mode(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMarqueeElement::set_input_mode(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::virtual_keyboard_policy(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMarqueeElement::set_virtual_keyboard_policy(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::scroll_parent(self: HTMLMarqueeElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMarqueeElement::offset_parent(self: HTMLMarqueeElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMarqueeElement::offset_top(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMarqueeElement::offset_left(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMarqueeElement::offset_width(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMarqueeElement::offset_height(self: HTMLMarqueeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMarqueeElement::popover(self: HTMLMarqueeElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMarqueeElement::set_popover(self: mut HTMLMarqueeElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMarqueeElement::inner_text(self: HTMLMarqueeElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMarqueeElement::set_inner_text(self: mut HTMLMarqueeElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMarqueeElement::outer_text(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMarqueeElement::set_outer_text(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::writing_suggestions(self: HTMLMarqueeElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMarqueeElement::set_writing_suggestions(self: mut HTMLMarqueeElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMarqueeElement::start(__self: mut HTMLMarqueeElement) -> Unit = "
    const r = #var(__self).start();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMarqueeElement::stop(__self: mut HTMLMarqueeElement) -> Unit = "
    const r = #var(__self).stop();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMarqueeElement::click(__self: mut HTMLMarqueeElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMarqueeElement::attach_internals(__self: mut HTMLMarqueeElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMarqueeElement::toggle_popover(__self: mut HTMLMarqueeElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMarqueeElement::show_popover(__self: mut HTMLMarqueeElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMarqueeElement::hide_popover(__self: mut HTMLMarqueeElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMarqueeElement::start_view_transition(__self: mut HTMLMarqueeElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMarqueeElement::start_view_transition_f_prom_unit(__self: mut HTMLMarqueeElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMarqueeElement::start_view_transition_mview_transition_options(__self: mut HTMLMarqueeElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMarqueeElement::as_js(self: HTMLMarqueeElement) -> JsValue = JsValue::unsafe_from[HTMLMarqueeElement](self)

pub fun HTMLMarqueeElement::from_js(v: JsValue) -> mut HTMLMarqueeElement = JsValue::unsafe_as[mut HTMLMarqueeElement](v)

struct HTMLMenuBarElement()

/// Converts a reference to 'HTMLMenuBarElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::as_html_element(self: HTMLMenuBarElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuBarElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::as_mhtml_element(self: mut HTMLMenuBarElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMenuBarElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuBarElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::from_html_element(base: HTMLElement) -> HTMLMenuBarElement = "
    if(#var(base) instanceof HTMLMenuBarElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuBarElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMenuBarElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuBarElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMenuBarElement = "
    if(#var(base) instanceof HTMLMenuBarElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuBarElement'!\");
"

/// Converts a reference to 'HTMLMenuBarElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::as_element(self: HTMLMenuBarElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuBarElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::as_melement(self: mut HTMLMenuBarElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMenuBarElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuBarElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::from_element(base: Element) -> HTMLMenuBarElement = "
    if(#var(base) instanceof HTMLMenuBarElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuBarElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMenuBarElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuBarElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuBarElement::from_melement(base: mut Element) -> mut HTMLMenuBarElement = "
    if(#var(base) instanceof HTMLMenuBarElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuBarElement'!\");
"

pub ext fun HTMLMenuBarElement::title(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMenuBarElement::set_title(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::lang(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMenuBarElement::set_lang(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::translate(self: HTMLMenuBarElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMenuBarElement::set_translate(self: mut HTMLMenuBarElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::dir(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMenuBarElement::set_dir(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::hidden(self: HTMLMenuBarElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMenuBarElement::set_hidden(self: mut HTMLMenuBarElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMenuBarElement::inert(self: HTMLMenuBarElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMenuBarElement::set_inert(self: mut HTMLMenuBarElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::access_key(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMenuBarElement::set_access_key(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::draggable(self: HTMLMenuBarElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMenuBarElement::set_draggable(self: mut HTMLMenuBarElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::spellcheck(self: HTMLMenuBarElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMenuBarElement::set_spellcheck(self: mut HTMLMenuBarElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::autocapitalize(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMenuBarElement::set_autocapitalize(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::edit_context(self: HTMLMenuBarElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMenuBarElement::set_edit_context(self: mut HTMLMenuBarElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMenuBarElement::content_editable(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMenuBarElement::set_content_editable(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::enter_key_hint(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMenuBarElement::set_enter_key_hint(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::is_content_editable(self: HTMLMenuBarElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMenuBarElement::input_mode(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMenuBarElement::set_input_mode(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::virtual_keyboard_policy(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMenuBarElement::set_virtual_keyboard_policy(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::scroll_parent(self: HTMLMenuBarElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMenuBarElement::offset_parent(self: HTMLMenuBarElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMenuBarElement::offset_top(self: HTMLMenuBarElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMenuBarElement::offset_left(self: HTMLMenuBarElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMenuBarElement::offset_width(self: HTMLMenuBarElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMenuBarElement::offset_height(self: HTMLMenuBarElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMenuBarElement::popover(self: HTMLMenuBarElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMenuBarElement::set_popover(self: mut HTMLMenuBarElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMenuBarElement::inner_text(self: HTMLMenuBarElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMenuBarElement::set_inner_text(self: mut HTMLMenuBarElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMenuBarElement::outer_text(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMenuBarElement::set_outer_text(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::writing_suggestions(self: HTMLMenuBarElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMenuBarElement::set_writing_suggestions(self: mut HTMLMenuBarElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuBarElement::click(__self: mut HTMLMenuBarElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuBarElement::attach_internals(__self: mut HTMLMenuBarElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMenuBarElement::toggle_popover(__self: mut HTMLMenuBarElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMenuBarElement::show_popover(__self: mut HTMLMenuBarElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuBarElement::hide_popover(__self: mut HTMLMenuBarElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuBarElement::start_view_transition(__self: mut HTMLMenuBarElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuBarElement::start_view_transition_f_prom_unit(__self: mut HTMLMenuBarElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuBarElement::start_view_transition_mview_transition_options(__self: mut HTMLMenuBarElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMenuBarElement::as_js(self: HTMLMenuBarElement) -> JsValue = JsValue::unsafe_from[HTMLMenuBarElement](self)

pub fun HTMLMenuBarElement::from_js(v: JsValue) -> mut HTMLMenuBarElement = JsValue::unsafe_as[mut HTMLMenuBarElement](v)

struct HTMLMenuElement()

/// Converts a reference to 'HTMLMenuElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::as_html_element(self: HTMLMenuElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::as_mhtml_element(self: mut HTMLMenuElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMenuElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::from_html_element(base: HTMLElement) -> HTMLMenuElement = "
    if(#var(base) instanceof HTMLMenuElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMenuElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMenuElement = "
    if(#var(base) instanceof HTMLMenuElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuElement'!\");
"

/// Converts a reference to 'HTMLMenuElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::as_element(self: HTMLMenuElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::as_melement(self: mut HTMLMenuElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMenuElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::from_element(base: Element) -> HTMLMenuElement = "
    if(#var(base) instanceof HTMLMenuElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMenuElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuElement::from_melement(base: mut Element) -> mut HTMLMenuElement = "
    if(#var(base) instanceof HTMLMenuElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuElement'!\");
"

pub ext fun HTMLMenuElement::compact(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).compact);"

pub ext fun HTMLMenuElement::set_compact(self: mut HTMLMenuElement, value: Bool)
    = "#var(self).compact = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuElement::title(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMenuElement::set_title(self: mut HTMLMenuElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::lang(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMenuElement::set_lang(self: mut HTMLMenuElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::translate(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMenuElement::set_translate(self: mut HTMLMenuElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuElement::dir(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMenuElement::set_dir(self: mut HTMLMenuElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::hidden(self: HTMLMenuElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMenuElement::set_hidden(self: mut HTMLMenuElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMenuElement::inert(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMenuElement::set_inert(self: mut HTMLMenuElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuElement::access_key(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMenuElement::set_access_key(self: mut HTMLMenuElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::draggable(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMenuElement::set_draggable(self: mut HTMLMenuElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuElement::spellcheck(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMenuElement::set_spellcheck(self: mut HTMLMenuElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuElement::autocapitalize(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMenuElement::set_autocapitalize(self: mut HTMLMenuElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::edit_context(self: HTMLMenuElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMenuElement::set_edit_context(self: mut HTMLMenuElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMenuElement::content_editable(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMenuElement::set_content_editable(self: mut HTMLMenuElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::enter_key_hint(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMenuElement::set_enter_key_hint(self: mut HTMLMenuElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::is_content_editable(self: HTMLMenuElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMenuElement::input_mode(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMenuElement::set_input_mode(self: mut HTMLMenuElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::virtual_keyboard_policy(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMenuElement::set_virtual_keyboard_policy(self: mut HTMLMenuElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::scroll_parent(self: HTMLMenuElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMenuElement::offset_parent(self: HTMLMenuElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMenuElement::offset_top(self: HTMLMenuElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMenuElement::offset_left(self: HTMLMenuElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMenuElement::offset_width(self: HTMLMenuElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMenuElement::offset_height(self: HTMLMenuElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMenuElement::popover(self: HTMLMenuElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMenuElement::set_popover(self: mut HTMLMenuElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMenuElement::inner_text(self: HTMLMenuElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMenuElement::set_inner_text(self: mut HTMLMenuElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMenuElement::outer_text(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMenuElement::set_outer_text(self: mut HTMLMenuElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::writing_suggestions(self: HTMLMenuElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMenuElement::set_writing_suggestions(self: mut HTMLMenuElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuElement::click(__self: mut HTMLMenuElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuElement::attach_internals(__self: mut HTMLMenuElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMenuElement::toggle_popover(__self: mut HTMLMenuElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMenuElement::show_popover(__self: mut HTMLMenuElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuElement::hide_popover(__self: mut HTMLMenuElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuElement::start_view_transition(__self: mut HTMLMenuElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuElement::start_view_transition_f_prom_unit(__self: mut HTMLMenuElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuElement::start_view_transition_mview_transition_options(__self: mut HTMLMenuElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMenuElement::as_js(self: HTMLMenuElement) -> JsValue = JsValue::unsafe_from[HTMLMenuElement](self)

pub fun HTMLMenuElement::from_js(v: JsValue) -> mut HTMLMenuElement = JsValue::unsafe_as[mut HTMLMenuElement](v)

struct HTMLMenuItemElement()

/// Converts a reference to 'HTMLMenuItemElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::as_html_element(self: HTMLMenuItemElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuItemElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::as_mhtml_element(self: mut HTMLMenuItemElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMenuItemElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuItemElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::from_html_element(base: HTMLElement) -> HTMLMenuItemElement = "
    if(#var(base) instanceof HTMLMenuItemElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuItemElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMenuItemElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuItemElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMenuItemElement = "
    if(#var(base) instanceof HTMLMenuItemElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuItemElement'!\");
"

/// Converts a reference to 'HTMLMenuItemElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::as_element(self: HTMLMenuItemElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuItemElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::as_melement(self: mut HTMLMenuItemElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMenuItemElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuItemElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::from_element(base: Element) -> HTMLMenuItemElement = "
    if(#var(base) instanceof HTMLMenuItemElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuItemElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMenuItemElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuItemElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuItemElement::from_melement(base: mut Element) -> mut HTMLMenuItemElement = "
    if(#var(base) instanceof HTMLMenuItemElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuItemElement'!\");
"

pub ext fun HTMLMenuItemElement::disabled(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLMenuItemElement::set_disabled(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::checked(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).checked);"

pub ext fun HTMLMenuItemElement::set_checked(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).checked = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::command_for_element(self: HTMLMenuItemElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).commandForElement);"

pub ext fun HTMLMenuItemElement::set_command_for_element(self: mut HTMLMenuItemElement, value: Option[mut Element])
    = "#var(self).commandForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun HTMLMenuItemElement::command(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).command);"

pub ext fun HTMLMenuItemElement::set_command(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).command = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::title(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMenuItemElement::set_title(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::lang(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMenuItemElement::set_lang(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::translate(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMenuItemElement::set_translate(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::dir(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMenuItemElement::set_dir(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::hidden(self: HTMLMenuItemElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMenuItemElement::set_hidden(self: mut HTMLMenuItemElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMenuItemElement::inert(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMenuItemElement::set_inert(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::access_key(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMenuItemElement::set_access_key(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::draggable(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMenuItemElement::set_draggable(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::spellcheck(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMenuItemElement::set_spellcheck(self: mut HTMLMenuItemElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::autocapitalize(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMenuItemElement::set_autocapitalize(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::edit_context(self: HTMLMenuItemElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMenuItemElement::set_edit_context(self: mut HTMLMenuItemElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMenuItemElement::content_editable(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMenuItemElement::set_content_editable(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::enter_key_hint(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMenuItemElement::set_enter_key_hint(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::is_content_editable(self: HTMLMenuItemElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMenuItemElement::input_mode(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMenuItemElement::set_input_mode(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::virtual_keyboard_policy(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMenuItemElement::set_virtual_keyboard_policy(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::scroll_parent(self: HTMLMenuItemElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMenuItemElement::offset_parent(self: HTMLMenuItemElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMenuItemElement::offset_top(self: HTMLMenuItemElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMenuItemElement::offset_left(self: HTMLMenuItemElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMenuItemElement::offset_width(self: HTMLMenuItemElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMenuItemElement::offset_height(self: HTMLMenuItemElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMenuItemElement::popover(self: HTMLMenuItemElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMenuItemElement::set_popover(self: mut HTMLMenuItemElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMenuItemElement::inner_text(self: HTMLMenuItemElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMenuItemElement::set_inner_text(self: mut HTMLMenuItemElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMenuItemElement::outer_text(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMenuItemElement::set_outer_text(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::writing_suggestions(self: HTMLMenuItemElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMenuItemElement::set_writing_suggestions(self: mut HTMLMenuItemElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuItemElement::click(__self: mut HTMLMenuItemElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuItemElement::attach_internals(__self: mut HTMLMenuItemElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMenuItemElement::toggle_popover(__self: mut HTMLMenuItemElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMenuItemElement::show_popover(__self: mut HTMLMenuItemElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuItemElement::hide_popover(__self: mut HTMLMenuItemElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuItemElement::start_view_transition(__self: mut HTMLMenuItemElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuItemElement::start_view_transition_f_prom_unit(__self: mut HTMLMenuItemElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuItemElement::start_view_transition_mview_transition_options(__self: mut HTMLMenuItemElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMenuItemElement::as_js(self: HTMLMenuItemElement) -> JsValue = JsValue::unsafe_from[HTMLMenuItemElement](self)

pub fun HTMLMenuItemElement::from_js(v: JsValue) -> mut HTMLMenuItemElement = JsValue::unsafe_as[mut HTMLMenuItemElement](v)

struct HTMLMenuListElement()

/// Converts a reference to 'HTMLMenuListElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::as_html_element(self: HTMLMenuListElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuListElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::as_mhtml_element(self: mut HTMLMenuListElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMenuListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::from_html_element(base: HTMLElement) -> HTMLMenuListElement = "
    if(#var(base) instanceof HTMLMenuListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuListElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMenuListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMenuListElement = "
    if(#var(base) instanceof HTMLMenuListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMenuListElement'!\");
"

/// Converts a reference to 'HTMLMenuListElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::as_element(self: HTMLMenuListElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMenuListElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::as_melement(self: mut HTMLMenuListElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMenuListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::from_element(base: Element) -> HTMLMenuListElement = "
    if(#var(base) instanceof HTMLMenuListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuListElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMenuListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMenuListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMenuListElement::from_melement(base: mut Element) -> mut HTMLMenuListElement = "
    if(#var(base) instanceof HTMLMenuListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMenuListElement'!\");
"

pub ext fun HTMLMenuListElement::title(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMenuListElement::set_title(self: mut HTMLMenuListElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::lang(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMenuListElement::set_lang(self: mut HTMLMenuListElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::translate(self: HTMLMenuListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMenuListElement::set_translate(self: mut HTMLMenuListElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::dir(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMenuListElement::set_dir(self: mut HTMLMenuListElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::hidden(self: HTMLMenuListElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMenuListElement::set_hidden(self: mut HTMLMenuListElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMenuListElement::inert(self: HTMLMenuListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMenuListElement::set_inert(self: mut HTMLMenuListElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::access_key(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMenuListElement::set_access_key(self: mut HTMLMenuListElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::draggable(self: HTMLMenuListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMenuListElement::set_draggable(self: mut HTMLMenuListElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::spellcheck(self: HTMLMenuListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMenuListElement::set_spellcheck(self: mut HTMLMenuListElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::autocapitalize(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMenuListElement::set_autocapitalize(self: mut HTMLMenuListElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::edit_context(self: HTMLMenuListElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMenuListElement::set_edit_context(self: mut HTMLMenuListElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMenuListElement::content_editable(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMenuListElement::set_content_editable(self: mut HTMLMenuListElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::enter_key_hint(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMenuListElement::set_enter_key_hint(self: mut HTMLMenuListElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::is_content_editable(self: HTMLMenuListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMenuListElement::input_mode(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMenuListElement::set_input_mode(self: mut HTMLMenuListElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::virtual_keyboard_policy(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMenuListElement::set_virtual_keyboard_policy(self: mut HTMLMenuListElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::scroll_parent(self: HTMLMenuListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMenuListElement::offset_parent(self: HTMLMenuListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMenuListElement::offset_top(self: HTMLMenuListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMenuListElement::offset_left(self: HTMLMenuListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMenuListElement::offset_width(self: HTMLMenuListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMenuListElement::offset_height(self: HTMLMenuListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMenuListElement::popover(self: HTMLMenuListElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMenuListElement::set_popover(self: mut HTMLMenuListElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMenuListElement::inner_text(self: HTMLMenuListElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMenuListElement::set_inner_text(self: mut HTMLMenuListElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMenuListElement::outer_text(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMenuListElement::set_outer_text(self: mut HTMLMenuListElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::writing_suggestions(self: HTMLMenuListElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMenuListElement::set_writing_suggestions(self: mut HTMLMenuListElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMenuListElement::click(__self: mut HTMLMenuListElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuListElement::attach_internals(__self: mut HTMLMenuListElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMenuListElement::toggle_popover(__self: mut HTMLMenuListElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMenuListElement::show_popover(__self: mut HTMLMenuListElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuListElement::hide_popover(__self: mut HTMLMenuListElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMenuListElement::start_view_transition(__self: mut HTMLMenuListElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuListElement::start_view_transition_f_prom_unit(__self: mut HTMLMenuListElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMenuListElement::start_view_transition_mview_transition_options(__self: mut HTMLMenuListElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMenuListElement::as_js(self: HTMLMenuListElement) -> JsValue = JsValue::unsafe_from[HTMLMenuListElement](self)

pub fun HTMLMenuListElement::from_js(v: JsValue) -> mut HTMLMenuListElement = JsValue::unsafe_as[mut HTMLMenuListElement](v)

struct HTMLMetaElement()

/// Converts a reference to 'HTMLMetaElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::as_html_element(self: HTMLMetaElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMetaElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::as_mhtml_element(self: mut HTMLMetaElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMetaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMetaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::from_html_element(base: HTMLElement) -> HTMLMetaElement = "
    if(#var(base) instanceof HTMLMetaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMetaElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMetaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMetaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMetaElement = "
    if(#var(base) instanceof HTMLMetaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMetaElement'!\");
"

/// Converts a reference to 'HTMLMetaElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::as_element(self: HTMLMetaElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMetaElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::as_melement(self: mut HTMLMetaElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMetaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMetaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::from_element(base: Element) -> HTMLMetaElement = "
    if(#var(base) instanceof HTMLMetaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMetaElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMetaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMetaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMetaElement::from_melement(base: mut Element) -> mut HTMLMetaElement = "
    if(#var(base) instanceof HTMLMetaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMetaElement'!\");
"

pub ext fun HTMLMetaElement::name(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLMetaElement::set_name(self: mut HTMLMetaElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::http_equiv(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).httpEquiv);"

pub ext fun HTMLMetaElement::set_http_equiv(self: mut HTMLMetaElement, value: String)
    = "#var(self).httpEquiv = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::content(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).content);"

pub ext fun HTMLMetaElement::set_content(self: mut HTMLMetaElement, value: String)
    = "#var(self).content = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::media(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun HTMLMetaElement::set_media(self: mut HTMLMetaElement, value: String)
    = "#var(self).media = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::scheme(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).scheme);"

pub ext fun HTMLMetaElement::set_scheme(self: mut HTMLMetaElement, value: String)
    = "#var(self).scheme = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::title(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMetaElement::set_title(self: mut HTMLMetaElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::lang(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMetaElement::set_lang(self: mut HTMLMetaElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::translate(self: HTMLMetaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMetaElement::set_translate(self: mut HTMLMetaElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMetaElement::dir(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMetaElement::set_dir(self: mut HTMLMetaElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::hidden(self: HTMLMetaElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMetaElement::set_hidden(self: mut HTMLMetaElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMetaElement::inert(self: HTMLMetaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMetaElement::set_inert(self: mut HTMLMetaElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMetaElement::access_key(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMetaElement::set_access_key(self: mut HTMLMetaElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::draggable(self: HTMLMetaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMetaElement::set_draggable(self: mut HTMLMetaElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMetaElement::spellcheck(self: HTMLMetaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMetaElement::set_spellcheck(self: mut HTMLMetaElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMetaElement::autocapitalize(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMetaElement::set_autocapitalize(self: mut HTMLMetaElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::edit_context(self: HTMLMetaElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMetaElement::set_edit_context(self: mut HTMLMetaElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMetaElement::content_editable(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMetaElement::set_content_editable(self: mut HTMLMetaElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::enter_key_hint(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMetaElement::set_enter_key_hint(self: mut HTMLMetaElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::is_content_editable(self: HTMLMetaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMetaElement::input_mode(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMetaElement::set_input_mode(self: mut HTMLMetaElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::virtual_keyboard_policy(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMetaElement::set_virtual_keyboard_policy(self: mut HTMLMetaElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::scroll_parent(self: HTMLMetaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMetaElement::offset_parent(self: HTMLMetaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMetaElement::offset_top(self: HTMLMetaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMetaElement::offset_left(self: HTMLMetaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMetaElement::offset_width(self: HTMLMetaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMetaElement::offset_height(self: HTMLMetaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMetaElement::popover(self: HTMLMetaElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMetaElement::set_popover(self: mut HTMLMetaElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMetaElement::inner_text(self: HTMLMetaElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMetaElement::set_inner_text(self: mut HTMLMetaElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMetaElement::outer_text(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMetaElement::set_outer_text(self: mut HTMLMetaElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::writing_suggestions(self: HTMLMetaElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMetaElement::set_writing_suggestions(self: mut HTMLMetaElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMetaElement::click(__self: mut HTMLMetaElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMetaElement::attach_internals(__self: mut HTMLMetaElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMetaElement::toggle_popover(__self: mut HTMLMetaElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMetaElement::show_popover(__self: mut HTMLMetaElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMetaElement::hide_popover(__self: mut HTMLMetaElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMetaElement::start_view_transition(__self: mut HTMLMetaElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMetaElement::start_view_transition_f_prom_unit(__self: mut HTMLMetaElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMetaElement::start_view_transition_mview_transition_options(__self: mut HTMLMetaElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMetaElement::as_js(self: HTMLMetaElement) -> JsValue = JsValue::unsafe_from[HTMLMetaElement](self)

pub fun HTMLMetaElement::from_js(v: JsValue) -> mut HTMLMetaElement = JsValue::unsafe_as[mut HTMLMetaElement](v)

struct HTMLMeterElement()

/// Converts a reference to 'HTMLMeterElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::as_html_element(self: HTMLMeterElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMeterElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::as_mhtml_element(self: mut HTMLMeterElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMeterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMeterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::from_html_element(base: HTMLElement) -> HTMLMeterElement = "
    if(#var(base) instanceof HTMLMeterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMeterElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMeterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMeterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMeterElement = "
    if(#var(base) instanceof HTMLMeterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMeterElement'!\");
"

/// Converts a reference to 'HTMLMeterElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::as_element(self: HTMLMeterElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMeterElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::as_melement(self: mut HTMLMeterElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMeterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMeterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::from_element(base: Element) -> HTMLMeterElement = "
    if(#var(base) instanceof HTMLMeterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMeterElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMeterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMeterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMeterElement::from_melement(base: mut Element) -> mut HTMLMeterElement = "
    if(#var(base) instanceof HTMLMeterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMeterElement'!\");
"

pub ext fun HTMLMeterElement::value(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun HTMLMeterElement::set_value(self: mut HTMLMeterElement, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::min(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).min);"

pub ext fun HTMLMeterElement::set_min(self: mut HTMLMeterElement, value: Float)
    = "#var(self).min = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::max(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).max);"

pub ext fun HTMLMeterElement::set_max(self: mut HTMLMeterElement, value: Float)
    = "#var(self).max = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::low(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).low);"

pub ext fun HTMLMeterElement::set_low(self: mut HTMLMeterElement, value: Float)
    = "#var(self).low = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::high(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).high);"

pub ext fun HTMLMeterElement::set_high(self: mut HTMLMeterElement, value: Float)
    = "#var(self).high = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::optimum(self: HTMLMeterElement) -> Float
    = "return #fun(Float::from_js)(#var(self).optimum);"

pub ext fun HTMLMeterElement::set_optimum(self: mut HTMLMeterElement, value: Float)
    = "#var(self).optimum = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMeterElement::labels(self: HTMLMeterElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLMeterElement::title(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMeterElement::set_title(self: mut HTMLMeterElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::lang(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMeterElement::set_lang(self: mut HTMLMeterElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::translate(self: HTMLMeterElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMeterElement::set_translate(self: mut HTMLMeterElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMeterElement::dir(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMeterElement::set_dir(self: mut HTMLMeterElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::hidden(self: HTMLMeterElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMeterElement::set_hidden(self: mut HTMLMeterElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMeterElement::inert(self: HTMLMeterElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMeterElement::set_inert(self: mut HTMLMeterElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMeterElement::access_key(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMeterElement::set_access_key(self: mut HTMLMeterElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::draggable(self: HTMLMeterElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMeterElement::set_draggable(self: mut HTMLMeterElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMeterElement::spellcheck(self: HTMLMeterElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMeterElement::set_spellcheck(self: mut HTMLMeterElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMeterElement::autocapitalize(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMeterElement::set_autocapitalize(self: mut HTMLMeterElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::edit_context(self: HTMLMeterElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMeterElement::set_edit_context(self: mut HTMLMeterElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMeterElement::content_editable(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMeterElement::set_content_editable(self: mut HTMLMeterElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::enter_key_hint(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMeterElement::set_enter_key_hint(self: mut HTMLMeterElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::is_content_editable(self: HTMLMeterElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMeterElement::input_mode(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMeterElement::set_input_mode(self: mut HTMLMeterElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::virtual_keyboard_policy(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMeterElement::set_virtual_keyboard_policy(self: mut HTMLMeterElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::scroll_parent(self: HTMLMeterElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMeterElement::offset_parent(self: HTMLMeterElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMeterElement::offset_top(self: HTMLMeterElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMeterElement::offset_left(self: HTMLMeterElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMeterElement::offset_width(self: HTMLMeterElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMeterElement::offset_height(self: HTMLMeterElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMeterElement::popover(self: HTMLMeterElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMeterElement::set_popover(self: mut HTMLMeterElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMeterElement::inner_text(self: HTMLMeterElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMeterElement::set_inner_text(self: mut HTMLMeterElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMeterElement::outer_text(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMeterElement::set_outer_text(self: mut HTMLMeterElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::writing_suggestions(self: HTMLMeterElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMeterElement::set_writing_suggestions(self: mut HTMLMeterElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMeterElement::click(__self: mut HTMLMeterElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMeterElement::attach_internals(__self: mut HTMLMeterElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMeterElement::toggle_popover(__self: mut HTMLMeterElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMeterElement::show_popover(__self: mut HTMLMeterElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMeterElement::hide_popover(__self: mut HTMLMeterElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMeterElement::start_view_transition(__self: mut HTMLMeterElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMeterElement::start_view_transition_f_prom_unit(__self: mut HTMLMeterElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMeterElement::start_view_transition_mview_transition_options(__self: mut HTMLMeterElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMeterElement::as_js(self: HTMLMeterElement) -> JsValue = JsValue::unsafe_from[HTMLMeterElement](self)

pub fun HTMLMeterElement::from_js(v: JsValue) -> mut HTMLMeterElement = JsValue::unsafe_as[mut HTMLMeterElement](v)

struct HTMLModElement()

/// Converts a reference to 'HTMLModElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::as_html_element(self: HTMLModElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLModElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::as_mhtml_element(self: mut HTMLModElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLModElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLModElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::from_html_element(base: HTMLElement) -> HTMLModElement = "
    if(#var(base) instanceof HTMLModElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLModElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLModElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLModElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLModElement = "
    if(#var(base) instanceof HTMLModElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLModElement'!\");
"

/// Converts a reference to 'HTMLModElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::as_element(self: HTMLModElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLModElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::as_melement(self: mut HTMLModElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLModElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLModElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::from_element(base: Element) -> HTMLModElement = "
    if(#var(base) instanceof HTMLModElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLModElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLModElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLModElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLModElement::from_melement(base: mut Element) -> mut HTMLModElement = "
    if(#var(base) instanceof HTMLModElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLModElement'!\");
"

pub ext fun HTMLModElement::cite(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).cite);"

pub ext fun HTMLModElement::set_cite(self: mut HTMLModElement, value: String)
    = "#var(self).cite = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::date_time(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).dateTime);"

pub ext fun HTMLModElement::set_date_time(self: mut HTMLModElement, value: String)
    = "#var(self).dateTime = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::title(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLModElement::set_title(self: mut HTMLModElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::lang(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLModElement::set_lang(self: mut HTMLModElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::translate(self: HTMLModElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLModElement::set_translate(self: mut HTMLModElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLModElement::dir(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLModElement::set_dir(self: mut HTMLModElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::hidden(self: HTMLModElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLModElement::set_hidden(self: mut HTMLModElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLModElement::inert(self: HTMLModElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLModElement::set_inert(self: mut HTMLModElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLModElement::access_key(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLModElement::set_access_key(self: mut HTMLModElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::draggable(self: HTMLModElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLModElement::set_draggable(self: mut HTMLModElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLModElement::spellcheck(self: HTMLModElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLModElement::set_spellcheck(self: mut HTMLModElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLModElement::autocapitalize(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLModElement::set_autocapitalize(self: mut HTMLModElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::edit_context(self: HTMLModElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLModElement::set_edit_context(self: mut HTMLModElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLModElement::content_editable(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLModElement::set_content_editable(self: mut HTMLModElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::enter_key_hint(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLModElement::set_enter_key_hint(self: mut HTMLModElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::is_content_editable(self: HTMLModElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLModElement::input_mode(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLModElement::set_input_mode(self: mut HTMLModElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::virtual_keyboard_policy(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLModElement::set_virtual_keyboard_policy(self: mut HTMLModElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::scroll_parent(self: HTMLModElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLModElement::offset_parent(self: HTMLModElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLModElement::offset_top(self: HTMLModElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLModElement::offset_left(self: HTMLModElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLModElement::offset_width(self: HTMLModElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLModElement::offset_height(self: HTMLModElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLModElement::popover(self: HTMLModElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLModElement::set_popover(self: mut HTMLModElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLModElement::inner_text(self: HTMLModElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLModElement::set_inner_text(self: mut HTMLModElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLModElement::outer_text(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLModElement::set_outer_text(self: mut HTMLModElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::writing_suggestions(self: HTMLModElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLModElement::set_writing_suggestions(self: mut HTMLModElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLModElement::click(__self: mut HTMLModElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLModElement::attach_internals(__self: mut HTMLModElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLModElement::toggle_popover(__self: mut HTMLModElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLModElement::show_popover(__self: mut HTMLModElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLModElement::hide_popover(__self: mut HTMLModElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLModElement::start_view_transition(__self: mut HTMLModElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLModElement::start_view_transition_f_prom_unit(__self: mut HTMLModElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLModElement::start_view_transition_mview_transition_options(__self: mut HTMLModElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLModElement::as_js(self: HTMLModElement) -> JsValue = JsValue::unsafe_from[HTMLModElement](self)

pub fun HTMLModElement::from_js(v: JsValue) -> mut HTMLModElement = JsValue::unsafe_as[mut HTMLModElement](v)

struct HTMLObjectElement()

/// Converts a reference to 'HTMLObjectElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::as_html_element(self: HTMLObjectElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLObjectElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::as_mhtml_element(self: mut HTMLObjectElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::from_html_element(base: HTMLElement) -> HTMLObjectElement = "
    if(#var(base) instanceof HTMLObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLObjectElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLObjectElement = "
    if(#var(base) instanceof HTMLObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLObjectElement'!\");
"

/// Converts a reference to 'HTMLObjectElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::as_element(self: HTMLObjectElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLObjectElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::as_melement(self: mut HTMLObjectElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::from_element(base: Element) -> HTMLObjectElement = "
    if(#var(base) instanceof HTMLObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLObjectElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLObjectElement::from_melement(base: mut Element) -> mut HTMLObjectElement = "
    if(#var(base) instanceof HTMLObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLObjectElement'!\");
"

pub ext fun HTMLObjectElement::data(self: HTMLObjectElement) -> JsValue
    = "return #var(self).data;"

pub ext fun HTMLObjectElement::set_data(self: mut HTMLObjectElement, value: JsValue)
    = "#var(self).data = #var(value);"

pub ext fun HTMLObjectElement::type(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLObjectElement::set_type(self: mut HTMLObjectElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::name(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLObjectElement::set_name(self: mut HTMLObjectElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::use_map(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).useMap);"

pub ext fun HTMLObjectElement::set_use_map(self: mut HTMLObjectElement, value: String)
    = "#var(self).useMap = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::form(self: HTMLObjectElement) -> Option[mut HTMLElement]
    = "return #fun(Option::from_js[mut HTMLElement])(#var(self).form);"

pub ext fun HTMLObjectElement::width(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLObjectElement::set_width(self: mut HTMLObjectElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::height(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLObjectElement::set_height(self: mut HTMLObjectElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::content_document(self: HTMLObjectElement) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).contentDocument);"

pub ext fun HTMLObjectElement::content_window(self: HTMLObjectElement) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).contentWindow);"

pub ext fun HTMLObjectElement::will_validate(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).willValidate);"

pub ext fun HTMLObjectElement::validity(self: HTMLObjectElement) -> mut ValidityState
    = "return #fun(ValidityState::from_js)(#var(self).validity);"

pub ext fun HTMLObjectElement::validation_message(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).validationMessage);"

pub ext fun HTMLObjectElement::align(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLObjectElement::set_align(self: mut HTMLObjectElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::archive(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).archive);"

pub ext fun HTMLObjectElement::set_archive(self: mut HTMLObjectElement, value: String)
    = "#var(self).archive = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::code(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).code);"

pub ext fun HTMLObjectElement::set_code(self: mut HTMLObjectElement, value: String)
    = "#var(self).code = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::declare(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).declare);"

pub ext fun HTMLObjectElement::set_declare(self: mut HTMLObjectElement, value: Bool)
    = "#var(self).declare = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLObjectElement::hspace(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).hspace);"

pub ext fun HTMLObjectElement::set_hspace(self: mut HTMLObjectElement, value: Int)
    = "#var(self).hspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLObjectElement::standby(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).standby);"

pub ext fun HTMLObjectElement::set_standby(self: mut HTMLObjectElement, value: String)
    = "#var(self).standby = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::vspace(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).vspace);"

pub ext fun HTMLObjectElement::set_vspace(self: mut HTMLObjectElement, value: Int)
    = "#var(self).vspace = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLObjectElement::code_base(self: HTMLObjectElement) -> JsValue
    = "return #var(self).codeBase;"

pub ext fun HTMLObjectElement::set_code_base(self: mut HTMLObjectElement, value: JsValue)
    = "#var(self).codeBase = #var(value);"

pub ext fun HTMLObjectElement::code_type(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).codeType);"

pub ext fun HTMLObjectElement::set_code_type(self: mut HTMLObjectElement, value: String)
    = "#var(self).codeType = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::border(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).border);"

pub ext fun HTMLObjectElement::set_border(self: mut HTMLObjectElement, value: String)
    = "#var(self).border = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::title(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLObjectElement::set_title(self: mut HTMLObjectElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::lang(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLObjectElement::set_lang(self: mut HTMLObjectElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::translate(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLObjectElement::set_translate(self: mut HTMLObjectElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLObjectElement::dir(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLObjectElement::set_dir(self: mut HTMLObjectElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::hidden(self: HTMLObjectElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLObjectElement::set_hidden(self: mut HTMLObjectElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLObjectElement::inert(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLObjectElement::set_inert(self: mut HTMLObjectElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLObjectElement::access_key(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLObjectElement::set_access_key(self: mut HTMLObjectElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::draggable(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLObjectElement::set_draggable(self: mut HTMLObjectElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLObjectElement::spellcheck(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLObjectElement::set_spellcheck(self: mut HTMLObjectElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLObjectElement::autocapitalize(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLObjectElement::set_autocapitalize(self: mut HTMLObjectElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::edit_context(self: HTMLObjectElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLObjectElement::set_edit_context(self: mut HTMLObjectElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLObjectElement::content_editable(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLObjectElement::set_content_editable(self: mut HTMLObjectElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::enter_key_hint(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLObjectElement::set_enter_key_hint(self: mut HTMLObjectElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::is_content_editable(self: HTMLObjectElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLObjectElement::input_mode(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLObjectElement::set_input_mode(self: mut HTMLObjectElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::virtual_keyboard_policy(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLObjectElement::set_virtual_keyboard_policy(self: mut HTMLObjectElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::scroll_parent(self: HTMLObjectElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLObjectElement::offset_parent(self: HTMLObjectElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLObjectElement::offset_top(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLObjectElement::offset_left(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLObjectElement::offset_width(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLObjectElement::offset_height(self: HTMLObjectElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLObjectElement::popover(self: HTMLObjectElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLObjectElement::set_popover(self: mut HTMLObjectElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLObjectElement::inner_text(self: HTMLObjectElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLObjectElement::set_inner_text(self: mut HTMLObjectElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLObjectElement::outer_text(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLObjectElement::set_outer_text(self: mut HTMLObjectElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::writing_suggestions(self: HTMLObjectElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLObjectElement::set_writing_suggestions(self: mut HTMLObjectElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLObjectElement::get_svg_document(__self: mut HTMLObjectElement) -> Option[mut Document] = "
    const r = #var(__self).getSVGDocument();
    return #fun(Option::from_js[mut Document])(r);
"

pub ext fun HTMLObjectElement::check_validity(__self: mut HTMLObjectElement) -> Bool = "
    const r = #var(__self).checkValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLObjectElement::report_validity(__self: mut HTMLObjectElement) -> Bool = "
    const r = #var(__self).reportValidity();
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLObjectElement::set_custom_validity(__self: mut HTMLObjectElement, error: String) -> Unit = "
    const r = #var(__self).setCustomValidity(#fun(String::as_js)(#var(error)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLObjectElement::get(__self: HTMLObjectElement, name: String) -> JsValue = "
    const r = HTMLObjectElement[#fun(String::as_js)(#var(name))];
    return r;
"

pub ext fun HTMLObjectElement::set(__self: mut HTMLObjectElement, name: String, value: JsValue) = "
    HTMLObjectElement[#fun(String::as_js)(#var(name))] = #var(value);
"

pub ext fun HTMLObjectElement::click(__self: mut HTMLObjectElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLObjectElement::attach_internals(__self: mut HTMLObjectElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLObjectElement::toggle_popover(__self: mut HTMLObjectElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLObjectElement::show_popover(__self: mut HTMLObjectElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLObjectElement::hide_popover(__self: mut HTMLObjectElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLObjectElement::start_view_transition(__self: mut HTMLObjectElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLObjectElement::start_view_transition_f_prom_unit(__self: mut HTMLObjectElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLObjectElement::start_view_transition_mview_transition_options(__self: mut HTMLObjectElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLObjectElement::as_js(self: HTMLObjectElement) -> JsValue = JsValue::unsafe_from[HTMLObjectElement](self)

pub fun HTMLObjectElement::from_js(v: JsValue) -> mut HTMLObjectElement = JsValue::unsafe_as[mut HTMLObjectElement](v)

struct HTMLOListElement()

/// Converts a reference to 'HTMLOListElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::as_html_element(self: HTMLOListElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLOListElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::as_mhtml_element(self: mut HTMLOListElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLOListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::from_html_element(base: HTMLElement) -> HTMLOListElement = "
    if(#var(base) instanceof HTMLOListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOListElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLOListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLOListElement = "
    if(#var(base) instanceof HTMLOListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLOListElement'!\");
"

/// Converts a reference to 'HTMLOListElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::as_element(self: HTMLOListElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLOListElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::as_melement(self: mut HTMLOListElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLOListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::from_element(base: Element) -> HTMLOListElement = "
    if(#var(base) instanceof HTMLOListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOListElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLOListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLOListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLOListElement::from_melement(base: mut Element) -> mut HTMLOListElement = "
    if(#var(base) instanceof HTMLOListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLOListElement'!\");
"

pub ext fun HTMLOListElement::reversed(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).reversed);"

pub ext fun HTMLOListElement::set_reversed(self: mut HTMLOListElement, value: Bool)
    = "#var(self).reversed = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::start(self: HTMLOListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).start);"

pub ext fun HTMLOListElement::set_start(self: mut HTMLOListElement, value: Int)
    = "#var(self).start = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLOListElement::type(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLOListElement::set_type(self: mut HTMLOListElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::compact(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).compact);"

pub ext fun HTMLOListElement::set_compact(self: mut HTMLOListElement, value: Bool)
    = "#var(self).compact = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::title(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLOListElement::set_title(self: mut HTMLOListElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::lang(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLOListElement::set_lang(self: mut HTMLOListElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::translate(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLOListElement::set_translate(self: mut HTMLOListElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::dir(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLOListElement::set_dir(self: mut HTMLOListElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::hidden(self: HTMLOListElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLOListElement::set_hidden(self: mut HTMLOListElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLOListElement::inert(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLOListElement::set_inert(self: mut HTMLOListElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::access_key(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLOListElement::set_access_key(self: mut HTMLOListElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::draggable(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLOListElement::set_draggable(self: mut HTMLOListElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::spellcheck(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLOListElement::set_spellcheck(self: mut HTMLOListElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLOListElement::autocapitalize(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLOListElement::set_autocapitalize(self: mut HTMLOListElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::edit_context(self: HTMLOListElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLOListElement::set_edit_context(self: mut HTMLOListElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLOListElement::content_editable(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLOListElement::set_content_editable(self: mut HTMLOListElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::enter_key_hint(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLOListElement::set_enter_key_hint(self: mut HTMLOListElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::is_content_editable(self: HTMLOListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLOListElement::input_mode(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLOListElement::set_input_mode(self: mut HTMLOListElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::virtual_keyboard_policy(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLOListElement::set_virtual_keyboard_policy(self: mut HTMLOListElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::scroll_parent(self: HTMLOListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLOListElement::offset_parent(self: HTMLOListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLOListElement::offset_top(self: HTMLOListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLOListElement::offset_left(self: HTMLOListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLOListElement::offset_width(self: HTMLOListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLOListElement::offset_height(self: HTMLOListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLOListElement::popover(self: HTMLOListElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLOListElement::set_popover(self: mut HTMLOListElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLOListElement::inner_text(self: HTMLOListElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLOListElement::set_inner_text(self: mut HTMLOListElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLOListElement::outer_text(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLOListElement::set_outer_text(self: mut HTMLOListElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::writing_suggestions(self: HTMLOListElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLOListElement::set_writing_suggestions(self: mut HTMLOListElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLOListElement::click(__self: mut HTMLOListElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOListElement::attach_internals(__self: mut HTMLOListElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLOListElement::toggle_popover(__self: mut HTMLOListElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLOListElement::show_popover(__self: mut HTMLOListElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOListElement::hide_popover(__self: mut HTMLOListElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLOListElement::start_view_transition(__self: mut HTMLOListElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOListElement::start_view_transition_f_prom_unit(__self: mut HTMLOListElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLOListElement::start_view_transition_mview_transition_options(__self: mut HTMLOListElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLOListElement::as_js(self: HTMLOListElement) -> JsValue = JsValue::unsafe_from[HTMLOListElement](self)

pub fun HTMLOListElement::from_js(v: JsValue) -> mut HTMLOListElement = JsValue::unsafe_as[mut HTMLOListElement](v)

struct HTMLParagraphElement()

/// Converts a reference to 'HTMLParagraphElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::as_html_element(self: HTMLParagraphElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLParagraphElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::as_mhtml_element(self: mut HTMLParagraphElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLParagraphElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParagraphElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::from_html_element(base: HTMLElement) -> HTMLParagraphElement = "
    if(#var(base) instanceof HTMLParagraphElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLParagraphElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLParagraphElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParagraphElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLParagraphElement = "
    if(#var(base) instanceof HTMLParagraphElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLParagraphElement'!\");
"

/// Converts a reference to 'HTMLParagraphElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::as_element(self: HTMLParagraphElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLParagraphElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::as_melement(self: mut HTMLParagraphElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLParagraphElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParagraphElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::from_element(base: Element) -> HTMLParagraphElement = "
    if(#var(base) instanceof HTMLParagraphElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLParagraphElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLParagraphElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParagraphElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParagraphElement::from_melement(base: mut Element) -> mut HTMLParagraphElement = "
    if(#var(base) instanceof HTMLParagraphElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLParagraphElement'!\");
"

pub ext fun HTMLParagraphElement::align(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLParagraphElement::set_align(self: mut HTMLParagraphElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::title(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLParagraphElement::set_title(self: mut HTMLParagraphElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::lang(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLParagraphElement::set_lang(self: mut HTMLParagraphElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::translate(self: HTMLParagraphElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLParagraphElement::set_translate(self: mut HTMLParagraphElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::dir(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLParagraphElement::set_dir(self: mut HTMLParagraphElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::hidden(self: HTMLParagraphElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLParagraphElement::set_hidden(self: mut HTMLParagraphElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLParagraphElement::inert(self: HTMLParagraphElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLParagraphElement::set_inert(self: mut HTMLParagraphElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::access_key(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLParagraphElement::set_access_key(self: mut HTMLParagraphElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::draggable(self: HTMLParagraphElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLParagraphElement::set_draggable(self: mut HTMLParagraphElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::spellcheck(self: HTMLParagraphElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLParagraphElement::set_spellcheck(self: mut HTMLParagraphElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::autocapitalize(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLParagraphElement::set_autocapitalize(self: mut HTMLParagraphElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::edit_context(self: HTMLParagraphElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLParagraphElement::set_edit_context(self: mut HTMLParagraphElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLParagraphElement::content_editable(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLParagraphElement::set_content_editable(self: mut HTMLParagraphElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::enter_key_hint(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLParagraphElement::set_enter_key_hint(self: mut HTMLParagraphElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::is_content_editable(self: HTMLParagraphElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLParagraphElement::input_mode(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLParagraphElement::set_input_mode(self: mut HTMLParagraphElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::virtual_keyboard_policy(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLParagraphElement::set_virtual_keyboard_policy(self: mut HTMLParagraphElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::scroll_parent(self: HTMLParagraphElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLParagraphElement::offset_parent(self: HTMLParagraphElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLParagraphElement::offset_top(self: HTMLParagraphElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLParagraphElement::offset_left(self: HTMLParagraphElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLParagraphElement::offset_width(self: HTMLParagraphElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLParagraphElement::offset_height(self: HTMLParagraphElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLParagraphElement::popover(self: HTMLParagraphElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLParagraphElement::set_popover(self: mut HTMLParagraphElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLParagraphElement::inner_text(self: HTMLParagraphElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLParagraphElement::set_inner_text(self: mut HTMLParagraphElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLParagraphElement::outer_text(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLParagraphElement::set_outer_text(self: mut HTMLParagraphElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::writing_suggestions(self: HTMLParagraphElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLParagraphElement::set_writing_suggestions(self: mut HTMLParagraphElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParagraphElement::click(__self: mut HTMLParagraphElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParagraphElement::attach_internals(__self: mut HTMLParagraphElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLParagraphElement::toggle_popover(__self: mut HTMLParagraphElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLParagraphElement::show_popover(__self: mut HTMLParagraphElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParagraphElement::hide_popover(__self: mut HTMLParagraphElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParagraphElement::start_view_transition(__self: mut HTMLParagraphElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLParagraphElement::start_view_transition_f_prom_unit(__self: mut HTMLParagraphElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLParagraphElement::start_view_transition_mview_transition_options(__self: mut HTMLParagraphElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLParagraphElement::as_js(self: HTMLParagraphElement) -> JsValue = JsValue::unsafe_from[HTMLParagraphElement](self)

pub fun HTMLParagraphElement::from_js(v: JsValue) -> mut HTMLParagraphElement = JsValue::unsafe_as[mut HTMLParagraphElement](v)

struct HTMLParamElement()

/// Converts a reference to 'HTMLParamElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::as_html_element(self: HTMLParamElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLParamElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::as_mhtml_element(self: mut HTMLParamElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLParamElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParamElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::from_html_element(base: HTMLElement) -> HTMLParamElement = "
    if(#var(base) instanceof HTMLParamElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLParamElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLParamElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParamElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLParamElement = "
    if(#var(base) instanceof HTMLParamElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLParamElement'!\");
"

/// Converts a reference to 'HTMLParamElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::as_element(self: HTMLParamElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLParamElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::as_melement(self: mut HTMLParamElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLParamElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParamElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::from_element(base: Element) -> HTMLParamElement = "
    if(#var(base) instanceof HTMLParamElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLParamElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLParamElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLParamElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLParamElement::from_melement(base: mut Element) -> mut HTMLParamElement = "
    if(#var(base) instanceof HTMLParamElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLParamElement'!\");
"

pub ext fun HTMLParamElement::name(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLParamElement::set_name(self: mut HTMLParamElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::value(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun HTMLParamElement::set_value(self: mut HTMLParamElement, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::type(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLParamElement::set_type(self: mut HTMLParamElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::value_type(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).valueType);"

pub ext fun HTMLParamElement::set_value_type(self: mut HTMLParamElement, value: String)
    = "#var(self).valueType = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::title(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLParamElement::set_title(self: mut HTMLParamElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::lang(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLParamElement::set_lang(self: mut HTMLParamElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::translate(self: HTMLParamElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLParamElement::set_translate(self: mut HTMLParamElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParamElement::dir(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLParamElement::set_dir(self: mut HTMLParamElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::hidden(self: HTMLParamElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLParamElement::set_hidden(self: mut HTMLParamElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLParamElement::inert(self: HTMLParamElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLParamElement::set_inert(self: mut HTMLParamElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParamElement::access_key(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLParamElement::set_access_key(self: mut HTMLParamElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::draggable(self: HTMLParamElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLParamElement::set_draggable(self: mut HTMLParamElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParamElement::spellcheck(self: HTMLParamElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLParamElement::set_spellcheck(self: mut HTMLParamElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLParamElement::autocapitalize(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLParamElement::set_autocapitalize(self: mut HTMLParamElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::edit_context(self: HTMLParamElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLParamElement::set_edit_context(self: mut HTMLParamElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLParamElement::content_editable(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLParamElement::set_content_editable(self: mut HTMLParamElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::enter_key_hint(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLParamElement::set_enter_key_hint(self: mut HTMLParamElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::is_content_editable(self: HTMLParamElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLParamElement::input_mode(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLParamElement::set_input_mode(self: mut HTMLParamElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::virtual_keyboard_policy(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLParamElement::set_virtual_keyboard_policy(self: mut HTMLParamElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::scroll_parent(self: HTMLParamElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLParamElement::offset_parent(self: HTMLParamElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLParamElement::offset_top(self: HTMLParamElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLParamElement::offset_left(self: HTMLParamElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLParamElement::offset_width(self: HTMLParamElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLParamElement::offset_height(self: HTMLParamElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLParamElement::popover(self: HTMLParamElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLParamElement::set_popover(self: mut HTMLParamElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLParamElement::inner_text(self: HTMLParamElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLParamElement::set_inner_text(self: mut HTMLParamElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLParamElement::outer_text(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLParamElement::set_outer_text(self: mut HTMLParamElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::writing_suggestions(self: HTMLParamElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLParamElement::set_writing_suggestions(self: mut HTMLParamElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLParamElement::click(__self: mut HTMLParamElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParamElement::attach_internals(__self: mut HTMLParamElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLParamElement::toggle_popover(__self: mut HTMLParamElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLParamElement::show_popover(__self: mut HTMLParamElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParamElement::hide_popover(__self: mut HTMLParamElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLParamElement::start_view_transition(__self: mut HTMLParamElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLParamElement::start_view_transition_f_prom_unit(__self: mut HTMLParamElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLParamElement::start_view_transition_mview_transition_options(__self: mut HTMLParamElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLParamElement::as_js(self: HTMLParamElement) -> JsValue = JsValue::unsafe_from[HTMLParamElement](self)

pub fun HTMLParamElement::from_js(v: JsValue) -> mut HTMLParamElement = JsValue::unsafe_as[mut HTMLParamElement](v)

pub val PermissionState::Granted: String = "granted"
pub val PermissionState::Denied: String = "denied"
pub val PermissionState::Prompt: String = "prompt"

struct HTMLPermissionElement()

/// Converts a reference to 'HTMLPermissionElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::as_html_element(self: HTMLPermissionElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLPermissionElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::as_mhtml_element(self: mut HTMLPermissionElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLPermissionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPermissionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::from_html_element(base: HTMLElement) -> HTMLPermissionElement = "
    if(#var(base) instanceof HTMLPermissionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPermissionElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLPermissionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPermissionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLPermissionElement = "
    if(#var(base) instanceof HTMLPermissionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPermissionElement'!\");
"

/// Converts a reference to 'HTMLPermissionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::as_element(self: HTMLPermissionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLPermissionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::as_melement(self: mut HTMLPermissionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLPermissionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPermissionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::from_element(base: Element) -> HTMLPermissionElement = "
    if(#var(base) instanceof HTMLPermissionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPermissionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLPermissionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPermissionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPermissionElement::from_melement(base: mut Element) -> mut HTMLPermissionElement = "
    if(#var(base) instanceof HTMLPermissionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPermissionElement'!\");
"

pub ext fun HTMLPermissionElement::new() -> mut HTMLPermissionElement
    = "return new HTMLPermissionElement();"

pub ext fun HTMLPermissionElement::type(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLPermissionElement::set_type(self: mut HTMLPermissionElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::is_valid(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isValid);"

pub ext fun HTMLPermissionElement::invalid_reason(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).invalidReason);"

pub ext fun HTMLPermissionElement::initial_permission_status(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).initialPermissionStatus);"

pub ext fun HTMLPermissionElement::permission_status(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).permissionStatus);"

pub ext fun HTMLPermissionElement::onresolve(self: HTMLPermissionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresolve);"

pub ext fun HTMLPermissionElement::set_onresolve(self: mut HTMLPermissionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresolve = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::ondismiss(self: HTMLPermissionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondismiss);"

pub ext fun HTMLPermissionElement::set_ondismiss(self: mut HTMLPermissionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondismiss = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::onpromptaction(self: HTMLPermissionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpromptaction);"

pub ext fun HTMLPermissionElement::set_onpromptaction(self: mut HTMLPermissionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpromptaction = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::onpromptdismiss(self: HTMLPermissionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpromptdismiss);"

pub ext fun HTMLPermissionElement::set_onpromptdismiss(self: mut HTMLPermissionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpromptdismiss = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::onvalidationstatuschange(self: HTMLPermissionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvalidationstatuschange);"

pub ext fun HTMLPermissionElement::set_onvalidationstatuschange(self: mut HTMLPermissionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvalidationstatuschange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::title(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLPermissionElement::set_title(self: mut HTMLPermissionElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::lang(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLPermissionElement::set_lang(self: mut HTMLPermissionElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::translate(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLPermissionElement::set_translate(self: mut HTMLPermissionElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::dir(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLPermissionElement::set_dir(self: mut HTMLPermissionElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::hidden(self: HTMLPermissionElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLPermissionElement::set_hidden(self: mut HTMLPermissionElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLPermissionElement::inert(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLPermissionElement::set_inert(self: mut HTMLPermissionElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::access_key(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLPermissionElement::set_access_key(self: mut HTMLPermissionElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::draggable(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLPermissionElement::set_draggable(self: mut HTMLPermissionElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::spellcheck(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLPermissionElement::set_spellcheck(self: mut HTMLPermissionElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::autocapitalize(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLPermissionElement::set_autocapitalize(self: mut HTMLPermissionElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::edit_context(self: HTMLPermissionElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLPermissionElement::set_edit_context(self: mut HTMLPermissionElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLPermissionElement::content_editable(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLPermissionElement::set_content_editable(self: mut HTMLPermissionElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::enter_key_hint(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLPermissionElement::set_enter_key_hint(self: mut HTMLPermissionElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::is_content_editable(self: HTMLPermissionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLPermissionElement::input_mode(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLPermissionElement::set_input_mode(self: mut HTMLPermissionElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::virtual_keyboard_policy(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLPermissionElement::set_virtual_keyboard_policy(self: mut HTMLPermissionElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::scroll_parent(self: HTMLPermissionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLPermissionElement::offset_parent(self: HTMLPermissionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLPermissionElement::offset_top(self: HTMLPermissionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLPermissionElement::offset_left(self: HTMLPermissionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLPermissionElement::offset_width(self: HTMLPermissionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLPermissionElement::offset_height(self: HTMLPermissionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLPermissionElement::popover(self: HTMLPermissionElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLPermissionElement::set_popover(self: mut HTMLPermissionElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLPermissionElement::inner_text(self: HTMLPermissionElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLPermissionElement::set_inner_text(self: mut HTMLPermissionElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLPermissionElement::outer_text(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLPermissionElement::set_outer_text(self: mut HTMLPermissionElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::writing_suggestions(self: HTMLPermissionElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLPermissionElement::set_writing_suggestions(self: mut HTMLPermissionElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPermissionElement::is_type_supported(type: String) -> Bool = "
    const r = HTMLPermissionElement.isTypeSupported(#fun(String::as_js)(#var(type)));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLPermissionElement::click(__self: mut HTMLPermissionElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPermissionElement::attach_internals(__self: mut HTMLPermissionElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLPermissionElement::toggle_popover(__self: mut HTMLPermissionElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLPermissionElement::show_popover(__self: mut HTMLPermissionElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPermissionElement::hide_popover(__self: mut HTMLPermissionElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPermissionElement::start_view_transition(__self: mut HTMLPermissionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPermissionElement::start_view_transition_f_prom_unit(__self: mut HTMLPermissionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPermissionElement::start_view_transition_mview_transition_options(__self: mut HTMLPermissionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLPermissionElement::as_js(self: HTMLPermissionElement) -> JsValue = JsValue::unsafe_from[HTMLPermissionElement](self)

pub fun HTMLPermissionElement::from_js(v: JsValue) -> mut HTMLPermissionElement = JsValue::unsafe_as[mut HTMLPermissionElement](v)

struct HTMLPictureElement()

/// Converts a reference to 'HTMLPictureElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::as_html_element(self: HTMLPictureElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLPictureElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::as_mhtml_element(self: mut HTMLPictureElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLPictureElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPictureElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::from_html_element(base: HTMLElement) -> HTMLPictureElement = "
    if(#var(base) instanceof HTMLPictureElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPictureElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLPictureElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPictureElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLPictureElement = "
    if(#var(base) instanceof HTMLPictureElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPictureElement'!\");
"

/// Converts a reference to 'HTMLPictureElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::as_element(self: HTMLPictureElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLPictureElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::as_melement(self: mut HTMLPictureElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLPictureElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPictureElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::from_element(base: Element) -> HTMLPictureElement = "
    if(#var(base) instanceof HTMLPictureElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPictureElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLPictureElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPictureElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPictureElement::from_melement(base: mut Element) -> mut HTMLPictureElement = "
    if(#var(base) instanceof HTMLPictureElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPictureElement'!\");
"

pub ext fun HTMLPictureElement::title(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLPictureElement::set_title(self: mut HTMLPictureElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::lang(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLPictureElement::set_lang(self: mut HTMLPictureElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::translate(self: HTMLPictureElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLPictureElement::set_translate(self: mut HTMLPictureElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPictureElement::dir(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLPictureElement::set_dir(self: mut HTMLPictureElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::hidden(self: HTMLPictureElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLPictureElement::set_hidden(self: mut HTMLPictureElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLPictureElement::inert(self: HTMLPictureElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLPictureElement::set_inert(self: mut HTMLPictureElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPictureElement::access_key(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLPictureElement::set_access_key(self: mut HTMLPictureElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::draggable(self: HTMLPictureElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLPictureElement::set_draggable(self: mut HTMLPictureElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPictureElement::spellcheck(self: HTMLPictureElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLPictureElement::set_spellcheck(self: mut HTMLPictureElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPictureElement::autocapitalize(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLPictureElement::set_autocapitalize(self: mut HTMLPictureElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::edit_context(self: HTMLPictureElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLPictureElement::set_edit_context(self: mut HTMLPictureElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLPictureElement::content_editable(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLPictureElement::set_content_editable(self: mut HTMLPictureElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::enter_key_hint(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLPictureElement::set_enter_key_hint(self: mut HTMLPictureElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::is_content_editable(self: HTMLPictureElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLPictureElement::input_mode(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLPictureElement::set_input_mode(self: mut HTMLPictureElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::virtual_keyboard_policy(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLPictureElement::set_virtual_keyboard_policy(self: mut HTMLPictureElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::scroll_parent(self: HTMLPictureElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLPictureElement::offset_parent(self: HTMLPictureElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLPictureElement::offset_top(self: HTMLPictureElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLPictureElement::offset_left(self: HTMLPictureElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLPictureElement::offset_width(self: HTMLPictureElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLPictureElement::offset_height(self: HTMLPictureElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLPictureElement::popover(self: HTMLPictureElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLPictureElement::set_popover(self: mut HTMLPictureElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLPictureElement::inner_text(self: HTMLPictureElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLPictureElement::set_inner_text(self: mut HTMLPictureElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLPictureElement::outer_text(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLPictureElement::set_outer_text(self: mut HTMLPictureElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::writing_suggestions(self: HTMLPictureElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLPictureElement::set_writing_suggestions(self: mut HTMLPictureElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPictureElement::click(__self: mut HTMLPictureElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPictureElement::attach_internals(__self: mut HTMLPictureElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLPictureElement::toggle_popover(__self: mut HTMLPictureElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLPictureElement::show_popover(__self: mut HTMLPictureElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPictureElement::hide_popover(__self: mut HTMLPictureElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPictureElement::start_view_transition(__self: mut HTMLPictureElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPictureElement::start_view_transition_f_prom_unit(__self: mut HTMLPictureElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPictureElement::start_view_transition_mview_transition_options(__self: mut HTMLPictureElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLPictureElement::as_js(self: HTMLPictureElement) -> JsValue = JsValue::unsafe_from[HTMLPictureElement](self)

pub fun HTMLPictureElement::from_js(v: JsValue) -> mut HTMLPictureElement = JsValue::unsafe_as[mut HTMLPictureElement](v)

struct HTMLPreElement()

/// Converts a reference to 'HTMLPreElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::as_html_element(self: HTMLPreElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLPreElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::as_mhtml_element(self: mut HTMLPreElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLPreElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPreElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::from_html_element(base: HTMLElement) -> HTMLPreElement = "
    if(#var(base) instanceof HTMLPreElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPreElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLPreElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPreElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLPreElement = "
    if(#var(base) instanceof HTMLPreElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLPreElement'!\");
"

/// Converts a reference to 'HTMLPreElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::as_element(self: HTMLPreElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLPreElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::as_melement(self: mut HTMLPreElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLPreElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPreElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::from_element(base: Element) -> HTMLPreElement = "
    if(#var(base) instanceof HTMLPreElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPreElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLPreElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLPreElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLPreElement::from_melement(base: mut Element) -> mut HTMLPreElement = "
    if(#var(base) instanceof HTMLPreElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLPreElement'!\");
"

pub ext fun HTMLPreElement::width(self: HTMLPreElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLPreElement::set_width(self: mut HTMLPreElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLPreElement::title(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLPreElement::set_title(self: mut HTMLPreElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::lang(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLPreElement::set_lang(self: mut HTMLPreElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::translate(self: HTMLPreElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLPreElement::set_translate(self: mut HTMLPreElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPreElement::dir(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLPreElement::set_dir(self: mut HTMLPreElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::hidden(self: HTMLPreElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLPreElement::set_hidden(self: mut HTMLPreElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLPreElement::inert(self: HTMLPreElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLPreElement::set_inert(self: mut HTMLPreElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPreElement::access_key(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLPreElement::set_access_key(self: mut HTMLPreElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::draggable(self: HTMLPreElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLPreElement::set_draggable(self: mut HTMLPreElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPreElement::spellcheck(self: HTMLPreElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLPreElement::set_spellcheck(self: mut HTMLPreElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLPreElement::autocapitalize(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLPreElement::set_autocapitalize(self: mut HTMLPreElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::edit_context(self: HTMLPreElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLPreElement::set_edit_context(self: mut HTMLPreElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLPreElement::content_editable(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLPreElement::set_content_editable(self: mut HTMLPreElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::enter_key_hint(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLPreElement::set_enter_key_hint(self: mut HTMLPreElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::is_content_editable(self: HTMLPreElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLPreElement::input_mode(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLPreElement::set_input_mode(self: mut HTMLPreElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::virtual_keyboard_policy(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLPreElement::set_virtual_keyboard_policy(self: mut HTMLPreElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::scroll_parent(self: HTMLPreElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLPreElement::offset_parent(self: HTMLPreElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLPreElement::offset_top(self: HTMLPreElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLPreElement::offset_left(self: HTMLPreElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLPreElement::offset_width(self: HTMLPreElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLPreElement::offset_height(self: HTMLPreElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLPreElement::popover(self: HTMLPreElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLPreElement::set_popover(self: mut HTMLPreElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLPreElement::inner_text(self: HTMLPreElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLPreElement::set_inner_text(self: mut HTMLPreElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLPreElement::outer_text(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLPreElement::set_outer_text(self: mut HTMLPreElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::writing_suggestions(self: HTMLPreElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLPreElement::set_writing_suggestions(self: mut HTMLPreElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLPreElement::click(__self: mut HTMLPreElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPreElement::attach_internals(__self: mut HTMLPreElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLPreElement::toggle_popover(__self: mut HTMLPreElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLPreElement::show_popover(__self: mut HTMLPreElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPreElement::hide_popover(__self: mut HTMLPreElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLPreElement::start_view_transition(__self: mut HTMLPreElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPreElement::start_view_transition_f_prom_unit(__self: mut HTMLPreElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLPreElement::start_view_transition_mview_transition_options(__self: mut HTMLPreElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLPreElement::as_js(self: HTMLPreElement) -> JsValue = JsValue::unsafe_from[HTMLPreElement](self)

pub fun HTMLPreElement::from_js(v: JsValue) -> mut HTMLPreElement = JsValue::unsafe_as[mut HTMLPreElement](v)

struct HTMLProgressElement()

/// Converts a reference to 'HTMLProgressElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::as_html_element(self: HTMLProgressElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLProgressElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::as_mhtml_element(self: mut HTMLProgressElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLProgressElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLProgressElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::from_html_element(base: HTMLElement) -> HTMLProgressElement = "
    if(#var(base) instanceof HTMLProgressElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLProgressElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLProgressElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLProgressElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLProgressElement = "
    if(#var(base) instanceof HTMLProgressElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLProgressElement'!\");
"

/// Converts a reference to 'HTMLProgressElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::as_element(self: HTMLProgressElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLProgressElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::as_melement(self: mut HTMLProgressElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLProgressElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLProgressElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::from_element(base: Element) -> HTMLProgressElement = "
    if(#var(base) instanceof HTMLProgressElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLProgressElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLProgressElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLProgressElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLProgressElement::from_melement(base: mut Element) -> mut HTMLProgressElement = "
    if(#var(base) instanceof HTMLProgressElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLProgressElement'!\");
"

pub ext fun HTMLProgressElement::value(self: HTMLProgressElement) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun HTMLProgressElement::set_value(self: mut HTMLProgressElement, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLProgressElement::max(self: HTMLProgressElement) -> Float
    = "return #fun(Float::from_js)(#var(self).max);"

pub ext fun HTMLProgressElement::set_max(self: mut HTMLProgressElement, value: Float)
    = "#var(self).max = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLProgressElement::position(self: HTMLProgressElement) -> Float
    = "return #fun(Float::from_js)(#var(self).position);"

pub ext fun HTMLProgressElement::labels(self: HTMLProgressElement) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).labels);"

pub ext fun HTMLProgressElement::title(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLProgressElement::set_title(self: mut HTMLProgressElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::lang(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLProgressElement::set_lang(self: mut HTMLProgressElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::translate(self: HTMLProgressElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLProgressElement::set_translate(self: mut HTMLProgressElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLProgressElement::dir(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLProgressElement::set_dir(self: mut HTMLProgressElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::hidden(self: HTMLProgressElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLProgressElement::set_hidden(self: mut HTMLProgressElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLProgressElement::inert(self: HTMLProgressElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLProgressElement::set_inert(self: mut HTMLProgressElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLProgressElement::access_key(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLProgressElement::set_access_key(self: mut HTMLProgressElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::draggable(self: HTMLProgressElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLProgressElement::set_draggable(self: mut HTMLProgressElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLProgressElement::spellcheck(self: HTMLProgressElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLProgressElement::set_spellcheck(self: mut HTMLProgressElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLProgressElement::autocapitalize(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLProgressElement::set_autocapitalize(self: mut HTMLProgressElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::edit_context(self: HTMLProgressElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLProgressElement::set_edit_context(self: mut HTMLProgressElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLProgressElement::content_editable(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLProgressElement::set_content_editable(self: mut HTMLProgressElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::enter_key_hint(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLProgressElement::set_enter_key_hint(self: mut HTMLProgressElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::is_content_editable(self: HTMLProgressElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLProgressElement::input_mode(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLProgressElement::set_input_mode(self: mut HTMLProgressElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::virtual_keyboard_policy(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLProgressElement::set_virtual_keyboard_policy(self: mut HTMLProgressElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::scroll_parent(self: HTMLProgressElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLProgressElement::offset_parent(self: HTMLProgressElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLProgressElement::offset_top(self: HTMLProgressElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLProgressElement::offset_left(self: HTMLProgressElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLProgressElement::offset_width(self: HTMLProgressElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLProgressElement::offset_height(self: HTMLProgressElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLProgressElement::popover(self: HTMLProgressElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLProgressElement::set_popover(self: mut HTMLProgressElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLProgressElement::inner_text(self: HTMLProgressElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLProgressElement::set_inner_text(self: mut HTMLProgressElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLProgressElement::outer_text(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLProgressElement::set_outer_text(self: mut HTMLProgressElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::writing_suggestions(self: HTMLProgressElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLProgressElement::set_writing_suggestions(self: mut HTMLProgressElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLProgressElement::click(__self: mut HTMLProgressElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLProgressElement::attach_internals(__self: mut HTMLProgressElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLProgressElement::toggle_popover(__self: mut HTMLProgressElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLProgressElement::show_popover(__self: mut HTMLProgressElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLProgressElement::hide_popover(__self: mut HTMLProgressElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLProgressElement::start_view_transition(__self: mut HTMLProgressElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLProgressElement::start_view_transition_f_prom_unit(__self: mut HTMLProgressElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLProgressElement::start_view_transition_mview_transition_options(__self: mut HTMLProgressElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLProgressElement::as_js(self: HTMLProgressElement) -> JsValue = JsValue::unsafe_from[HTMLProgressElement](self)

pub fun HTMLProgressElement::from_js(v: JsValue) -> mut HTMLProgressElement = JsValue::unsafe_as[mut HTMLProgressElement](v)

struct HTMLQuoteElement()

/// Converts a reference to 'HTMLQuoteElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::as_html_element(self: HTMLQuoteElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLQuoteElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::as_mhtml_element(self: mut HTMLQuoteElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLQuoteElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLQuoteElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::from_html_element(base: HTMLElement) -> HTMLQuoteElement = "
    if(#var(base) instanceof HTMLQuoteElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLQuoteElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLQuoteElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLQuoteElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLQuoteElement = "
    if(#var(base) instanceof HTMLQuoteElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLQuoteElement'!\");
"

/// Converts a reference to 'HTMLQuoteElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::as_element(self: HTMLQuoteElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLQuoteElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::as_melement(self: mut HTMLQuoteElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLQuoteElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLQuoteElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::from_element(base: Element) -> HTMLQuoteElement = "
    if(#var(base) instanceof HTMLQuoteElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLQuoteElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLQuoteElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLQuoteElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLQuoteElement::from_melement(base: mut Element) -> mut HTMLQuoteElement = "
    if(#var(base) instanceof HTMLQuoteElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLQuoteElement'!\");
"

pub ext fun HTMLQuoteElement::cite(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).cite);"

pub ext fun HTMLQuoteElement::set_cite(self: mut HTMLQuoteElement, value: String)
    = "#var(self).cite = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::title(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLQuoteElement::set_title(self: mut HTMLQuoteElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::lang(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLQuoteElement::set_lang(self: mut HTMLQuoteElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::translate(self: HTMLQuoteElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLQuoteElement::set_translate(self: mut HTMLQuoteElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::dir(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLQuoteElement::set_dir(self: mut HTMLQuoteElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::hidden(self: HTMLQuoteElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLQuoteElement::set_hidden(self: mut HTMLQuoteElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLQuoteElement::inert(self: HTMLQuoteElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLQuoteElement::set_inert(self: mut HTMLQuoteElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::access_key(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLQuoteElement::set_access_key(self: mut HTMLQuoteElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::draggable(self: HTMLQuoteElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLQuoteElement::set_draggable(self: mut HTMLQuoteElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::spellcheck(self: HTMLQuoteElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLQuoteElement::set_spellcheck(self: mut HTMLQuoteElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::autocapitalize(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLQuoteElement::set_autocapitalize(self: mut HTMLQuoteElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::edit_context(self: HTMLQuoteElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLQuoteElement::set_edit_context(self: mut HTMLQuoteElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLQuoteElement::content_editable(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLQuoteElement::set_content_editable(self: mut HTMLQuoteElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::enter_key_hint(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLQuoteElement::set_enter_key_hint(self: mut HTMLQuoteElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::is_content_editable(self: HTMLQuoteElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLQuoteElement::input_mode(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLQuoteElement::set_input_mode(self: mut HTMLQuoteElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::virtual_keyboard_policy(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLQuoteElement::set_virtual_keyboard_policy(self: mut HTMLQuoteElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::scroll_parent(self: HTMLQuoteElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLQuoteElement::offset_parent(self: HTMLQuoteElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLQuoteElement::offset_top(self: HTMLQuoteElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLQuoteElement::offset_left(self: HTMLQuoteElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLQuoteElement::offset_width(self: HTMLQuoteElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLQuoteElement::offset_height(self: HTMLQuoteElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLQuoteElement::popover(self: HTMLQuoteElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLQuoteElement::set_popover(self: mut HTMLQuoteElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLQuoteElement::inner_text(self: HTMLQuoteElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLQuoteElement::set_inner_text(self: mut HTMLQuoteElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLQuoteElement::outer_text(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLQuoteElement::set_outer_text(self: mut HTMLQuoteElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::writing_suggestions(self: HTMLQuoteElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLQuoteElement::set_writing_suggestions(self: mut HTMLQuoteElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLQuoteElement::click(__self: mut HTMLQuoteElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLQuoteElement::attach_internals(__self: mut HTMLQuoteElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLQuoteElement::toggle_popover(__self: mut HTMLQuoteElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLQuoteElement::show_popover(__self: mut HTMLQuoteElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLQuoteElement::hide_popover(__self: mut HTMLQuoteElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLQuoteElement::start_view_transition(__self: mut HTMLQuoteElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLQuoteElement::start_view_transition_f_prom_unit(__self: mut HTMLQuoteElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLQuoteElement::start_view_transition_mview_transition_options(__self: mut HTMLQuoteElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLQuoteElement::as_js(self: HTMLQuoteElement) -> JsValue = JsValue::unsafe_from[HTMLQuoteElement](self)

pub fun HTMLQuoteElement::from_js(v: JsValue) -> mut HTMLQuoteElement = JsValue::unsafe_as[mut HTMLQuoteElement](v)

struct HTMLScriptElement()

/// Converts a reference to 'HTMLScriptElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::as_html_element(self: HTMLScriptElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLScriptElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::as_mhtml_element(self: mut HTMLScriptElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::from_html_element(base: HTMLElement) -> HTMLScriptElement = "
    if(#var(base) instanceof HTMLScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLScriptElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLScriptElement = "
    if(#var(base) instanceof HTMLScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLScriptElement'!\");
"

/// Converts a reference to 'HTMLScriptElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::as_element(self: HTMLScriptElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLScriptElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::as_melement(self: mut HTMLScriptElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::from_element(base: Element) -> HTMLScriptElement = "
    if(#var(base) instanceof HTMLScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLScriptElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLScriptElement::from_melement(base: mut Element) -> mut HTMLScriptElement = "
    if(#var(base) instanceof HTMLScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLScriptElement'!\");
"

pub ext fun HTMLScriptElement::src(self: HTMLScriptElement) -> JsValue
    = "return #var(self).src;"

pub ext fun HTMLScriptElement::set_src(self: mut HTMLScriptElement, value: JsValue)
    = "#var(self).src = #var(value);"

pub ext fun HTMLScriptElement::type(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLScriptElement::set_type(self: mut HTMLScriptElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::no_module(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noModule);"

pub ext fun HTMLScriptElement::set_no_module(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).noModule = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::charset(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun HTMLScriptElement::set_charset(self: mut HTMLScriptElement, value: String)
    = "#var(self).charset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::async(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).async);"

pub ext fun HTMLScriptElement::set_async(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).async = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::defer(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defer);"

pub ext fun HTMLScriptElement::set_defer(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).defer = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::cross_origin(self: HTMLScriptElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLScriptElement::set_cross_origin(self: mut HTMLScriptElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLScriptElement::text(self: HTMLScriptElement) -> JsValue
    = "return #var(self).text;"

pub ext fun HTMLScriptElement::set_text(self: mut HTMLScriptElement, value: JsValue)
    = "#var(self).text = #var(value);"

pub ext fun HTMLScriptElement::referrer_policy(self: HTMLScriptElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).referrerPolicy);"

pub ext fun HTMLScriptElement::set_referrer_policy(self: mut HTMLScriptElement, value: Option[String])
    = "#var(self).referrerPolicy = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLScriptElement::fetch_priority(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).fetchPriority);"

pub ext fun HTMLScriptElement::set_fetch_priority(self: mut HTMLScriptElement, value: String)
    = "#var(self).fetchPriority = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::event(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).event);"

pub ext fun HTMLScriptElement::set_event(self: mut HTMLScriptElement, value: String)
    = "#var(self).event = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::html_for(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).htmlFor);"

pub ext fun HTMLScriptElement::set_html_for(self: mut HTMLScriptElement, value: String)
    = "#var(self).htmlFor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::integrity(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).integrity);"

pub ext fun HTMLScriptElement::set_integrity(self: mut HTMLScriptElement, value: String)
    = "#var(self).integrity = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::signature(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).signature);"

pub ext fun HTMLScriptElement::set_signature(self: mut HTMLScriptElement, value: String)
    = "#var(self).signature = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::blocking(self: HTMLScriptElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).blocking);"

pub ext fun HTMLScriptElement::title(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLScriptElement::set_title(self: mut HTMLScriptElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::lang(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLScriptElement::set_lang(self: mut HTMLScriptElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::translate(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLScriptElement::set_translate(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::dir(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLScriptElement::set_dir(self: mut HTMLScriptElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::hidden(self: HTMLScriptElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLScriptElement::set_hidden(self: mut HTMLScriptElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLScriptElement::inert(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLScriptElement::set_inert(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::access_key(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLScriptElement::set_access_key(self: mut HTMLScriptElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::draggable(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLScriptElement::set_draggable(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::spellcheck(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLScriptElement::set_spellcheck(self: mut HTMLScriptElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLScriptElement::autocapitalize(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLScriptElement::set_autocapitalize(self: mut HTMLScriptElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::edit_context(self: HTMLScriptElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLScriptElement::set_edit_context(self: mut HTMLScriptElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLScriptElement::content_editable(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLScriptElement::set_content_editable(self: mut HTMLScriptElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::enter_key_hint(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLScriptElement::set_enter_key_hint(self: mut HTMLScriptElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::is_content_editable(self: HTMLScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLScriptElement::input_mode(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLScriptElement::set_input_mode(self: mut HTMLScriptElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::virtual_keyboard_policy(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLScriptElement::set_virtual_keyboard_policy(self: mut HTMLScriptElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::scroll_parent(self: HTMLScriptElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLScriptElement::offset_parent(self: HTMLScriptElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLScriptElement::offset_top(self: HTMLScriptElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLScriptElement::offset_left(self: HTMLScriptElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLScriptElement::offset_width(self: HTMLScriptElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLScriptElement::offset_height(self: HTMLScriptElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLScriptElement::popover(self: HTMLScriptElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLScriptElement::set_popover(self: mut HTMLScriptElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLScriptElement::inner_text(self: HTMLScriptElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLScriptElement::set_inner_text(self: mut HTMLScriptElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLScriptElement::outer_text(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLScriptElement::set_outer_text(self: mut HTMLScriptElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::writing_suggestions(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLScriptElement::set_writing_suggestions(self: mut HTMLScriptElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::attribution_src(self: HTMLScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).attributionSrc);"

pub ext fun HTMLScriptElement::set_attribution_src(self: mut HTMLScriptElement, value: String)
    = "#var(self).attributionSrc = #fun(String::as_js)(#var(value));"

pub ext fun HTMLScriptElement::supports(type: String) -> Bool = "
    const r = HTMLScriptElement.supports(#fun(String::as_js)(#var(type)));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLScriptElement::click(__self: mut HTMLScriptElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLScriptElement::attach_internals(__self: mut HTMLScriptElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLScriptElement::toggle_popover(__self: mut HTMLScriptElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLScriptElement::show_popover(__self: mut HTMLScriptElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLScriptElement::hide_popover(__self: mut HTMLScriptElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLScriptElement::start_view_transition(__self: mut HTMLScriptElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLScriptElement::start_view_transition_f_prom_unit(__self: mut HTMLScriptElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLScriptElement::start_view_transition_mview_transition_options(__self: mut HTMLScriptElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLScriptElement::as_js(self: HTMLScriptElement) -> JsValue = JsValue::unsafe_from[HTMLScriptElement](self)

pub fun HTMLScriptElement::from_js(v: JsValue) -> mut HTMLScriptElement = JsValue::unsafe_as[mut HTMLScriptElement](v)

struct HTMLSlotElement()

/// Converts a reference to 'HTMLSlotElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::as_html_element(self: HTMLSlotElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLSlotElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::as_mhtml_element(self: mut HTMLSlotElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLSlotElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSlotElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::from_html_element(base: HTMLElement) -> HTMLSlotElement = "
    if(#var(base) instanceof HTMLSlotElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSlotElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLSlotElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSlotElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLSlotElement = "
    if(#var(base) instanceof HTMLSlotElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSlotElement'!\");
"

/// Converts a reference to 'HTMLSlotElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::as_element(self: HTMLSlotElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLSlotElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::as_melement(self: mut HTMLSlotElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLSlotElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSlotElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::from_element(base: Element) -> HTMLSlotElement = "
    if(#var(base) instanceof HTMLSlotElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSlotElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLSlotElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSlotElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSlotElement::from_melement(base: mut Element) -> mut HTMLSlotElement = "
    if(#var(base) instanceof HTMLSlotElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSlotElement'!\");
"

pub ext fun HTMLSlotElement::name(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun HTMLSlotElement::set_name(self: mut HTMLSlotElement, value: String)
    = "#var(self).name = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::title(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLSlotElement::set_title(self: mut HTMLSlotElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::lang(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLSlotElement::set_lang(self: mut HTMLSlotElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::translate(self: HTMLSlotElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLSlotElement::set_translate(self: mut HTMLSlotElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSlotElement::dir(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLSlotElement::set_dir(self: mut HTMLSlotElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::hidden(self: HTMLSlotElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLSlotElement::set_hidden(self: mut HTMLSlotElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLSlotElement::inert(self: HTMLSlotElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLSlotElement::set_inert(self: mut HTMLSlotElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSlotElement::access_key(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLSlotElement::set_access_key(self: mut HTMLSlotElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::draggable(self: HTMLSlotElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLSlotElement::set_draggable(self: mut HTMLSlotElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSlotElement::spellcheck(self: HTMLSlotElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLSlotElement::set_spellcheck(self: mut HTMLSlotElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSlotElement::autocapitalize(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLSlotElement::set_autocapitalize(self: mut HTMLSlotElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::edit_context(self: HTMLSlotElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLSlotElement::set_edit_context(self: mut HTMLSlotElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLSlotElement::content_editable(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLSlotElement::set_content_editable(self: mut HTMLSlotElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::enter_key_hint(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLSlotElement::set_enter_key_hint(self: mut HTMLSlotElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::is_content_editable(self: HTMLSlotElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLSlotElement::input_mode(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLSlotElement::set_input_mode(self: mut HTMLSlotElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::virtual_keyboard_policy(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLSlotElement::set_virtual_keyboard_policy(self: mut HTMLSlotElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::scroll_parent(self: HTMLSlotElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLSlotElement::offset_parent(self: HTMLSlotElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLSlotElement::offset_top(self: HTMLSlotElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLSlotElement::offset_left(self: HTMLSlotElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLSlotElement::offset_width(self: HTMLSlotElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLSlotElement::offset_height(self: HTMLSlotElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLSlotElement::popover(self: HTMLSlotElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLSlotElement::set_popover(self: mut HTMLSlotElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLSlotElement::inner_text(self: HTMLSlotElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLSlotElement::set_inner_text(self: mut HTMLSlotElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLSlotElement::outer_text(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLSlotElement::set_outer_text(self: mut HTMLSlotElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::writing_suggestions(self: HTMLSlotElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLSlotElement::set_writing_suggestions(self: mut HTMLSlotElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSlotElement::assigned_nodes(__self: mut HTMLSlotElement, options: mut AssignedNodesOptions) -> List[mut Node] = "
    const r = #var(__self).assignedNodes(#fun(AssignedNodesOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut Node])(r);
"

pub ext fun HTMLSlotElement::assigned_elements(__self: mut HTMLSlotElement, options: mut AssignedNodesOptions) -> List[mut Element] = "
    const r = #var(__self).assignedElements(#fun(AssignedNodesOptions::as_js)(#var(options)));
    return #fun(List::from_js[mut Element])(r);
"

pub ext fun HTMLSlotElement::assign(__self: mut HTMLSlotElement, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).assign(...((#var(nodes)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSlotElement::click(__self: mut HTMLSlotElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSlotElement::attach_internals(__self: mut HTMLSlotElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLSlotElement::toggle_popover(__self: mut HTMLSlotElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSlotElement::show_popover(__self: mut HTMLSlotElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSlotElement::hide_popover(__self: mut HTMLSlotElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSlotElement::start_view_transition(__self: mut HTMLSlotElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSlotElement::start_view_transition_f_prom_unit(__self: mut HTMLSlotElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSlotElement::start_view_transition_mview_transition_options(__self: mut HTMLSlotElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLSlotElement::as_js(self: HTMLSlotElement) -> JsValue = JsValue::unsafe_from[HTMLSlotElement](self)

pub fun HTMLSlotElement::from_js(v: JsValue) -> mut HTMLSlotElement = JsValue::unsafe_as[mut HTMLSlotElement](v)

struct HTMLSourceElement()

/// Converts a reference to 'HTMLSourceElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::as_html_element(self: HTMLSourceElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLSourceElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::as_mhtml_element(self: mut HTMLSourceElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLSourceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSourceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::from_html_element(base: HTMLElement) -> HTMLSourceElement = "
    if(#var(base) instanceof HTMLSourceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSourceElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLSourceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSourceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLSourceElement = "
    if(#var(base) instanceof HTMLSourceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSourceElement'!\");
"

/// Converts a reference to 'HTMLSourceElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::as_element(self: HTMLSourceElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLSourceElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::as_melement(self: mut HTMLSourceElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLSourceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSourceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::from_element(base: Element) -> HTMLSourceElement = "
    if(#var(base) instanceof HTMLSourceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSourceElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLSourceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSourceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSourceElement::from_melement(base: mut Element) -> mut HTMLSourceElement = "
    if(#var(base) instanceof HTMLSourceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSourceElement'!\");
"

pub ext fun HTMLSourceElement::src(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLSourceElement::set_src(self: mut HTMLSourceElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::type(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLSourceElement::set_type(self: mut HTMLSourceElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::srcset(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).srcset);"

pub ext fun HTMLSourceElement::set_srcset(self: mut HTMLSourceElement, value: String)
    = "#var(self).srcset = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::sizes(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).sizes);"

pub ext fun HTMLSourceElement::set_sizes(self: mut HTMLSourceElement, value: String)
    = "#var(self).sizes = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::media(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun HTMLSourceElement::set_media(self: mut HTMLSourceElement, value: String)
    = "#var(self).media = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::width(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLSourceElement::set_width(self: mut HTMLSourceElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLSourceElement::height(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun HTMLSourceElement::set_height(self: mut HTMLSourceElement, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLSourceElement::title(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLSourceElement::set_title(self: mut HTMLSourceElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::lang(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLSourceElement::set_lang(self: mut HTMLSourceElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::translate(self: HTMLSourceElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLSourceElement::set_translate(self: mut HTMLSourceElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSourceElement::dir(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLSourceElement::set_dir(self: mut HTMLSourceElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::hidden(self: HTMLSourceElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLSourceElement::set_hidden(self: mut HTMLSourceElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLSourceElement::inert(self: HTMLSourceElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLSourceElement::set_inert(self: mut HTMLSourceElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSourceElement::access_key(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLSourceElement::set_access_key(self: mut HTMLSourceElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::draggable(self: HTMLSourceElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLSourceElement::set_draggable(self: mut HTMLSourceElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSourceElement::spellcheck(self: HTMLSourceElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLSourceElement::set_spellcheck(self: mut HTMLSourceElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSourceElement::autocapitalize(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLSourceElement::set_autocapitalize(self: mut HTMLSourceElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::edit_context(self: HTMLSourceElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLSourceElement::set_edit_context(self: mut HTMLSourceElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLSourceElement::content_editable(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLSourceElement::set_content_editable(self: mut HTMLSourceElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::enter_key_hint(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLSourceElement::set_enter_key_hint(self: mut HTMLSourceElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::is_content_editable(self: HTMLSourceElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLSourceElement::input_mode(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLSourceElement::set_input_mode(self: mut HTMLSourceElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::virtual_keyboard_policy(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLSourceElement::set_virtual_keyboard_policy(self: mut HTMLSourceElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::scroll_parent(self: HTMLSourceElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLSourceElement::offset_parent(self: HTMLSourceElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLSourceElement::offset_top(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLSourceElement::offset_left(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLSourceElement::offset_width(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLSourceElement::offset_height(self: HTMLSourceElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLSourceElement::popover(self: HTMLSourceElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLSourceElement::set_popover(self: mut HTMLSourceElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLSourceElement::inner_text(self: HTMLSourceElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLSourceElement::set_inner_text(self: mut HTMLSourceElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLSourceElement::outer_text(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLSourceElement::set_outer_text(self: mut HTMLSourceElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::writing_suggestions(self: HTMLSourceElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLSourceElement::set_writing_suggestions(self: mut HTMLSourceElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSourceElement::click(__self: mut HTMLSourceElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSourceElement::attach_internals(__self: mut HTMLSourceElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLSourceElement::toggle_popover(__self: mut HTMLSourceElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSourceElement::show_popover(__self: mut HTMLSourceElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSourceElement::hide_popover(__self: mut HTMLSourceElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSourceElement::start_view_transition(__self: mut HTMLSourceElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSourceElement::start_view_transition_f_prom_unit(__self: mut HTMLSourceElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSourceElement::start_view_transition_mview_transition_options(__self: mut HTMLSourceElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLSourceElement::as_js(self: HTMLSourceElement) -> JsValue = JsValue::unsafe_from[HTMLSourceElement](self)

pub fun HTMLSourceElement::from_js(v: JsValue) -> mut HTMLSourceElement = JsValue::unsafe_as[mut HTMLSourceElement](v)

struct HTMLSpanElement()

/// Converts a reference to 'HTMLSpanElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::as_html_element(self: HTMLSpanElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLSpanElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::as_mhtml_element(self: mut HTMLSpanElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::from_html_element(base: HTMLElement) -> HTMLSpanElement = "
    if(#var(base) instanceof HTMLSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLSpanElement = "
    if(#var(base) instanceof HTMLSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLSpanElement'!\");
"

/// Converts a reference to 'HTMLSpanElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::as_element(self: HTMLSpanElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLSpanElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::as_melement(self: mut HTMLSpanElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::from_element(base: Element) -> HTMLSpanElement = "
    if(#var(base) instanceof HTMLSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLSpanElement::from_melement(base: mut Element) -> mut HTMLSpanElement = "
    if(#var(base) instanceof HTMLSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLSpanElement'!\");
"

pub ext fun HTMLSpanElement::title(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLSpanElement::set_title(self: mut HTMLSpanElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::lang(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLSpanElement::set_lang(self: mut HTMLSpanElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::translate(self: HTMLSpanElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLSpanElement::set_translate(self: mut HTMLSpanElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSpanElement::dir(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLSpanElement::set_dir(self: mut HTMLSpanElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::hidden(self: HTMLSpanElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLSpanElement::set_hidden(self: mut HTMLSpanElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLSpanElement::inert(self: HTMLSpanElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLSpanElement::set_inert(self: mut HTMLSpanElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSpanElement::access_key(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLSpanElement::set_access_key(self: mut HTMLSpanElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::draggable(self: HTMLSpanElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLSpanElement::set_draggable(self: mut HTMLSpanElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSpanElement::spellcheck(self: HTMLSpanElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLSpanElement::set_spellcheck(self: mut HTMLSpanElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLSpanElement::autocapitalize(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLSpanElement::set_autocapitalize(self: mut HTMLSpanElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::edit_context(self: HTMLSpanElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLSpanElement::set_edit_context(self: mut HTMLSpanElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLSpanElement::content_editable(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLSpanElement::set_content_editable(self: mut HTMLSpanElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::enter_key_hint(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLSpanElement::set_enter_key_hint(self: mut HTMLSpanElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::is_content_editable(self: HTMLSpanElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLSpanElement::input_mode(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLSpanElement::set_input_mode(self: mut HTMLSpanElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::virtual_keyboard_policy(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLSpanElement::set_virtual_keyboard_policy(self: mut HTMLSpanElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::scroll_parent(self: HTMLSpanElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLSpanElement::offset_parent(self: HTMLSpanElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLSpanElement::offset_top(self: HTMLSpanElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLSpanElement::offset_left(self: HTMLSpanElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLSpanElement::offset_width(self: HTMLSpanElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLSpanElement::offset_height(self: HTMLSpanElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLSpanElement::popover(self: HTMLSpanElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLSpanElement::set_popover(self: mut HTMLSpanElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLSpanElement::inner_text(self: HTMLSpanElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLSpanElement::set_inner_text(self: mut HTMLSpanElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLSpanElement::outer_text(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLSpanElement::set_outer_text(self: mut HTMLSpanElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::writing_suggestions(self: HTMLSpanElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLSpanElement::set_writing_suggestions(self: mut HTMLSpanElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLSpanElement::click(__self: mut HTMLSpanElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSpanElement::attach_internals(__self: mut HTMLSpanElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLSpanElement::toggle_popover(__self: mut HTMLSpanElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLSpanElement::show_popover(__self: mut HTMLSpanElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSpanElement::hide_popover(__self: mut HTMLSpanElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLSpanElement::start_view_transition(__self: mut HTMLSpanElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSpanElement::start_view_transition_f_prom_unit(__self: mut HTMLSpanElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLSpanElement::start_view_transition_mview_transition_options(__self: mut HTMLSpanElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLSpanElement::as_js(self: HTMLSpanElement) -> JsValue = JsValue::unsafe_from[HTMLSpanElement](self)

pub fun HTMLSpanElement::from_js(v: JsValue) -> mut HTMLSpanElement = JsValue::unsafe_as[mut HTMLSpanElement](v)

struct HTMLStyleElement()

/// Converts a reference to 'HTMLStyleElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::as_html_element(self: HTMLStyleElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLStyleElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::as_mhtml_element(self: mut HTMLStyleElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::from_html_element(base: HTMLElement) -> HTMLStyleElement = "
    if(#var(base) instanceof HTMLStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLStyleElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLStyleElement = "
    if(#var(base) instanceof HTMLStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLStyleElement'!\");
"

/// Converts a reference to 'HTMLStyleElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::as_element(self: HTMLStyleElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLStyleElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::as_melement(self: mut HTMLStyleElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::from_element(base: Element) -> HTMLStyleElement = "
    if(#var(base) instanceof HTMLStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLStyleElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLStyleElement::from_melement(base: mut Element) -> mut HTMLStyleElement = "
    if(#var(base) instanceof HTMLStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLStyleElement'!\");
"

pub ext fun HTMLStyleElement::disabled(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun HTMLStyleElement::set_disabled(self: mut HTMLStyleElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLStyleElement::media(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun HTMLStyleElement::set_media(self: mut HTMLStyleElement, value: String)
    = "#var(self).media = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::type(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLStyleElement::set_type(self: mut HTMLStyleElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::sheet(self: HTMLStyleElement) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).sheet);"

pub ext fun HTMLStyleElement::blocking(self: HTMLStyleElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).blocking);"

pub ext fun HTMLStyleElement::title(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLStyleElement::set_title(self: mut HTMLStyleElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::lang(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLStyleElement::set_lang(self: mut HTMLStyleElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::translate(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLStyleElement::set_translate(self: mut HTMLStyleElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLStyleElement::dir(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLStyleElement::set_dir(self: mut HTMLStyleElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::hidden(self: HTMLStyleElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLStyleElement::set_hidden(self: mut HTMLStyleElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLStyleElement::inert(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLStyleElement::set_inert(self: mut HTMLStyleElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLStyleElement::access_key(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLStyleElement::set_access_key(self: mut HTMLStyleElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::draggable(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLStyleElement::set_draggable(self: mut HTMLStyleElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLStyleElement::spellcheck(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLStyleElement::set_spellcheck(self: mut HTMLStyleElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLStyleElement::autocapitalize(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLStyleElement::set_autocapitalize(self: mut HTMLStyleElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::edit_context(self: HTMLStyleElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLStyleElement::set_edit_context(self: mut HTMLStyleElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLStyleElement::content_editable(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLStyleElement::set_content_editable(self: mut HTMLStyleElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::enter_key_hint(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLStyleElement::set_enter_key_hint(self: mut HTMLStyleElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::is_content_editable(self: HTMLStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLStyleElement::input_mode(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLStyleElement::set_input_mode(self: mut HTMLStyleElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::virtual_keyboard_policy(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLStyleElement::set_virtual_keyboard_policy(self: mut HTMLStyleElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::scroll_parent(self: HTMLStyleElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLStyleElement::offset_parent(self: HTMLStyleElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLStyleElement::offset_top(self: HTMLStyleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLStyleElement::offset_left(self: HTMLStyleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLStyleElement::offset_width(self: HTMLStyleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLStyleElement::offset_height(self: HTMLStyleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLStyleElement::popover(self: HTMLStyleElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLStyleElement::set_popover(self: mut HTMLStyleElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLStyleElement::inner_text(self: HTMLStyleElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLStyleElement::set_inner_text(self: mut HTMLStyleElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLStyleElement::outer_text(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLStyleElement::set_outer_text(self: mut HTMLStyleElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::writing_suggestions(self: HTMLStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLStyleElement::set_writing_suggestions(self: mut HTMLStyleElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLStyleElement::click(__self: mut HTMLStyleElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLStyleElement::attach_internals(__self: mut HTMLStyleElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLStyleElement::toggle_popover(__self: mut HTMLStyleElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLStyleElement::show_popover(__self: mut HTMLStyleElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLStyleElement::hide_popover(__self: mut HTMLStyleElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLStyleElement::start_view_transition(__self: mut HTMLStyleElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLStyleElement::start_view_transition_f_prom_unit(__self: mut HTMLStyleElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLStyleElement::start_view_transition_mview_transition_options(__self: mut HTMLStyleElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLStyleElement::as_js(self: HTMLStyleElement) -> JsValue = JsValue::unsafe_from[HTMLStyleElement](self)

pub fun HTMLStyleElement::from_js(v: JsValue) -> mut HTMLStyleElement = JsValue::unsafe_as[mut HTMLStyleElement](v)

struct HTMLTableCaptionElement()

/// Converts a reference to 'HTMLTableCaptionElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::as_html_element(self: HTMLTableCaptionElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableCaptionElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::as_mhtml_element(self: mut HTMLTableCaptionElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableCaptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCaptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::from_html_element(base: HTMLElement) -> HTMLTableCaptionElement = "
    if(#var(base) instanceof HTMLTableCaptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableCaptionElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableCaptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCaptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableCaptionElement = "
    if(#var(base) instanceof HTMLTableCaptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableCaptionElement'!\");
"

/// Converts a reference to 'HTMLTableCaptionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::as_element(self: HTMLTableCaptionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableCaptionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::as_melement(self: mut HTMLTableCaptionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableCaptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCaptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::from_element(base: Element) -> HTMLTableCaptionElement = "
    if(#var(base) instanceof HTMLTableCaptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableCaptionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableCaptionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCaptionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCaptionElement::from_melement(base: mut Element) -> mut HTMLTableCaptionElement = "
    if(#var(base) instanceof HTMLTableCaptionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableCaptionElement'!\");
"

pub ext fun HTMLTableCaptionElement::align(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableCaptionElement::set_align(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::title(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableCaptionElement::set_title(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::lang(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableCaptionElement::set_lang(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::translate(self: HTMLTableCaptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableCaptionElement::set_translate(self: mut HTMLTableCaptionElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::dir(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableCaptionElement::set_dir(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::hidden(self: HTMLTableCaptionElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableCaptionElement::set_hidden(self: mut HTMLTableCaptionElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableCaptionElement::inert(self: HTMLTableCaptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableCaptionElement::set_inert(self: mut HTMLTableCaptionElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::access_key(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableCaptionElement::set_access_key(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::draggable(self: HTMLTableCaptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableCaptionElement::set_draggable(self: mut HTMLTableCaptionElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::spellcheck(self: HTMLTableCaptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableCaptionElement::set_spellcheck(self: mut HTMLTableCaptionElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::autocapitalize(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableCaptionElement::set_autocapitalize(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::edit_context(self: HTMLTableCaptionElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableCaptionElement::set_edit_context(self: mut HTMLTableCaptionElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableCaptionElement::content_editable(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableCaptionElement::set_content_editable(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::enter_key_hint(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableCaptionElement::set_enter_key_hint(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::is_content_editable(self: HTMLTableCaptionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableCaptionElement::input_mode(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableCaptionElement::set_input_mode(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::virtual_keyboard_policy(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableCaptionElement::set_virtual_keyboard_policy(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::scroll_parent(self: HTMLTableCaptionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableCaptionElement::offset_parent(self: HTMLTableCaptionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableCaptionElement::offset_top(self: HTMLTableCaptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableCaptionElement::offset_left(self: HTMLTableCaptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableCaptionElement::offset_width(self: HTMLTableCaptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableCaptionElement::offset_height(self: HTMLTableCaptionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableCaptionElement::popover(self: HTMLTableCaptionElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableCaptionElement::set_popover(self: mut HTMLTableCaptionElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableCaptionElement::inner_text(self: HTMLTableCaptionElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableCaptionElement::set_inner_text(self: mut HTMLTableCaptionElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableCaptionElement::outer_text(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableCaptionElement::set_outer_text(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::writing_suggestions(self: HTMLTableCaptionElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableCaptionElement::set_writing_suggestions(self: mut HTMLTableCaptionElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCaptionElement::click(__self: mut HTMLTableCaptionElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::attach_internals(__self: mut HTMLTableCaptionElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::toggle_popover(__self: mut HTMLTableCaptionElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::show_popover(__self: mut HTMLTableCaptionElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::hide_popover(__self: mut HTMLTableCaptionElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::start_view_transition(__self: mut HTMLTableCaptionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::start_view_transition_f_prom_unit(__self: mut HTMLTableCaptionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableCaptionElement::start_view_transition_mview_transition_options(__self: mut HTMLTableCaptionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableCaptionElement::as_js(self: HTMLTableCaptionElement) -> JsValue = JsValue::unsafe_from[HTMLTableCaptionElement](self)

pub fun HTMLTableCaptionElement::from_js(v: JsValue) -> mut HTMLTableCaptionElement = JsValue::unsafe_as[mut HTMLTableCaptionElement](v)

struct HTMLTableCellElement()

/// Converts a reference to 'HTMLTableCellElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::as_html_element(self: HTMLTableCellElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableCellElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::as_mhtml_element(self: mut HTMLTableCellElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableCellElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCellElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::from_html_element(base: HTMLElement) -> HTMLTableCellElement = "
    if(#var(base) instanceof HTMLTableCellElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableCellElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableCellElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCellElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableCellElement = "
    if(#var(base) instanceof HTMLTableCellElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableCellElement'!\");
"

/// Converts a reference to 'HTMLTableCellElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::as_element(self: HTMLTableCellElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableCellElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::as_melement(self: mut HTMLTableCellElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableCellElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCellElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::from_element(base: Element) -> HTMLTableCellElement = "
    if(#var(base) instanceof HTMLTableCellElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableCellElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableCellElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableCellElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableCellElement::from_melement(base: mut Element) -> mut HTMLTableCellElement = "
    if(#var(base) instanceof HTMLTableCellElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableCellElement'!\");
"

pub ext fun HTMLTableCellElement::col_span(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).colSpan);"

pub ext fun HTMLTableCellElement::set_col_span(self: mut HTMLTableCellElement, value: Int)
    = "#var(self).colSpan = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::row_span(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).rowSpan);"

pub ext fun HTMLTableCellElement::set_row_span(self: mut HTMLTableCellElement, value: Int)
    = "#var(self).rowSpan = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::headers(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).headers);"

pub ext fun HTMLTableCellElement::set_headers(self: mut HTMLTableCellElement, value: String)
    = "#var(self).headers = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::cell_index(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).cellIndex);"

pub ext fun HTMLTableCellElement::align(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableCellElement::set_align(self: mut HTMLTableCellElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::axis(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).axis);"

pub ext fun HTMLTableCellElement::set_axis(self: mut HTMLTableCellElement, value: String)
    = "#var(self).axis = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::height(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).height);"

pub ext fun HTMLTableCellElement::set_height(self: mut HTMLTableCellElement, value: String)
    = "#var(self).height = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::width(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLTableCellElement::set_width(self: mut HTMLTableCellElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::ch(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).ch);"

pub ext fun HTMLTableCellElement::set_ch(self: mut HTMLTableCellElement, value: String)
    = "#var(self).ch = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::ch_off(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).chOff);"

pub ext fun HTMLTableCellElement::set_ch_off(self: mut HTMLTableCellElement, value: String)
    = "#var(self).chOff = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::no_wrap(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).noWrap);"

pub ext fun HTMLTableCellElement::set_no_wrap(self: mut HTMLTableCellElement, value: Bool)
    = "#var(self).noWrap = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::v_align(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).vAlign);"

pub ext fun HTMLTableCellElement::set_v_align(self: mut HTMLTableCellElement, value: String)
    = "#var(self).vAlign = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::bg_color(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun HTMLTableCellElement::set_bg_color(self: mut HTMLTableCellElement, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::abbr(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).abbr);"

pub ext fun HTMLTableCellElement::set_abbr(self: mut HTMLTableCellElement, value: String)
    = "#var(self).abbr = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::scope(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).scope);"

pub ext fun HTMLTableCellElement::set_scope(self: mut HTMLTableCellElement, value: String)
    = "#var(self).scope = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::title(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableCellElement::set_title(self: mut HTMLTableCellElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::lang(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableCellElement::set_lang(self: mut HTMLTableCellElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::translate(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableCellElement::set_translate(self: mut HTMLTableCellElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::dir(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableCellElement::set_dir(self: mut HTMLTableCellElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::hidden(self: HTMLTableCellElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableCellElement::set_hidden(self: mut HTMLTableCellElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableCellElement::inert(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableCellElement::set_inert(self: mut HTMLTableCellElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::access_key(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableCellElement::set_access_key(self: mut HTMLTableCellElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::draggable(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableCellElement::set_draggable(self: mut HTMLTableCellElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::spellcheck(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableCellElement::set_spellcheck(self: mut HTMLTableCellElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::autocapitalize(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableCellElement::set_autocapitalize(self: mut HTMLTableCellElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::edit_context(self: HTMLTableCellElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableCellElement::set_edit_context(self: mut HTMLTableCellElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableCellElement::content_editable(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableCellElement::set_content_editable(self: mut HTMLTableCellElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::enter_key_hint(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableCellElement::set_enter_key_hint(self: mut HTMLTableCellElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::is_content_editable(self: HTMLTableCellElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableCellElement::input_mode(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableCellElement::set_input_mode(self: mut HTMLTableCellElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::virtual_keyboard_policy(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableCellElement::set_virtual_keyboard_policy(self: mut HTMLTableCellElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::scroll_parent(self: HTMLTableCellElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableCellElement::offset_parent(self: HTMLTableCellElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableCellElement::offset_top(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableCellElement::offset_left(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableCellElement::offset_width(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableCellElement::offset_height(self: HTMLTableCellElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableCellElement::popover(self: HTMLTableCellElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableCellElement::set_popover(self: mut HTMLTableCellElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableCellElement::inner_text(self: HTMLTableCellElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableCellElement::set_inner_text(self: mut HTMLTableCellElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableCellElement::outer_text(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableCellElement::set_outer_text(self: mut HTMLTableCellElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::writing_suggestions(self: HTMLTableCellElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableCellElement::set_writing_suggestions(self: mut HTMLTableCellElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableCellElement::click(__self: mut HTMLTableCellElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCellElement::attach_internals(__self: mut HTMLTableCellElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableCellElement::toggle_popover(__self: mut HTMLTableCellElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableCellElement::show_popover(__self: mut HTMLTableCellElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCellElement::hide_popover(__self: mut HTMLTableCellElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableCellElement::start_view_transition(__self: mut HTMLTableCellElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableCellElement::start_view_transition_f_prom_unit(__self: mut HTMLTableCellElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableCellElement::start_view_transition_mview_transition_options(__self: mut HTMLTableCellElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableCellElement::as_js(self: HTMLTableCellElement) -> JsValue = JsValue::unsafe_from[HTMLTableCellElement](self)

pub fun HTMLTableCellElement::from_js(v: JsValue) -> mut HTMLTableCellElement = JsValue::unsafe_as[mut HTMLTableCellElement](v)

struct HTMLTableColElement()

/// Converts a reference to 'HTMLTableColElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::as_html_element(self: HTMLTableColElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableColElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::as_mhtml_element(self: mut HTMLTableColElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableColElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableColElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::from_html_element(base: HTMLElement) -> HTMLTableColElement = "
    if(#var(base) instanceof HTMLTableColElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableColElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableColElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableColElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableColElement = "
    if(#var(base) instanceof HTMLTableColElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableColElement'!\");
"

/// Converts a reference to 'HTMLTableColElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::as_element(self: HTMLTableColElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableColElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::as_melement(self: mut HTMLTableColElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableColElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableColElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::from_element(base: Element) -> HTMLTableColElement = "
    if(#var(base) instanceof HTMLTableColElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableColElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableColElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableColElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableColElement::from_melement(base: mut Element) -> mut HTMLTableColElement = "
    if(#var(base) instanceof HTMLTableColElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableColElement'!\");
"

pub ext fun HTMLTableColElement::span(self: HTMLTableColElement) -> Int
    = "return #fun(Int::from_js)(#var(self).span);"

pub ext fun HTMLTableColElement::set_span(self: mut HTMLTableColElement, value: Int)
    = "#var(self).span = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLTableColElement::align(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableColElement::set_align(self: mut HTMLTableColElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::ch(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).ch);"

pub ext fun HTMLTableColElement::set_ch(self: mut HTMLTableColElement, value: String)
    = "#var(self).ch = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::ch_off(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).chOff);"

pub ext fun HTMLTableColElement::set_ch_off(self: mut HTMLTableColElement, value: String)
    = "#var(self).chOff = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::v_align(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).vAlign);"

pub ext fun HTMLTableColElement::set_v_align(self: mut HTMLTableColElement, value: String)
    = "#var(self).vAlign = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::width(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLTableColElement::set_width(self: mut HTMLTableColElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::title(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableColElement::set_title(self: mut HTMLTableColElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::lang(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableColElement::set_lang(self: mut HTMLTableColElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::translate(self: HTMLTableColElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableColElement::set_translate(self: mut HTMLTableColElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableColElement::dir(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableColElement::set_dir(self: mut HTMLTableColElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::hidden(self: HTMLTableColElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableColElement::set_hidden(self: mut HTMLTableColElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableColElement::inert(self: HTMLTableColElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableColElement::set_inert(self: mut HTMLTableColElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableColElement::access_key(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableColElement::set_access_key(self: mut HTMLTableColElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::draggable(self: HTMLTableColElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableColElement::set_draggable(self: mut HTMLTableColElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableColElement::spellcheck(self: HTMLTableColElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableColElement::set_spellcheck(self: mut HTMLTableColElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableColElement::autocapitalize(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableColElement::set_autocapitalize(self: mut HTMLTableColElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::edit_context(self: HTMLTableColElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableColElement::set_edit_context(self: mut HTMLTableColElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableColElement::content_editable(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableColElement::set_content_editable(self: mut HTMLTableColElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::enter_key_hint(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableColElement::set_enter_key_hint(self: mut HTMLTableColElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::is_content_editable(self: HTMLTableColElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableColElement::input_mode(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableColElement::set_input_mode(self: mut HTMLTableColElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::virtual_keyboard_policy(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableColElement::set_virtual_keyboard_policy(self: mut HTMLTableColElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::scroll_parent(self: HTMLTableColElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableColElement::offset_parent(self: HTMLTableColElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableColElement::offset_top(self: HTMLTableColElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableColElement::offset_left(self: HTMLTableColElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableColElement::offset_width(self: HTMLTableColElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableColElement::offset_height(self: HTMLTableColElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableColElement::popover(self: HTMLTableColElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableColElement::set_popover(self: mut HTMLTableColElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableColElement::inner_text(self: HTMLTableColElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableColElement::set_inner_text(self: mut HTMLTableColElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableColElement::outer_text(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableColElement::set_outer_text(self: mut HTMLTableColElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::writing_suggestions(self: HTMLTableColElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableColElement::set_writing_suggestions(self: mut HTMLTableColElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableColElement::click(__self: mut HTMLTableColElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableColElement::attach_internals(__self: mut HTMLTableColElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableColElement::toggle_popover(__self: mut HTMLTableColElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableColElement::show_popover(__self: mut HTMLTableColElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableColElement::hide_popover(__self: mut HTMLTableColElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableColElement::start_view_transition(__self: mut HTMLTableColElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableColElement::start_view_transition_f_prom_unit(__self: mut HTMLTableColElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableColElement::start_view_transition_mview_transition_options(__self: mut HTMLTableColElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableColElement::as_js(self: HTMLTableColElement) -> JsValue = JsValue::unsafe_from[HTMLTableColElement](self)

pub fun HTMLTableColElement::from_js(v: JsValue) -> mut HTMLTableColElement = JsValue::unsafe_as[mut HTMLTableColElement](v)

struct HTMLTableElement()

/// Converts a reference to 'HTMLTableElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::as_html_element(self: HTMLTableElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::as_mhtml_element(self: mut HTMLTableElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::from_html_element(base: HTMLElement) -> HTMLTableElement = "
    if(#var(base) instanceof HTMLTableElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableElement = "
    if(#var(base) instanceof HTMLTableElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableElement'!\");
"

/// Converts a reference to 'HTMLTableElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::as_element(self: HTMLTableElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::as_melement(self: mut HTMLTableElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::from_element(base: Element) -> HTMLTableElement = "
    if(#var(base) instanceof HTMLTableElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableElement::from_melement(base: mut Element) -> mut HTMLTableElement = "
    if(#var(base) instanceof HTMLTableElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableElement'!\");
"

pub ext fun HTMLTableElement::caption(self: HTMLTableElement) -> Option[mut HTMLTableCaptionElement]
    = "return #fun(Option::from_js[mut HTMLTableCaptionElement])(#var(self).caption);"

pub ext fun HTMLTableElement::set_caption(self: mut HTMLTableElement, value: Option[mut HTMLTableCaptionElement])
    = "#var(self).caption = #fun(Option::as_js[mut HTMLTableCaptionElement])(#var(value));"

pub ext fun HTMLTableElement::t_head(self: HTMLTableElement) -> Option[mut HTMLTableSectionElement]
    = "return #fun(Option::from_js[mut HTMLTableSectionElement])(#var(self).tHead);"

pub ext fun HTMLTableElement::set_t_head(self: mut HTMLTableElement, value: Option[mut HTMLTableSectionElement])
    = "#var(self).tHead = #fun(Option::as_js[mut HTMLTableSectionElement])(#var(value));"

pub ext fun HTMLTableElement::t_foot(self: HTMLTableElement) -> Option[mut HTMLTableSectionElement]
    = "return #fun(Option::from_js[mut HTMLTableSectionElement])(#var(self).tFoot);"

pub ext fun HTMLTableElement::set_t_foot(self: mut HTMLTableElement, value: Option[mut HTMLTableSectionElement])
    = "#var(self).tFoot = #fun(Option::as_js[mut HTMLTableSectionElement])(#var(value));"

pub ext fun HTMLTableElement::t_bodies(self: HTMLTableElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).tBodies);"

pub ext fun HTMLTableElement::rows(self: HTMLTableElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).rows);"

pub ext fun HTMLTableElement::align(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableElement::set_align(self: mut HTMLTableElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::border(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).border);"

pub ext fun HTMLTableElement::set_border(self: mut HTMLTableElement, value: String)
    = "#var(self).border = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::frame(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).frame);"

pub ext fun HTMLTableElement::set_frame(self: mut HTMLTableElement, value: String)
    = "#var(self).frame = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::rules(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).rules);"

pub ext fun HTMLTableElement::set_rules(self: mut HTMLTableElement, value: String)
    = "#var(self).rules = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::summary(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).summary);"

pub ext fun HTMLTableElement::set_summary(self: mut HTMLTableElement, value: String)
    = "#var(self).summary = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::width(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).width);"

pub ext fun HTMLTableElement::set_width(self: mut HTMLTableElement, value: String)
    = "#var(self).width = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::bg_color(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun HTMLTableElement::set_bg_color(self: mut HTMLTableElement, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::cell_padding(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).cellPadding);"

pub ext fun HTMLTableElement::set_cell_padding(self: mut HTMLTableElement, value: String)
    = "#var(self).cellPadding = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::cell_spacing(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).cellSpacing);"

pub ext fun HTMLTableElement::set_cell_spacing(self: mut HTMLTableElement, value: String)
    = "#var(self).cellSpacing = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::title(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableElement::set_title(self: mut HTMLTableElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::lang(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableElement::set_lang(self: mut HTMLTableElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::translate(self: HTMLTableElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableElement::set_translate(self: mut HTMLTableElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableElement::dir(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableElement::set_dir(self: mut HTMLTableElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::hidden(self: HTMLTableElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableElement::set_hidden(self: mut HTMLTableElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableElement::inert(self: HTMLTableElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableElement::set_inert(self: mut HTMLTableElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableElement::access_key(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableElement::set_access_key(self: mut HTMLTableElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::draggable(self: HTMLTableElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableElement::set_draggable(self: mut HTMLTableElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableElement::spellcheck(self: HTMLTableElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableElement::set_spellcheck(self: mut HTMLTableElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableElement::autocapitalize(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableElement::set_autocapitalize(self: mut HTMLTableElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::edit_context(self: HTMLTableElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableElement::set_edit_context(self: mut HTMLTableElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableElement::content_editable(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableElement::set_content_editable(self: mut HTMLTableElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::enter_key_hint(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableElement::set_enter_key_hint(self: mut HTMLTableElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::is_content_editable(self: HTMLTableElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableElement::input_mode(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableElement::set_input_mode(self: mut HTMLTableElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::virtual_keyboard_policy(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableElement::set_virtual_keyboard_policy(self: mut HTMLTableElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::scroll_parent(self: HTMLTableElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableElement::offset_parent(self: HTMLTableElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableElement::offset_top(self: HTMLTableElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableElement::offset_left(self: HTMLTableElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableElement::offset_width(self: HTMLTableElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableElement::offset_height(self: HTMLTableElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableElement::popover(self: HTMLTableElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableElement::set_popover(self: mut HTMLTableElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableElement::inner_text(self: HTMLTableElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableElement::set_inner_text(self: mut HTMLTableElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableElement::outer_text(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableElement::set_outer_text(self: mut HTMLTableElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::writing_suggestions(self: HTMLTableElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableElement::set_writing_suggestions(self: mut HTMLTableElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableElement::create_caption(__self: mut HTMLTableElement) -> mut HTMLTableCaptionElement = "
    const r = #var(__self).createCaption();
    return #fun(HTMLTableCaptionElement::from_js)(r);
"

pub ext fun HTMLTableElement::delete_caption(__self: mut HTMLTableElement) -> Unit = "
    const r = #var(__self).deleteCaption();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::create_t_head(__self: mut HTMLTableElement) -> mut HTMLTableSectionElement = "
    const r = #var(__self).createTHead();
    return #fun(HTMLTableSectionElement::from_js)(r);
"

pub ext fun HTMLTableElement::delete_t_head(__self: mut HTMLTableElement) -> Unit = "
    const r = #var(__self).deleteTHead();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::create_t_foot(__self: mut HTMLTableElement) -> mut HTMLTableSectionElement = "
    const r = #var(__self).createTFoot();
    return #fun(HTMLTableSectionElement::from_js)(r);
"

pub ext fun HTMLTableElement::delete_t_foot(__self: mut HTMLTableElement) -> Unit = "
    const r = #var(__self).deleteTFoot();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::create_t_body(__self: mut HTMLTableElement) -> mut HTMLTableSectionElement = "
    const r = #var(__self).createTBody();
    return #fun(HTMLTableSectionElement::from_js)(r);
"

pub ext fun HTMLTableElement::insert_row(__self: mut HTMLTableElement, index: Int) -> mut HTMLTableRowElement = "
    const r = #var(__self).insertRow(#fun(Int::as_js)(#var(index)));
    return #fun(HTMLTableRowElement::from_js)(r);
"

pub ext fun HTMLTableElement::delete_row(__self: mut HTMLTableElement, index: Int) -> Unit = "
    const r = #var(__self).deleteRow(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::click(__self: mut HTMLTableElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::attach_internals(__self: mut HTMLTableElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableElement::toggle_popover(__self: mut HTMLTableElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableElement::show_popover(__self: mut HTMLTableElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::hide_popover(__self: mut HTMLTableElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableElement::start_view_transition(__self: mut HTMLTableElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableElement::start_view_transition_f_prom_unit(__self: mut HTMLTableElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableElement::start_view_transition_mview_transition_options(__self: mut HTMLTableElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableElement::as_js(self: HTMLTableElement) -> JsValue = JsValue::unsafe_from[HTMLTableElement](self)

pub fun HTMLTableElement::from_js(v: JsValue) -> mut HTMLTableElement = JsValue::unsafe_as[mut HTMLTableElement](v)

struct HTMLTableRowElement()

/// Converts a reference to 'HTMLTableRowElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::as_html_element(self: HTMLTableRowElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableRowElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::as_mhtml_element(self: mut HTMLTableRowElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableRowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableRowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::from_html_element(base: HTMLElement) -> HTMLTableRowElement = "
    if(#var(base) instanceof HTMLTableRowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableRowElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableRowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableRowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableRowElement = "
    if(#var(base) instanceof HTMLTableRowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableRowElement'!\");
"

/// Converts a reference to 'HTMLTableRowElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::as_element(self: HTMLTableRowElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableRowElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::as_melement(self: mut HTMLTableRowElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableRowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableRowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::from_element(base: Element) -> HTMLTableRowElement = "
    if(#var(base) instanceof HTMLTableRowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableRowElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableRowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableRowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableRowElement::from_melement(base: mut Element) -> mut HTMLTableRowElement = "
    if(#var(base) instanceof HTMLTableRowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableRowElement'!\");
"

pub ext fun HTMLTableRowElement::row_index(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).rowIndex);"

pub ext fun HTMLTableRowElement::section_row_index(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).sectionRowIndex);"

pub ext fun HTMLTableRowElement::cells(self: HTMLTableRowElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).cells);"

pub ext fun HTMLTableRowElement::align(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableRowElement::set_align(self: mut HTMLTableRowElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::ch(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).ch);"

pub ext fun HTMLTableRowElement::set_ch(self: mut HTMLTableRowElement, value: String)
    = "#var(self).ch = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::ch_off(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).chOff);"

pub ext fun HTMLTableRowElement::set_ch_off(self: mut HTMLTableRowElement, value: String)
    = "#var(self).chOff = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::v_align(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).vAlign);"

pub ext fun HTMLTableRowElement::set_v_align(self: mut HTMLTableRowElement, value: String)
    = "#var(self).vAlign = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::bg_color(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).bgColor);"

pub ext fun HTMLTableRowElement::set_bg_color(self: mut HTMLTableRowElement, value: String)
    = "#var(self).bgColor = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::title(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableRowElement::set_title(self: mut HTMLTableRowElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::lang(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableRowElement::set_lang(self: mut HTMLTableRowElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::translate(self: HTMLTableRowElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableRowElement::set_translate(self: mut HTMLTableRowElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::dir(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableRowElement::set_dir(self: mut HTMLTableRowElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::hidden(self: HTMLTableRowElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableRowElement::set_hidden(self: mut HTMLTableRowElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableRowElement::inert(self: HTMLTableRowElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableRowElement::set_inert(self: mut HTMLTableRowElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::access_key(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableRowElement::set_access_key(self: mut HTMLTableRowElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::draggable(self: HTMLTableRowElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableRowElement::set_draggable(self: mut HTMLTableRowElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::spellcheck(self: HTMLTableRowElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableRowElement::set_spellcheck(self: mut HTMLTableRowElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::autocapitalize(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableRowElement::set_autocapitalize(self: mut HTMLTableRowElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::edit_context(self: HTMLTableRowElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableRowElement::set_edit_context(self: mut HTMLTableRowElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableRowElement::content_editable(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableRowElement::set_content_editable(self: mut HTMLTableRowElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::enter_key_hint(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableRowElement::set_enter_key_hint(self: mut HTMLTableRowElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::is_content_editable(self: HTMLTableRowElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableRowElement::input_mode(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableRowElement::set_input_mode(self: mut HTMLTableRowElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::virtual_keyboard_policy(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableRowElement::set_virtual_keyboard_policy(self: mut HTMLTableRowElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::scroll_parent(self: HTMLTableRowElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableRowElement::offset_parent(self: HTMLTableRowElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableRowElement::offset_top(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableRowElement::offset_left(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableRowElement::offset_width(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableRowElement::offset_height(self: HTMLTableRowElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableRowElement::popover(self: HTMLTableRowElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableRowElement::set_popover(self: mut HTMLTableRowElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableRowElement::inner_text(self: HTMLTableRowElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableRowElement::set_inner_text(self: mut HTMLTableRowElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableRowElement::outer_text(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableRowElement::set_outer_text(self: mut HTMLTableRowElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::writing_suggestions(self: HTMLTableRowElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableRowElement::set_writing_suggestions(self: mut HTMLTableRowElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableRowElement::insert_cell(__self: mut HTMLTableRowElement, index: Int) -> mut HTMLElement = "
    const r = #var(__self).insertCell(#fun(Int::as_js)(#var(index)));
    return #fun(HTMLElement::from_js)(r);
"

pub ext fun HTMLTableRowElement::delete_cell(__self: mut HTMLTableRowElement, index: Int) -> Unit = "
    const r = #var(__self).deleteCell(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableRowElement::click(__self: mut HTMLTableRowElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableRowElement::attach_internals(__self: mut HTMLTableRowElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableRowElement::toggle_popover(__self: mut HTMLTableRowElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableRowElement::show_popover(__self: mut HTMLTableRowElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableRowElement::hide_popover(__self: mut HTMLTableRowElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableRowElement::start_view_transition(__self: mut HTMLTableRowElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableRowElement::start_view_transition_f_prom_unit(__self: mut HTMLTableRowElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableRowElement::start_view_transition_mview_transition_options(__self: mut HTMLTableRowElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableRowElement::as_js(self: HTMLTableRowElement) -> JsValue = JsValue::unsafe_from[HTMLTableRowElement](self)

pub fun HTMLTableRowElement::from_js(v: JsValue) -> mut HTMLTableRowElement = JsValue::unsafe_as[mut HTMLTableRowElement](v)

struct HTMLTableSectionElement()

/// Converts a reference to 'HTMLTableSectionElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::as_html_element(self: HTMLTableSectionElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableSectionElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::as_mhtml_element(self: mut HTMLTableSectionElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTableSectionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableSectionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::from_html_element(base: HTMLElement) -> HTMLTableSectionElement = "
    if(#var(base) instanceof HTMLTableSectionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableSectionElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTableSectionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableSectionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTableSectionElement = "
    if(#var(base) instanceof HTMLTableSectionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTableSectionElement'!\");
"

/// Converts a reference to 'HTMLTableSectionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::as_element(self: HTMLTableSectionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTableSectionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::as_melement(self: mut HTMLTableSectionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTableSectionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableSectionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::from_element(base: Element) -> HTMLTableSectionElement = "
    if(#var(base) instanceof HTMLTableSectionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableSectionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTableSectionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTableSectionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTableSectionElement::from_melement(base: mut Element) -> mut HTMLTableSectionElement = "
    if(#var(base) instanceof HTMLTableSectionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTableSectionElement'!\");
"

pub ext fun HTMLTableSectionElement::rows(self: HTMLTableSectionElement) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).rows);"

pub ext fun HTMLTableSectionElement::align(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun HTMLTableSectionElement::set_align(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).align = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::ch(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).ch);"

pub ext fun HTMLTableSectionElement::set_ch(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).ch = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::ch_off(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).chOff);"

pub ext fun HTMLTableSectionElement::set_ch_off(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).chOff = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::v_align(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).vAlign);"

pub ext fun HTMLTableSectionElement::set_v_align(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).vAlign = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::title(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTableSectionElement::set_title(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::lang(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTableSectionElement::set_lang(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::translate(self: HTMLTableSectionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTableSectionElement::set_translate(self: mut HTMLTableSectionElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::dir(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTableSectionElement::set_dir(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::hidden(self: HTMLTableSectionElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTableSectionElement::set_hidden(self: mut HTMLTableSectionElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTableSectionElement::inert(self: HTMLTableSectionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTableSectionElement::set_inert(self: mut HTMLTableSectionElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::access_key(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTableSectionElement::set_access_key(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::draggable(self: HTMLTableSectionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTableSectionElement::set_draggable(self: mut HTMLTableSectionElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::spellcheck(self: HTMLTableSectionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTableSectionElement::set_spellcheck(self: mut HTMLTableSectionElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::autocapitalize(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTableSectionElement::set_autocapitalize(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::edit_context(self: HTMLTableSectionElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTableSectionElement::set_edit_context(self: mut HTMLTableSectionElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTableSectionElement::content_editable(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTableSectionElement::set_content_editable(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::enter_key_hint(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTableSectionElement::set_enter_key_hint(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::is_content_editable(self: HTMLTableSectionElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTableSectionElement::input_mode(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTableSectionElement::set_input_mode(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::virtual_keyboard_policy(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTableSectionElement::set_virtual_keyboard_policy(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::scroll_parent(self: HTMLTableSectionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTableSectionElement::offset_parent(self: HTMLTableSectionElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTableSectionElement::offset_top(self: HTMLTableSectionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTableSectionElement::offset_left(self: HTMLTableSectionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTableSectionElement::offset_width(self: HTMLTableSectionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTableSectionElement::offset_height(self: HTMLTableSectionElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTableSectionElement::popover(self: HTMLTableSectionElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTableSectionElement::set_popover(self: mut HTMLTableSectionElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTableSectionElement::inner_text(self: HTMLTableSectionElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTableSectionElement::set_inner_text(self: mut HTMLTableSectionElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTableSectionElement::outer_text(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTableSectionElement::set_outer_text(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::writing_suggestions(self: HTMLTableSectionElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTableSectionElement::set_writing_suggestions(self: mut HTMLTableSectionElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTableSectionElement::insert_row(__self: mut HTMLTableSectionElement, index: Int) -> mut HTMLElement = "
    const r = #var(__self).insertRow(#fun(Int::as_js)(#var(index)));
    return #fun(HTMLElement::from_js)(r);
"

pub ext fun HTMLTableSectionElement::delete_row(__self: mut HTMLTableSectionElement, index: Int) -> Unit = "
    const r = #var(__self).deleteRow(#fun(Int::as_js)(#var(index)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableSectionElement::click(__self: mut HTMLTableSectionElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableSectionElement::attach_internals(__self: mut HTMLTableSectionElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTableSectionElement::toggle_popover(__self: mut HTMLTableSectionElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTableSectionElement::show_popover(__self: mut HTMLTableSectionElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableSectionElement::hide_popover(__self: mut HTMLTableSectionElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTableSectionElement::start_view_transition(__self: mut HTMLTableSectionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableSectionElement::start_view_transition_f_prom_unit(__self: mut HTMLTableSectionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTableSectionElement::start_view_transition_mview_transition_options(__self: mut HTMLTableSectionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTableSectionElement::as_js(self: HTMLTableSectionElement) -> JsValue = JsValue::unsafe_from[HTMLTableSectionElement](self)

pub fun HTMLTableSectionElement::from_js(v: JsValue) -> mut HTMLTableSectionElement = JsValue::unsafe_as[mut HTMLTableSectionElement](v)

struct HTMLTemplateElement()

/// Converts a reference to 'HTMLTemplateElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::as_html_element(self: HTMLTemplateElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTemplateElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::as_mhtml_element(self: mut HTMLTemplateElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTemplateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTemplateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::from_html_element(base: HTMLElement) -> HTMLTemplateElement = "
    if(#var(base) instanceof HTMLTemplateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTemplateElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTemplateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTemplateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTemplateElement = "
    if(#var(base) instanceof HTMLTemplateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTemplateElement'!\");
"

/// Converts a reference to 'HTMLTemplateElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::as_element(self: HTMLTemplateElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTemplateElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::as_melement(self: mut HTMLTemplateElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTemplateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTemplateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::from_element(base: Element) -> HTMLTemplateElement = "
    if(#var(base) instanceof HTMLTemplateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTemplateElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTemplateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTemplateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTemplateElement::from_melement(base: mut Element) -> mut HTMLTemplateElement = "
    if(#var(base) instanceof HTMLTemplateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTemplateElement'!\");
"

pub ext fun HTMLTemplateElement::content(self: HTMLTemplateElement) -> mut DocumentFragment
    = "return #fun(DocumentFragment::from_js)(#var(self).content);"

pub ext fun HTMLTemplateElement::shadow_root_mode(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).shadowRootMode);"

pub ext fun HTMLTemplateElement::set_shadow_root_mode(self: mut HTMLTemplateElement, value: String)
    = "#var(self).shadowRootMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::shadow_root_delegates_focus(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shadowRootDelegatesFocus);"

pub ext fun HTMLTemplateElement::set_shadow_root_delegates_focus(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).shadowRootDelegatesFocus = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::shadow_root_clonable(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shadowRootClonable);"

pub ext fun HTMLTemplateElement::set_shadow_root_clonable(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).shadowRootClonable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::shadow_root_serializable(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).shadowRootSerializable);"

pub ext fun HTMLTemplateElement::set_shadow_root_serializable(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).shadowRootSerializable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::parseparts(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).parseparts);"

pub ext fun HTMLTemplateElement::set_parseparts(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).parseparts = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::shadow_root_custom_element_registry(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).shadowRootCustomElementRegistry);"

pub ext fun HTMLTemplateElement::set_shadow_root_custom_element_registry(self: mut HTMLTemplateElement, value: String)
    = "#var(self).shadowRootCustomElementRegistry = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::title(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTemplateElement::set_title(self: mut HTMLTemplateElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::lang(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTemplateElement::set_lang(self: mut HTMLTemplateElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::translate(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTemplateElement::set_translate(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::dir(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTemplateElement::set_dir(self: mut HTMLTemplateElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::hidden(self: HTMLTemplateElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTemplateElement::set_hidden(self: mut HTMLTemplateElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTemplateElement::inert(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTemplateElement::set_inert(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::access_key(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTemplateElement::set_access_key(self: mut HTMLTemplateElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::draggable(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTemplateElement::set_draggable(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::spellcheck(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTemplateElement::set_spellcheck(self: mut HTMLTemplateElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::autocapitalize(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTemplateElement::set_autocapitalize(self: mut HTMLTemplateElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::edit_context(self: HTMLTemplateElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTemplateElement::set_edit_context(self: mut HTMLTemplateElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTemplateElement::content_editable(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTemplateElement::set_content_editable(self: mut HTMLTemplateElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::enter_key_hint(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTemplateElement::set_enter_key_hint(self: mut HTMLTemplateElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::is_content_editable(self: HTMLTemplateElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTemplateElement::input_mode(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTemplateElement::set_input_mode(self: mut HTMLTemplateElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::virtual_keyboard_policy(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTemplateElement::set_virtual_keyboard_policy(self: mut HTMLTemplateElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::scroll_parent(self: HTMLTemplateElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTemplateElement::offset_parent(self: HTMLTemplateElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTemplateElement::offset_top(self: HTMLTemplateElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTemplateElement::offset_left(self: HTMLTemplateElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTemplateElement::offset_width(self: HTMLTemplateElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTemplateElement::offset_height(self: HTMLTemplateElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTemplateElement::popover(self: HTMLTemplateElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTemplateElement::set_popover(self: mut HTMLTemplateElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTemplateElement::inner_text(self: HTMLTemplateElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTemplateElement::set_inner_text(self: mut HTMLTemplateElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTemplateElement::outer_text(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTemplateElement::set_outer_text(self: mut HTMLTemplateElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::writing_suggestions(self: HTMLTemplateElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTemplateElement::set_writing_suggestions(self: mut HTMLTemplateElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTemplateElement::click(__self: mut HTMLTemplateElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTemplateElement::attach_internals(__self: mut HTMLTemplateElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTemplateElement::toggle_popover(__self: mut HTMLTemplateElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTemplateElement::show_popover(__self: mut HTMLTemplateElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTemplateElement::hide_popover(__self: mut HTMLTemplateElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTemplateElement::start_view_transition(__self: mut HTMLTemplateElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTemplateElement::start_view_transition_f_prom_unit(__self: mut HTMLTemplateElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTemplateElement::start_view_transition_mview_transition_options(__self: mut HTMLTemplateElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTemplateElement::as_js(self: HTMLTemplateElement) -> JsValue = JsValue::unsafe_from[HTMLTemplateElement](self)

pub fun HTMLTemplateElement::from_js(v: JsValue) -> mut HTMLTemplateElement = JsValue::unsafe_as[mut HTMLTemplateElement](v)

struct HTMLTimeElement()

/// Converts a reference to 'HTMLTimeElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::as_html_element(self: HTMLTimeElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTimeElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::as_mhtml_element(self: mut HTMLTimeElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTimeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTimeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::from_html_element(base: HTMLElement) -> HTMLTimeElement = "
    if(#var(base) instanceof HTMLTimeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTimeElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTimeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTimeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTimeElement = "
    if(#var(base) instanceof HTMLTimeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTimeElement'!\");
"

/// Converts a reference to 'HTMLTimeElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::as_element(self: HTMLTimeElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTimeElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::as_melement(self: mut HTMLTimeElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTimeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTimeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::from_element(base: Element) -> HTMLTimeElement = "
    if(#var(base) instanceof HTMLTimeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTimeElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTimeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTimeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTimeElement::from_melement(base: mut Element) -> mut HTMLTimeElement = "
    if(#var(base) instanceof HTMLTimeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTimeElement'!\");
"

pub ext fun HTMLTimeElement::date_time(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).dateTime);"

pub ext fun HTMLTimeElement::set_date_time(self: mut HTMLTimeElement, value: String)
    = "#var(self).dateTime = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::title(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTimeElement::set_title(self: mut HTMLTimeElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::lang(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTimeElement::set_lang(self: mut HTMLTimeElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::translate(self: HTMLTimeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTimeElement::set_translate(self: mut HTMLTimeElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTimeElement::dir(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTimeElement::set_dir(self: mut HTMLTimeElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::hidden(self: HTMLTimeElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTimeElement::set_hidden(self: mut HTMLTimeElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTimeElement::inert(self: HTMLTimeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTimeElement::set_inert(self: mut HTMLTimeElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTimeElement::access_key(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTimeElement::set_access_key(self: mut HTMLTimeElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::draggable(self: HTMLTimeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTimeElement::set_draggable(self: mut HTMLTimeElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTimeElement::spellcheck(self: HTMLTimeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTimeElement::set_spellcheck(self: mut HTMLTimeElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTimeElement::autocapitalize(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTimeElement::set_autocapitalize(self: mut HTMLTimeElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::edit_context(self: HTMLTimeElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTimeElement::set_edit_context(self: mut HTMLTimeElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTimeElement::content_editable(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTimeElement::set_content_editable(self: mut HTMLTimeElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::enter_key_hint(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTimeElement::set_enter_key_hint(self: mut HTMLTimeElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::is_content_editable(self: HTMLTimeElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTimeElement::input_mode(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTimeElement::set_input_mode(self: mut HTMLTimeElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::virtual_keyboard_policy(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTimeElement::set_virtual_keyboard_policy(self: mut HTMLTimeElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::scroll_parent(self: HTMLTimeElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTimeElement::offset_parent(self: HTMLTimeElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTimeElement::offset_top(self: HTMLTimeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTimeElement::offset_left(self: HTMLTimeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTimeElement::offset_width(self: HTMLTimeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTimeElement::offset_height(self: HTMLTimeElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTimeElement::popover(self: HTMLTimeElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTimeElement::set_popover(self: mut HTMLTimeElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTimeElement::inner_text(self: HTMLTimeElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTimeElement::set_inner_text(self: mut HTMLTimeElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTimeElement::outer_text(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTimeElement::set_outer_text(self: mut HTMLTimeElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::writing_suggestions(self: HTMLTimeElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTimeElement::set_writing_suggestions(self: mut HTMLTimeElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTimeElement::click(__self: mut HTMLTimeElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTimeElement::attach_internals(__self: mut HTMLTimeElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTimeElement::toggle_popover(__self: mut HTMLTimeElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTimeElement::show_popover(__self: mut HTMLTimeElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTimeElement::hide_popover(__self: mut HTMLTimeElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTimeElement::start_view_transition(__self: mut HTMLTimeElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTimeElement::start_view_transition_f_prom_unit(__self: mut HTMLTimeElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTimeElement::start_view_transition_mview_transition_options(__self: mut HTMLTimeElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTimeElement::as_js(self: HTMLTimeElement) -> JsValue = JsValue::unsafe_from[HTMLTimeElement](self)

pub fun HTMLTimeElement::from_js(v: JsValue) -> mut HTMLTimeElement = JsValue::unsafe_as[mut HTMLTimeElement](v)

struct HTMLTitleElement()

/// Converts a reference to 'HTMLTitleElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::as_html_element(self: HTMLTitleElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTitleElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::as_mhtml_element(self: mut HTMLTitleElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::from_html_element(base: HTMLElement) -> HTMLTitleElement = "
    if(#var(base) instanceof HTMLTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTitleElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTitleElement = "
    if(#var(base) instanceof HTMLTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTitleElement'!\");
"

/// Converts a reference to 'HTMLTitleElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::as_element(self: HTMLTitleElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTitleElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::as_melement(self: mut HTMLTitleElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::from_element(base: Element) -> HTMLTitleElement = "
    if(#var(base) instanceof HTMLTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTitleElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTitleElement::from_melement(base: mut Element) -> mut HTMLTitleElement = "
    if(#var(base) instanceof HTMLTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTitleElement'!\");
"

pub ext fun HTMLTitleElement::text(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun HTMLTitleElement::set_text(self: mut HTMLTitleElement, value: String)
    = "#var(self).text = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::title(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTitleElement::set_title(self: mut HTMLTitleElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::lang(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTitleElement::set_lang(self: mut HTMLTitleElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::translate(self: HTMLTitleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTitleElement::set_translate(self: mut HTMLTitleElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTitleElement::dir(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTitleElement::set_dir(self: mut HTMLTitleElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::hidden(self: HTMLTitleElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTitleElement::set_hidden(self: mut HTMLTitleElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTitleElement::inert(self: HTMLTitleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTitleElement::set_inert(self: mut HTMLTitleElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTitleElement::access_key(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTitleElement::set_access_key(self: mut HTMLTitleElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::draggable(self: HTMLTitleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTitleElement::set_draggable(self: mut HTMLTitleElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTitleElement::spellcheck(self: HTMLTitleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTitleElement::set_spellcheck(self: mut HTMLTitleElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTitleElement::autocapitalize(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTitleElement::set_autocapitalize(self: mut HTMLTitleElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::edit_context(self: HTMLTitleElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTitleElement::set_edit_context(self: mut HTMLTitleElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTitleElement::content_editable(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTitleElement::set_content_editable(self: mut HTMLTitleElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::enter_key_hint(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTitleElement::set_enter_key_hint(self: mut HTMLTitleElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::is_content_editable(self: HTMLTitleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTitleElement::input_mode(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTitleElement::set_input_mode(self: mut HTMLTitleElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::virtual_keyboard_policy(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTitleElement::set_virtual_keyboard_policy(self: mut HTMLTitleElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::scroll_parent(self: HTMLTitleElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTitleElement::offset_parent(self: HTMLTitleElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTitleElement::offset_top(self: HTMLTitleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTitleElement::offset_left(self: HTMLTitleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTitleElement::offset_width(self: HTMLTitleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTitleElement::offset_height(self: HTMLTitleElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTitleElement::popover(self: HTMLTitleElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTitleElement::set_popover(self: mut HTMLTitleElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTitleElement::inner_text(self: HTMLTitleElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTitleElement::set_inner_text(self: mut HTMLTitleElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTitleElement::outer_text(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTitleElement::set_outer_text(self: mut HTMLTitleElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::writing_suggestions(self: HTMLTitleElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTitleElement::set_writing_suggestions(self: mut HTMLTitleElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTitleElement::click(__self: mut HTMLTitleElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTitleElement::attach_internals(__self: mut HTMLTitleElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTitleElement::toggle_popover(__self: mut HTMLTitleElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTitleElement::show_popover(__self: mut HTMLTitleElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTitleElement::hide_popover(__self: mut HTMLTitleElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTitleElement::start_view_transition(__self: mut HTMLTitleElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTitleElement::start_view_transition_f_prom_unit(__self: mut HTMLTitleElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTitleElement::start_view_transition_mview_transition_options(__self: mut HTMLTitleElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTitleElement::as_js(self: HTMLTitleElement) -> JsValue = JsValue::unsafe_from[HTMLTitleElement](self)

pub fun HTMLTitleElement::from_js(v: JsValue) -> mut HTMLTitleElement = JsValue::unsafe_as[mut HTMLTitleElement](v)

struct HTMLUListElement()

/// Converts a reference to 'HTMLUListElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::as_html_element(self: HTMLUListElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLUListElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::as_mhtml_element(self: mut HTMLUListElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLUListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::from_html_element(base: HTMLElement) -> HTMLUListElement = "
    if(#var(base) instanceof HTMLUListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLUListElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLUListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLUListElement = "
    if(#var(base) instanceof HTMLUListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLUListElement'!\");
"

/// Converts a reference to 'HTMLUListElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::as_element(self: HTMLUListElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLUListElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::as_melement(self: mut HTMLUListElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLUListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::from_element(base: Element) -> HTMLUListElement = "
    if(#var(base) instanceof HTMLUListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLUListElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLUListElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUListElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUListElement::from_melement(base: mut Element) -> mut HTMLUListElement = "
    if(#var(base) instanceof HTMLUListElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLUListElement'!\");
"

pub ext fun HTMLUListElement::compact(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).compact);"

pub ext fun HTMLUListElement::set_compact(self: mut HTMLUListElement, value: Bool)
    = "#var(self).compact = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUListElement::type(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun HTMLUListElement::set_type(self: mut HTMLUListElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::title(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLUListElement::set_title(self: mut HTMLUListElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::lang(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLUListElement::set_lang(self: mut HTMLUListElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::translate(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLUListElement::set_translate(self: mut HTMLUListElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUListElement::dir(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLUListElement::set_dir(self: mut HTMLUListElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::hidden(self: HTMLUListElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLUListElement::set_hidden(self: mut HTMLUListElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLUListElement::inert(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLUListElement::set_inert(self: mut HTMLUListElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUListElement::access_key(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLUListElement::set_access_key(self: mut HTMLUListElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::draggable(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLUListElement::set_draggable(self: mut HTMLUListElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUListElement::spellcheck(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLUListElement::set_spellcheck(self: mut HTMLUListElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUListElement::autocapitalize(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLUListElement::set_autocapitalize(self: mut HTMLUListElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::edit_context(self: HTMLUListElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLUListElement::set_edit_context(self: mut HTMLUListElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLUListElement::content_editable(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLUListElement::set_content_editable(self: mut HTMLUListElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::enter_key_hint(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLUListElement::set_enter_key_hint(self: mut HTMLUListElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::is_content_editable(self: HTMLUListElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLUListElement::input_mode(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLUListElement::set_input_mode(self: mut HTMLUListElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::virtual_keyboard_policy(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLUListElement::set_virtual_keyboard_policy(self: mut HTMLUListElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::scroll_parent(self: HTMLUListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLUListElement::offset_parent(self: HTMLUListElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLUListElement::offset_top(self: HTMLUListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLUListElement::offset_left(self: HTMLUListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLUListElement::offset_width(self: HTMLUListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLUListElement::offset_height(self: HTMLUListElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLUListElement::popover(self: HTMLUListElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLUListElement::set_popover(self: mut HTMLUListElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLUListElement::inner_text(self: HTMLUListElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLUListElement::set_inner_text(self: mut HTMLUListElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLUListElement::outer_text(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLUListElement::set_outer_text(self: mut HTMLUListElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::writing_suggestions(self: HTMLUListElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLUListElement::set_writing_suggestions(self: mut HTMLUListElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUListElement::click(__self: mut HTMLUListElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUListElement::attach_internals(__self: mut HTMLUListElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLUListElement::toggle_popover(__self: mut HTMLUListElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLUListElement::show_popover(__self: mut HTMLUListElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUListElement::hide_popover(__self: mut HTMLUListElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUListElement::start_view_transition(__self: mut HTMLUListElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLUListElement::start_view_transition_f_prom_unit(__self: mut HTMLUListElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLUListElement::start_view_transition_mview_transition_options(__self: mut HTMLUListElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLUListElement::as_js(self: HTMLUListElement) -> JsValue = JsValue::unsafe_from[HTMLUListElement](self)

pub fun HTMLUListElement::from_js(v: JsValue) -> mut HTMLUListElement = JsValue::unsafe_as[mut HTMLUListElement](v)

struct HTMLUnknownElement()

/// Converts a reference to 'HTMLUnknownElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::as_html_element(self: HTMLUnknownElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLUnknownElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::as_mhtml_element(self: mut HTMLUnknownElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLUnknownElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUnknownElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::from_html_element(base: HTMLElement) -> HTMLUnknownElement = "
    if(#var(base) instanceof HTMLUnknownElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLUnknownElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLUnknownElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUnknownElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLUnknownElement = "
    if(#var(base) instanceof HTMLUnknownElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLUnknownElement'!\");
"

/// Converts a reference to 'HTMLUnknownElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::as_element(self: HTMLUnknownElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLUnknownElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::as_melement(self: mut HTMLUnknownElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLUnknownElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUnknownElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::from_element(base: Element) -> HTMLUnknownElement = "
    if(#var(base) instanceof HTMLUnknownElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLUnknownElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLUnknownElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLUnknownElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLUnknownElement::from_melement(base: mut Element) -> mut HTMLUnknownElement = "
    if(#var(base) instanceof HTMLUnknownElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLUnknownElement'!\");
"

pub ext fun HTMLUnknownElement::title(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLUnknownElement::set_title(self: mut HTMLUnknownElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::lang(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLUnknownElement::set_lang(self: mut HTMLUnknownElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::translate(self: HTMLUnknownElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLUnknownElement::set_translate(self: mut HTMLUnknownElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::dir(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLUnknownElement::set_dir(self: mut HTMLUnknownElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::hidden(self: HTMLUnknownElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLUnknownElement::set_hidden(self: mut HTMLUnknownElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLUnknownElement::inert(self: HTMLUnknownElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLUnknownElement::set_inert(self: mut HTMLUnknownElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::access_key(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLUnknownElement::set_access_key(self: mut HTMLUnknownElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::draggable(self: HTMLUnknownElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLUnknownElement::set_draggable(self: mut HTMLUnknownElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::spellcheck(self: HTMLUnknownElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLUnknownElement::set_spellcheck(self: mut HTMLUnknownElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::autocapitalize(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLUnknownElement::set_autocapitalize(self: mut HTMLUnknownElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::edit_context(self: HTMLUnknownElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLUnknownElement::set_edit_context(self: mut HTMLUnknownElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLUnknownElement::content_editable(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLUnknownElement::set_content_editable(self: mut HTMLUnknownElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::enter_key_hint(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLUnknownElement::set_enter_key_hint(self: mut HTMLUnknownElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::is_content_editable(self: HTMLUnknownElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLUnknownElement::input_mode(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLUnknownElement::set_input_mode(self: mut HTMLUnknownElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::virtual_keyboard_policy(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLUnknownElement::set_virtual_keyboard_policy(self: mut HTMLUnknownElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::scroll_parent(self: HTMLUnknownElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLUnknownElement::offset_parent(self: HTMLUnknownElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLUnknownElement::offset_top(self: HTMLUnknownElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLUnknownElement::offset_left(self: HTMLUnknownElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLUnknownElement::offset_width(self: HTMLUnknownElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLUnknownElement::offset_height(self: HTMLUnknownElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLUnknownElement::popover(self: HTMLUnknownElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLUnknownElement::set_popover(self: mut HTMLUnknownElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLUnknownElement::inner_text(self: HTMLUnknownElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLUnknownElement::set_inner_text(self: mut HTMLUnknownElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLUnknownElement::outer_text(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLUnknownElement::set_outer_text(self: mut HTMLUnknownElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::writing_suggestions(self: HTMLUnknownElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLUnknownElement::set_writing_suggestions(self: mut HTMLUnknownElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLUnknownElement::click(__self: mut HTMLUnknownElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUnknownElement::attach_internals(__self: mut HTMLUnknownElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLUnknownElement::toggle_popover(__self: mut HTMLUnknownElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLUnknownElement::show_popover(__self: mut HTMLUnknownElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUnknownElement::hide_popover(__self: mut HTMLUnknownElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLUnknownElement::start_view_transition(__self: mut HTMLUnknownElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLUnknownElement::start_view_transition_f_prom_unit(__self: mut HTMLUnknownElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLUnknownElement::start_view_transition_mview_transition_options(__self: mut HTMLUnknownElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLUnknownElement::as_js(self: HTMLUnknownElement) -> JsValue = JsValue::unsafe_from[HTMLUnknownElement](self)

pub fun HTMLUnknownElement::from_js(v: JsValue) -> mut HTMLUnknownElement = JsValue::unsafe_as[mut HTMLUnknownElement](v)

struct HTMLAudioElement()

/// Converts a reference to 'HTMLAudioElement' to a reference to 'HTMLMediaElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_html_media_element(self: HTMLAudioElement) -> HTMLMediaElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLAudioElement' to a mutable reference to 'HTMLMediaElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_mhtml_media_element(self: mut HTMLAudioElement) -> mut HTMLMediaElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLMediaElement' to a reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_html_media_element(base: HTMLMediaElement) -> HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLMediaElement' to 'HTMLAudioElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLMediaElement' to a mutable reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_mhtml_media_element(base: mut HTMLMediaElement) -> mut HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLMediaElement' to 'HTMLAudioElement'!\");
"

/// Converts a reference to 'HTMLAudioElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_html_element(self: HTMLAudioElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLAudioElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_mhtml_element(self: mut HTMLAudioElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_html_element(base: HTMLElement) -> HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAudioElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLAudioElement'!\");
"

/// Converts a reference to 'HTMLAudioElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_element(self: HTMLAudioElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLAudioElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::as_melement(self: mut HTMLAudioElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_element(base: Element) -> HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAudioElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLAudioElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLAudioElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLAudioElement::from_melement(base: mut Element) -> mut HTMLAudioElement = "
    if(#var(base) instanceof HTMLAudioElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLAudioElement'!\");
"

pub ext fun HTMLAudioElement::new() -> mut HTMLAudioElement
    = "return new HTMLAudioElement();"

pub ext fun HTMLAudioElement::error(self: HTMLAudioElement) -> Option[mut MediaError]
    = "return #fun(Option::from_js[mut MediaError])(#var(self).error);"

pub ext fun HTMLAudioElement::src(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLAudioElement::set_src(self: mut HTMLAudioElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::current_src(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).currentSrc);"

pub ext fun HTMLAudioElement::cross_origin(self: HTMLAudioElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLAudioElement::set_cross_origin(self: mut HTMLAudioElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLAudioElement::network_state(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).networkState);"

pub ext fun HTMLAudioElement::preload(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).preload);"

pub ext fun HTMLAudioElement::set_preload(self: mut HTMLAudioElement, value: String)
    = "#var(self).preload = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::buffered(self: HTMLAudioElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).buffered);"

pub ext fun HTMLAudioElement::ready_state(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun HTMLAudioElement::seeking(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).seeking);"

pub ext fun HTMLAudioElement::current_time(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).currentTime);"

pub ext fun HTMLAudioElement::set_current_time(self: mut HTMLAudioElement, value: Float)
    = "#var(self).currentTime = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLAudioElement::duration(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun HTMLAudioElement::paused(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).paused);"

pub ext fun HTMLAudioElement::default_playback_rate(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).defaultPlaybackRate);"

pub ext fun HTMLAudioElement::set_default_playback_rate(self: mut HTMLAudioElement, value: Float)
    = "#var(self).defaultPlaybackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLAudioElement::playback_rate(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun HTMLAudioElement::set_playback_rate(self: mut HTMLAudioElement, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLAudioElement::played(self: HTMLAudioElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).played);"

pub ext fun HTMLAudioElement::seekable(self: HTMLAudioElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).seekable);"

pub ext fun HTMLAudioElement::ended(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ended);"

pub ext fun HTMLAudioElement::autoplay(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autoplay);"

pub ext fun HTMLAudioElement::set_autoplay(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).autoplay = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::loop(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).loop);"

pub ext fun HTMLAudioElement::set_loop(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).loop = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::latency_hint(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).latencyHint);"

pub ext fun HTMLAudioElement::set_latency_hint(self: mut HTMLAudioElement, value: Float)
    = "#var(self).latencyHint = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLAudioElement::preserves_pitch(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).preservesPitch);"

pub ext fun HTMLAudioElement::set_preserves_pitch(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).preservesPitch = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::controls(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).controls);"

pub ext fun HTMLAudioElement::set_controls(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).controls = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::controls_list(self: HTMLAudioElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).controlsList);"

pub ext fun HTMLAudioElement::volume(self: HTMLAudioElement) -> Float
    = "return #fun(Float::from_js)(#var(self).volume);"

pub ext fun HTMLAudioElement::set_volume(self: mut HTMLAudioElement, value: Float)
    = "#var(self).volume = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLAudioElement::muted(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).muted);"

pub ext fun HTMLAudioElement::set_muted(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).muted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::default_muted(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultMuted);"

pub ext fun HTMLAudioElement::set_default_muted(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).defaultMuted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::audio_tracks(self: HTMLAudioElement) -> mut AudioTrackList
    = "return #fun(AudioTrackList::from_js)(#var(self).audioTracks);"

pub ext fun HTMLAudioElement::video_tracks(self: HTMLAudioElement) -> mut VideoTrackList
    = "return #fun(VideoTrackList::from_js)(#var(self).videoTracks);"

pub ext fun HTMLAudioElement::text_tracks(self: HTMLAudioElement) -> mut TextTrackList
    = "return #fun(TextTrackList::from_js)(#var(self).textTracks);"

pub ext fun HTMLAudioElement::webkit_audio_decoded_byte_count(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitAudioDecodedByteCount);"

pub ext fun HTMLAudioElement::webkit_video_decoded_byte_count(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitVideoDecodedByteCount);"

pub ext fun HTMLAudioElement::title(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLAudioElement::set_title(self: mut HTMLAudioElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::lang(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLAudioElement::set_lang(self: mut HTMLAudioElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::translate(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLAudioElement::set_translate(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::dir(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLAudioElement::set_dir(self: mut HTMLAudioElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::hidden(self: HTMLAudioElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLAudioElement::set_hidden(self: mut HTMLAudioElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLAudioElement::inert(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLAudioElement::set_inert(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::access_key(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLAudioElement::set_access_key(self: mut HTMLAudioElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::draggable(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLAudioElement::set_draggable(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::spellcheck(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLAudioElement::set_spellcheck(self: mut HTMLAudioElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLAudioElement::autocapitalize(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLAudioElement::set_autocapitalize(self: mut HTMLAudioElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::edit_context(self: HTMLAudioElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLAudioElement::set_edit_context(self: mut HTMLAudioElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLAudioElement::content_editable(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLAudioElement::set_content_editable(self: mut HTMLAudioElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::enter_key_hint(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLAudioElement::set_enter_key_hint(self: mut HTMLAudioElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::is_content_editable(self: HTMLAudioElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLAudioElement::input_mode(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLAudioElement::set_input_mode(self: mut HTMLAudioElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::virtual_keyboard_policy(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLAudioElement::set_virtual_keyboard_policy(self: mut HTMLAudioElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::scroll_parent(self: HTMLAudioElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLAudioElement::offset_parent(self: HTMLAudioElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLAudioElement::offset_top(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLAudioElement::offset_left(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLAudioElement::offset_width(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLAudioElement::offset_height(self: HTMLAudioElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLAudioElement::popover(self: HTMLAudioElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLAudioElement::set_popover(self: mut HTMLAudioElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLAudioElement::inner_text(self: HTMLAudioElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLAudioElement::set_inner_text(self: mut HTMLAudioElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLAudioElement::outer_text(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLAudioElement::set_outer_text(self: mut HTMLAudioElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::writing_suggestions(self: HTMLAudioElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLAudioElement::set_writing_suggestions(self: mut HTMLAudioElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLAudioElement::load(__self: mut HTMLAudioElement) -> Unit = "
    const r = #var(__self).load();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAudioElement::can_play_type(__self: mut HTMLAudioElement, type: String) -> String = "
    const r = #var(__self).canPlayType(#fun(String::as_js)(#var(type)));
    return #fun(String::from_js)(r);
"

pub ext fun HTMLAudioElement::play(__self: mut HTMLAudioElement) -> Promise[Unit] = "
    const r = #var(__self).play();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun HTMLAudioElement::pause(__self: mut HTMLAudioElement) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAudioElement::add_text_track(__self: mut HTMLAudioElement, kind: String, label: String, language: String) -> mut TextTrack = "
    const r = #var(__self).addTextTrack(#var(kind), #fun(String::as_js)(#var(label)), #fun(String::as_js)(#var(language)));
    return #fun(TextTrack::from_js)(r);
"

pub ext fun HTMLAudioElement::click(__self: mut HTMLAudioElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAudioElement::attach_internals(__self: mut HTMLAudioElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLAudioElement::toggle_popover(__self: mut HTMLAudioElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLAudioElement::show_popover(__self: mut HTMLAudioElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAudioElement::hide_popover(__self: mut HTMLAudioElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLAudioElement::start_view_transition(__self: mut HTMLAudioElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAudioElement::start_view_transition_f_prom_unit(__self: mut HTMLAudioElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLAudioElement::start_view_transition_mview_transition_options(__self: mut HTMLAudioElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLAudioElement::as_js(self: HTMLAudioElement) -> JsValue = JsValue::unsafe_from[HTMLAudioElement](self)

pub fun HTMLAudioElement::from_js(v: JsValue) -> mut HTMLAudioElement = JsValue::unsafe_as[mut HTMLAudioElement](v)

pub val HTMLAudioElement::network_empty: Int = 0
pub val HTMLAudioElement::network_idle: Int = 1
pub val HTMLAudioElement::network_loading: Int = 2
pub val HTMLAudioElement::network_no_source: Int = 3
pub val HTMLAudioElement::have_nothing: Int = 0
pub val HTMLAudioElement::have_metadata: Int = 1
pub val HTMLAudioElement::have_current_data: Int = 2
pub val HTMLAudioElement::have_future_data: Int = 3
pub val HTMLAudioElement::have_enough_data: Int = 4

pub val CanPlayTypeResult::Maybe: String = "maybe"
pub val CanPlayTypeResult::Probably: String = "probably"

struct HTMLMediaElement()

/// Converts a reference to 'HTMLMediaElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::as_html_element(self: HTMLMediaElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLMediaElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::as_mhtml_element(self: mut HTMLMediaElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLMediaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMediaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::from_html_element(base: HTMLElement) -> HTMLMediaElement = "
    if(#var(base) instanceof HTMLMediaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMediaElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLMediaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMediaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLMediaElement = "
    if(#var(base) instanceof HTMLMediaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLMediaElement'!\");
"

/// Converts a reference to 'HTMLMediaElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::as_element(self: HTMLMediaElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLMediaElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::as_melement(self: mut HTMLMediaElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLMediaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMediaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::from_element(base: Element) -> HTMLMediaElement = "
    if(#var(base) instanceof HTMLMediaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMediaElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLMediaElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLMediaElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLMediaElement::from_melement(base: mut Element) -> mut HTMLMediaElement = "
    if(#var(base) instanceof HTMLMediaElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLMediaElement'!\");
"

pub ext fun HTMLMediaElement::error(self: HTMLMediaElement) -> Option[mut MediaError]
    = "return #fun(Option::from_js[mut MediaError])(#var(self).error);"

pub ext fun HTMLMediaElement::src(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLMediaElement::set_src(self: mut HTMLMediaElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::current_src(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).currentSrc);"

pub ext fun HTMLMediaElement::cross_origin(self: HTMLMediaElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLMediaElement::set_cross_origin(self: mut HTMLMediaElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMediaElement::network_state(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).networkState);"

pub ext fun HTMLMediaElement::preload(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).preload);"

pub ext fun HTMLMediaElement::set_preload(self: mut HTMLMediaElement, value: String)
    = "#var(self).preload = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::buffered(self: HTMLMediaElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).buffered);"

pub ext fun HTMLMediaElement::ready_state(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun HTMLMediaElement::seeking(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).seeking);"

pub ext fun HTMLMediaElement::current_time(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).currentTime);"

pub ext fun HTMLMediaElement::set_current_time(self: mut HTMLMediaElement, value: Float)
    = "#var(self).currentTime = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMediaElement::duration(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun HTMLMediaElement::paused(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).paused);"

pub ext fun HTMLMediaElement::default_playback_rate(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).defaultPlaybackRate);"

pub ext fun HTMLMediaElement::set_default_playback_rate(self: mut HTMLMediaElement, value: Float)
    = "#var(self).defaultPlaybackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMediaElement::playback_rate(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun HTMLMediaElement::set_playback_rate(self: mut HTMLMediaElement, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMediaElement::played(self: HTMLMediaElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).played);"

pub ext fun HTMLMediaElement::seekable(self: HTMLMediaElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).seekable);"

pub ext fun HTMLMediaElement::ended(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ended);"

pub ext fun HTMLMediaElement::autoplay(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autoplay);"

pub ext fun HTMLMediaElement::set_autoplay(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).autoplay = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::loop(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).loop);"

pub ext fun HTMLMediaElement::set_loop(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).loop = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::latency_hint(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).latencyHint);"

pub ext fun HTMLMediaElement::set_latency_hint(self: mut HTMLMediaElement, value: Float)
    = "#var(self).latencyHint = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMediaElement::preserves_pitch(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).preservesPitch);"

pub ext fun HTMLMediaElement::set_preserves_pitch(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).preservesPitch = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::controls(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).controls);"

pub ext fun HTMLMediaElement::set_controls(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).controls = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::controls_list(self: HTMLMediaElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).controlsList);"

pub ext fun HTMLMediaElement::volume(self: HTMLMediaElement) -> Float
    = "return #fun(Float::from_js)(#var(self).volume);"

pub ext fun HTMLMediaElement::set_volume(self: mut HTMLMediaElement, value: Float)
    = "#var(self).volume = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLMediaElement::muted(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).muted);"

pub ext fun HTMLMediaElement::set_muted(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).muted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::default_muted(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultMuted);"

pub ext fun HTMLMediaElement::set_default_muted(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).defaultMuted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::audio_tracks(self: HTMLMediaElement) -> mut AudioTrackList
    = "return #fun(AudioTrackList::from_js)(#var(self).audioTracks);"

pub ext fun HTMLMediaElement::video_tracks(self: HTMLMediaElement) -> mut VideoTrackList
    = "return #fun(VideoTrackList::from_js)(#var(self).videoTracks);"

pub ext fun HTMLMediaElement::text_tracks(self: HTMLMediaElement) -> mut TextTrackList
    = "return #fun(TextTrackList::from_js)(#var(self).textTracks);"

pub ext fun HTMLMediaElement::webkit_audio_decoded_byte_count(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitAudioDecodedByteCount);"

pub ext fun HTMLMediaElement::webkit_video_decoded_byte_count(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitVideoDecodedByteCount);"

pub ext fun HTMLMediaElement::title(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLMediaElement::set_title(self: mut HTMLMediaElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::lang(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLMediaElement::set_lang(self: mut HTMLMediaElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::translate(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLMediaElement::set_translate(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::dir(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLMediaElement::set_dir(self: mut HTMLMediaElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::hidden(self: HTMLMediaElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLMediaElement::set_hidden(self: mut HTMLMediaElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLMediaElement::inert(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLMediaElement::set_inert(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::access_key(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLMediaElement::set_access_key(self: mut HTMLMediaElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::draggable(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLMediaElement::set_draggable(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::spellcheck(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLMediaElement::set_spellcheck(self: mut HTMLMediaElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLMediaElement::autocapitalize(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLMediaElement::set_autocapitalize(self: mut HTMLMediaElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::edit_context(self: HTMLMediaElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLMediaElement::set_edit_context(self: mut HTMLMediaElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLMediaElement::content_editable(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLMediaElement::set_content_editable(self: mut HTMLMediaElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::enter_key_hint(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLMediaElement::set_enter_key_hint(self: mut HTMLMediaElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::is_content_editable(self: HTMLMediaElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLMediaElement::input_mode(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLMediaElement::set_input_mode(self: mut HTMLMediaElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::virtual_keyboard_policy(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLMediaElement::set_virtual_keyboard_policy(self: mut HTMLMediaElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::scroll_parent(self: HTMLMediaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLMediaElement::offset_parent(self: HTMLMediaElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLMediaElement::offset_top(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLMediaElement::offset_left(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLMediaElement::offset_width(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLMediaElement::offset_height(self: HTMLMediaElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLMediaElement::popover(self: HTMLMediaElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLMediaElement::set_popover(self: mut HTMLMediaElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLMediaElement::inner_text(self: HTMLMediaElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLMediaElement::set_inner_text(self: mut HTMLMediaElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLMediaElement::outer_text(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLMediaElement::set_outer_text(self: mut HTMLMediaElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::writing_suggestions(self: HTMLMediaElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLMediaElement::set_writing_suggestions(self: mut HTMLMediaElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLMediaElement::load(__self: mut HTMLMediaElement) -> Unit = "
    const r = #var(__self).load();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMediaElement::can_play_type(__self: mut HTMLMediaElement, type: String) -> String = "
    const r = #var(__self).canPlayType(#fun(String::as_js)(#var(type)));
    return #fun(String::from_js)(r);
"

pub ext fun HTMLMediaElement::play(__self: mut HTMLMediaElement) -> Promise[Unit] = "
    const r = #var(__self).play();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun HTMLMediaElement::pause(__self: mut HTMLMediaElement) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMediaElement::add_text_track(__self: mut HTMLMediaElement, kind: String, label: String, language: String) -> mut TextTrack = "
    const r = #var(__self).addTextTrack(#var(kind), #fun(String::as_js)(#var(label)), #fun(String::as_js)(#var(language)));
    return #fun(TextTrack::from_js)(r);
"

pub ext fun HTMLMediaElement::click(__self: mut HTMLMediaElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMediaElement::attach_internals(__self: mut HTMLMediaElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLMediaElement::toggle_popover(__self: mut HTMLMediaElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLMediaElement::show_popover(__self: mut HTMLMediaElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMediaElement::hide_popover(__self: mut HTMLMediaElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLMediaElement::start_view_transition(__self: mut HTMLMediaElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMediaElement::start_view_transition_f_prom_unit(__self: mut HTMLMediaElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLMediaElement::start_view_transition_mview_transition_options(__self: mut HTMLMediaElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLMediaElement::as_js(self: HTMLMediaElement) -> JsValue = JsValue::unsafe_from[HTMLMediaElement](self)

pub fun HTMLMediaElement::from_js(v: JsValue) -> mut HTMLMediaElement = JsValue::unsafe_as[mut HTMLMediaElement](v)

pub val HTMLMediaElement::network_empty: Int = 0
pub val HTMLMediaElement::network_idle: Int = 1
pub val HTMLMediaElement::network_loading: Int = 2
pub val HTMLMediaElement::network_no_source: Int = 3
pub val HTMLMediaElement::have_nothing: Int = 0
pub val HTMLMediaElement::have_metadata: Int = 1
pub val HTMLMediaElement::have_current_data: Int = 2
pub val HTMLMediaElement::have_future_data: Int = 3
pub val HTMLMediaElement::have_enough_data: Int = 4

struct HTMLVideoElement()

/// Converts a reference to 'HTMLVideoElement' to a reference to 'HTMLMediaElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_html_media_element(self: HTMLVideoElement) -> HTMLMediaElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLVideoElement' to a mutable reference to 'HTMLMediaElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_mhtml_media_element(self: mut HTMLVideoElement) -> mut HTMLMediaElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLMediaElement' to a reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_html_media_element(base: HTMLMediaElement) -> HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLMediaElement' to 'HTMLVideoElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLMediaElement' to a mutable reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_mhtml_media_element(base: mut HTMLMediaElement) -> mut HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLMediaElement' to 'HTMLVideoElement'!\");
"

/// Converts a reference to 'HTMLVideoElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_html_element(self: HTMLVideoElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLVideoElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_mhtml_element(self: mut HTMLVideoElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_html_element(base: HTMLElement) -> HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLVideoElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLVideoElement'!\");
"

/// Converts a reference to 'HTMLVideoElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_element(self: HTMLVideoElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLVideoElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::as_melement(self: mut HTMLVideoElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_element(base: Element) -> HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLVideoElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLVideoElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLVideoElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLVideoElement::from_melement(base: mut Element) -> mut HTMLVideoElement = "
    if(#var(base) instanceof HTMLVideoElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLVideoElement'!\");
"

pub ext fun HTMLVideoElement::width(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun HTMLVideoElement::set_width(self: mut HTMLVideoElement, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLVideoElement::height(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun HTMLVideoElement::set_height(self: mut HTMLVideoElement, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun HTMLVideoElement::video_width(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).videoWidth);"

pub ext fun HTMLVideoElement::video_height(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).videoHeight);"

pub ext fun HTMLVideoElement::poster(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).poster);"

pub ext fun HTMLVideoElement::set_poster(self: mut HTMLVideoElement, value: String)
    = "#var(self).poster = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::webkit_decoded_frame_count(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitDecodedFrameCount);"

pub ext fun HTMLVideoElement::webkit_dropped_frame_count(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitDroppedFrameCount);"

pub ext fun HTMLVideoElement::plays_inline(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).playsInline);"

pub ext fun HTMLVideoElement::set_plays_inline(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).playsInline = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::error(self: HTMLVideoElement) -> Option[mut MediaError]
    = "return #fun(Option::from_js[mut MediaError])(#var(self).error);"

pub ext fun HTMLVideoElement::src(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLVideoElement::set_src(self: mut HTMLVideoElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::current_src(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).currentSrc);"

pub ext fun HTMLVideoElement::cross_origin(self: HTMLVideoElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun HTMLVideoElement::set_cross_origin(self: mut HTMLVideoElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLVideoElement::network_state(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).networkState);"

pub ext fun HTMLVideoElement::preload(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).preload);"

pub ext fun HTMLVideoElement::set_preload(self: mut HTMLVideoElement, value: String)
    = "#var(self).preload = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::buffered(self: HTMLVideoElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).buffered);"

pub ext fun HTMLVideoElement::ready_state(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun HTMLVideoElement::seeking(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).seeking);"

pub ext fun HTMLVideoElement::current_time(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).currentTime);"

pub ext fun HTMLVideoElement::set_current_time(self: mut HTMLVideoElement, value: Float)
    = "#var(self).currentTime = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLVideoElement::duration(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun HTMLVideoElement::paused(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).paused);"

pub ext fun HTMLVideoElement::default_playback_rate(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).defaultPlaybackRate);"

pub ext fun HTMLVideoElement::set_default_playback_rate(self: mut HTMLVideoElement, value: Float)
    = "#var(self).defaultPlaybackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLVideoElement::playback_rate(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).playbackRate);"

pub ext fun HTMLVideoElement::set_playback_rate(self: mut HTMLVideoElement, value: Float)
    = "#var(self).playbackRate = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLVideoElement::played(self: HTMLVideoElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).played);"

pub ext fun HTMLVideoElement::seekable(self: HTMLVideoElement) -> mut TimeRanges
    = "return #fun(TimeRanges::from_js)(#var(self).seekable);"

pub ext fun HTMLVideoElement::ended(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).ended);"

pub ext fun HTMLVideoElement::autoplay(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autoplay);"

pub ext fun HTMLVideoElement::set_autoplay(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).autoplay = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::loop(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).loop);"

pub ext fun HTMLVideoElement::set_loop(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).loop = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::latency_hint(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).latencyHint);"

pub ext fun HTMLVideoElement::set_latency_hint(self: mut HTMLVideoElement, value: Float)
    = "#var(self).latencyHint = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLVideoElement::preserves_pitch(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).preservesPitch);"

pub ext fun HTMLVideoElement::set_preserves_pitch(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).preservesPitch = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::controls(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).controls);"

pub ext fun HTMLVideoElement::set_controls(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).controls = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::controls_list(self: HTMLVideoElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).controlsList);"

pub ext fun HTMLVideoElement::volume(self: HTMLVideoElement) -> Float
    = "return #fun(Float::from_js)(#var(self).volume);"

pub ext fun HTMLVideoElement::set_volume(self: mut HTMLVideoElement, value: Float)
    = "#var(self).volume = #fun(Float::as_js)(#var(value));"

pub ext fun HTMLVideoElement::muted(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).muted);"

pub ext fun HTMLVideoElement::set_muted(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).muted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::default_muted(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultMuted);"

pub ext fun HTMLVideoElement::set_default_muted(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).defaultMuted = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::audio_tracks(self: HTMLVideoElement) -> mut AudioTrackList
    = "return #fun(AudioTrackList::from_js)(#var(self).audioTracks);"

pub ext fun HTMLVideoElement::video_tracks(self: HTMLVideoElement) -> mut VideoTrackList
    = "return #fun(VideoTrackList::from_js)(#var(self).videoTracks);"

pub ext fun HTMLVideoElement::text_tracks(self: HTMLVideoElement) -> mut TextTrackList
    = "return #fun(TextTrackList::from_js)(#var(self).textTracks);"

pub ext fun HTMLVideoElement::webkit_audio_decoded_byte_count(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitAudioDecodedByteCount);"

pub ext fun HTMLVideoElement::webkit_video_decoded_byte_count(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).webkitVideoDecodedByteCount);"

pub ext fun HTMLVideoElement::title(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLVideoElement::set_title(self: mut HTMLVideoElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::lang(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLVideoElement::set_lang(self: mut HTMLVideoElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::translate(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLVideoElement::set_translate(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::dir(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLVideoElement::set_dir(self: mut HTMLVideoElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::hidden(self: HTMLVideoElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLVideoElement::set_hidden(self: mut HTMLVideoElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLVideoElement::inert(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLVideoElement::set_inert(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::access_key(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLVideoElement::set_access_key(self: mut HTMLVideoElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::draggable(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLVideoElement::set_draggable(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::spellcheck(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLVideoElement::set_spellcheck(self: mut HTMLVideoElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLVideoElement::autocapitalize(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLVideoElement::set_autocapitalize(self: mut HTMLVideoElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::edit_context(self: HTMLVideoElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLVideoElement::set_edit_context(self: mut HTMLVideoElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLVideoElement::content_editable(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLVideoElement::set_content_editable(self: mut HTMLVideoElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::enter_key_hint(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLVideoElement::set_enter_key_hint(self: mut HTMLVideoElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::is_content_editable(self: HTMLVideoElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLVideoElement::input_mode(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLVideoElement::set_input_mode(self: mut HTMLVideoElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::virtual_keyboard_policy(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLVideoElement::set_virtual_keyboard_policy(self: mut HTMLVideoElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::scroll_parent(self: HTMLVideoElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLVideoElement::offset_parent(self: HTMLVideoElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLVideoElement::offset_top(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLVideoElement::offset_left(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLVideoElement::offset_width(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLVideoElement::offset_height(self: HTMLVideoElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLVideoElement::popover(self: HTMLVideoElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLVideoElement::set_popover(self: mut HTMLVideoElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLVideoElement::inner_text(self: HTMLVideoElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLVideoElement::set_inner_text(self: mut HTMLVideoElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLVideoElement::outer_text(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLVideoElement::set_outer_text(self: mut HTMLVideoElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::writing_suggestions(self: HTMLVideoElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLVideoElement::set_writing_suggestions(self: mut HTMLVideoElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLVideoElement::load(__self: mut HTMLVideoElement) -> Unit = "
    const r = #var(__self).load();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLVideoElement::can_play_type(__self: mut HTMLVideoElement, type: String) -> String = "
    const r = #var(__self).canPlayType(#fun(String::as_js)(#var(type)));
    return #fun(String::from_js)(r);
"

pub ext fun HTMLVideoElement::play(__self: mut HTMLVideoElement) -> Promise[Unit] = "
    const r = #var(__self).play();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun HTMLVideoElement::pause(__self: mut HTMLVideoElement) -> Unit = "
    const r = #var(__self).pause();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLVideoElement::add_text_track(__self: mut HTMLVideoElement, kind: String, label: String, language: String) -> mut TextTrack = "
    const r = #var(__self).addTextTrack(#var(kind), #fun(String::as_js)(#var(label)), #fun(String::as_js)(#var(language)));
    return #fun(TextTrack::from_js)(r);
"

pub ext fun HTMLVideoElement::click(__self: mut HTMLVideoElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLVideoElement::attach_internals(__self: mut HTMLVideoElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLVideoElement::toggle_popover(__self: mut HTMLVideoElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLVideoElement::show_popover(__self: mut HTMLVideoElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLVideoElement::hide_popover(__self: mut HTMLVideoElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLVideoElement::start_view_transition(__self: mut HTMLVideoElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLVideoElement::start_view_transition_f_prom_unit(__self: mut HTMLVideoElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLVideoElement::start_view_transition_mview_transition_options(__self: mut HTMLVideoElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLVideoElement::as_js(self: HTMLVideoElement) -> JsValue = JsValue::unsafe_from[HTMLVideoElement](self)

pub fun HTMLVideoElement::from_js(v: JsValue) -> mut HTMLVideoElement = JsValue::unsafe_as[mut HTMLVideoElement](v)

pub val HTMLVideoElement::network_empty: Int = 0
pub val HTMLVideoElement::network_idle: Int = 1
pub val HTMLVideoElement::network_loading: Int = 2
pub val HTMLVideoElement::network_no_source: Int = 3
pub val HTMLVideoElement::have_nothing: Int = 0
pub val HTMLVideoElement::have_metadata: Int = 1
pub val HTMLVideoElement::have_current_data: Int = 2
pub val HTMLVideoElement::have_future_data: Int = 3
pub val HTMLVideoElement::have_enough_data: Int = 4

struct MediaError()

pub ext fun MediaError::code(self: MediaError) -> Int
    = "return #fun(Int::from_js)(#var(self).code);"

pub ext fun MediaError::message(self: MediaError) -> String
    = "return #fun(String::from_js)(#var(self).message);"

pub fun MediaError::as_js(self: MediaError) -> JsValue = JsValue::unsafe_from[MediaError](self)

pub fun MediaError::from_js(v: JsValue) -> mut MediaError = JsValue::unsafe_as[mut MediaError](v)

pub val MediaError::media_err_aborted: Int = 1
pub val MediaError::media_err_network: Int = 2
pub val MediaError::media_err_decode: Int = 3
pub val MediaError::media_err_src_not_supported: Int = 4

pub struct ShowPopoverOptions(
    source: Option[mut HTMLElement]
)

pub fun ShowPopoverOptions::default() -> mut ShowPopoverOptions
    = ShowPopoverOptions(Option::None)

pub ext fun ShowPopoverOptions::from_js(value: JsValue) -> mut ShowPopoverOptions = "
    const r = {};
    r.m_source = #fun(Option::from_js[mut HTMLElement])(#var(value).source);
    return r;
"

pub ext fun ShowPopoverOptions::as_js(self: ShowPopoverOptions) -> JsValue = "
    const r = {};
    r.source = #fun(Option::as_js_undef[mut HTMLElement])(#var(self).m_source);
    return r;
"

pub struct TogglePopoverOptions(
    force: Option[Bool],
    source: Option[mut HTMLElement]
)

pub fun TogglePopoverOptions::default() -> mut TogglePopoverOptions
    = TogglePopoverOptions(Option::None, Option::None)

/// Converts a reference to 'TogglePopoverOptions' to a reference to 'ShowPopoverOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun TogglePopoverOptions::as_show_popover_options(self: TogglePopoverOptions) -> ShowPopoverOptions = "return #var(self);"

/// Converts a mutable reference to 'TogglePopoverOptions' to a mutable reference to 'ShowPopoverOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun TogglePopoverOptions::as_mshow_popover_options(self: mut TogglePopoverOptions) -> mut ShowPopoverOptions = "return #var(self);"

/// Attempts to convert a reference to 'ShowPopoverOptions' to a reference to 'TogglePopoverOptions'.
/// A 'base' that is not a reference to 'TogglePopoverOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TogglePopoverOptions::from_show_popover_options_unchecked(base: ShowPopoverOptions) -> TogglePopoverOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'ShowPopoverOptions' to a mutable reference to 'TogglePopoverOptions'.
/// A 'base' that is not a reference to 'TogglePopoverOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TogglePopoverOptions::from_mshow_popover_options_unchecked(base: mut ShowPopoverOptions) -> mut TogglePopoverOptions = "return #var(base);"

pub ext fun TogglePopoverOptions::from_js(value: JsValue) -> mut TogglePopoverOptions = "
    const r = {};
    r.m_force = #fun(Option::from_js[Bool])(#var(value).force);
    r.m_source = #fun(Option::from_js[mut HTMLElement])(#var(value).source);
    return r;
"

pub ext fun TogglePopoverOptions::as_js(self: TogglePopoverOptions) -> JsValue = "
    const r = {};
    r.force = #fun(Option::as_js_undef[Bool])(#var(self).m_force);
    r.source = #fun(Option::as_js_undef[mut HTMLElement])(#var(self).m_source);
    return r;
"

struct TimeRanges()

pub ext fun TimeRanges::length(self: TimeRanges) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun TimeRanges::start(__self: mut TimeRanges, index: Int) -> Float = "
    const r = #var(__self).start(#fun(Int::as_js)(#var(index)));
    return #fun(Float::from_js)(r);
"

pub ext fun TimeRanges::end(__self: mut TimeRanges, index: Int) -> Float = "
    const r = #var(__self).end(#fun(Int::as_js)(#var(index)));
    return #fun(Float::from_js)(r);
"

pub fun TimeRanges::as_js(self: TimeRanges) -> JsValue = JsValue::unsafe_from[TimeRanges](self)

pub fun TimeRanges::from_js(v: JsValue) -> mut TimeRanges = JsValue::unsafe_as[mut TimeRanges](v)

struct AudioTrack()

pub ext fun AudioTrack::id(self: AudioTrack) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun AudioTrack::kind(self: AudioTrack) -> String
    = "return #fun(String::from_js)(#var(self).kind);"

pub ext fun AudioTrack::label(self: AudioTrack) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun AudioTrack::language(self: AudioTrack) -> String
    = "return #fun(String::from_js)(#var(self).language);"

pub ext fun AudioTrack::enabled(self: AudioTrack) -> Bool
    = "return #fun(Bool::from_js)(#var(self).enabled);"

pub ext fun AudioTrack::set_enabled(self: mut AudioTrack, value: Bool)
    = "#var(self).enabled = #fun(Bool::as_js)(#var(value));"

pub fun AudioTrack::as_js(self: AudioTrack) -> JsValue = JsValue::unsafe_from[AudioTrack](self)

pub fun AudioTrack::from_js(v: JsValue) -> mut AudioTrack = JsValue::unsafe_as[mut AudioTrack](v)

struct AudioTrackList()

/// Converts a reference to 'AudioTrackList' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AudioTrackList::as_event_target(self: AudioTrackList) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'AudioTrackList' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AudioTrackList::as_mevent_target(self: mut AudioTrackList) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'AudioTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'AudioTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AudioTrackList::from_event_target(base: EventTarget) -> AudioTrackList = "
    if(#var(base) instanceof AudioTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AudioTrackList'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'AudioTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'AudioTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AudioTrackList::from_mevent_target(base: mut EventTarget) -> mut AudioTrackList = "
    if(#var(base) instanceof AudioTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AudioTrackList'!\");
"

pub ext fun AudioTrackList::length(self: AudioTrackList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun AudioTrackList::onchange(self: AudioTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun AudioTrackList::set_onchange(self: mut AudioTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun AudioTrackList::onaddtrack(self: AudioTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onaddtrack);"

pub ext fun AudioTrackList::set_onaddtrack(self: mut AudioTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onaddtrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun AudioTrackList::onremovetrack(self: AudioTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremovetrack);"

pub ext fun AudioTrackList::set_onremovetrack(self: mut AudioTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremovetrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun AudioTrackList::get(__self: AudioTrackList, index: Int) -> mut AudioTrack = "
    const r = AudioTrackList[#fun(Int::as_js)(#var(index))];
    return #fun(AudioTrack::from_js)(r);
"

pub ext fun AudioTrackList::get_track_by_id(__self: mut AudioTrackList, id: String) -> Option[mut AudioTrack] = "
    const r = #var(__self).getTrackById(#fun(String::as_js)(#var(id)));
    return #fun(Option::from_js[mut AudioTrack])(r);
"

pub ext fun AudioTrackList::add_event_listener(__self: mut AudioTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AudioTrackList::remove_event_listener(__self: mut AudioTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AudioTrackList::dispatch_event(__self: mut AudioTrackList, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun AudioTrackList::when(__self: mut AudioTrackList, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun AudioTrackList::as_js(self: AudioTrackList) -> JsValue = JsValue::unsafe_from[AudioTrackList](self)

pub fun AudioTrackList::from_js(v: JsValue) -> mut AudioTrackList = JsValue::unsafe_as[mut AudioTrackList](v)

struct HTMLTrackElement()

/// Converts a reference to 'HTMLTrackElement' to a reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::as_html_element(self: HTMLTrackElement) -> HTMLElement = "return #var(self);"

/// Converts a mutable reference to 'HTMLTrackElement' to a mutable reference to 'HTMLElement'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::as_mhtml_element(self: mut HTMLTrackElement) -> mut HTMLElement = "return #var(self);"

/// Attempts to convert a reference to 'HTMLElement' to a reference to 'HTMLTrackElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTrackElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::from_html_element(base: HTMLElement) -> HTMLTrackElement = "
    if(#var(base) instanceof HTMLTrackElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTrackElement'!\");
"

/// Attempts to convert a mutable reference to 'HTMLElement' to a mutable reference to 'HTMLTrackElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTrackElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::from_mhtml_element(base: mut HTMLElement) -> mut HTMLTrackElement = "
    if(#var(base) instanceof HTMLTrackElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'HTMLElement' to 'HTMLTrackElement'!\");
"

/// Converts a reference to 'HTMLTrackElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::as_element(self: HTMLTrackElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'HTMLTrackElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::as_melement(self: mut HTMLTrackElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'HTMLTrackElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTrackElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::from_element(base: Element) -> HTMLTrackElement = "
    if(#var(base) instanceof HTMLTrackElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTrackElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'HTMLTrackElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'HTMLTrackElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun HTMLTrackElement::from_melement(base: mut Element) -> mut HTMLTrackElement = "
    if(#var(base) instanceof HTMLTrackElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'HTMLTrackElement'!\");
"

pub ext fun HTMLTrackElement::kind(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).kind);"

pub ext fun HTMLTrackElement::set_kind(self: mut HTMLTrackElement, value: String)
    = "#var(self).kind = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::src(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).src);"

pub ext fun HTMLTrackElement::set_src(self: mut HTMLTrackElement, value: String)
    = "#var(self).src = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::srclang(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).srclang);"

pub ext fun HTMLTrackElement::set_srclang(self: mut HTMLTrackElement, value: String)
    = "#var(self).srclang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::label(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun HTMLTrackElement::set_label(self: mut HTMLTrackElement, value: String)
    = "#var(self).label = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::default(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).default);"

pub ext fun HTMLTrackElement::set_default(self: mut HTMLTrackElement, value: Bool)
    = "#var(self).default = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTrackElement::ready_state(self: HTMLTrackElement) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun HTMLTrackElement::track(self: HTMLTrackElement) -> mut TextTrack
    = "return #fun(TextTrack::from_js)(#var(self).track);"

pub ext fun HTMLTrackElement::title(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun HTMLTrackElement::set_title(self: mut HTMLTrackElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::lang(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).lang);"

pub ext fun HTMLTrackElement::set_lang(self: mut HTMLTrackElement, value: String)
    = "#var(self).lang = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::translate(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).translate);"

pub ext fun HTMLTrackElement::set_translate(self: mut HTMLTrackElement, value: Bool)
    = "#var(self).translate = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTrackElement::dir(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).dir);"

pub ext fun HTMLTrackElement::set_dir(self: mut HTMLTrackElement, value: String)
    = "#var(self).dir = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::hidden(self: HTMLTrackElement) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).hidden);"

pub ext fun HTMLTrackElement::set_hidden(self: mut HTMLTrackElement, value: Option[JsValue])
    = "#var(self).hidden = #fun(Option::as_js[JsValue])(#var(value));"

pub ext fun HTMLTrackElement::inert(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).inert);"

pub ext fun HTMLTrackElement::set_inert(self: mut HTMLTrackElement, value: Bool)
    = "#var(self).inert = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTrackElement::access_key(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).accessKey);"

pub ext fun HTMLTrackElement::set_access_key(self: mut HTMLTrackElement, value: String)
    = "#var(self).accessKey = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::draggable(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).draggable);"

pub ext fun HTMLTrackElement::set_draggable(self: mut HTMLTrackElement, value: Bool)
    = "#var(self).draggable = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTrackElement::spellcheck(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).spellcheck);"

pub ext fun HTMLTrackElement::set_spellcheck(self: mut HTMLTrackElement, value: Bool)
    = "#var(self).spellcheck = #fun(Bool::as_js)(#var(value));"

pub ext fun HTMLTrackElement::autocapitalize(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).autocapitalize);"

pub ext fun HTMLTrackElement::set_autocapitalize(self: mut HTMLTrackElement, value: String)
    = "#var(self).autocapitalize = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::edit_context(self: HTMLTrackElement) -> Option[mut EditContext]
    = "return #fun(Option::from_js[mut EditContext])(#var(self).editContext);"

pub ext fun HTMLTrackElement::set_edit_context(self: mut HTMLTrackElement, value: Option[mut EditContext])
    = "#var(self).editContext = #fun(Option::as_js[mut EditContext])(#var(value));"

pub ext fun HTMLTrackElement::content_editable(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).contentEditable);"

pub ext fun HTMLTrackElement::set_content_editable(self: mut HTMLTrackElement, value: String)
    = "#var(self).contentEditable = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::enter_key_hint(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).enterKeyHint);"

pub ext fun HTMLTrackElement::set_enter_key_hint(self: mut HTMLTrackElement, value: String)
    = "#var(self).enterKeyHint = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::is_content_editable(self: HTMLTrackElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isContentEditable);"

pub ext fun HTMLTrackElement::input_mode(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).inputMode);"

pub ext fun HTMLTrackElement::set_input_mode(self: mut HTMLTrackElement, value: String)
    = "#var(self).inputMode = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::virtual_keyboard_policy(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).virtualKeyboardPolicy);"

pub ext fun HTMLTrackElement::set_virtual_keyboard_policy(self: mut HTMLTrackElement, value: String)
    = "#var(self).virtualKeyboardPolicy = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::scroll_parent(self: HTMLTrackElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).scrollParent);"

pub ext fun HTMLTrackElement::offset_parent(self: HTMLTrackElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).offsetParent);"

pub ext fun HTMLTrackElement::offset_top(self: HTMLTrackElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetTop);"

pub ext fun HTMLTrackElement::offset_left(self: HTMLTrackElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetLeft);"

pub ext fun HTMLTrackElement::offset_width(self: HTMLTrackElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetWidth);"

pub ext fun HTMLTrackElement::offset_height(self: HTMLTrackElement) -> Int
    = "return #fun(Int::from_js)(#var(self).offsetHeight);"

pub ext fun HTMLTrackElement::popover(self: HTMLTrackElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).popover);"

pub ext fun HTMLTrackElement::set_popover(self: mut HTMLTrackElement, value: Option[String])
    = "#var(self).popover = #fun(Option::as_js[String])(#var(value));"

pub ext fun HTMLTrackElement::inner_text(self: HTMLTrackElement) -> JsValue
    = "return #var(self).innerText;"

pub ext fun HTMLTrackElement::set_inner_text(self: mut HTMLTrackElement, value: JsValue)
    = "#var(self).innerText = #var(value);"

pub ext fun HTMLTrackElement::outer_text(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).outerText);"

pub ext fun HTMLTrackElement::set_outer_text(self: mut HTMLTrackElement, value: String)
    = "#var(self).outerText = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::writing_suggestions(self: HTMLTrackElement) -> String
    = "return #fun(String::from_js)(#var(self).writingSuggestions);"

pub ext fun HTMLTrackElement::set_writing_suggestions(self: mut HTMLTrackElement, value: String)
    = "#var(self).writingSuggestions = #fun(String::as_js)(#var(value));"

pub ext fun HTMLTrackElement::click(__self: mut HTMLTrackElement) -> Unit = "
    const r = #var(__self).click();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTrackElement::attach_internals(__self: mut HTMLTrackElement) -> mut ElementInternals = "
    const r = #var(__self).attachInternals();
    return #fun(ElementInternals::from_js)(r);
"

pub ext fun HTMLTrackElement::toggle_popover(__self: mut HTMLTrackElement, options: JsValue) -> Bool = "
    const r = #var(__self).togglePopover(#var(options));
    return #fun(Bool::from_js)(r);
"

pub ext fun HTMLTrackElement::show_popover(__self: mut HTMLTrackElement, options: mut ShowPopoverOptions) -> Unit = "
    const r = #var(__self).showPopover(#fun(ShowPopoverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTrackElement::hide_popover(__self: mut HTMLTrackElement) -> Unit = "
    const r = #var(__self).hidePopover();
    return #fun(Unit::from_js)(r);
"

pub ext fun HTMLTrackElement::start_view_transition(__self: mut HTMLTrackElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTrackElement::start_view_transition_f_prom_unit(__self: mut HTMLTrackElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun HTMLTrackElement::start_view_transition_mview_transition_options(__self: mut HTMLTrackElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun HTMLTrackElement::as_js(self: HTMLTrackElement) -> JsValue = JsValue::unsafe_from[HTMLTrackElement](self)

pub fun HTMLTrackElement::from_js(v: JsValue) -> mut HTMLTrackElement = JsValue::unsafe_as[mut HTMLTrackElement](v)

pub val HTMLTrackElement::none: Int = 0
pub val HTMLTrackElement::loading: Int = 1
pub val HTMLTrackElement::loaded: Int = 2
pub val HTMLTrackElement::error: Int = 3

pub val TextTrackMode::Disabled: String = "disabled"
pub val TextTrackMode::Hidden: String = "hidden"
pub val TextTrackMode::Showing: String = "showing"

pub val TextTrackKind::Subtitles: String = "subtitles"
pub val TextTrackKind::Captions: String = "captions"
pub val TextTrackKind::Descriptions: String = "descriptions"
pub val TextTrackKind::Chapters: String = "chapters"
pub val TextTrackKind::Metadata: String = "metadata"

struct TextTrack()

/// Converts a reference to 'TextTrack' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrack::as_event_target(self: TextTrack) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'TextTrack' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrack::as_mevent_target(self: mut TextTrack) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'TextTrack'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrack' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrack::from_event_target(base: EventTarget) -> TextTrack = "
    if(#var(base) instanceof TextTrack) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrack'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'TextTrack'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrack' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrack::from_mevent_target(base: mut EventTarget) -> mut TextTrack = "
    if(#var(base) instanceof TextTrack) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrack'!\");
"

pub ext fun TextTrack::kind(self: TextTrack) -> String
    = "return #fun(String::from_js)(#var(self).kind);"

pub ext fun TextTrack::label(self: TextTrack) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun TextTrack::language(self: TextTrack) -> String
    = "return #fun(String::from_js)(#var(self).language);"

pub ext fun TextTrack::id(self: TextTrack) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun TextTrack::mode(self: TextTrack) -> String
    = "return #fun(String::from_js)(#var(self).mode);"

pub ext fun TextTrack::set_mode(self: mut TextTrack, value: String)
    = "#var(self).mode = #var(value);"

pub ext fun TextTrack::cues(self: TextTrack) -> Option[mut TextTrackCueList]
    = "return #fun(Option::from_js[mut TextTrackCueList])(#var(self).cues);"

pub ext fun TextTrack::active_cues(self: TextTrack) -> Option[mut TextTrackCueList]
    = "return #fun(Option::from_js[mut TextTrackCueList])(#var(self).activeCues);"

pub ext fun TextTrack::oncuechange(self: TextTrack) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun TextTrack::set_oncuechange(self: mut TextTrack, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrack::add_cue(__self: mut TextTrack, cue: mut TextTrackCue) -> Unit = "
    const r = #var(__self).addCue(#fun(TextTrackCue::as_js)(#var(cue)));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrack::remove_cue(__self: mut TextTrack, cue: mut TextTrackCue) -> Unit = "
    const r = #var(__self).removeCue(#fun(TextTrackCue::as_js)(#var(cue)));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrack::add_event_listener(__self: mut TextTrack, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrack::remove_event_listener(__self: mut TextTrack, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrack::dispatch_event(__self: mut TextTrack, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun TextTrack::when(__self: mut TextTrack, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun TextTrack::as_js(self: TextTrack) -> JsValue = JsValue::unsafe_from[TextTrack](self)

pub fun TextTrack::from_js(v: JsValue) -> mut TextTrack = JsValue::unsafe_as[mut TextTrack](v)

struct TextTrackCue()

/// Converts a reference to 'TextTrackCue' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackCue::as_event_target(self: TextTrackCue) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'TextTrackCue' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackCue::as_mevent_target(self: mut TextTrackCue) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'TextTrackCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrackCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackCue::from_event_target(base: EventTarget) -> TextTrackCue = "
    if(#var(base) instanceof TextTrackCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrackCue'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'TextTrackCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrackCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackCue::from_mevent_target(base: mut EventTarget) -> mut TextTrackCue = "
    if(#var(base) instanceof TextTrackCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrackCue'!\");
"

pub ext fun TextTrackCue::track(self: TextTrackCue) -> Option[mut TextTrack]
    = "return #fun(Option::from_js[mut TextTrack])(#var(self).track);"

pub ext fun TextTrackCue::id(self: TextTrackCue) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun TextTrackCue::set_id(self: mut TextTrackCue, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun TextTrackCue::start_time(self: TextTrackCue) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun TextTrackCue::set_start_time(self: mut TextTrackCue, value: Float)
    = "#var(self).startTime = #fun(Float::as_js)(#var(value));"

pub ext fun TextTrackCue::end_time(self: TextTrackCue) -> Float
    = "return #fun(Float::from_js)(#var(self).endTime);"

pub ext fun TextTrackCue::set_end_time(self: mut TextTrackCue, value: Float)
    = "#var(self).endTime = #fun(Float::as_js)(#var(value));"

pub ext fun TextTrackCue::pause_on_exit(self: TextTrackCue) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pauseOnExit);"

pub ext fun TextTrackCue::set_pause_on_exit(self: mut TextTrackCue, value: Bool)
    = "#var(self).pauseOnExit = #fun(Bool::as_js)(#var(value));"

pub ext fun TextTrackCue::onenter(self: TextTrackCue) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onenter);"

pub ext fun TextTrackCue::set_onenter(self: mut TextTrackCue, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrackCue::onexit(self: TextTrackCue) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onexit);"

pub ext fun TextTrackCue::set_onexit(self: mut TextTrackCue, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onexit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrackCue::add_event_listener(__self: mut TextTrackCue, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrackCue::remove_event_listener(__self: mut TextTrackCue, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrackCue::dispatch_event(__self: mut TextTrackCue, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun TextTrackCue::when(__self: mut TextTrackCue, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun TextTrackCue::as_js(self: TextTrackCue) -> JsValue = JsValue::unsafe_from[TextTrackCue](self)

pub fun TextTrackCue::from_js(v: JsValue) -> mut TextTrackCue = JsValue::unsafe_as[mut TextTrackCue](v)

struct TextTrackCueList()

pub ext fun TextTrackCueList::length(self: TextTrackCueList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun TextTrackCueList::get(__self: TextTrackCueList, index: Int) -> mut TextTrackCue = "
    const r = TextTrackCueList[#fun(Int::as_js)(#var(index))];
    return #fun(TextTrackCue::from_js)(r);
"

pub ext fun TextTrackCueList::get_cue_by_id(__self: mut TextTrackCueList, id: String) -> Option[mut TextTrackCue] = "
    const r = #var(__self).getCueById(#fun(String::as_js)(#var(id)));
    return #fun(Option::from_js[mut TextTrackCue])(r);
"

pub fun TextTrackCueList::as_js(self: TextTrackCueList) -> JsValue = JsValue::unsafe_from[TextTrackCueList](self)

pub fun TextTrackCueList::from_js(v: JsValue) -> mut TextTrackCueList = JsValue::unsafe_as[mut TextTrackCueList](v)

struct TextTrackList()

/// Converts a reference to 'TextTrackList' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackList::as_event_target(self: TextTrackList) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'TextTrackList' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackList::as_mevent_target(self: mut TextTrackList) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'TextTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackList::from_event_target(base: EventTarget) -> TextTrackList = "
    if(#var(base) instanceof TextTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrackList'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'TextTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'TextTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TextTrackList::from_mevent_target(base: mut EventTarget) -> mut TextTrackList = "
    if(#var(base) instanceof TextTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TextTrackList'!\");
"

pub ext fun TextTrackList::length(self: TextTrackList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun TextTrackList::onchange(self: TextTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun TextTrackList::set_onchange(self: mut TextTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrackList::onaddtrack(self: TextTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onaddtrack);"

pub ext fun TextTrackList::set_onaddtrack(self: mut TextTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onaddtrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrackList::onremovetrack(self: TextTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremovetrack);"

pub ext fun TextTrackList::set_onremovetrack(self: mut TextTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremovetrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TextTrackList::get(__self: TextTrackList, index: Int) -> mut TextTrack = "
    const r = TextTrackList[#fun(Int::as_js)(#var(index))];
    return #fun(TextTrack::from_js)(r);
"

pub ext fun TextTrackList::get_track_by_id(__self: mut TextTrackList, id: String) -> Option[mut TextTrack] = "
    const r = #var(__self).getTrackById(#fun(String::as_js)(#var(id)));
    return #fun(Option::from_js[mut TextTrack])(r);
"

pub ext fun TextTrackList::add_event_listener(__self: mut TextTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrackList::remove_event_listener(__self: mut TextTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TextTrackList::dispatch_event(__self: mut TextTrackList, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun TextTrackList::when(__self: mut TextTrackList, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun TextTrackList::as_js(self: TextTrackList) -> JsValue = JsValue::unsafe_from[TextTrackList](self)

pub fun TextTrackList::from_js(v: JsValue) -> mut TextTrackList = JsValue::unsafe_as[mut TextTrackList](v)

struct TrackEvent()

/// Converts a reference to 'TrackEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEvent::as_event(self: TrackEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TrackEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEvent::as_mevent(self: mut TrackEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TrackEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TrackEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEvent::from_event(base: Event) -> TrackEvent = "
    if(#var(base) instanceof TrackEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TrackEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TrackEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TrackEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEvent::from_mevent(base: mut Event) -> mut TrackEvent = "
    if(#var(base) instanceof TrackEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TrackEvent'!\");
"

pub ext fun TrackEvent::from_str_mtrack_event_init(type: String, event_init_dict: mut TrackEventInit) -> mut TrackEvent
    = "return new TrackEvent(#fun(String::as_js)(#var(type)), #fun(TrackEventInit::as_js)(#var(event_init_dict)));"

pub ext fun TrackEvent::track(self: TrackEvent) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).track);"

pub ext fun TrackEvent::type(self: TrackEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TrackEvent::target(self: TrackEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TrackEvent::current_target(self: TrackEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TrackEvent::event_phase(self: TrackEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TrackEvent::bubbles(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TrackEvent::cancelable(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TrackEvent::default_prevented(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TrackEvent::composed(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TrackEvent::is_trusted(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TrackEvent::time_stamp(self: TrackEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TrackEvent::src_element(self: TrackEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TrackEvent::return_value(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TrackEvent::set_return_value(self: mut TrackEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TrackEvent::cancel_bubble(self: TrackEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TrackEvent::set_cancel_bubble(self: mut TrackEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TrackEvent::composed_path(__self: mut TrackEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TrackEvent::stop_propagation(__self: mut TrackEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TrackEvent::stop_immediate_propagation(__self: mut TrackEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TrackEvent::prevent_default(__self: mut TrackEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TrackEvent::init_event(__self: mut TrackEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TrackEvent::as_js(self: TrackEvent) -> JsValue = JsValue::unsafe_from[TrackEvent](self)

pub fun TrackEvent::from_js(v: JsValue) -> mut TrackEvent = JsValue::unsafe_as[mut TrackEvent](v)

pub val TrackEvent::none: Int = 0
pub val TrackEvent::capturing_phase: Int = 1
pub val TrackEvent::at_target: Int = 2
pub val TrackEvent::bubbling_phase: Int = 3

pub struct TrackEventInit(
    track: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TrackEventInit::default() -> mut TrackEventInit
    = TrackEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TrackEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEventInit::as_event_init(self: TrackEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'TrackEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEventInit::as_mevent_init(self: mut TrackEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'TrackEventInit'.
/// A 'base' that is not a reference to 'TrackEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEventInit::from_event_init_unchecked(base: EventInit) -> TrackEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'TrackEventInit'.
/// A 'base' that is not a reference to 'TrackEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TrackEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut TrackEventInit = "return #var(base);"

pub ext fun TrackEventInit::from_js(value: JsValue) -> mut TrackEventInit = "
    const r = {};
    r.m_track = #fun(Option::from_js[JsValue])(#var(value).track);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TrackEventInit::as_js(self: TrackEventInit) -> JsValue = "
    const r = {};
    r.track = #fun(Option::as_js_undef[JsValue])(#var(self).m_track);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct VideoTrack()

pub ext fun VideoTrack::id(self: VideoTrack) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun VideoTrack::kind(self: VideoTrack) -> String
    = "return #fun(String::from_js)(#var(self).kind);"

pub ext fun VideoTrack::label(self: VideoTrack) -> String
    = "return #fun(String::from_js)(#var(self).label);"

pub ext fun VideoTrack::language(self: VideoTrack) -> String
    = "return #fun(String::from_js)(#var(self).language);"

pub ext fun VideoTrack::selected(self: VideoTrack) -> Bool
    = "return #fun(Bool::from_js)(#var(self).selected);"

pub ext fun VideoTrack::set_selected(self: mut VideoTrack, value: Bool)
    = "#var(self).selected = #fun(Bool::as_js)(#var(value));"

pub fun VideoTrack::as_js(self: VideoTrack) -> JsValue = JsValue::unsafe_from[VideoTrack](self)

pub fun VideoTrack::from_js(v: JsValue) -> mut VideoTrack = JsValue::unsafe_as[mut VideoTrack](v)

struct VideoTrackList()

/// Converts a reference to 'VideoTrackList' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VideoTrackList::as_event_target(self: VideoTrackList) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'VideoTrackList' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VideoTrackList::as_mevent_target(self: mut VideoTrackList) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'VideoTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'VideoTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VideoTrackList::from_event_target(base: EventTarget) -> VideoTrackList = "
    if(#var(base) instanceof VideoTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VideoTrackList'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'VideoTrackList'.
/// The conversion may fail and panic if 'base' is not a reference to 'VideoTrackList' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VideoTrackList::from_mevent_target(base: mut EventTarget) -> mut VideoTrackList = "
    if(#var(base) instanceof VideoTrackList) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VideoTrackList'!\");
"

pub ext fun VideoTrackList::length(self: VideoTrackList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun VideoTrackList::selected_index(self: VideoTrackList) -> Int
    = "return #fun(Int::from_js)(#var(self).selectedIndex);"

pub ext fun VideoTrackList::onchange(self: VideoTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun VideoTrackList::set_onchange(self: mut VideoTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VideoTrackList::onaddtrack(self: VideoTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onaddtrack);"

pub ext fun VideoTrackList::set_onaddtrack(self: mut VideoTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onaddtrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VideoTrackList::onremovetrack(self: VideoTrackList) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onremovetrack);"

pub ext fun VideoTrackList::set_onremovetrack(self: mut VideoTrackList, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onremovetrack = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VideoTrackList::get(__self: VideoTrackList, index: Int) -> mut VideoTrack = "
    const r = VideoTrackList[#fun(Int::as_js)(#var(index))];
    return #fun(VideoTrack::from_js)(r);
"

pub ext fun VideoTrackList::get_track_by_id(__self: mut VideoTrackList, id: String) -> Option[mut VideoTrack] = "
    const r = #var(__self).getTrackById(#fun(String::as_js)(#var(id)));
    return #fun(Option::from_js[mut VideoTrack])(r);
"

pub ext fun VideoTrackList::add_event_listener(__self: mut VideoTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VideoTrackList::remove_event_listener(__self: mut VideoTrackList, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VideoTrackList::dispatch_event(__self: mut VideoTrackList, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun VideoTrackList::when(__self: mut VideoTrackList, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun VideoTrackList::as_js(self: VideoTrackList) -> JsValue = JsValue::unsafe_from[VideoTrackList](self)

pub fun VideoTrackList::from_js(v: JsValue) -> mut VideoTrackList = JsValue::unsafe_as[mut VideoTrackList](v)

pub val AutoKeyword::Auto: String = "auto"

pub val DirectionSetting::Rl: String = "rl"
pub val DirectionSetting::Lr: String = "lr"

pub val AlignSetting::Start: String = "start"
pub val AlignSetting::Center: String = "center"
pub val AlignSetting::End: String = "end"
pub val AlignSetting::Left: String = "left"
pub val AlignSetting::Right: String = "right"

struct VTTCue()

/// Converts a reference to 'VTTCue' to a reference to 'TextTrackCue'.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::as_text_track_cue(self: VTTCue) -> TextTrackCue = "return #var(self);"

/// Converts a mutable reference to 'VTTCue' to a mutable reference to 'TextTrackCue'.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::as_mtext_track_cue(self: mut VTTCue) -> mut TextTrackCue = "return #var(self);"

/// Attempts to convert a reference to 'TextTrackCue' to a reference to 'VTTCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'VTTCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::from_text_track_cue(base: TextTrackCue) -> VTTCue = "
    if(#var(base) instanceof VTTCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'TextTrackCue' to 'VTTCue'!\");
"

/// Attempts to convert a mutable reference to 'TextTrackCue' to a mutable reference to 'VTTCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'VTTCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::from_mtext_track_cue(base: mut TextTrackCue) -> mut VTTCue = "
    if(#var(base) instanceof VTTCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'TextTrackCue' to 'VTTCue'!\");
"

/// Converts a reference to 'VTTCue' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::as_event_target(self: VTTCue) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'VTTCue' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::as_mevent_target(self: mut VTTCue) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'VTTCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'VTTCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::from_event_target(base: EventTarget) -> VTTCue = "
    if(#var(base) instanceof VTTCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VTTCue'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'VTTCue'.
/// The conversion may fail and panic if 'base' is not a reference to 'VTTCue' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VTTCue::from_mevent_target(base: mut EventTarget) -> mut VTTCue = "
    if(#var(base) instanceof VTTCue) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'VTTCue'!\");
"

pub ext fun VTTCue::from_flt_flt_str(start_time: Float, end_time: Float, text: String) -> mut VTTCue
    = "return new VTTCue(#fun(Float::as_js)(#var(start_time)), #fun(Float::as_js)(#var(end_time)), #fun(String::as_js)(#var(text)));"

pub ext fun VTTCue::region(self: VTTCue) -> Option[mut VTTRegion]
    = "return #fun(Option::from_js[mut VTTRegion])(#var(self).region);"

pub ext fun VTTCue::set_region(self: mut VTTCue, value: Option[mut VTTRegion])
    = "#var(self).region = #fun(Option::as_js[mut VTTRegion])(#var(value));"

pub ext fun VTTCue::vertical(self: VTTCue) -> String
    = "return #fun(String::from_js)(#var(self).vertical);"

pub ext fun VTTCue::set_vertical(self: mut VTTCue, value: String)
    = "#var(self).vertical = #var(value);"

pub ext fun VTTCue::snap_to_lines(self: VTTCue) -> Bool
    = "return #fun(Bool::from_js)(#var(self).snapToLines);"

pub ext fun VTTCue::set_snap_to_lines(self: mut VTTCue, value: Bool)
    = "#var(self).snapToLines = #fun(Bool::as_js)(#var(value));"

pub ext fun VTTCue::line(self: VTTCue) -> JsValue
    = "return #var(self).line;"

pub ext fun VTTCue::set_line(self: mut VTTCue, value: JsValue)
    = "#var(self).line = #var(value);"

pub ext fun VTTCue::position(self: VTTCue) -> JsValue
    = "return #var(self).position;"

pub ext fun VTTCue::set_position(self: mut VTTCue, value: JsValue)
    = "#var(self).position = #var(value);"

pub ext fun VTTCue::size(self: VTTCue) -> Float
    = "return #fun(Float::from_js)(#var(self).size);"

pub ext fun VTTCue::set_size(self: mut VTTCue, value: Float)
    = "#var(self).size = #fun(Float::as_js)(#var(value));"

pub ext fun VTTCue::align(self: VTTCue) -> String
    = "return #fun(String::from_js)(#var(self).align);"

pub ext fun VTTCue::set_align(self: mut VTTCue, value: String)
    = "#var(self).align = #var(value);"

pub ext fun VTTCue::text(self: VTTCue) -> String
    = "return #fun(String::from_js)(#var(self).text);"

pub ext fun VTTCue::set_text(self: mut VTTCue, value: String)
    = "#var(self).text = #fun(String::as_js)(#var(value));"

pub ext fun VTTCue::track(self: VTTCue) -> Option[mut TextTrack]
    = "return #fun(Option::from_js[mut TextTrack])(#var(self).track);"

pub ext fun VTTCue::id(self: VTTCue) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun VTTCue::set_id(self: mut VTTCue, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun VTTCue::start_time(self: VTTCue) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun VTTCue::set_start_time(self: mut VTTCue, value: Float)
    = "#var(self).startTime = #fun(Float::as_js)(#var(value));"

pub ext fun VTTCue::end_time(self: VTTCue) -> Float
    = "return #fun(Float::from_js)(#var(self).endTime);"

pub ext fun VTTCue::set_end_time(self: mut VTTCue, value: Float)
    = "#var(self).endTime = #fun(Float::as_js)(#var(value));"

pub ext fun VTTCue::pause_on_exit(self: VTTCue) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pauseOnExit);"

pub ext fun VTTCue::set_pause_on_exit(self: mut VTTCue, value: Bool)
    = "#var(self).pauseOnExit = #fun(Bool::as_js)(#var(value));"

pub ext fun VTTCue::onenter(self: VTTCue) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onenter);"

pub ext fun VTTCue::set_onenter(self: mut VTTCue, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VTTCue::onexit(self: VTTCue) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onexit);"

pub ext fun VTTCue::set_onexit(self: mut VTTCue, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onexit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun VTTCue::get_cue_as_html(__self: mut VTTCue) -> mut DocumentFragment = "
    const r = #var(__self).getCueAsHTML();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun VTTCue::add_event_listener(__self: mut VTTCue, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VTTCue::remove_event_listener(__self: mut VTTCue, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun VTTCue::dispatch_event(__self: mut VTTCue, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun VTTCue::when(__self: mut VTTCue, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun VTTCue::as_js(self: VTTCue) -> JsValue = JsValue::unsafe_from[VTTCue](self)

pub fun VTTCue::from_js(v: JsValue) -> mut VTTCue = JsValue::unsafe_as[mut VTTCue](v)

pub val ScrollSetting::Up: String = "up"

struct VTTRegion()

pub ext fun VTTRegion::new() -> mut VTTRegion
    = "return new VTTRegion();"

pub ext fun VTTRegion::id(self: VTTRegion) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun VTTRegion::set_id(self: mut VTTRegion, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun VTTRegion::width(self: VTTRegion) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun VTTRegion::set_width(self: mut VTTRegion, value: Float)
    = "#var(self).width = #fun(Float::as_js)(#var(value));"

pub ext fun VTTRegion::lines(self: VTTRegion) -> Int
    = "return #fun(Int::from_js)(#var(self).lines);"

pub ext fun VTTRegion::set_lines(self: mut VTTRegion, value: Int)
    = "#var(self).lines = #fun(Int::as_js)(#var(value));"

pub ext fun VTTRegion::region_anchor_x(self: VTTRegion) -> Float
    = "return #fun(Float::from_js)(#var(self).regionAnchorX);"

pub ext fun VTTRegion::set_region_anchor_x(self: mut VTTRegion, value: Float)
    = "#var(self).regionAnchorX = #fun(Float::as_js)(#var(value));"

pub ext fun VTTRegion::region_anchor_y(self: VTTRegion) -> Float
    = "return #fun(Float::from_js)(#var(self).regionAnchorY);"

pub ext fun VTTRegion::set_region_anchor_y(self: mut VTTRegion, value: Float)
    = "#var(self).regionAnchorY = #fun(Float::as_js)(#var(value));"

pub ext fun VTTRegion::viewport_anchor_x(self: VTTRegion) -> Float
    = "return #fun(Float::from_js)(#var(self).viewportAnchorX);"

pub ext fun VTTRegion::set_viewport_anchor_x(self: mut VTTRegion, value: Float)
    = "#var(self).viewportAnchorX = #fun(Float::as_js)(#var(value));"

pub ext fun VTTRegion::viewport_anchor_y(self: VTTRegion) -> Float
    = "return #fun(Float::from_js)(#var(self).viewportAnchorY);"

pub ext fun VTTRegion::set_viewport_anchor_y(self: mut VTTRegion, value: Float)
    = "#var(self).viewportAnchorY = #fun(Float::as_js)(#var(value));"

pub ext fun VTTRegion::scroll(self: VTTRegion) -> String
    = "return #fun(String::from_js)(#var(self).scroll);"

pub ext fun VTTRegion::set_scroll(self: mut VTTRegion, value: String)
    = "#var(self).scroll = #var(value);"

pub fun VTTRegion::as_js(self: VTTRegion) -> JsValue = JsValue::unsafe_from[VTTRegion](self)

pub fun VTTRegion::from_js(v: JsValue) -> mut VTTRegion = JsValue::unsafe_as[mut VTTRegion](v)

struct ImageBitmap()

pub ext fun ImageBitmap::width(self: ImageBitmap) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun ImageBitmap::height(self: ImageBitmap) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun ImageBitmap::close(__self: mut ImageBitmap) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub fun ImageBitmap::as_js(self: ImageBitmap) -> JsValue = JsValue::unsafe_from[ImageBitmap](self)

pub fun ImageBitmap::from_js(v: JsValue) -> mut ImageBitmap = JsValue::unsafe_as[mut ImageBitmap](v)

pub val ImageOrientation::FromImage: String = "from-image"
pub val ImageOrientation::None: String = "none"
pub val ImageOrientation::FlipY: String = "flipY"

pub val PremultiplyAlpha::None: String = "none"
pub val PremultiplyAlpha::Premultiply: String = "premultiply"
pub val PremultiplyAlpha::Default: String = "default"

pub val ColorSpaceConversion::None: String = "none"
pub val ColorSpaceConversion::Default: String = "default"

pub val ResizeQuality::Pixelated: String = "pixelated"
pub val ResizeQuality::Low: String = "low"
pub val ResizeQuality::Medium: String = "medium"
pub val ResizeQuality::High: String = "high"

pub struct ImageBitmapOptions(
    image_orientation: Option[String],
    premultiply_alpha: Option[String],
    color_space_conversion: Option[String],
    resize_width: Option[Int],
    resize_height: Option[Int],
    resize_quality: Option[String]
)

pub fun ImageBitmapOptions::default() -> mut ImageBitmapOptions
    = ImageBitmapOptions(Option::Some("from-image"), Option::Some("default"), Option::Some("default"), Option::None, Option::None, Option::Some("low"))

pub ext fun ImageBitmapOptions::from_js(value: JsValue) -> mut ImageBitmapOptions = "
    const r = {};
    r.m_image_orientation = #fun(Option::from_js[String])(#var(value).imageOrientation);
    r.m_premultiply_alpha = #fun(Option::from_js[String])(#var(value).premultiplyAlpha);
    r.m_color_space_conversion = #fun(Option::from_js[String])(#var(value).colorSpaceConversion);
    r.m_resize_width = #fun(Option::from_js[Int])(#var(value).resizeWidth);
    r.m_resize_height = #fun(Option::from_js[Int])(#var(value).resizeHeight);
    r.m_resize_quality = #fun(Option::from_js[String])(#var(value).resizeQuality);
    return r;
"

pub ext fun ImageBitmapOptions::as_js(self: ImageBitmapOptions) -> JsValue = "
    const r = {};
    r.imageOrientation = #fun(Option::as_js_undef[String])(#var(self).m_image_orientation);
    r.premultiplyAlpha = #fun(Option::as_js_undef[String])(#var(self).m_premultiply_alpha);
    r.colorSpaceConversion = #fun(Option::as_js_undef[String])(#var(self).m_color_space_conversion);
    r.resizeWidth = #fun(Option::as_js_undef[Int])(#var(self).m_resize_width);
    r.resizeHeight = #fun(Option::as_js_undef[Int])(#var(self).m_resize_height);
    r.resizeQuality = #fun(Option::as_js_undef[String])(#var(self).m_resize_quality);
    return r;
"

struct InputDeviceCapabilities()

pub ext fun InputDeviceCapabilities::from_minput_device_capabilities_init(device_init_dict: mut InputDeviceCapabilitiesInit) -> mut InputDeviceCapabilities
    = "return new InputDeviceCapabilities(#fun(InputDeviceCapabilitiesInit::as_js)(#var(device_init_dict)));"

pub ext fun InputDeviceCapabilities::fires_touch_events(self: InputDeviceCapabilities) -> Bool
    = "return #fun(Bool::from_js)(#var(self).firesTouchEvents);"

pub fun InputDeviceCapabilities::as_js(self: InputDeviceCapabilities) -> JsValue = JsValue::unsafe_from[InputDeviceCapabilities](self)

pub fun InputDeviceCapabilities::from_js(v: JsValue) -> mut InputDeviceCapabilities = JsValue::unsafe_as[mut InputDeviceCapabilities](v)

pub struct InputDeviceCapabilitiesInit(
    fires_touch_events: Option[Bool]
)

pub fun InputDeviceCapabilitiesInit::default() -> mut InputDeviceCapabilitiesInit
    = InputDeviceCapabilitiesInit(Option::Some(false))

pub ext fun InputDeviceCapabilitiesInit::from_js(value: JsValue) -> mut InputDeviceCapabilitiesInit = "
    const r = {};
    r.m_fires_touch_events = #fun(Option::from_js[Bool])(#var(value).firesTouchEvents);
    return r;
"

pub ext fun InputDeviceCapabilitiesInit::as_js(self: InputDeviceCapabilitiesInit) -> JsValue = "
    const r = {};
    r.firesTouchEvents = #fun(Option::as_js_undef[Bool])(#var(self).m_fires_touch_events);
    return r;
"

struct Touch()

pub ext fun Touch::from_mtouch_init(init_dict: mut TouchInit) -> mut Touch
    = "return new Touch(#fun(TouchInit::as_js)(#var(init_dict)));"

pub ext fun Touch::identifier(self: Touch) -> Int
    = "return #fun(Int::from_js)(#var(self).identifier);"

pub ext fun Touch::target(self: Touch) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).target);"

pub ext fun Touch::screen_x(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).screenX);"

pub ext fun Touch::screen_y(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).screenY);"

pub ext fun Touch::client_x(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).clientX);"

pub ext fun Touch::client_y(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).clientY);"

pub ext fun Touch::page_x(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).pageX);"

pub ext fun Touch::page_y(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).pageY);"

pub ext fun Touch::radius_x(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).radiusX);"

pub ext fun Touch::radius_y(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).radiusY);"

pub ext fun Touch::rotation_angle(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).rotationAngle);"

pub ext fun Touch::force(self: Touch) -> Float
    = "return #fun(Float::from_js)(#var(self).force);"

pub fun Touch::as_js(self: Touch) -> JsValue = JsValue::unsafe_from[Touch](self)

pub fun Touch::from_js(v: JsValue) -> mut Touch = JsValue::unsafe_as[mut Touch](v)

pub struct TouchInit(
    identifier: Int,
    target: mut EventTarget,
    client_x: Option[Float],
    client_y: Option[Float],
    screen_x: Option[Float],
    screen_y: Option[Float],
    page_x: Option[Float],
    page_y: Option[Float],
    radius_x: Option[Float],
    radius_y: Option[Float],
    rotation_angle: Option[Float],
    force: Option[Float]
)

pub fun TouchInit::default(identifier: Int, target: mut EventTarget) -> mut TouchInit
    = TouchInit(identifier, target, Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0), Option::Some(0.0))

pub ext fun TouchInit::from_js(value: JsValue) -> mut TouchInit = "
    const r = {};
    r.m_identifier = #fun(Int::from_js)(#var(value).identifier);
    r.m_target = #fun(EventTarget::from_js)(#var(value).target);
    r.m_client_x = #fun(Option::from_js[Float])(#var(value).clientX);
    r.m_client_y = #fun(Option::from_js[Float])(#var(value).clientY);
    r.m_screen_x = #fun(Option::from_js[Float])(#var(value).screenX);
    r.m_screen_y = #fun(Option::from_js[Float])(#var(value).screenY);
    r.m_page_x = #fun(Option::from_js[Float])(#var(value).pageX);
    r.m_page_y = #fun(Option::from_js[Float])(#var(value).pageY);
    r.m_radius_x = #fun(Option::from_js[Float])(#var(value).radiusX);
    r.m_radius_y = #fun(Option::from_js[Float])(#var(value).radiusY);
    r.m_rotation_angle = #fun(Option::from_js[Float])(#var(value).rotationAngle);
    r.m_force = #fun(Option::from_js[Float])(#var(value).force);
    return r;
"

pub ext fun TouchInit::as_js(self: TouchInit) -> JsValue = "
    const r = {};
    r.identifier = #fun(Int::as_js)(#var(self).m_identifier);
    r.target = #fun(EventTarget::as_js)(#var(self).m_target);
    r.clientX = #fun(Option::as_js_undef[Float])(#var(self).m_client_x);
    r.clientY = #fun(Option::as_js_undef[Float])(#var(self).m_client_y);
    r.screenX = #fun(Option::as_js_undef[Float])(#var(self).m_screen_x);
    r.screenY = #fun(Option::as_js_undef[Float])(#var(self).m_screen_y);
    r.pageX = #fun(Option::as_js_undef[Float])(#var(self).m_page_x);
    r.pageY = #fun(Option::as_js_undef[Float])(#var(self).m_page_y);
    r.radiusX = #fun(Option::as_js_undef[Float])(#var(self).m_radius_x);
    r.radiusY = #fun(Option::as_js_undef[Float])(#var(self).m_radius_y);
    r.rotationAngle = #fun(Option::as_js_undef[Float])(#var(self).m_rotation_angle);
    r.force = #fun(Option::as_js_undef[Float])(#var(self).m_force);
    return r;
"

struct TouchList()

pub ext fun TouchList::length(self: TouchList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun TouchList::item(__self: mut TouchList, index: Int) -> Option[mut Touch] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Touch])(r);
"

pub fun TouchList::as_js(self: TouchList) -> JsValue = JsValue::unsafe_from[TouchList](self)

pub fun TouchList::from_js(v: JsValue) -> mut TouchList = JsValue::unsafe_as[mut TouchList](v)

pub struct Accelerator(
    key_code: Option[Int],
    modifiers: Option[Int]
)

pub fun Accelerator::default() -> mut Accelerator
    = Accelerator(Option::None, Option::None)

pub ext fun Accelerator::from_js(value: JsValue) -> mut Accelerator = "
    const r = {};
    r.m_key_code = #fun(Option::from_js[Int])(#var(value).keyCode);
    r.m_modifiers = #fun(Option::from_js[Int])(#var(value).modifiers);
    return r;
"

pub ext fun Accelerator::as_js(self: Accelerator) -> JsValue = "
    const r = {};
    r.keyCode = #fun(Option::as_js_undef[Int])(#var(self).m_key_code);
    r.modifiers = #fun(Option::as_js_undef[Int])(#var(self).m_modifiers);
    return r;
"

pub struct ShowContextMenuItem(
    type: String,
    id: Option[Int],
    label: Option[String],
    is_experimental_feature: Option[Bool],
    enabled: Option[Bool],
    checked: Option[Bool],
    is_dev_tools_performance_menu_item: Option[Bool],
    accelerator: Option[mut Accelerator],
    sub_items: Option[List[mut ShowContextMenuItem]]
)

pub fun ShowContextMenuItem::default(type: String) -> mut ShowContextMenuItem
    = ShowContextMenuItem(type, Option::None, Option::None, Option::Some(false), Option::Some(true), Option::Some(false), Option::Some(false), Option::None, Option::None)

pub ext fun ShowContextMenuItem::from_js(value: JsValue) -> mut ShowContextMenuItem = "
    const r = {};
    r.m_type = #fun(String::from_js)(#var(value).type);
    r.m_id = #fun(Option::from_js[Int])(#var(value).id);
    r.m_label = #fun(Option::from_js[String])(#var(value).label);
    r.m_is_experimental_feature = #fun(Option::from_js[Bool])(#var(value).isExperimentalFeature);
    r.m_enabled = #fun(Option::from_js[Bool])(#var(value).enabled);
    r.m_checked = #fun(Option::from_js[Bool])(#var(value).checked);
    r.m_is_dev_tools_performance_menu_item = #fun(Option::from_js[Bool])(#var(value).isDevToolsPerformanceMenuItem);
    r.m_accelerator = #fun(Option::from_js[mut Accelerator])(#var(value).accelerator);
    r.m_sub_items = #fun(Option::from_js[List[mut ShowContextMenuItem]])(#var(value).subItems);
    return r;
"

pub ext fun ShowContextMenuItem::as_js(self: ShowContextMenuItem) -> JsValue = "
    const r = {};
    r.type = #fun(String::as_js)(#var(self).m_type);
    r.id = #fun(Option::as_js_undef[Int])(#var(self).m_id);
    r.label = #fun(Option::as_js_undef[String])(#var(self).m_label);
    r.isExperimentalFeature = #fun(Option::as_js_undef[Bool])(#var(self).m_is_experimental_feature);
    r.enabled = #fun(Option::as_js_undef[Bool])(#var(self).m_enabled);
    r.checked = #fun(Option::as_js_undef[Bool])(#var(self).m_checked);
    r.isDevToolsPerformanceMenuItem = #fun(Option::as_js_undef[Bool])(#var(self).m_is_dev_tools_performance_menu_item);
    r.accelerator = #fun(Option::as_js_undef[mut Accelerator])(#var(self).m_accelerator);
    r.subItems = #fun(Option::as_js_undef[List[mut ShowContextMenuItem]])(#var(self).m_sub_items);
    return r;
"

struct DevToolsHost()

pub ext fun DevToolsHost::zoom_factor(__self: mut DevToolsHost) -> Float = "
    const r = #var(__self).zoomFactor();
    return #fun(Float::from_js)(r);
"

pub ext fun DevToolsHost::copy_text(__self: mut DevToolsHost, text: String) -> Unit = "
    const r = #var(__self).copyText(#fun(String::as_js)(#var(text)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DevToolsHost::platform(__self: mut DevToolsHost) -> String = "
    const r = #var(__self).platform();
    return #fun(String::from_js)(r);
"

pub ext fun DevToolsHost::show_context_menu_at_point(__self: mut DevToolsHost, x: Float, y: Float, items: List[mut ShowContextMenuItem], document: mut Document) -> Unit = "
    const r = #var(__self).showContextMenuAtPoint(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(List::as_js[mut ShowContextMenuItem])(#var(items)), #fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DevToolsHost::send_message_to_embedder(__self: mut DevToolsHost, message: String) -> Unit = "
    const r = #var(__self).sendMessageToEmbedder(#fun(String::as_js)(#var(message)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DevToolsHost::is_hosted_mode(__self: mut DevToolsHost) -> Bool = "
    const r = #var(__self).isHostedMode();
    return #fun(Bool::from_js)(r);
"

pub fun DevToolsHost::as_js(self: DevToolsHost) -> JsValue = JsValue::unsafe_from[DevToolsHost](self)

pub fun DevToolsHost::from_js(v: JsValue) -> mut DevToolsHost = JsValue::unsafe_as[mut DevToolsHost](v)

struct InspectorOverlayHost()

pub ext fun InspectorOverlayHost::send(__self: mut InspectorOverlayHost, command: JsValue) -> Unit = "
    const r = #var(__self).send(#var(command));
    return #fun(Unit::from_js)(r);
"

pub fun InspectorOverlayHost::as_js(self: InspectorOverlayHost) -> JsValue = JsValue::unsafe_from[InspectorOverlayHost](self)

pub fun InspectorOverlayHost::from_js(v: JsValue) -> mut InspectorOverlayHost = JsValue::unsafe_as[mut InspectorOverlayHost](v)

struct IntersectionObserver()

pub ext fun IntersectionObserver::from_f_list_mintersection_observer_entry_mintersection_observer_unit_mintersection_observer_init(callback: Fun(List[mut IntersectionObserverEntry], mut IntersectionObserver) -> Unit, options: mut IntersectionObserverInit) -> mut IntersectionObserver
    = "return new IntersectionObserver(((p0, p1) => { const r = #var(callback)(#fun(List::from_js[mut IntersectionObserverEntry])(p0), #fun(IntersectionObserver::from_js)(p1)); return #fun(Unit::as_js)(r); }), #fun(IntersectionObserverInit::as_js)(#var(options)));"

pub ext fun IntersectionObserver::root(self: IntersectionObserver) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).root);"

pub ext fun IntersectionObserver::root_margin(self: IntersectionObserver) -> String
    = "return #fun(String::from_js)(#var(self).rootMargin);"

pub ext fun IntersectionObserver::scroll_margin(self: IntersectionObserver) -> String
    = "return #fun(String::from_js)(#var(self).scrollMargin);"

pub ext fun IntersectionObserver::thresholds(self: IntersectionObserver) -> JsValue
    = "return #var(self).thresholds;"

pub ext fun IntersectionObserver::delay(self: IntersectionObserver) -> Float
    = "return #fun(Float::from_js)(#var(self).delay);"

pub ext fun IntersectionObserver::track_visibility(self: IntersectionObserver) -> Bool
    = "return #fun(Bool::from_js)(#var(self).trackVisibility);"

pub ext fun IntersectionObserver::observe(__self: mut IntersectionObserver, target: mut Element) -> Unit = "
    const r = #var(__self).observe(#fun(Element::as_js)(#var(target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun IntersectionObserver::unobserve(__self: mut IntersectionObserver, target: mut Element) -> Unit = "
    const r = #var(__self).unobserve(#fun(Element::as_js)(#var(target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun IntersectionObserver::disconnect(__self: mut IntersectionObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun IntersectionObserver::take_records(__self: mut IntersectionObserver) -> List[mut IntersectionObserverEntry] = "
    const r = #var(__self).takeRecords();
    return #fun(List::from_js[mut IntersectionObserverEntry])(r);
"

pub fun IntersectionObserver::as_js(self: IntersectionObserver) -> JsValue = JsValue::unsafe_from[IntersectionObserver](self)

pub fun IntersectionObserver::from_js(v: JsValue) -> mut IntersectionObserver = JsValue::unsafe_as[mut IntersectionObserver](v)

struct IntersectionObserverEntry()

pub ext fun IntersectionObserverEntry::time(self: IntersectionObserverEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).time);"

pub ext fun IntersectionObserverEntry::root_bounds(self: IntersectionObserverEntry) -> Option[mut DOMRectReadOnly]
    = "return #fun(Option::from_js[mut DOMRectReadOnly])(#var(self).rootBounds);"

pub ext fun IntersectionObserverEntry::bounding_client_rect(self: IntersectionObserverEntry) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).boundingClientRect);"

pub ext fun IntersectionObserverEntry::intersection_rect(self: IntersectionObserverEntry) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).intersectionRect);"

pub ext fun IntersectionObserverEntry::is_intersecting(self: IntersectionObserverEntry) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isIntersecting);"

pub ext fun IntersectionObserverEntry::is_visible(self: IntersectionObserverEntry) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isVisible);"

pub ext fun IntersectionObserverEntry::intersection_ratio(self: IntersectionObserverEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).intersectionRatio);"

pub ext fun IntersectionObserverEntry::target(self: IntersectionObserverEntry) -> mut Element
    = "return #fun(Element::from_js)(#var(self).target);"

pub fun IntersectionObserverEntry::as_js(self: IntersectionObserverEntry) -> JsValue = JsValue::unsafe_from[IntersectionObserverEntry](self)

pub fun IntersectionObserverEntry::from_js(v: JsValue) -> mut IntersectionObserverEntry = JsValue::unsafe_as[mut IntersectionObserverEntry](v)

pub struct IntersectionObserverInit(
    root: Option[JsValue],
    root_margin: Option[String],
    scroll_margin: Option[String],
    threshold: Option[JsValue],
    delay: Option[Float],
    track_visibility: Option[Bool]
)

pub fun IntersectionObserverInit::default() -> mut IntersectionObserverInit
    = IntersectionObserverInit(Option::None, Option::Some("0px"), Option::Some("0px"), Option::Some(0.0 |> as_js()), Option::Some(0.0), Option::Some(false))

pub ext fun IntersectionObserverInit::from_js(value: JsValue) -> mut IntersectionObserverInit = "
    const r = {};
    r.m_root = #fun(Option::from_js[JsValue])(#var(value).root);
    r.m_root_margin = #fun(Option::from_js[String])(#var(value).rootMargin);
    r.m_scroll_margin = #fun(Option::from_js[String])(#var(value).scrollMargin);
    r.m_threshold = #fun(Option::from_js[JsValue])(#var(value).threshold);
    r.m_delay = #fun(Option::from_js[Float])(#var(value).delay);
    r.m_track_visibility = #fun(Option::from_js[Bool])(#var(value).trackVisibility);
    return r;
"

pub ext fun IntersectionObserverInit::as_js(self: IntersectionObserverInit) -> JsValue = "
    const r = {};
    r.root = #fun(Option::as_js_undef[JsValue])(#var(self).m_root);
    r.rootMargin = #fun(Option::as_js_undef[String])(#var(self).m_root_margin);
    r.scrollMargin = #fun(Option::as_js_undef[String])(#var(self).m_scroll_margin);
    r.threshold = #fun(Option::as_js_undef[JsValue])(#var(self).m_threshold);
    r.delay = #fun(Option::as_js_undef[Float])(#var(self).m_delay);
    r.trackVisibility = #fun(Option::as_js_undef[Bool])(#var(self).m_track_visibility);
    return r;
"

// TODO: Definitions of type 'namespace'

pub struct CustomLayoutConstraintsOptions(
    available_inline_size: Option[Float],
    available_block_size: Option[Float],
    fixed_inline_size: Option[Float],
    fixed_block_size: Option[Float],
    percentage_inline_size: Option[Float],
    percentage_block_size: Option[Float],
    data: Option[JsValue]
)

pub fun CustomLayoutConstraintsOptions::default() -> mut CustomLayoutConstraintsOptions
    = CustomLayoutConstraintsOptions(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun CustomLayoutConstraintsOptions::from_js(value: JsValue) -> mut CustomLayoutConstraintsOptions = "
    const r = {};
    r.m_available_inline_size = #fun(Option::from_js[Float])(#var(value).availableInlineSize);
    r.m_available_block_size = #fun(Option::from_js[Float])(#var(value).availableBlockSize);
    r.m_fixed_inline_size = #fun(Option::from_js[Float])(#var(value).fixedInlineSize);
    r.m_fixed_block_size = #fun(Option::from_js[Float])(#var(value).fixedBlockSize);
    r.m_percentage_inline_size = #fun(Option::from_js[Float])(#var(value).percentageInlineSize);
    r.m_percentage_block_size = #fun(Option::from_js[Float])(#var(value).percentageBlockSize);
    r.m_data = #fun(Option::from_js[JsValue])(#var(value).data);
    return r;
"

pub ext fun CustomLayoutConstraintsOptions::as_js(self: CustomLayoutConstraintsOptions) -> JsValue = "
    const r = {};
    r.availableInlineSize = #fun(Option::as_js_undef[Float])(#var(self).m_available_inline_size);
    r.availableBlockSize = #fun(Option::as_js_undef[Float])(#var(self).m_available_block_size);
    r.fixedInlineSize = #fun(Option::as_js_undef[Float])(#var(self).m_fixed_inline_size);
    r.fixedBlockSize = #fun(Option::as_js_undef[Float])(#var(self).m_fixed_block_size);
    r.percentageInlineSize = #fun(Option::as_js_undef[Float])(#var(self).m_percentage_inline_size);
    r.percentageBlockSize = #fun(Option::as_js_undef[Float])(#var(self).m_percentage_block_size);
    r.data = #fun(Option::as_js_undef[JsValue])(#var(self).m_data);
    return r;
"

pub struct FragmentResultOptions(
    auto_block_size: Option[Float],
    baseline: Option[Float],
    child_fragments: Option[List[mut LayoutFragment]],
    data: Option[JsValue]
)

pub fun FragmentResultOptions::default() -> mut FragmentResultOptions
    = FragmentResultOptions(Option::Some(0.0), Option::None, Option::Some(List::empty()), Option::None)

pub ext fun FragmentResultOptions::from_js(value: JsValue) -> mut FragmentResultOptions = "
    const r = {};
    r.m_auto_block_size = #fun(Option::from_js[Float])(#var(value).autoBlockSize);
    r.m_baseline = #fun(Option::from_js[Float])(#var(value).baseline);
    r.m_child_fragments = #fun(Option::from_js[List[mut LayoutFragment]])(#var(value).childFragments);
    r.m_data = #fun(Option::from_js[JsValue])(#var(value).data);
    return r;
"

pub ext fun FragmentResultOptions::as_js(self: FragmentResultOptions) -> JsValue = "
    const r = {};
    r.autoBlockSize = #fun(Option::as_js_undef[Float])(#var(self).m_auto_block_size);
    r.baseline = #fun(Option::as_js_undef[Float])(#var(self).m_baseline);
    r.childFragments = #fun(Option::as_js_undef[List[mut LayoutFragment]])(#var(self).m_child_fragments);
    r.data = #fun(Option::as_js_undef[JsValue])(#var(self).m_data);
    return r;
"

struct IntrinsicSizes()

pub ext fun IntrinsicSizes::min_content_size(self: IntrinsicSizes) -> Float
    = "return #fun(Float::from_js)(#var(self).minContentSize);"

pub ext fun IntrinsicSizes::max_content_size(self: IntrinsicSizes) -> Float
    = "return #fun(Float::from_js)(#var(self).maxContentSize);"

pub fun IntrinsicSizes::as_js(self: IntrinsicSizes) -> JsValue = JsValue::unsafe_from[IntrinsicSizes](self)

pub fun IntrinsicSizes::from_js(v: JsValue) -> mut IntrinsicSizes = JsValue::unsafe_as[mut IntrinsicSizes](v)

pub struct IntrinsicSizesResultOptions(
    min_content_size: Option[Float],
    max_content_size: Option[Float]
)

pub fun IntrinsicSizesResultOptions::default() -> mut IntrinsicSizesResultOptions
    = IntrinsicSizesResultOptions(Option::Some(0.0), Option::Some(0.0))

pub ext fun IntrinsicSizesResultOptions::from_js(value: JsValue) -> mut IntrinsicSizesResultOptions = "
    const r = {};
    r.m_min_content_size = #fun(Option::from_js[Float])(#var(value).minContentSize);
    r.m_max_content_size = #fun(Option::from_js[Float])(#var(value).maxContentSize);
    return r;
"

pub ext fun IntrinsicSizesResultOptions::as_js(self: IntrinsicSizesResultOptions) -> JsValue = "
    const r = {};
    r.minContentSize = #fun(Option::as_js_undef[Float])(#var(self).m_min_content_size);
    r.maxContentSize = #fun(Option::as_js_undef[Float])(#var(self).m_max_content_size);
    return r;
"

struct LayoutChild()

pub ext fun LayoutChild::style_map(self: LayoutChild) -> mut StylePropertyMapReadOnly
    = "return #fun(StylePropertyMapReadOnly::from_js)(#var(self).styleMap);"

pub ext fun LayoutChild::intrinsic_sizes(__self: mut LayoutChild) -> Promise[mut IntrinsicSizes] = "
    const r = #var(__self).intrinsicSizes();
    return #fun(Promise::from_js[mut IntrinsicSizes])(r);
"

pub ext fun LayoutChild::layout_next_fragment(__self: mut LayoutChild, options: mut CustomLayoutConstraintsOptions) -> Promise[mut LayoutFragment] = "
    const r = #var(__self).layoutNextFragment(#fun(CustomLayoutConstraintsOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[mut LayoutFragment])(r);
"

pub fun LayoutChild::as_js(self: LayoutChild) -> JsValue = JsValue::unsafe_from[LayoutChild](self)

pub fun LayoutChild::from_js(v: JsValue) -> mut LayoutChild = JsValue::unsafe_as[mut LayoutChild](v)

struct LayoutConstraints()

pub ext fun LayoutConstraints::fixed_inline_size(self: LayoutConstraints) -> Float
    = "return #fun(Float::from_js)(#var(self).fixedInlineSize);"

pub ext fun LayoutConstraints::fixed_block_size(self: LayoutConstraints) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).fixedBlockSize);"

pub ext fun LayoutConstraints::data(self: LayoutConstraints) -> JsValue
    = "return #var(self).data;"

pub fun LayoutConstraints::as_js(self: LayoutConstraints) -> JsValue = JsValue::unsafe_from[LayoutConstraints](self)

pub fun LayoutConstraints::from_js(v: JsValue) -> mut LayoutConstraints = JsValue::unsafe_as[mut LayoutConstraints](v)

struct LayoutEdges()

pub ext fun LayoutEdges::inline_start(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).inlineStart);"

pub ext fun LayoutEdges::inline_end(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).inlineEnd);"

pub ext fun LayoutEdges::block_start(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).blockStart);"

pub ext fun LayoutEdges::block_end(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).blockEnd);"

pub ext fun LayoutEdges::inline(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).inline);"

pub ext fun LayoutEdges::block(self: LayoutEdges) -> Float
    = "return #fun(Float::from_js)(#var(self).block);"

pub fun LayoutEdges::as_js(self: LayoutEdges) -> JsValue = JsValue::unsafe_from[LayoutEdges](self)

pub fun LayoutEdges::from_js(v: JsValue) -> mut LayoutEdges = JsValue::unsafe_as[mut LayoutEdges](v)

struct LayoutFragment()

pub ext fun LayoutFragment::inline_size(self: LayoutFragment) -> Float
    = "return #fun(Float::from_js)(#var(self).inlineSize);"

pub ext fun LayoutFragment::block_size(self: LayoutFragment) -> Float
    = "return #fun(Float::from_js)(#var(self).blockSize);"

pub ext fun LayoutFragment::inline_offset(self: LayoutFragment) -> Float
    = "return #fun(Float::from_js)(#var(self).inlineOffset);"

pub ext fun LayoutFragment::set_inline_offset(self: mut LayoutFragment, value: Float)
    = "#var(self).inlineOffset = #fun(Float::as_js)(#var(value));"

pub ext fun LayoutFragment::block_offset(self: LayoutFragment) -> Float
    = "return #fun(Float::from_js)(#var(self).blockOffset);"

pub ext fun LayoutFragment::set_block_offset(self: mut LayoutFragment, value: Float)
    = "#var(self).blockOffset = #fun(Float::as_js)(#var(value));"

pub ext fun LayoutFragment::baseline(self: LayoutFragment) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).baseline);"

pub ext fun LayoutFragment::data(self: LayoutFragment) -> JsValue
    = "return #var(self).data;"

pub fun LayoutFragment::as_js(self: LayoutFragment) -> JsValue = JsValue::unsafe_from[LayoutFragment](self)

pub fun LayoutFragment::from_js(v: JsValue) -> mut LayoutFragment = JsValue::unsafe_as[mut LayoutFragment](v)

struct LayoutWorkletGlobalScope()

/// Converts a reference to 'LayoutWorkletGlobalScope' to a reference to 'WorkletGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutWorkletGlobalScope::as_worklet_global_scope(self: LayoutWorkletGlobalScope) -> WorkletGlobalScope = "return #var(self);"

/// Converts a mutable reference to 'LayoutWorkletGlobalScope' to a mutable reference to 'WorkletGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutWorkletGlobalScope::as_mworklet_global_scope(self: mut LayoutWorkletGlobalScope) -> mut WorkletGlobalScope = "return #var(self);"

/// Attempts to convert a reference to 'WorkletGlobalScope' to a reference to 'LayoutWorkletGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'LayoutWorkletGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutWorkletGlobalScope::from_worklet_global_scope(base: WorkletGlobalScope) -> LayoutWorkletGlobalScope = "
    if(#var(base) instanceof LayoutWorkletGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkletGlobalScope' to 'LayoutWorkletGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'WorkletGlobalScope' to a mutable reference to 'LayoutWorkletGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'LayoutWorkletGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutWorkletGlobalScope::from_mworklet_global_scope(base: mut WorkletGlobalScope) -> mut LayoutWorkletGlobalScope = "
    if(#var(base) instanceof LayoutWorkletGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkletGlobalScope' to 'LayoutWorkletGlobalScope'!\");
"

pub ext fun LayoutWorkletGlobalScope::register_layout(__self: mut LayoutWorkletGlobalScope, name: String, layout_ctor: Fun() -> JsValue) -> Unit = "
    const r = #var(__self).registerLayout(#fun(String::as_js)(#var(name)), (() => { const r = #var(layout_ctor)(); return r; }));
    return #fun(Unit::from_js)(r);
"

pub fun LayoutWorkletGlobalScope::as_js(self: LayoutWorkletGlobalScope) -> JsValue = JsValue::unsafe_from[LayoutWorkletGlobalScope](self)

pub fun LayoutWorkletGlobalScope::from_js(v: JsValue) -> mut LayoutWorkletGlobalScope = JsValue::unsafe_as[mut LayoutWorkletGlobalScope](v)

struct MathMLElement()

/// Converts a reference to 'MathMLElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun MathMLElement::as_element(self: MathMLElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'MathMLElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun MathMLElement::as_melement(self: mut MathMLElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'MathMLElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'MathMLElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MathMLElement::from_element(base: Element) -> MathMLElement = "
    if(#var(base) instanceof MathMLElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'MathMLElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'MathMLElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'MathMLElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MathMLElement::from_melement(base: mut Element) -> mut MathMLElement = "
    if(#var(base) instanceof MathMLElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'MathMLElement'!\");
"

pub ext fun MathMLElement::onabort(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun MathMLElement::set_onabort(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onbeforeinput(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeinput);"

pub ext fun MathMLElement::set_onbeforeinput(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeinput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onbeforematch(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforematch);"

pub ext fun MathMLElement::set_onbeforematch(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforematch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onbeforetoggle(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforetoggle);"

pub ext fun MathMLElement::set_onbeforetoggle(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforetoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onblur(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun MathMLElement::set_onblur(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncancel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun MathMLElement::set_oncancel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncanplay(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplay);"

pub ext fun MathMLElement::set_oncanplay(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncanplaythrough(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplaythrough);"

pub ext fun MathMLElement::set_oncanplaythrough(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplaythrough = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onchange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun MathMLElement::set_onchange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onclick(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclick);"

pub ext fun MathMLElement::set_onclick(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onclose(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun MathMLElement::set_onclose(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncommand(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncommand);"

pub ext fun MathMLElement::set_oncommand(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncommand = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncontentvisibilityautostatechange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontentvisibilityautostatechange);"

pub ext fun MathMLElement::set_oncontentvisibilityautostatechange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontentvisibilityautostatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncontextlost(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun MathMLElement::set_oncontextlost(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncontextmenu(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextmenu);"

pub ext fun MathMLElement::set_oncontextmenu(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextmenu = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncontextrestored(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun MathMLElement::set_oncontextrestored(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncuechange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun MathMLElement::set_oncuechange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondblclick(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondblclick);"

pub ext fun MathMLElement::set_ondblclick(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondblclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondrag(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrag);"

pub ext fun MathMLElement::set_ondrag(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrag = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondragend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragend);"

pub ext fun MathMLElement::set_ondragend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondragenter(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragenter);"

pub ext fun MathMLElement::set_ondragenter(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondragleave(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragleave);"

pub ext fun MathMLElement::set_ondragleave(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondragover(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragover);"

pub ext fun MathMLElement::set_ondragover(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondragstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragstart);"

pub ext fun MathMLElement::set_ondragstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondrop(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrop);"

pub ext fun MathMLElement::set_ondrop(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrop = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ondurationchange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondurationchange);"

pub ext fun MathMLElement::set_ondurationchange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondurationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onemptied(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onemptied);"

pub ext fun MathMLElement::set_onemptied(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onemptied = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onended(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onended);"

pub ext fun MathMLElement::set_onended(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onended = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onerror(self: MathMLElement) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun MathMLElement::set_onerror(self: mut MathMLElement, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onfencedtreeclick(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfencedtreeclick);"

pub ext fun MathMLElement::set_onfencedtreeclick(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfencedtreeclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onfocus(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun MathMLElement::set_onfocus(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onformdata(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onformdata);"

pub ext fun MathMLElement::set_onformdata(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onformdata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oninput(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninput);"

pub ext fun MathMLElement::set_oninput(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oninvalid(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninvalid);"

pub ext fun MathMLElement::set_oninvalid(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninvalid = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onkeydown(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeydown);"

pub ext fun MathMLElement::set_onkeydown(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeydown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onkeypress(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeypress);"

pub ext fun MathMLElement::set_onkeypress(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeypress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onkeyup(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeyup);"

pub ext fun MathMLElement::set_onkeyup(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeyup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onload(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun MathMLElement::set_onload(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onloadeddata(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadeddata);"

pub ext fun MathMLElement::set_onloadeddata(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadeddata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onloadedmetadata(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadedmetadata);"

pub ext fun MathMLElement::set_onloadedmetadata(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadedmetadata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onloadstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun MathMLElement::set_onloadstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmousedown(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousedown);"

pub ext fun MathMLElement::set_onmousedown(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousedown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmouseenter(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseenter);"

pub ext fun MathMLElement::set_onmouseenter(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmouseleave(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseleave);"

pub ext fun MathMLElement::set_onmouseleave(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmousemove(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousemove);"

pub ext fun MathMLElement::set_onmousemove(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousemove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmouseout(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseout);"

pub ext fun MathMLElement::set_onmouseout(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmouseover(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseover);"

pub ext fun MathMLElement::set_onmouseover(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmouseup(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseup);"

pub ext fun MathMLElement::set_onmouseup(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onmousewheel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousewheel);"

pub ext fun MathMLElement::set_onmousewheel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousewheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onoverscroll(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoverscroll);"

pub ext fun MathMLElement::set_onoverscroll(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoverscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpause(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpause);"

pub ext fun MathMLElement::set_onpause(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpause = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onplay(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplay);"

pub ext fun MathMLElement::set_onplay(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onplaying(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplaying);"

pub ext fun MathMLElement::set_onplaying(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplaying = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onprogress(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun MathMLElement::set_onprogress(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onratechange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onratechange);"

pub ext fun MathMLElement::set_onratechange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onratechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onreset(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreset);"

pub ext fun MathMLElement::set_onreset(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreset = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onresize(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun MathMLElement::set_onresize(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onscroll(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun MathMLElement::set_onscroll(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onscrollend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun MathMLElement::set_onscrollend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onsecuritypolicyviolation(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsecuritypolicyviolation);"

pub ext fun MathMLElement::set_onsecuritypolicyviolation(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsecuritypolicyviolation = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onseeked(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeked);"

pub ext fun MathMLElement::set_onseeked(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeked = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onseeking(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeking);"

pub ext fun MathMLElement::set_onseeking(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeking = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onselect(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselect);"

pub ext fun MathMLElement::set_onselect(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onslotchange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun MathMLElement::set_onslotchange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onscrollsnapchange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchange);"

pub ext fun MathMLElement::set_onscrollsnapchange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onscrollsnapchanging(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchanging);"

pub ext fun MathMLElement::set_onscrollsnapchanging(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchanging = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onstalled(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstalled);"

pub ext fun MathMLElement::set_onstalled(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstalled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onsubmit(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsubmit);"

pub ext fun MathMLElement::set_onsubmit(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsubmit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onsuspend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsuspend);"

pub ext fun MathMLElement::set_onsuspend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsuspend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontimeupdate(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeupdate);"

pub ext fun MathMLElement::set_ontimeupdate(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontoggle(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontoggle);"

pub ext fun MathMLElement::set_ontoggle(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onvolumechange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvolumechange);"

pub ext fun MathMLElement::set_onvolumechange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvolumechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwaiting(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwaiting);"

pub ext fun MathMLElement::set_onwaiting(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwaiting = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwebkitanimationend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationend);"

pub ext fun MathMLElement::set_onwebkitanimationend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwebkitanimationiteration(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationiteration);"

pub ext fun MathMLElement::set_onwebkitanimationiteration(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwebkitanimationstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationstart);"

pub ext fun MathMLElement::set_onwebkitanimationstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwebkittransitionend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkittransitionend);"

pub ext fun MathMLElement::set_onwebkittransitionend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkittransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onwheel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwheel);"

pub ext fun MathMLElement::set_onwheel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onauxclick(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onauxclick);"

pub ext fun MathMLElement::set_onauxclick(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onauxclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ongotpointercapture(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ongotpointercapture);"

pub ext fun MathMLElement::set_ongotpointercapture(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ongotpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onlostpointercapture(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlostpointercapture);"

pub ext fun MathMLElement::set_onlostpointercapture(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlostpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerdown(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerdown);"

pub ext fun MathMLElement::set_onpointerdown(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerdown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointermove(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointermove);"

pub ext fun MathMLElement::set_onpointermove(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointermove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerrawupdate(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerrawupdate);"

pub ext fun MathMLElement::set_onpointerrawupdate(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerrawupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerup(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerup);"

pub ext fun MathMLElement::set_onpointerup(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointercancel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointercancel);"

pub ext fun MathMLElement::set_onpointercancel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointercancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerover(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerover);"

pub ext fun MathMLElement::set_onpointerover(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerout(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerout);"

pub ext fun MathMLElement::set_onpointerout(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerenter(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerenter);"

pub ext fun MathMLElement::set_onpointerenter(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpointerleave(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerleave);"

pub ext fun MathMLElement::set_onpointerleave(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontouchcancel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchcancel);"

pub ext fun MathMLElement::set_ontouchcancel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchcancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontouchend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchend);"

pub ext fun MathMLElement::set_ontouchend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontouchmove(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchmove);"

pub ext fun MathMLElement::set_ontouchmove(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontouchstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchstart);"

pub ext fun MathMLElement::set_ontouchstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onselectstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectstart);"

pub ext fun MathMLElement::set_onselectstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onselectionchange(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectionchange);"

pub ext fun MathMLElement::set_onselectionchange(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectionchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onanimationend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationend);"

pub ext fun MathMLElement::set_onanimationend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onanimationiteration(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationiteration);"

pub ext fun MathMLElement::set_onanimationiteration(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onanimationstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationstart);"

pub ext fun MathMLElement::set_onanimationstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontransitionrun(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionrun);"

pub ext fun MathMLElement::set_ontransitionrun(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionrun = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontransitionstart(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionstart);"

pub ext fun MathMLElement::set_ontransitionstart(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontransitionend(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionend);"

pub ext fun MathMLElement::set_ontransitionend(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::ontransitioncancel(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitioncancel);"

pub ext fun MathMLElement::set_ontransitioncancel(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitioncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncopy(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncopy);"

pub ext fun MathMLElement::set_oncopy(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::oncut(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncut);"

pub ext fun MathMLElement::set_oncut(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::onpaste(self: MathMLElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpaste);"

pub ext fun MathMLElement::set_onpaste(self: mut MathMLElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MathMLElement::dataset(self: MathMLElement) -> mut DOMStringMap
    = "return #fun(DOMStringMap::from_js)(#var(self).dataset);"

pub ext fun MathMLElement::nonce(self: MathMLElement) -> String
    = "return #fun(String::from_js)(#var(self).nonce);"

pub ext fun MathMLElement::set_nonce(self: mut MathMLElement, value: String)
    = "#var(self).nonce = #fun(String::as_js)(#var(value));"

pub ext fun MathMLElement::autofocus(self: MathMLElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autofocus);"

pub ext fun MathMLElement::set_autofocus(self: mut MathMLElement, value: Bool)
    = "#var(self).autofocus = #fun(Bool::as_js)(#var(value));"

pub ext fun MathMLElement::tab_index(self: MathMLElement) -> Int
    = "return #fun(Int::from_js)(#var(self).tabIndex);"

pub ext fun MathMLElement::set_tab_index(self: mut MathMLElement, value: Int)
    = "#var(self).tabIndex = #fun(Int::as_js)(#var(value));"

pub ext fun MathMLElement::focusgroup(self: MathMLElement) -> String
    = "return #fun(String::from_js)(#var(self).focusgroup);"

pub ext fun MathMLElement::set_focusgroup(self: mut MathMLElement, value: String)
    = "#var(self).focusgroup = #fun(String::as_js)(#var(value));"

pub ext fun MathMLElement::style(self: MathMLElement) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun MathMLElement::attribute_style_map(self: MathMLElement) -> mut StylePropertyMap
    = "return #fun(StylePropertyMap::from_js)(#var(self).attributeStyleMap);"

pub ext fun MathMLElement::start_view_transition(__self: mut MathMLElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun MathMLElement::start_view_transition_f_prom_unit(__self: mut MathMLElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun MathMLElement::start_view_transition_mview_transition_options(__self: mut MathMLElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun MathMLElement::focus(__self: mut MathMLElement, options: mut FocusOptions) -> Unit = "
    const r = #var(__self).focus(#fun(FocusOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MathMLElement::blur(__self: mut MathMLElement) -> Unit = "
    const r = #var(__self).blur();
    return #fun(Unit::from_js)(r);
"

pub fun MathMLElement::as_js(self: MathMLElement) -> JsValue = JsValue::unsafe_from[MathMLElement](self)

pub fun MathMLElement::from_js(v: JsValue) -> mut MathMLElement = JsValue::unsafe_as[mut MathMLElement](v)

struct MessageChannel()

pub ext fun MessageChannel::new() -> mut MessageChannel
    = "return new MessageChannel();"

pub ext fun MessageChannel::port_1(self: MessageChannel) -> mut MessagePort
    = "return #fun(MessagePort::from_js)(#var(self).port1);"

pub ext fun MessageChannel::port_2(self: MessageChannel) -> mut MessagePort
    = "return #fun(MessagePort::from_js)(#var(self).port2);"

pub fun MessageChannel::as_js(self: MessageChannel) -> JsValue = JsValue::unsafe_from[MessageChannel](self)

pub fun MessageChannel::from_js(v: JsValue) -> mut MessageChannel = JsValue::unsafe_as[mut MessageChannel](v)

struct MessagePort()

/// Converts a reference to 'MessagePort' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MessagePort::as_event_target(self: MessagePort) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'MessagePort' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MessagePort::as_mevent_target(self: mut MessagePort) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'MessagePort'.
/// The conversion may fail and panic if 'base' is not a reference to 'MessagePort' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MessagePort::from_event_target(base: EventTarget) -> MessagePort = "
    if(#var(base) instanceof MessagePort) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MessagePort'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'MessagePort'.
/// The conversion may fail and panic if 'base' is not a reference to 'MessagePort' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MessagePort::from_mevent_target(base: mut EventTarget) -> mut MessagePort = "
    if(#var(base) instanceof MessagePort) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MessagePort'!\");
"

pub ext fun MessagePort::onmessage(self: MessagePort) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun MessagePort::set_onmessage(self: mut MessagePort, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MessagePort::onmessageerror(self: MessagePort) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessageerror);"

pub ext fun MessagePort::set_onmessageerror(self: mut MessagePort, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessageerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MessagePort::onclose(self: MessagePort) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun MessagePort::set_onclose(self: mut MessagePort, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MessagePort::post_message_any_list_obj(__self: mut MessagePort, message: JsValue, transfer: List[JsObject]) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(List::as_js[JsObject])(#var(transfer)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::post_message_any_mpost_message_options(__self: mut MessagePort, message: JsValue, options: mut PostMessageOptions) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(PostMessageOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::start(__self: mut MessagePort) -> Unit = "
    const r = #var(__self).start();
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::close(__self: mut MessagePort) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::add_event_listener(__self: mut MessagePort, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::remove_event_listener(__self: mut MessagePort, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MessagePort::dispatch_event(__self: mut MessagePort, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun MessagePort::when(__self: mut MessagePort, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun MessagePort::as_js(self: MessagePort) -> JsValue = JsValue::unsafe_from[MessagePort](self)

pub fun MessagePort::from_js(v: JsValue) -> mut MessagePort = JsValue::unsafe_as[mut MessagePort](v)

pub struct PostMessageOptions(
    include_user_activation: Option[Bool],
    transfer: Option[List[JsObject]]
)

pub fun PostMessageOptions::default() -> mut PostMessageOptions
    = PostMessageOptions(Option::Some(false), Option::Some(List::empty()))

/// Converts a reference to 'PostMessageOptions' to a reference to 'StructuredSerializeOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun PostMessageOptions::as_structured_serialize_options(self: PostMessageOptions) -> StructuredSerializeOptions = "return #var(self);"

/// Converts a mutable reference to 'PostMessageOptions' to a mutable reference to 'StructuredSerializeOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun PostMessageOptions::as_mstructured_serialize_options(self: mut PostMessageOptions) -> mut StructuredSerializeOptions = "return #var(self);"

/// Attempts to convert a reference to 'StructuredSerializeOptions' to a reference to 'PostMessageOptions'.
/// A 'base' that is not a reference to 'PostMessageOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PostMessageOptions::from_structured_serialize_options_unchecked(base: StructuredSerializeOptions) -> PostMessageOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'StructuredSerializeOptions' to a mutable reference to 'PostMessageOptions'.
/// A 'base' that is not a reference to 'PostMessageOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PostMessageOptions::from_mstructured_serialize_options_unchecked(base: mut StructuredSerializeOptions) -> mut PostMessageOptions = "return #var(base);"

pub ext fun PostMessageOptions::from_js(value: JsValue) -> mut PostMessageOptions = "
    const r = {};
    r.m_include_user_activation = #fun(Option::from_js[Bool])(#var(value).includeUserActivation);
    r.m_transfer = #fun(Option::from_js[List[JsObject]])(#var(value).transfer);
    return r;
"

pub ext fun PostMessageOptions::as_js(self: PostMessageOptions) -> JsValue = "
    const r = {};
    r.includeUserActivation = #fun(Option::as_js_undef[Bool])(#var(self).m_include_user_activation);
    r.transfer = #fun(Option::as_js_undef[List[JsObject]])(#var(self).m_transfer);
    return r;
"

pub struct StructuredSerializeOptions(
    transfer: Option[List[JsObject]]
)

pub fun StructuredSerializeOptions::default() -> mut StructuredSerializeOptions
    = StructuredSerializeOptions(Option::Some(List::empty()))

pub ext fun StructuredSerializeOptions::from_js(value: JsValue) -> mut StructuredSerializeOptions = "
    const r = {};
    r.m_transfer = #fun(Option::from_js[List[JsObject]])(#var(value).transfer);
    return r;
"

pub ext fun StructuredSerializeOptions::as_js(self: StructuredSerializeOptions) -> JsValue = "
    const r = {};
    r.transfer = #fun(Option::as_js_undef[List[JsObject]])(#var(self).m_transfer);
    return r;
"

pub val MojoScope::Context: String = "context"
pub val MojoScope::Process: String = "process"

struct Mojo()

pub ext fun Mojo::create_message_pipe() -> mut MojoCreateMessagePipeResult = "
    const r = Mojo.createMessagePipe();
    return #fun(MojoCreateMessagePipeResult::from_js)(r);
"

pub ext fun Mojo::create_data_pipe(options: mut MojoCreateDataPipeOptions) -> mut MojoCreateDataPipeResult = "
    const r = Mojo.createDataPipe(#fun(MojoCreateDataPipeOptions::as_js)(#var(options)));
    return #fun(MojoCreateDataPipeResult::from_js)(r);
"

pub ext fun Mojo::create_shared_buffer(num_bytes: Int) -> mut MojoCreateSharedBufferResult = "
    const r = Mojo.createSharedBuffer(#fun(Int::as_js)(#var(num_bytes)));
    return #fun(MojoCreateSharedBufferResult::from_js)(r);
"

pub ext fun Mojo::bind_interface(interface_name: String, request__handle: mut MojoHandle, scope: String) -> Unit = "
    const r = Mojo.bindInterface(#fun(String::as_js)(#var(interface_name)), #fun(MojoHandle::as_js)(#var(request__handle)), #var(scope));
    return #fun(Unit::from_js)(r);
"

pub fun Mojo::as_js(self: Mojo) -> JsValue = JsValue::unsafe_from[Mojo](self)

pub fun Mojo::from_js(v: JsValue) -> mut Mojo = JsValue::unsafe_as[mut Mojo](v)

pub val Mojo::result_ok: Int = 0
pub val Mojo::result_cancelled: Int = 1
pub val Mojo::result_unknown: Int = 2
pub val Mojo::result_invalid_argument: Int = 3
pub val Mojo::result_deadline_exceeded: Int = 4
pub val Mojo::result_not_found: Int = 5
pub val Mojo::result_already_exists: Int = 6
pub val Mojo::result_permission_denied: Int = 7
pub val Mojo::result_resource_exhausted: Int = 8
pub val Mojo::result_failed_precondition: Int = 9
pub val Mojo::result_aborted: Int = 10
pub val Mojo::result_out_of_range: Int = 11
pub val Mojo::result_unimplemented: Int = 12
pub val Mojo::result_internal: Int = 13
pub val Mojo::result_unavailable: Int = 14
pub val Mojo::result_data_loss: Int = 15
pub val Mojo::result_busy: Int = 16
pub val Mojo::result_should_wait: Int = 17

pub struct MojoCreateDataPipeOptions(
    element_num_bytes: Option[Int],
    capacity_num_bytes: Option[Int]
)

pub fun MojoCreateDataPipeOptions::default() -> mut MojoCreateDataPipeOptions
    = MojoCreateDataPipeOptions(Option::None, Option::None)

pub ext fun MojoCreateDataPipeOptions::from_js(value: JsValue) -> mut MojoCreateDataPipeOptions = "
    const r = {};
    r.m_element_num_bytes = #fun(Option::from_js[Int])(#var(value).elementNumBytes);
    r.m_capacity_num_bytes = #fun(Option::from_js[Int])(#var(value).capacityNumBytes);
    return r;
"

pub ext fun MojoCreateDataPipeOptions::as_js(self: MojoCreateDataPipeOptions) -> JsValue = "
    const r = {};
    r.elementNumBytes = #fun(Option::as_js_undef[Int])(#var(self).m_element_num_bytes);
    r.capacityNumBytes = #fun(Option::as_js_undef[Int])(#var(self).m_capacity_num_bytes);
    return r;
"

pub struct MojoCreateDataPipeResult(
    result: Int,
    producer: Option[mut MojoHandle],
    consumer: Option[mut MojoHandle]
)

pub fun MojoCreateDataPipeResult::default(result: Int) -> mut MojoCreateDataPipeResult
    = MojoCreateDataPipeResult(result, Option::None, Option::None)

pub ext fun MojoCreateDataPipeResult::from_js(value: JsValue) -> mut MojoCreateDataPipeResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_producer = #fun(Option::from_js[mut MojoHandle])(#var(value).producer);
    r.m_consumer = #fun(Option::from_js[mut MojoHandle])(#var(value).consumer);
    return r;
"

pub ext fun MojoCreateDataPipeResult::as_js(self: MojoCreateDataPipeResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.producer = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_producer);
    r.consumer = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_consumer);
    return r;
"

pub struct MojoCreateMessagePipeResult(
    result: Int,
    handle_0: Option[mut MojoHandle],
    handle_1: Option[mut MojoHandle]
)

pub fun MojoCreateMessagePipeResult::default(result: Int) -> mut MojoCreateMessagePipeResult
    = MojoCreateMessagePipeResult(result, Option::None, Option::None)

pub ext fun MojoCreateMessagePipeResult::from_js(value: JsValue) -> mut MojoCreateMessagePipeResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_handle_0 = #fun(Option::from_js[mut MojoHandle])(#var(value).handle0);
    r.m_handle_1 = #fun(Option::from_js[mut MojoHandle])(#var(value).handle1);
    return r;
"

pub ext fun MojoCreateMessagePipeResult::as_js(self: MojoCreateMessagePipeResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.handle0 = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_handle_0);
    r.handle1 = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_handle_1);
    return r;
"

pub struct MojoCreateSharedBufferResult(
    result: Int,
    handle: Option[mut MojoHandle]
)

pub fun MojoCreateSharedBufferResult::default(result: Int) -> mut MojoCreateSharedBufferResult
    = MojoCreateSharedBufferResult(result, Option::None)

pub ext fun MojoCreateSharedBufferResult::from_js(value: JsValue) -> mut MojoCreateSharedBufferResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_handle = #fun(Option::from_js[mut MojoHandle])(#var(value).handle);
    return r;
"

pub ext fun MojoCreateSharedBufferResult::as_js(self: MojoCreateSharedBufferResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.handle = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_handle);
    return r;
"

pub struct MojoDiscardDataOptions(
    all_or_none: Option[Bool]
)

pub fun MojoDiscardDataOptions::default() -> mut MojoDiscardDataOptions
    = MojoDiscardDataOptions(Option::Some(false))

pub ext fun MojoDiscardDataOptions::from_js(value: JsValue) -> mut MojoDiscardDataOptions = "
    const r = {};
    r.m_all_or_none = #fun(Option::from_js[Bool])(#var(value).allOrNone);
    return r;
"

pub ext fun MojoDiscardDataOptions::as_js(self: MojoDiscardDataOptions) -> JsValue = "
    const r = {};
    r.allOrNone = #fun(Option::as_js_undef[Bool])(#var(self).m_all_or_none);
    return r;
"

pub struct MojoDuplicateBufferHandleOptions(
    read_only: Option[Bool]
)

pub fun MojoDuplicateBufferHandleOptions::default() -> mut MojoDuplicateBufferHandleOptions
    = MojoDuplicateBufferHandleOptions(Option::Some(false))

pub ext fun MojoDuplicateBufferHandleOptions::from_js(value: JsValue) -> mut MojoDuplicateBufferHandleOptions = "
    const r = {};
    r.m_read_only = #fun(Option::from_js[Bool])(#var(value).readOnly);
    return r;
"

pub ext fun MojoDuplicateBufferHandleOptions::as_js(self: MojoDuplicateBufferHandleOptions) -> JsValue = "
    const r = {};
    r.readOnly = #fun(Option::as_js_undef[Bool])(#var(self).m_read_only);
    return r;
"

struct MojoHandle()

pub ext fun MojoHandle::close(__self: mut MojoHandle) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoHandle::watch(__self: mut MojoHandle, signals: mut MojoHandleSignals, callback: Fun(Int) -> Unit) -> mut MojoWatcher = "
    const r = #var(__self).watch(#fun(MojoHandleSignals::as_js)(#var(signals)), ((p0) => { const r = #var(callback)(#fun(Int::from_js)(p0)); return #fun(Unit::as_js)(r); }));
    return #fun(MojoWatcher::from_js)(r);
"

pub ext fun MojoHandle::write_message(__self: mut MojoHandle, buffer: JsValue, handles: List[mut MojoHandle]) -> Int = "
    const r = #var(__self).writeMessage(#var(buffer), #fun(List::as_js[mut MojoHandle])(#var(handles)));
    return #fun(Int::from_js)(r);
"

pub ext fun MojoHandle::read_message(__self: mut MojoHandle, flags: mut MojoReadMessageFlags) -> mut MojoReadMessageResult = "
    const r = #var(__self).readMessage(#fun(MojoReadMessageFlags::as_js)(#var(flags)));
    return #fun(MojoReadMessageResult::from_js)(r);
"

pub ext fun MojoHandle::write_data(__self: mut MojoHandle, buffer: JsValue, options: mut MojoWriteDataOptions) -> mut MojoWriteDataResult = "
    const r = #var(__self).writeData(#var(buffer), #fun(MojoWriteDataOptions::as_js)(#var(options)));
    return #fun(MojoWriteDataResult::from_js)(r);
"

pub ext fun MojoHandle::query_data(__self: mut MojoHandle) -> mut MojoReadDataResult = "
    const r = #var(__self).queryData();
    return #fun(MojoReadDataResult::from_js)(r);
"

pub ext fun MojoHandle::discard_data(__self: mut MojoHandle, num_bytes: Int, options: mut MojoDiscardDataOptions) -> mut MojoReadDataResult = "
    const r = #var(__self).discardData(#fun(Int::as_js)(#var(num_bytes)), #fun(MojoDiscardDataOptions::as_js)(#var(options)));
    return #fun(MojoReadDataResult::from_js)(r);
"

pub ext fun MojoHandle::read_data(__self: mut MojoHandle, buffer: JsValue, options: mut MojoReadDataOptions) -> mut MojoReadDataResult = "
    const r = #var(__self).readData(#var(buffer), #fun(MojoReadDataOptions::as_js)(#var(options)));
    return #fun(MojoReadDataResult::from_js)(r);
"

pub ext fun MojoHandle::map_buffer(__self: mut MojoHandle, offset: Int, num_bytes: Int) -> mut MojoMapBufferResult = "
    const r = #var(__self).mapBuffer(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(num_bytes)));
    return #fun(MojoMapBufferResult::from_js)(r);
"

pub ext fun MojoHandle::duplicate_buffer_handle(__self: mut MojoHandle, options: mut MojoDuplicateBufferHandleOptions) -> mut MojoCreateSharedBufferResult = "
    const r = #var(__self).duplicateBufferHandle(#fun(MojoDuplicateBufferHandleOptions::as_js)(#var(options)));
    return #fun(MojoCreateSharedBufferResult::from_js)(r);
"

pub fun MojoHandle::as_js(self: MojoHandle) -> JsValue = JsValue::unsafe_from[MojoHandle](self)

pub fun MojoHandle::from_js(v: JsValue) -> mut MojoHandle = JsValue::unsafe_as[mut MojoHandle](v)

pub struct MojoHandleSignals(
    readable: Option[Bool],
    writable: Option[Bool],
    peer_closed: Option[Bool]
)

pub fun MojoHandleSignals::default() -> mut MojoHandleSignals
    = MojoHandleSignals(Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun MojoHandleSignals::from_js(value: JsValue) -> mut MojoHandleSignals = "
    const r = {};
    r.m_readable = #fun(Option::from_js[Bool])(#var(value).readable);
    r.m_writable = #fun(Option::from_js[Bool])(#var(value).writable);
    r.m_peer_closed = #fun(Option::from_js[Bool])(#var(value).peerClosed);
    return r;
"

pub ext fun MojoHandleSignals::as_js(self: MojoHandleSignals) -> JsValue = "
    const r = {};
    r.readable = #fun(Option::as_js_undef[Bool])(#var(self).m_readable);
    r.writable = #fun(Option::as_js_undef[Bool])(#var(self).m_writable);
    r.peerClosed = #fun(Option::as_js_undef[Bool])(#var(self).m_peer_closed);
    return r;
"

pub struct MojoMapBufferResult(
    result: Int,
    buffer: Option[JsValue]
)

pub fun MojoMapBufferResult::default(result: Int) -> mut MojoMapBufferResult
    = MojoMapBufferResult(result, Option::None)

pub ext fun MojoMapBufferResult::from_js(value: JsValue) -> mut MojoMapBufferResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_buffer = #fun(Option::from_js[JsValue])(#var(value).buffer);
    return r;
"

pub ext fun MojoMapBufferResult::as_js(self: MojoMapBufferResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.buffer = #fun(Option::as_js_undef[JsValue])(#var(self).m_buffer);
    return r;
"

pub struct MojoReadDataOptions(
    all_or_none: Option[Bool],
    peek: Option[Bool]
)

pub fun MojoReadDataOptions::default() -> mut MojoReadDataOptions
    = MojoReadDataOptions(Option::Some(false), Option::Some(false))

pub ext fun MojoReadDataOptions::from_js(value: JsValue) -> mut MojoReadDataOptions = "
    const r = {};
    r.m_all_or_none = #fun(Option::from_js[Bool])(#var(value).allOrNone);
    r.m_peek = #fun(Option::from_js[Bool])(#var(value).peek);
    return r;
"

pub ext fun MojoReadDataOptions::as_js(self: MojoReadDataOptions) -> JsValue = "
    const r = {};
    r.allOrNone = #fun(Option::as_js_undef[Bool])(#var(self).m_all_or_none);
    r.peek = #fun(Option::as_js_undef[Bool])(#var(self).m_peek);
    return r;
"

pub struct MojoReadDataResult(
    result: Int,
    num_bytes: Int
)

pub fun MojoReadDataResult::default(result: Int, num_bytes: Int) -> mut MojoReadDataResult
    = MojoReadDataResult(result, num_bytes)

pub ext fun MojoReadDataResult::from_js(value: JsValue) -> mut MojoReadDataResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_num_bytes = #fun(Int::from_js)(#var(value).numBytes);
    return r;
"

pub ext fun MojoReadDataResult::as_js(self: MojoReadDataResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.numBytes = #fun(Int::as_js)(#var(self).m_num_bytes);
    return r;
"

pub struct MojoReadMessageFlags(
    may_discard: Option[Bool]
)

pub fun MojoReadMessageFlags::default() -> mut MojoReadMessageFlags
    = MojoReadMessageFlags(Option::Some(false))

pub ext fun MojoReadMessageFlags::from_js(value: JsValue) -> mut MojoReadMessageFlags = "
    const r = {};
    r.m_may_discard = #fun(Option::from_js[Bool])(#var(value).mayDiscard);
    return r;
"

pub ext fun MojoReadMessageFlags::as_js(self: MojoReadMessageFlags) -> JsValue = "
    const r = {};
    r.mayDiscard = #fun(Option::as_js_undef[Bool])(#var(self).m_may_discard);
    return r;
"

pub struct MojoReadMessageResult(
    result: Int,
    buffer: Option[JsValue],
    handles: Option[List[mut MojoHandle]]
)

pub fun MojoReadMessageResult::default(result: Int) -> mut MojoReadMessageResult
    = MojoReadMessageResult(result, Option::None, Option::None)

pub ext fun MojoReadMessageResult::from_js(value: JsValue) -> mut MojoReadMessageResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_buffer = #fun(Option::from_js[JsValue])(#var(value).buffer);
    r.m_handles = #fun(Option::from_js[List[mut MojoHandle]])(#var(value).handles);
    return r;
"

pub ext fun MojoReadMessageResult::as_js(self: MojoReadMessageResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.buffer = #fun(Option::as_js_undef[JsValue])(#var(self).m_buffer);
    r.handles = #fun(Option::as_js_undef[List[mut MojoHandle]])(#var(self).m_handles);
    return r;
"

struct MojoWatcher()

pub ext fun MojoWatcher::cancel(__self: mut MojoWatcher) -> Int = "
    const r = #var(__self).cancel();
    return #fun(Int::from_js)(r);
"

pub fun MojoWatcher::as_js(self: MojoWatcher) -> JsValue = JsValue::unsafe_from[MojoWatcher](self)

pub fun MojoWatcher::from_js(v: JsValue) -> mut MojoWatcher = JsValue::unsafe_as[mut MojoWatcher](v)

pub struct MojoWriteDataOptions(
    all_or_none: Option[Bool]
)

pub fun MojoWriteDataOptions::default() -> mut MojoWriteDataOptions
    = MojoWriteDataOptions(Option::Some(false))

pub ext fun MojoWriteDataOptions::from_js(value: JsValue) -> mut MojoWriteDataOptions = "
    const r = {};
    r.m_all_or_none = #fun(Option::from_js[Bool])(#var(value).allOrNone);
    return r;
"

pub ext fun MojoWriteDataOptions::as_js(self: MojoWriteDataOptions) -> JsValue = "
    const r = {};
    r.allOrNone = #fun(Option::as_js_undef[Bool])(#var(self).m_all_or_none);
    return r;
"

pub struct MojoWriteDataResult(
    result: Int,
    num_bytes: Int
)

pub fun MojoWriteDataResult::default(result: Int, num_bytes: Int) -> mut MojoWriteDataResult
    = MojoWriteDataResult(result, num_bytes)

pub ext fun MojoWriteDataResult::from_js(value: JsValue) -> mut MojoWriteDataResult = "
    const r = {};
    r.m_result = #fun(Int::from_js)(#var(value).result);
    r.m_num_bytes = #fun(Int::from_js)(#var(value).numBytes);
    return r;
"

pub ext fun MojoWriteDataResult::as_js(self: MojoWriteDataResult) -> JsValue = "
    const r = {};
    r.result = #fun(Int::as_js)(#var(self).m_result);
    r.numBytes = #fun(Int::as_js)(#var(self).m_num_bytes);
    return r;
"

pub val MojoInterfaceInterceptorScope::Context: String = "context"
pub val MojoInterfaceInterceptorScope::ContextJs: String = "context_js"
pub val MojoInterfaceInterceptorScope::Process: String = "process"

struct MojoInterfaceInterceptor()

/// Converts a reference to 'MojoInterfaceInterceptor' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceInterceptor::as_event_target(self: MojoInterfaceInterceptor) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'MojoInterfaceInterceptor' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceInterceptor::as_mevent_target(self: mut MojoInterfaceInterceptor) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'MojoInterfaceInterceptor'.
/// The conversion may fail and panic if 'base' is not a reference to 'MojoInterfaceInterceptor' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceInterceptor::from_event_target(base: EventTarget) -> MojoInterfaceInterceptor = "
    if(#var(base) instanceof MojoInterfaceInterceptor) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MojoInterfaceInterceptor'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'MojoInterfaceInterceptor'.
/// The conversion may fail and panic if 'base' is not a reference to 'MojoInterfaceInterceptor' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceInterceptor::from_mevent_target(base: mut EventTarget) -> mut MojoInterfaceInterceptor = "
    if(#var(base) instanceof MojoInterfaceInterceptor) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'MojoInterfaceInterceptor'!\");
"

pub ext fun MojoInterfaceInterceptor::from_str_str(interface_name: String, scope: String) -> mut MojoInterfaceInterceptor
    = "return new MojoInterfaceInterceptor(#fun(String::as_js)(#var(interface_name)), #var(scope));"

pub ext fun MojoInterfaceInterceptor::oninterfacerequest(self: MojoInterfaceInterceptor) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninterfacerequest);"

pub ext fun MojoInterfaceInterceptor::set_oninterfacerequest(self: mut MojoInterfaceInterceptor, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninterfacerequest = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun MojoInterfaceInterceptor::start(__self: mut MojoInterfaceInterceptor) -> Unit = "
    const r = #var(__self).start();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceInterceptor::stop(__self: mut MojoInterfaceInterceptor) -> Unit = "
    const r = #var(__self).stop();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceInterceptor::add_event_listener(__self: mut MojoInterfaceInterceptor, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceInterceptor::remove_event_listener(__self: mut MojoInterfaceInterceptor, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceInterceptor::dispatch_event(__self: mut MojoInterfaceInterceptor, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun MojoInterfaceInterceptor::when(__self: mut MojoInterfaceInterceptor, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun MojoInterfaceInterceptor::as_js(self: MojoInterfaceInterceptor) -> JsValue = JsValue::unsafe_from[MojoInterfaceInterceptor](self)

pub fun MojoInterfaceInterceptor::from_js(v: JsValue) -> mut MojoInterfaceInterceptor = JsValue::unsafe_as[mut MojoInterfaceInterceptor](v)

struct MojoInterfaceRequestEvent()

/// Converts a reference to 'MojoInterfaceRequestEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEvent::as_event(self: MojoInterfaceRequestEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'MojoInterfaceRequestEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEvent::as_mevent(self: mut MojoInterfaceRequestEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'MojoInterfaceRequestEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MojoInterfaceRequestEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEvent::from_event(base: Event) -> MojoInterfaceRequestEvent = "
    if(#var(base) instanceof MojoInterfaceRequestEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MojoInterfaceRequestEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'MojoInterfaceRequestEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'MojoInterfaceRequestEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEvent::from_mevent(base: mut Event) -> mut MojoInterfaceRequestEvent = "
    if(#var(base) instanceof MojoInterfaceRequestEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'MojoInterfaceRequestEvent'!\");
"

pub ext fun MojoInterfaceRequestEvent::from_str_mmojo_interface_request_event_init(type: String, event_init_dict: mut MojoInterfaceRequestEventInit) -> mut MojoInterfaceRequestEvent
    = "return new MojoInterfaceRequestEvent(#fun(String::as_js)(#var(type)), #fun(MojoInterfaceRequestEventInit::as_js)(#var(event_init_dict)));"

pub ext fun MojoInterfaceRequestEvent::handle(self: MojoInterfaceRequestEvent) -> mut MojoHandle
    = "return #fun(MojoHandle::from_js)(#var(self).handle);"

pub ext fun MojoInterfaceRequestEvent::type(self: MojoInterfaceRequestEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MojoInterfaceRequestEvent::target(self: MojoInterfaceRequestEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun MojoInterfaceRequestEvent::current_target(self: MojoInterfaceRequestEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun MojoInterfaceRequestEvent::event_phase(self: MojoInterfaceRequestEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun MojoInterfaceRequestEvent::bubbles(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun MojoInterfaceRequestEvent::cancelable(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun MojoInterfaceRequestEvent::default_prevented(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun MojoInterfaceRequestEvent::composed(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun MojoInterfaceRequestEvent::is_trusted(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun MojoInterfaceRequestEvent::time_stamp(self: MojoInterfaceRequestEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun MojoInterfaceRequestEvent::src_element(self: MojoInterfaceRequestEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun MojoInterfaceRequestEvent::return_value(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun MojoInterfaceRequestEvent::set_return_value(self: mut MojoInterfaceRequestEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun MojoInterfaceRequestEvent::cancel_bubble(self: MojoInterfaceRequestEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun MojoInterfaceRequestEvent::set_cancel_bubble(self: mut MojoInterfaceRequestEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun MojoInterfaceRequestEvent::composed_path(__self: mut MojoInterfaceRequestEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun MojoInterfaceRequestEvent::stop_propagation(__self: mut MojoInterfaceRequestEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceRequestEvent::stop_immediate_propagation(__self: mut MojoInterfaceRequestEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceRequestEvent::prevent_default(__self: mut MojoInterfaceRequestEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun MojoInterfaceRequestEvent::init_event(__self: mut MojoInterfaceRequestEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun MojoInterfaceRequestEvent::as_js(self: MojoInterfaceRequestEvent) -> JsValue = JsValue::unsafe_from[MojoInterfaceRequestEvent](self)

pub fun MojoInterfaceRequestEvent::from_js(v: JsValue) -> mut MojoInterfaceRequestEvent = JsValue::unsafe_as[mut MojoInterfaceRequestEvent](v)

pub val MojoInterfaceRequestEvent::none: Int = 0
pub val MojoInterfaceRequestEvent::capturing_phase: Int = 1
pub val MojoInterfaceRequestEvent::at_target: Int = 2
pub val MojoInterfaceRequestEvent::bubbling_phase: Int = 3

pub struct MojoInterfaceRequestEventInit(
    handle: Option[mut MojoHandle],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun MojoInterfaceRequestEventInit::default() -> mut MojoInterfaceRequestEventInit
    = MojoInterfaceRequestEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'MojoInterfaceRequestEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEventInit::as_event_init(self: MojoInterfaceRequestEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'MojoInterfaceRequestEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEventInit::as_mevent_init(self: mut MojoInterfaceRequestEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'MojoInterfaceRequestEventInit'.
/// A 'base' that is not a reference to 'MojoInterfaceRequestEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEventInit::from_event_init_unchecked(base: EventInit) -> MojoInterfaceRequestEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'MojoInterfaceRequestEventInit'.
/// A 'base' that is not a reference to 'MojoInterfaceRequestEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun MojoInterfaceRequestEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut MojoInterfaceRequestEventInit = "return #var(base);"

pub ext fun MojoInterfaceRequestEventInit::from_js(value: JsValue) -> mut MojoInterfaceRequestEventInit = "
    const r = {};
    r.m_handle = #fun(Option::from_js[mut MojoHandle])(#var(value).handle);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun MojoInterfaceRequestEventInit::as_js(self: MojoInterfaceRequestEventInit) -> JsValue = "
    const r = {};
    r.handle = #fun(Option::as_js_undef[mut MojoHandle])(#var(self).m_handle);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct NavigateEvent()

/// Converts a reference to 'NavigateEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEvent::as_event(self: NavigateEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'NavigateEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEvent::as_mevent(self: mut NavigateEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'NavigateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEvent::from_event(base: Event) -> NavigateEvent = "
    if(#var(base) instanceof NavigateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'NavigateEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'NavigateEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigateEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEvent::from_mevent(base: mut Event) -> mut NavigateEvent = "
    if(#var(base) instanceof NavigateEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'NavigateEvent'!\");
"

pub ext fun NavigateEvent::from_str_mnavigate_event_init(type: String, event_init: mut NavigateEventInit) -> mut NavigateEvent
    = "return new NavigateEvent(#fun(String::as_js)(#var(type)), #fun(NavigateEventInit::as_js)(#var(event_init)));"

pub ext fun NavigateEvent::navigation_type(self: NavigateEvent) -> String
    = "return #fun(String::from_js)(#var(self).navigationType);"

pub ext fun NavigateEvent::destination(self: NavigateEvent) -> mut NavigationDestination
    = "return #fun(NavigationDestination::from_js)(#var(self).destination);"

pub ext fun NavigateEvent::can_transition(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).canTransition);"

pub ext fun NavigateEvent::can_intercept(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).canIntercept);"

pub ext fun NavigateEvent::user_initiated(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).userInitiated);"

pub ext fun NavigateEvent::hash_change(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hashChange);"

pub ext fun NavigateEvent::signal(self: NavigateEvent) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun NavigateEvent::form_data(self: NavigateEvent) -> Option[mut FormData]
    = "return #fun(Option::from_js[mut FormData])(#var(self).formData);"

pub ext fun NavigateEvent::download_request(self: NavigateEvent) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).downloadRequest);"

pub ext fun NavigateEvent::info(self: NavigateEvent) -> JsValue
    = "return #var(self).info;"

pub ext fun NavigateEvent::has_ua_visual_transition(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hasUAVisualTransition);"

pub ext fun NavigateEvent::source_element(self: NavigateEvent) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).sourceElement);"

pub ext fun NavigateEvent::type(self: NavigateEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun NavigateEvent::target(self: NavigateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun NavigateEvent::current_target(self: NavigateEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun NavigateEvent::event_phase(self: NavigateEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun NavigateEvent::bubbles(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun NavigateEvent::cancelable(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun NavigateEvent::default_prevented(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun NavigateEvent::composed(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun NavigateEvent::is_trusted(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun NavigateEvent::time_stamp(self: NavigateEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun NavigateEvent::src_element(self: NavigateEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun NavigateEvent::return_value(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun NavigateEvent::set_return_value(self: mut NavigateEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun NavigateEvent::cancel_bubble(self: NavigateEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun NavigateEvent::set_cancel_bubble(self: mut NavigateEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun NavigateEvent::intercept(__self: mut NavigateEvent, options: mut NavigationInterceptOptions) -> Unit = "
    const r = #var(__self).intercept(#fun(NavigationInterceptOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigateEvent::scroll(__self: mut NavigateEvent) -> Unit = "
    const r = #var(__self).scroll();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigateEvent::composed_path(__self: mut NavigateEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun NavigateEvent::stop_propagation(__self: mut NavigateEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigateEvent::stop_immediate_propagation(__self: mut NavigateEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigateEvent::prevent_default(__self: mut NavigateEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigateEvent::init_event(__self: mut NavigateEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun NavigateEvent::as_js(self: NavigateEvent) -> JsValue = JsValue::unsafe_from[NavigateEvent](self)

pub fun NavigateEvent::from_js(v: JsValue) -> mut NavigateEvent = JsValue::unsafe_as[mut NavigateEvent](v)

pub val NavigateEvent::none: Int = 0
pub val NavigateEvent::capturing_phase: Int = 1
pub val NavigateEvent::at_target: Int = 2
pub val NavigateEvent::bubbling_phase: Int = 3

pub val NavigationType::Reload: String = "reload"
pub val NavigationType::Push: String = "push"
pub val NavigationType::Replace: String = "replace"
pub val NavigationType::Traverse: String = "traverse"

pub struct NavigateEventInit(
    navigation_type: Option[String],
    destination: mut NavigationDestination,
    can_intercept: Option[Bool],
    user_initiated: Option[Bool],
    hash_change: Option[Bool],
    signal: mut AbortSignal,
    form_data: Option[mut FormData],
    download_request: Option[String],
    info: Option[JsValue],
    has_ua_visual_transition: Option[Bool],
    source_element: Option[mut Element],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun NavigateEventInit::default(destination: mut NavigationDestination, signal: mut AbortSignal) -> mut NavigateEventInit
    = NavigateEventInit(Option::Some("push"), destination, Option::Some(false), Option::Some(false), Option::Some(false), signal, Option::None, Option::None, Option::None, Option::Some(false), Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'NavigateEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEventInit::as_event_init(self: NavigateEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'NavigateEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEventInit::as_mevent_init(self: mut NavigateEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'NavigateEventInit'.
/// A 'base' that is not a reference to 'NavigateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEventInit::from_event_init_unchecked(base: EventInit) -> NavigateEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'NavigateEventInit'.
/// A 'base' that is not a reference to 'NavigateEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigateEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut NavigateEventInit = "return #var(base);"

pub ext fun NavigateEventInit::from_js(value: JsValue) -> mut NavigateEventInit = "
    const r = {};
    r.m_navigation_type = #fun(Option::from_js[String])(#var(value).navigationType);
    r.m_destination = #fun(NavigationDestination::from_js)(#var(value).destination);
    r.m_can_intercept = #fun(Option::from_js[Bool])(#var(value).canIntercept);
    r.m_user_initiated = #fun(Option::from_js[Bool])(#var(value).userInitiated);
    r.m_hash_change = #fun(Option::from_js[Bool])(#var(value).hashChange);
    r.m_signal = #fun(AbortSignal::from_js)(#var(value).signal);
    r.m_form_data = #fun(Option::from_js[mut FormData])(#var(value).formData);
    r.m_download_request = #fun(Option::from_js[String])(#var(value).downloadRequest);
    r.m_info = #fun(Option::from_js[JsValue])(#var(value).info);
    r.m_has_ua_visual_transition = #fun(Option::from_js[Bool])(#var(value).hasUAVisualTransition);
    r.m_source_element = #fun(Option::from_js[mut Element])(#var(value).sourceElement);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun NavigateEventInit::as_js(self: NavigateEventInit) -> JsValue = "
    const r = {};
    r.navigationType = #fun(Option::as_js_undef[String])(#var(self).m_navigation_type);
    r.destination = #fun(NavigationDestination::as_js)(#var(self).m_destination);
    r.canIntercept = #fun(Option::as_js_undef[Bool])(#var(self).m_can_intercept);
    r.userInitiated = #fun(Option::as_js_undef[Bool])(#var(self).m_user_initiated);
    r.hashChange = #fun(Option::as_js_undef[Bool])(#var(self).m_hash_change);
    r.signal = #fun(AbortSignal::as_js)(#var(self).m_signal);
    r.formData = #fun(Option::as_js_undef[mut FormData])(#var(self).m_form_data);
    r.downloadRequest = #fun(Option::as_js_undef[String])(#var(self).m_download_request);
    r.info = #fun(Option::as_js_undef[JsValue])(#var(self).m_info);
    r.hasUAVisualTransition = #fun(Option::as_js_undef[Bool])(#var(self).m_has_ua_visual_transition);
    r.sourceElement = #fun(Option::as_js_undef[mut Element])(#var(self).m_source_element);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct Navigation()

/// Converts a reference to 'Navigation' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Navigation::as_event_target(self: Navigation) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Navigation' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Navigation::as_mevent_target(self: mut Navigation) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Navigation'.
/// The conversion may fail and panic if 'base' is not a reference to 'Navigation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Navigation::from_event_target(base: EventTarget) -> Navigation = "
    if(#var(base) instanceof Navigation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Navigation'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Navigation'.
/// The conversion may fail and panic if 'base' is not a reference to 'Navigation' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Navigation::from_mevent_target(base: mut EventTarget) -> mut Navigation = "
    if(#var(base) instanceof Navigation) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Navigation'!\");
"

pub ext fun Navigation::current_entry(self: Navigation) -> Option[mut NavigationHistoryEntry]
    = "return #fun(Option::from_js[mut NavigationHistoryEntry])(#var(self).currentEntry);"

pub ext fun Navigation::transition(self: Navigation) -> Option[mut NavigationTransition]
    = "return #fun(Option::from_js[mut NavigationTransition])(#var(self).transition);"

pub ext fun Navigation::activation(self: Navigation) -> Option[mut NavigationActivation]
    = "return #fun(Option::from_js[mut NavigationActivation])(#var(self).activation);"

pub ext fun Navigation::can_go_back(self: Navigation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).canGoBack);"

pub ext fun Navigation::can_go_forward(self: Navigation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).canGoForward);"

pub ext fun Navigation::onnavigate(self: Navigation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onnavigate);"

pub ext fun Navigation::set_onnavigate(self: mut Navigation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onnavigate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Navigation::onnavigatesuccess(self: Navigation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onnavigatesuccess);"

pub ext fun Navigation::set_onnavigatesuccess(self: mut Navigation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onnavigatesuccess = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Navigation::onnavigateerror(self: Navigation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onnavigateerror);"

pub ext fun Navigation::set_onnavigateerror(self: mut Navigation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onnavigateerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Navigation::oncurrententrychange(self: Navigation) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncurrententrychange);"

pub ext fun Navigation::set_oncurrententrychange(self: mut Navigation, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncurrententrychange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Navigation::entries(__self: mut Navigation) -> List[mut NavigationHistoryEntry] = "
    const r = #var(__self).entries();
    return #fun(List::from_js[mut NavigationHistoryEntry])(r);
"

pub ext fun Navigation::update_current_entry(__self: mut Navigation, options: mut NavigationUpdateCurrentEntryOptions) -> Unit = "
    const r = #var(__self).updateCurrentEntry(#fun(NavigationUpdateCurrentEntryOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Navigation::navigate(__self: mut Navigation, url: String, options: mut NavigationNavigateOptions) -> mut NavigationResult = "
    const r = #var(__self).navigate(#fun(String::as_js)(#var(url)), #fun(NavigationNavigateOptions::as_js)(#var(options)));
    return #fun(NavigationResult::from_js)(r);
"

pub ext fun Navigation::reload(__self: mut Navigation, options: mut NavigationReloadOptions) -> mut NavigationResult = "
    const r = #var(__self).reload(#fun(NavigationReloadOptions::as_js)(#var(options)));
    return #fun(NavigationResult::from_js)(r);
"

pub ext fun Navigation::traverse_to(__self: mut Navigation, key: String, options: mut NavigationOptions) -> mut NavigationResult = "
    const r = #var(__self).traverseTo(#fun(String::as_js)(#var(key)), #fun(NavigationOptions::as_js)(#var(options)));
    return #fun(NavigationResult::from_js)(r);
"

pub ext fun Navigation::back(__self: mut Navigation, options: mut NavigationOptions) -> mut NavigationResult = "
    const r = #var(__self).back(#fun(NavigationOptions::as_js)(#var(options)));
    return #fun(NavigationResult::from_js)(r);
"

pub ext fun Navigation::forward(__self: mut Navigation, options: mut NavigationOptions) -> mut NavigationResult = "
    const r = #var(__self).forward(#fun(NavigationOptions::as_js)(#var(options)));
    return #fun(NavigationResult::from_js)(r);
"

pub ext fun Navigation::add_event_listener(__self: mut Navigation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Navigation::remove_event_listener(__self: mut Navigation, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Navigation::dispatch_event(__self: mut Navigation, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Navigation::when(__self: mut Navigation, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Navigation::as_js(self: Navigation) -> JsValue = JsValue::unsafe_from[Navigation](self)

pub fun Navigation::from_js(v: JsValue) -> mut Navigation = JsValue::unsafe_as[mut Navigation](v)

struct NavigationActivation()

pub ext fun NavigationActivation::entry(self: NavigationActivation) -> Option[mut NavigationHistoryEntry]
    = "return #fun(Option::from_js[mut NavigationHistoryEntry])(#var(self).entry);"

pub ext fun NavigationActivation::from(self: NavigationActivation) -> Option[mut NavigationHistoryEntry]
    = "return #fun(Option::from_js[mut NavigationHistoryEntry])(#var(self).from);"

pub ext fun NavigationActivation::navigation_type(self: NavigationActivation) -> String
    = "return #fun(String::from_js)(#var(self).navigationType);"

pub fun NavigationActivation::as_js(self: NavigationActivation) -> JsValue = JsValue::unsafe_from[NavigationActivation](self)

pub fun NavigationActivation::from_js(v: JsValue) -> mut NavigationActivation = JsValue::unsafe_as[mut NavigationActivation](v)

struct NavigationCurrentEntryChangeEvent()

/// Converts a reference to 'NavigationCurrentEntryChangeEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEvent::as_event(self: NavigationCurrentEntryChangeEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'NavigationCurrentEntryChangeEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEvent::as_mevent(self: mut NavigationCurrentEntryChangeEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'NavigationCurrentEntryChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigationCurrentEntryChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEvent::from_event(base: Event) -> NavigationCurrentEntryChangeEvent = "
    if(#var(base) instanceof NavigationCurrentEntryChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'NavigationCurrentEntryChangeEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'NavigationCurrentEntryChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigationCurrentEntryChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEvent::from_mevent(base: mut Event) -> mut NavigationCurrentEntryChangeEvent = "
    if(#var(base) instanceof NavigationCurrentEntryChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'NavigationCurrentEntryChangeEvent'!\");
"

pub ext fun NavigationCurrentEntryChangeEvent::from_str_mnavigation_current_entry_change_event_init(type: String, event_init: mut NavigationCurrentEntryChangeEventInit) -> mut NavigationCurrentEntryChangeEvent
    = "return new NavigationCurrentEntryChangeEvent(#fun(String::as_js)(#var(type)), #fun(NavigationCurrentEntryChangeEventInit::as_js)(#var(event_init)));"

pub ext fun NavigationCurrentEntryChangeEvent::navigation_type(self: NavigationCurrentEntryChangeEvent) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).navigationType);"

pub ext fun NavigationCurrentEntryChangeEvent::from(self: NavigationCurrentEntryChangeEvent) -> mut NavigationHistoryEntry
    = "return #fun(NavigationHistoryEntry::from_js)(#var(self).from);"

pub ext fun NavigationCurrentEntryChangeEvent::type(self: NavigationCurrentEntryChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun NavigationCurrentEntryChangeEvent::target(self: NavigationCurrentEntryChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun NavigationCurrentEntryChangeEvent::current_target(self: NavigationCurrentEntryChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun NavigationCurrentEntryChangeEvent::event_phase(self: NavigationCurrentEntryChangeEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun NavigationCurrentEntryChangeEvent::bubbles(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun NavigationCurrentEntryChangeEvent::cancelable(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun NavigationCurrentEntryChangeEvent::default_prevented(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun NavigationCurrentEntryChangeEvent::composed(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun NavigationCurrentEntryChangeEvent::is_trusted(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun NavigationCurrentEntryChangeEvent::time_stamp(self: NavigationCurrentEntryChangeEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun NavigationCurrentEntryChangeEvent::src_element(self: NavigationCurrentEntryChangeEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun NavigationCurrentEntryChangeEvent::return_value(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun NavigationCurrentEntryChangeEvent::set_return_value(self: mut NavigationCurrentEntryChangeEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun NavigationCurrentEntryChangeEvent::cancel_bubble(self: NavigationCurrentEntryChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun NavigationCurrentEntryChangeEvent::set_cancel_bubble(self: mut NavigationCurrentEntryChangeEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun NavigationCurrentEntryChangeEvent::composed_path(__self: mut NavigationCurrentEntryChangeEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun NavigationCurrentEntryChangeEvent::stop_propagation(__self: mut NavigationCurrentEntryChangeEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigationCurrentEntryChangeEvent::stop_immediate_propagation(__self: mut NavigationCurrentEntryChangeEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigationCurrentEntryChangeEvent::prevent_default(__self: mut NavigationCurrentEntryChangeEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigationCurrentEntryChangeEvent::init_event(__self: mut NavigationCurrentEntryChangeEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun NavigationCurrentEntryChangeEvent::as_js(self: NavigationCurrentEntryChangeEvent) -> JsValue = JsValue::unsafe_from[NavigationCurrentEntryChangeEvent](self)

pub fun NavigationCurrentEntryChangeEvent::from_js(v: JsValue) -> mut NavigationCurrentEntryChangeEvent = JsValue::unsafe_as[mut NavigationCurrentEntryChangeEvent](v)

pub val NavigationCurrentEntryChangeEvent::none: Int = 0
pub val NavigationCurrentEntryChangeEvent::capturing_phase: Int = 1
pub val NavigationCurrentEntryChangeEvent::at_target: Int = 2
pub val NavigationCurrentEntryChangeEvent::bubbling_phase: Int = 3

pub struct NavigationCurrentEntryChangeEventInit(
    navigation_type: Option[String],
    from: mut NavigationHistoryEntry,
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun NavigationCurrentEntryChangeEventInit::default(from: mut NavigationHistoryEntry) -> mut NavigationCurrentEntryChangeEventInit
    = NavigationCurrentEntryChangeEventInit(Option::None, from, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'NavigationCurrentEntryChangeEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEventInit::as_event_init(self: NavigationCurrentEntryChangeEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'NavigationCurrentEntryChangeEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEventInit::as_mevent_init(self: mut NavigationCurrentEntryChangeEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'NavigationCurrentEntryChangeEventInit'.
/// A 'base' that is not a reference to 'NavigationCurrentEntryChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEventInit::from_event_init_unchecked(base: EventInit) -> NavigationCurrentEntryChangeEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'NavigationCurrentEntryChangeEventInit'.
/// A 'base' that is not a reference to 'NavigationCurrentEntryChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationCurrentEntryChangeEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut NavigationCurrentEntryChangeEventInit = "return #var(base);"

pub ext fun NavigationCurrentEntryChangeEventInit::from_js(value: JsValue) -> mut NavigationCurrentEntryChangeEventInit = "
    const r = {};
    r.m_navigation_type = #fun(Option::from_js[String])(#var(value).navigationType);
    r.m_from = #fun(NavigationHistoryEntry::from_js)(#var(value).from);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun NavigationCurrentEntryChangeEventInit::as_js(self: NavigationCurrentEntryChangeEventInit) -> JsValue = "
    const r = {};
    r.navigationType = #fun(Option::as_js_undef[String])(#var(self).m_navigation_type);
    r.from = #fun(NavigationHistoryEntry::as_js)(#var(self).m_from);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct NavigationDestination()

pub ext fun NavigationDestination::key(self: NavigationDestination) -> String
    = "return #fun(String::from_js)(#var(self).key);"

pub ext fun NavigationDestination::id(self: NavigationDestination) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun NavigationDestination::url(self: NavigationDestination) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun NavigationDestination::index(self: NavigationDestination) -> Int
    = "return #fun(Int::from_js)(#var(self).index);"

pub ext fun NavigationDestination::same_document(self: NavigationDestination) -> Bool
    = "return #fun(Bool::from_js)(#var(self).sameDocument);"

pub ext fun NavigationDestination::get_state(__self: mut NavigationDestination) -> JsValue = "
    const r = #var(__self).getState();
    return r;
"

pub fun NavigationDestination::as_js(self: NavigationDestination) -> JsValue = JsValue::unsafe_from[NavigationDestination](self)

pub fun NavigationDestination::from_js(v: JsValue) -> mut NavigationDestination = JsValue::unsafe_as[mut NavigationDestination](v)

struct NavigationHistoryEntry()

/// Converts a reference to 'NavigationHistoryEntry' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationHistoryEntry::as_event_target(self: NavigationHistoryEntry) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'NavigationHistoryEntry' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationHistoryEntry::as_mevent_target(self: mut NavigationHistoryEntry) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'NavigationHistoryEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigationHistoryEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationHistoryEntry::from_event_target(base: EventTarget) -> NavigationHistoryEntry = "
    if(#var(base) instanceof NavigationHistoryEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'NavigationHistoryEntry'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'NavigationHistoryEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'NavigationHistoryEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationHistoryEntry::from_mevent_target(base: mut EventTarget) -> mut NavigationHistoryEntry = "
    if(#var(base) instanceof NavigationHistoryEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'NavigationHistoryEntry'!\");
"

pub ext fun NavigationHistoryEntry::key(self: NavigationHistoryEntry) -> String
    = "return #fun(String::from_js)(#var(self).key);"

pub ext fun NavigationHistoryEntry::id(self: NavigationHistoryEntry) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun NavigationHistoryEntry::url(self: NavigationHistoryEntry) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).url);"

pub ext fun NavigationHistoryEntry::index(self: NavigationHistoryEntry) -> Int
    = "return #fun(Int::from_js)(#var(self).index);"

pub ext fun NavigationHistoryEntry::same_document(self: NavigationHistoryEntry) -> Bool
    = "return #fun(Bool::from_js)(#var(self).sameDocument);"

pub ext fun NavigationHistoryEntry::ondispose(self: NavigationHistoryEntry) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondispose);"

pub ext fun NavigationHistoryEntry::set_ondispose(self: mut NavigationHistoryEntry, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondispose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun NavigationHistoryEntry::get_state(__self: mut NavigationHistoryEntry) -> JsValue = "
    const r = #var(__self).getState();
    return r;
"

pub ext fun NavigationHistoryEntry::add_event_listener(__self: mut NavigationHistoryEntry, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigationHistoryEntry::remove_event_listener(__self: mut NavigationHistoryEntry, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun NavigationHistoryEntry::dispatch_event(__self: mut NavigationHistoryEntry, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun NavigationHistoryEntry::when(__self: mut NavigationHistoryEntry, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun NavigationHistoryEntry::as_js(self: NavigationHistoryEntry) -> JsValue = JsValue::unsafe_from[NavigationHistoryEntry](self)

pub fun NavigationHistoryEntry::from_js(v: JsValue) -> mut NavigationHistoryEntry = JsValue::unsafe_as[mut NavigationHistoryEntry](v)

pub struct NavigationInterceptOptions(
    handler: Option[Fun() -> Promise[Unit]],
    precommit_handler: Option[Fun(mut NavigationPrecommitController) -> Promise[Unit]],
    focus_reset: Option[String],
    scroll: Option[String]
)

pub fun NavigationInterceptOptions::default() -> mut NavigationInterceptOptions
    = NavigationInterceptOptions(Option::None, Option::None, Option::None, Option::None)

pub ext fun NavigationInterceptOptions::from_js(value: JsValue) -> mut NavigationInterceptOptions = "
    const r = {};
    r.m_handler = #fun(Option::from_js[Fun() -> Promise[Unit]])(#var(value).handler);
    r.m_precommit_handler = #fun(Option::from_js[Fun(mut NavigationPrecommitController) -> Promise[Unit]])(#var(value).precommitHandler);
    r.m_focus_reset = #fun(Option::from_js[String])(#var(value).focusReset);
    r.m_scroll = #fun(Option::from_js[String])(#var(value).scroll);
    return r;
"

pub ext fun NavigationInterceptOptions::as_js(self: NavigationInterceptOptions) -> JsValue = "
    const r = {};
    r.handler = #fun(Option::as_js_undef[Fun() -> Promise[Unit]])(#var(self).m_handler);
    r.precommitHandler = #fun(Option::as_js_undef[Fun(mut NavigationPrecommitController) -> Promise[Unit]])(#var(self).m_precommit_handler);
    r.focusReset = #fun(Option::as_js_undef[String])(#var(self).m_focus_reset);
    r.scroll = #fun(Option::as_js_undef[String])(#var(self).m_scroll);
    return r;
"

pub val NavigationFocusReset::AfterTransition: String = "after-transition"
pub val NavigationFocusReset::Manual: String = "manual"

pub val NavigationScrollBehavior::AfterTransition: String = "after-transition"
pub val NavigationScrollBehavior::Manual: String = "manual"

pub struct NavigationNavigateOptions(
    state: Option[JsValue],
    history: Option[String],
    info: Option[JsValue]
)

pub fun NavigationNavigateOptions::default() -> mut NavigationNavigateOptions
    = NavigationNavigateOptions(Option::None, Option::Some("auto"), Option::None)

/// Converts a reference to 'NavigationNavigateOptions' to a reference to 'NavigationOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationNavigateOptions::as_navigation_options(self: NavigationNavigateOptions) -> NavigationOptions = "return #var(self);"

/// Converts a mutable reference to 'NavigationNavigateOptions' to a mutable reference to 'NavigationOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationNavigateOptions::as_mnavigation_options(self: mut NavigationNavigateOptions) -> mut NavigationOptions = "return #var(self);"

/// Attempts to convert a reference to 'NavigationOptions' to a reference to 'NavigationNavigateOptions'.
/// A 'base' that is not a reference to 'NavigationNavigateOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationNavigateOptions::from_navigation_options_unchecked(base: NavigationOptions) -> NavigationNavigateOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'NavigationOptions' to a mutable reference to 'NavigationNavigateOptions'.
/// A 'base' that is not a reference to 'NavigationNavigateOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationNavigateOptions::from_mnavigation_options_unchecked(base: mut NavigationOptions) -> mut NavigationNavigateOptions = "return #var(base);"

pub ext fun NavigationNavigateOptions::from_js(value: JsValue) -> mut NavigationNavigateOptions = "
    const r = {};
    r.m_state = #fun(Option::from_js[JsValue])(#var(value).state);
    r.m_history = #fun(Option::from_js[String])(#var(value).history);
    r.m_info = #fun(Option::from_js[JsValue])(#var(value).info);
    return r;
"

pub ext fun NavigationNavigateOptions::as_js(self: NavigationNavigateOptions) -> JsValue = "
    const r = {};
    r.state = #fun(Option::as_js_undef[JsValue])(#var(self).m_state);
    r.history = #fun(Option::as_js_undef[String])(#var(self).m_history);
    r.info = #fun(Option::as_js_undef[JsValue])(#var(self).m_info);
    return r;
"

pub val NavigationHistoryBehavior::Auto: String = "auto"
pub val NavigationHistoryBehavior::Push: String = "push"
pub val NavigationHistoryBehavior::Replace: String = "replace"

pub struct NavigationOptions(
    info: Option[JsValue]
)

pub fun NavigationOptions::default() -> mut NavigationOptions
    = NavigationOptions(Option::None)

pub ext fun NavigationOptions::from_js(value: JsValue) -> mut NavigationOptions = "
    const r = {};
    r.m_info = #fun(Option::from_js[JsValue])(#var(value).info);
    return r;
"

pub ext fun NavigationOptions::as_js(self: NavigationOptions) -> JsValue = "
    const r = {};
    r.info = #fun(Option::as_js_undef[JsValue])(#var(self).m_info);
    return r;
"

struct NavigationPrecommitController()

pub ext fun NavigationPrecommitController::redirect(__self: mut NavigationPrecommitController, url: String, options: mut NavigationReloadOptions) -> Unit = "
    const r = #var(__self).redirect(#fun(String::as_js)(#var(url)), #fun(NavigationReloadOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub fun NavigationPrecommitController::as_js(self: NavigationPrecommitController) -> JsValue = JsValue::unsafe_from[NavigationPrecommitController](self)

pub fun NavigationPrecommitController::from_js(v: JsValue) -> mut NavigationPrecommitController = JsValue::unsafe_as[mut NavigationPrecommitController](v)

pub struct NavigationReloadOptions(
    state: Option[JsValue],
    info: Option[JsValue]
)

pub fun NavigationReloadOptions::default() -> mut NavigationReloadOptions
    = NavigationReloadOptions(Option::None, Option::None)

/// Converts a reference to 'NavigationReloadOptions' to a reference to 'NavigationOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationReloadOptions::as_navigation_options(self: NavigationReloadOptions) -> NavigationOptions = "return #var(self);"

/// Converts a mutable reference to 'NavigationReloadOptions' to a mutable reference to 'NavigationOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationReloadOptions::as_mnavigation_options(self: mut NavigationReloadOptions) -> mut NavigationOptions = "return #var(self);"

/// Attempts to convert a reference to 'NavigationOptions' to a reference to 'NavigationReloadOptions'.
/// A 'base' that is not a reference to 'NavigationReloadOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationReloadOptions::from_navigation_options_unchecked(base: NavigationOptions) -> NavigationReloadOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'NavigationOptions' to a mutable reference to 'NavigationReloadOptions'.
/// A 'base' that is not a reference to 'NavigationReloadOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun NavigationReloadOptions::from_mnavigation_options_unchecked(base: mut NavigationOptions) -> mut NavigationReloadOptions = "return #var(base);"

pub ext fun NavigationReloadOptions::from_js(value: JsValue) -> mut NavigationReloadOptions = "
    const r = {};
    r.m_state = #fun(Option::from_js[JsValue])(#var(value).state);
    r.m_info = #fun(Option::from_js[JsValue])(#var(value).info);
    return r;
"

pub ext fun NavigationReloadOptions::as_js(self: NavigationReloadOptions) -> JsValue = "
    const r = {};
    r.state = #fun(Option::as_js_undef[JsValue])(#var(self).m_state);
    r.info = #fun(Option::as_js_undef[JsValue])(#var(self).m_info);
    return r;
"

pub struct NavigationResult(
    committed: Option[Promise[mut NavigationHistoryEntry]],
    finished: Option[Promise[mut NavigationHistoryEntry]]
)

pub fun NavigationResult::default() -> mut NavigationResult
    = NavigationResult(Option::None, Option::None)

pub ext fun NavigationResult::from_js(value: JsValue) -> mut NavigationResult = "
    const r = {};
    r.m_committed = #fun(Option::from_js[Promise[mut NavigationHistoryEntry]])(#var(value).committed);
    r.m_finished = #fun(Option::from_js[Promise[mut NavigationHistoryEntry]])(#var(value).finished);
    return r;
"

pub ext fun NavigationResult::as_js(self: NavigationResult) -> JsValue = "
    const r = {};
    r.committed = #fun(Option::as_js_undef[Promise[mut NavigationHistoryEntry]])(#var(self).m_committed);
    r.finished = #fun(Option::as_js_undef[Promise[mut NavigationHistoryEntry]])(#var(self).m_finished);
    return r;
"

struct NavigationTransition()

pub ext fun NavigationTransition::navigation_type(self: NavigationTransition) -> String
    = "return #fun(String::from_js)(#var(self).navigationType);"

pub ext fun NavigationTransition::from(self: NavigationTransition) -> mut NavigationHistoryEntry
    = "return #fun(NavigationHistoryEntry::from_js)(#var(self).from);"

pub ext fun NavigationTransition::committed(self: NavigationTransition) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).committed);"

pub ext fun NavigationTransition::finished(self: NavigationTransition) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).finished);"

pub fun NavigationTransition::as_js(self: NavigationTransition) -> JsValue = JsValue::unsafe_from[NavigationTransition](self)

pub fun NavigationTransition::from_js(v: JsValue) -> mut NavigationTransition = JsValue::unsafe_as[mut NavigationTransition](v)

pub struct NavigationUpdateCurrentEntryOptions(
    state: JsValue
)

pub fun NavigationUpdateCurrentEntryOptions::default(state: JsValue) -> mut NavigationUpdateCurrentEntryOptions
    = NavigationUpdateCurrentEntryOptions(state)

pub ext fun NavigationUpdateCurrentEntryOptions::from_js(value: JsValue) -> mut NavigationUpdateCurrentEntryOptions = "
    const r = {};
    r.m_state = #var(value).state;
    return r;
"

pub ext fun NavigationUpdateCurrentEntryOptions::as_js(self: NavigationUpdateCurrentEntryOptions) -> JsValue = "
    const r = {};
    r.state = #var(self).m_state;
    return r;
"

struct OffscreenCanvas()

/// Converts a reference to 'OffscreenCanvas' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun OffscreenCanvas::as_event_target(self: OffscreenCanvas) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'OffscreenCanvas' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun OffscreenCanvas::as_mevent_target(self: mut OffscreenCanvas) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'OffscreenCanvas'.
/// The conversion may fail and panic if 'base' is not a reference to 'OffscreenCanvas' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun OffscreenCanvas::from_event_target(base: EventTarget) -> OffscreenCanvas = "
    if(#var(base) instanceof OffscreenCanvas) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'OffscreenCanvas'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'OffscreenCanvas'.
/// The conversion may fail and panic if 'base' is not a reference to 'OffscreenCanvas' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun OffscreenCanvas::from_mevent_target(base: mut EventTarget) -> mut OffscreenCanvas = "
    if(#var(base) instanceof OffscreenCanvas) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'OffscreenCanvas'!\");
"

pub ext fun OffscreenCanvas::from_int_int(width: Int, height: Int) -> mut OffscreenCanvas
    = "return new OffscreenCanvas(#fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)));"

pub ext fun OffscreenCanvas::width(self: OffscreenCanvas) -> Int
    = "return #fun(Int::from_js)(#var(self).width);"

pub ext fun OffscreenCanvas::set_width(self: mut OffscreenCanvas, value: Int)
    = "#var(self).width = #fun(Int::as_js)(#var(value));"

pub ext fun OffscreenCanvas::height(self: OffscreenCanvas) -> Int
    = "return #fun(Int::from_js)(#var(self).height);"

pub ext fun OffscreenCanvas::set_height(self: mut OffscreenCanvas, value: Int)
    = "#var(self).height = #fun(Int::as_js)(#var(value));"

pub ext fun OffscreenCanvas::oncontextlost(self: OffscreenCanvas) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun OffscreenCanvas::set_oncontextlost(self: mut OffscreenCanvas, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun OffscreenCanvas::oncontextrestored(self: OffscreenCanvas) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun OffscreenCanvas::set_oncontextrestored(self: mut OffscreenCanvas, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun OffscreenCanvas::transfer_to_image_bitmap(__self: mut OffscreenCanvas) -> mut ImageBitmap = "
    const r = #var(__self).transferToImageBitmap();
    return #fun(ImageBitmap::from_js)(r);
"

pub ext fun OffscreenCanvas::convert_to_blob(__self: mut OffscreenCanvas, options: mut ImageEncodeOptions) -> Promise[mut Blob] = "
    const r = #var(__self).convertToBlob(#fun(ImageEncodeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[mut Blob])(r);
"

pub ext fun OffscreenCanvas::add_event_listener(__self: mut OffscreenCanvas, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun OffscreenCanvas::remove_event_listener(__self: mut OffscreenCanvas, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun OffscreenCanvas::dispatch_event(__self: mut OffscreenCanvas, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun OffscreenCanvas::when(__self: mut OffscreenCanvas, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun OffscreenCanvas::as_js(self: OffscreenCanvas) -> JsValue = JsValue::unsafe_from[OffscreenCanvas](self)

pub fun OffscreenCanvas::from_js(v: JsValue) -> mut OffscreenCanvas = JsValue::unsafe_as[mut OffscreenCanvas](v)

struct ColorPagePopupController()

/// Converts a reference to 'ColorPagePopupController' to a reference to 'PagePopupController'.
/// This does not involve manipulating the object or reference.
pub ext fun ColorPagePopupController::as_page_popup_controller(self: ColorPagePopupController) -> PagePopupController = "return #var(self);"

/// Converts a mutable reference to 'ColorPagePopupController' to a mutable reference to 'PagePopupController'.
/// This does not involve manipulating the object or reference.
pub ext fun ColorPagePopupController::as_mpage_popup_controller(self: mut ColorPagePopupController) -> mut PagePopupController = "return #var(self);"

/// Attempts to convert a reference to 'PagePopupController' to a reference to 'ColorPagePopupController'.
/// The conversion may fail and panic if 'base' is not a reference to 'ColorPagePopupController' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ColorPagePopupController::from_page_popup_controller(base: PagePopupController) -> ColorPagePopupController = "
    if(#var(base) instanceof ColorPagePopupController) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PagePopupController' to 'ColorPagePopupController'!\");
"

/// Attempts to convert a mutable reference to 'PagePopupController' to a mutable reference to 'ColorPagePopupController'.
/// The conversion may fail and panic if 'base' is not a reference to 'ColorPagePopupController' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ColorPagePopupController::from_mpage_popup_controller(base: mut PagePopupController) -> mut ColorPagePopupController = "
    if(#var(base) instanceof ColorPagePopupController) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PagePopupController' to 'ColorPagePopupController'!\");
"

pub ext fun ColorPagePopupController::open_eye_dropper(__self: mut ColorPagePopupController) -> Unit = "
    const r = #var(__self).openEyeDropper();
    return #fun(Unit::from_js)(r);
"

pub ext fun ColorPagePopupController::set_value_and_close_popup(__self: mut ColorPagePopupController, number_value: Int, string_value: String, is__keyboard__event: Bool) -> Unit = "
    const r = #var(__self).setValueAndClosePopup(#fun(Int::as_js)(#var(number_value)), #fun(String::as_js)(#var(string_value)), #fun(Bool::as_js)(#var(is__keyboard__event)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ColorPagePopupController::set_value(__self: mut ColorPagePopupController, value: String) -> Unit = "
    const r = #var(__self).setValue(#fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ColorPagePopupController::close_popup(__self: mut ColorPagePopupController) -> Unit = "
    const r = #var(__self).closePopup();
    return #fun(Unit::from_js)(r);
"

pub ext fun ColorPagePopupController::localize_number_string(__self: mut ColorPagePopupController, number_string: String) -> String = "
    const r = #var(__self).localizeNumberString(#fun(String::as_js)(#var(number_string)));
    return #fun(String::from_js)(r);
"

pub ext fun ColorPagePopupController::format_month(__self: mut ColorPagePopupController, year: Int, zero_base_month: Int) -> String = "
    const r = #var(__self).formatMonth(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(zero_base_month)));
    return #fun(String::from_js)(r);
"

pub ext fun ColorPagePopupController::format_short_month(__self: mut ColorPagePopupController, year: Int, zero_base_month: Int) -> String = "
    const r = #var(__self).formatShortMonth(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(zero_base_month)));
    return #fun(String::from_js)(r);
"

pub ext fun ColorPagePopupController::format_week(__self: mut ColorPagePopupController, year: Int, week_number: Int, localized_start_date: String) -> String = "
    const r = #var(__self).formatWeek(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(week_number)), #fun(String::as_js)(#var(localized_start_date)));
    return #fun(String::from_js)(r);
"

pub ext fun ColorPagePopupController::set_window_rect(__self: mut ColorPagePopupController, x: Int, y: Int, width: Int, height: Int) -> Unit = "
    const r = #var(__self).setWindowRect(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ColorPagePopupController::set_menu_list_options_bounds_in_ax_tree(__self: mut ColorPagePopupController, options__bounds: List[mut DOMRect], children__updated: Bool) -> Unit = "
    const r = #var(__self).setMenuListOptionsBoundsInAXTree(#fun(List::as_js[mut DOMRect])(#var(options__bounds)), #fun(Bool::as_js)(#var(children__updated)));
    return #fun(Unit::from_js)(r);
"

pub fun ColorPagePopupController::as_js(self: ColorPagePopupController) -> JsValue = JsValue::unsafe_from[ColorPagePopupController](self)

pub fun ColorPagePopupController::from_js(v: JsValue) -> mut ColorPagePopupController = JsValue::unsafe_as[mut ColorPagePopupController](v)

struct PagePopupController()

pub ext fun PagePopupController::set_value_and_close_popup(__self: mut PagePopupController, number_value: Int, string_value: String, is__keyboard__event: Bool) -> Unit = "
    const r = #var(__self).setValueAndClosePopup(#fun(Int::as_js)(#var(number_value)), #fun(String::as_js)(#var(string_value)), #fun(Bool::as_js)(#var(is__keyboard__event)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PagePopupController::set_value(__self: mut PagePopupController, value: String) -> Unit = "
    const r = #var(__self).setValue(#fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PagePopupController::close_popup(__self: mut PagePopupController) -> Unit = "
    const r = #var(__self).closePopup();
    return #fun(Unit::from_js)(r);
"

pub ext fun PagePopupController::localize_number_string(__self: mut PagePopupController, number_string: String) -> String = "
    const r = #var(__self).localizeNumberString(#fun(String::as_js)(#var(number_string)));
    return #fun(String::from_js)(r);
"

pub ext fun PagePopupController::format_month(__self: mut PagePopupController, year: Int, zero_base_month: Int) -> String = "
    const r = #var(__self).formatMonth(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(zero_base_month)));
    return #fun(String::from_js)(r);
"

pub ext fun PagePopupController::format_short_month(__self: mut PagePopupController, year: Int, zero_base_month: Int) -> String = "
    const r = #var(__self).formatShortMonth(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(zero_base_month)));
    return #fun(String::from_js)(r);
"

pub ext fun PagePopupController::format_week(__self: mut PagePopupController, year: Int, week_number: Int, localized_start_date: String) -> String = "
    const r = #var(__self).formatWeek(#fun(Int::as_js)(#var(year)), #fun(Int::as_js)(#var(week_number)), #fun(String::as_js)(#var(localized_start_date)));
    return #fun(String::from_js)(r);
"

pub ext fun PagePopupController::set_window_rect(__self: mut PagePopupController, x: Int, y: Int, width: Int, height: Int) -> Unit = "
    const r = #var(__self).setWindowRect(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PagePopupController::set_menu_list_options_bounds_in_ax_tree(__self: mut PagePopupController, options__bounds: List[mut DOMRect], children__updated: Bool) -> Unit = "
    const r = #var(__self).setMenuListOptionsBoundsInAXTree(#fun(List::as_js[mut DOMRect])(#var(options__bounds)), #fun(Bool::as_js)(#var(children__updated)));
    return #fun(Unit::from_js)(r);
"

pub fun PagePopupController::as_js(self: PagePopupController) -> JsValue = JsValue::unsafe_from[PagePopupController](self)

pub fun PagePopupController::from_js(v: JsValue) -> mut PagePopupController = JsValue::unsafe_as[mut PagePopupController](v)

struct FeaturePolicy()

pub ext fun FeaturePolicy::allows_feature(__self: mut FeaturePolicy, feature: String, origin: String) -> Bool = "
    const r = #var(__self).allowsFeature(#fun(String::as_js)(#var(feature)), #fun(String::as_js)(#var(origin)));
    return #fun(Bool::from_js)(r);
"

pub ext fun FeaturePolicy::features(__self: mut FeaturePolicy) -> List[String] = "
    const r = #var(__self).features();
    return #fun(List::from_js[String])(r);
"

pub ext fun FeaturePolicy::allowed_features(__self: mut FeaturePolicy) -> List[String] = "
    const r = #var(__self).allowedFeatures();
    return #fun(List::from_js[String])(r);
"

pub ext fun FeaturePolicy::get_allowlist_for_feature(__self: mut FeaturePolicy, feature: String) -> List[String] = "
    const r = #var(__self).getAllowlistForFeature(#fun(String::as_js)(#var(feature)));
    return #fun(List::from_js[String])(r);
"

pub fun FeaturePolicy::as_js(self: FeaturePolicy) -> JsValue = JsValue::unsafe_from[FeaturePolicy](self)

pub fun FeaturePolicy::from_js(v: JsValue) -> mut FeaturePolicy = JsValue::unsafe_as[mut FeaturePolicy](v)

pub ext fun Navigator::preferences(self: Navigator) -> mut PreferenceManager
    = "return #fun(PreferenceManager::from_js)(#var(self).preferences);"

struct PreferenceManager()

pub ext fun PreferenceManager::color_scheme(self: PreferenceManager) -> mut PreferenceObject
    = "return #fun(PreferenceObject::from_js)(#var(self).colorScheme);"

pub ext fun PreferenceManager::contrast(self: PreferenceManager) -> mut PreferenceObject
    = "return #fun(PreferenceObject::from_js)(#var(self).contrast);"

pub ext fun PreferenceManager::reduced_motion(self: PreferenceManager) -> mut PreferenceObject
    = "return #fun(PreferenceObject::from_js)(#var(self).reducedMotion);"

pub ext fun PreferenceManager::reduced_transparency(self: PreferenceManager) -> mut PreferenceObject
    = "return #fun(PreferenceObject::from_js)(#var(self).reducedTransparency);"

pub ext fun PreferenceManager::reduced_data(self: PreferenceManager) -> mut PreferenceObject
    = "return #fun(PreferenceObject::from_js)(#var(self).reducedData);"

pub fun PreferenceManager::as_js(self: PreferenceManager) -> JsValue = JsValue::unsafe_from[PreferenceManager](self)

pub fun PreferenceManager::from_js(v: JsValue) -> mut PreferenceManager = JsValue::unsafe_as[mut PreferenceManager](v)

struct PreferenceObject()

/// Converts a reference to 'PreferenceObject' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun PreferenceObject::as_event_target(self: PreferenceObject) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'PreferenceObject' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun PreferenceObject::as_mevent_target(self: mut PreferenceObject) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'PreferenceObject'.
/// The conversion may fail and panic if 'base' is not a reference to 'PreferenceObject' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PreferenceObject::from_event_target(base: EventTarget) -> PreferenceObject = "
    if(#var(base) instanceof PreferenceObject) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'PreferenceObject'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'PreferenceObject'.
/// The conversion may fail and panic if 'base' is not a reference to 'PreferenceObject' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PreferenceObject::from_mevent_target(base: mut EventTarget) -> mut PreferenceObject = "
    if(#var(base) instanceof PreferenceObject) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'PreferenceObject'!\");
"

pub ext fun PreferenceObject::override(self: PreferenceObject) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).override);"

pub ext fun PreferenceObject::value(self: PreferenceObject) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun PreferenceObject::valid_values(self: PreferenceObject) -> JsValue
    = "return #var(self).validValues;"

pub ext fun PreferenceObject::onchange(self: PreferenceObject) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun PreferenceObject::set_onchange(self: mut PreferenceObject, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun PreferenceObject::clear_override(__self: mut PreferenceObject) -> Unit = "
    const r = #var(__self).clearOverride();
    return #fun(Unit::from_js)(r);
"

pub ext fun PreferenceObject::request_override(__self: mut PreferenceObject, value: Option[String]) -> Promise[Unit] = "
    const r = #var(__self).requestOverride(#fun(Option::as_js[String])(#var(value)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun PreferenceObject::add_event_listener(__self: mut PreferenceObject, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun PreferenceObject::remove_event_listener(__self: mut PreferenceObject, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun PreferenceObject::dispatch_event(__self: mut PreferenceObject, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun PreferenceObject::when(__self: mut PreferenceObject, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun PreferenceObject::as_js(self: PreferenceObject) -> JsValue = JsValue::unsafe_from[PreferenceObject](self)

pub fun PreferenceObject::from_js(v: JsValue) -> mut PreferenceObject = JsValue::unsafe_as[mut PreferenceObject](v)

struct ResizeObserver()

pub ext fun ResizeObserver::from_f_list_mresize_observer_entry_mresize_observer_unit(callback: Fun(List[mut ResizeObserverEntry], mut ResizeObserver) -> Unit) -> mut ResizeObserver
    = "return new ResizeObserver(((p0, p1) => { const r = #var(callback)(#fun(List::from_js[mut ResizeObserverEntry])(p0), #fun(ResizeObserver::from_js)(p1)); return #fun(Unit::as_js)(r); }));"

pub ext fun ResizeObserver::observe_melement_mresize_observer_options(__self: mut ResizeObserver, target: mut Element, options: mut ResizeObserverOptions) -> Unit = "
    const r = #var(__self).observe(#fun(Element::as_js)(#var(target)), #fun(ResizeObserverOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ResizeObserver::observe_melement(__self: mut ResizeObserver, target: mut Element) -> Unit = "
    const r = #var(__self).observe(#fun(Element::as_js)(#var(target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ResizeObserver::unobserve(__self: mut ResizeObserver, target: mut Element) -> Unit = "
    const r = #var(__self).unobserve(#fun(Element::as_js)(#var(target)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ResizeObserver::disconnect(__self: mut ResizeObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub fun ResizeObserver::as_js(self: ResizeObserver) -> JsValue = JsValue::unsafe_from[ResizeObserver](self)

pub fun ResizeObserver::from_js(v: JsValue) -> mut ResizeObserver = JsValue::unsafe_as[mut ResizeObserver](v)

struct ResizeObserverEntry()

pub ext fun ResizeObserverEntry::target(self: ResizeObserverEntry) -> mut Element
    = "return #fun(Element::from_js)(#var(self).target);"

pub ext fun ResizeObserverEntry::content_rect(self: ResizeObserverEntry) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).contentRect);"

pub ext fun ResizeObserverEntry::content_box_size(self: ResizeObserverEntry) -> JsValue
    = "return #var(self).contentBoxSize;"

pub ext fun ResizeObserverEntry::border_box_size(self: ResizeObserverEntry) -> JsValue
    = "return #var(self).borderBoxSize;"

pub ext fun ResizeObserverEntry::device_pixel_content_box_size(self: ResizeObserverEntry) -> JsValue
    = "return #var(self).devicePixelContentBoxSize;"

pub fun ResizeObserverEntry::as_js(self: ResizeObserverEntry) -> JsValue = JsValue::unsafe_from[ResizeObserverEntry](self)

pub fun ResizeObserverEntry::from_js(v: JsValue) -> mut ResizeObserverEntry = JsValue::unsafe_as[mut ResizeObserverEntry](v)

pub val ResizeObserverBoxOptions::BorderBox: String = "border-box"
pub val ResizeObserverBoxOptions::ContentBox: String = "content-box"
pub val ResizeObserverBoxOptions::DevicePixelContentBox: String = "device-pixel-content-box"

pub struct ResizeObserverOptions(
    box: Option[String],
    fire_on_every_paint: Option[Bool]
)

pub fun ResizeObserverOptions::default() -> mut ResizeObserverOptions
    = ResizeObserverOptions(Option::Some("content-box"), Option::Some(false))

pub ext fun ResizeObserverOptions::from_js(value: JsValue) -> mut ResizeObserverOptions = "
    const r = {};
    r.m_box = #fun(Option::from_js[String])(#var(value).box);
    r.m_fire_on_every_paint = #fun(Option::from_js[Bool])(#var(value).fireOnEveryPaint);
    return r;
"

pub ext fun ResizeObserverOptions::as_js(self: ResizeObserverOptions) -> JsValue = "
    const r = {};
    r.box = #fun(Option::as_js_undef[String])(#var(self).m_box);
    r.fireOnEveryPaint = #fun(Option::as_js_undef[Bool])(#var(self).m_fire_on_every_paint);
    return r;
"

struct ResizeObserverSize()

pub ext fun ResizeObserverSize::inline_size(self: ResizeObserverSize) -> Float
    = "return #fun(Float::from_js)(#var(self).inlineSize);"

pub ext fun ResizeObserverSize::block_size(self: ResizeObserverSize) -> Float
    = "return #fun(Float::from_js)(#var(self).blockSize);"

pub fun ResizeObserverSize::as_js(self: ResizeObserverSize) -> JsValue = JsValue::unsafe_from[ResizeObserverSize](self)

pub fun ResizeObserverSize::from_js(v: JsValue) -> mut ResizeObserverSize = JsValue::unsafe_as[mut ResizeObserverSize](v)

struct Sanitizer()

pub ext fun Sanitizer::from_any(configuration: JsValue) -> mut Sanitizer
    = "return new Sanitizer(#var(configuration));"

pub ext fun Sanitizer::get(__self: mut Sanitizer) -> mut SanitizerConfig = "
    const r = #var(__self).get();
    return #fun(SanitizerConfig::from_js)(r);
"

pub ext fun Sanitizer::allow_element(__self: mut Sanitizer, element: JsValue) -> Unit = "
    const r = #var(__self).allowElement(#var(element));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::remove_element(__self: mut Sanitizer, element: JsValue) -> Unit = "
    const r = #var(__self).removeElement(#var(element));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::replace_element_with_children(__self: mut Sanitizer, element: JsValue) -> Unit = "
    const r = #var(__self).replaceElementWithChildren(#var(element));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::allow_attribute(__self: mut Sanitizer, attribute: JsValue) -> Unit = "
    const r = #var(__self).allowAttribute(#var(attribute));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::remove_attribute(__self: mut Sanitizer, attribute: JsValue) -> Unit = "
    const r = #var(__self).removeAttribute(#var(attribute));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::set_comments(__self: mut Sanitizer, allow: Bool) -> Unit = "
    const r = #var(__self).setComments(#fun(Bool::as_js)(#var(allow)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::set_data_attributes(__self: mut Sanitizer, allow: Bool) -> Unit = "
    const r = #var(__self).setDataAttributes(#fun(Bool::as_js)(#var(allow)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Sanitizer::remove_unsafe(__self: mut Sanitizer) -> Unit = "
    const r = #var(__self).removeUnsafe();
    return #fun(Unit::from_js)(r);
"

pub fun Sanitizer::as_js(self: Sanitizer) -> JsValue = JsValue::unsafe_from[Sanitizer](self)

pub fun Sanitizer::from_js(v: JsValue) -> mut Sanitizer = JsValue::unsafe_as[mut Sanitizer](v)

pub struct SanitizerElementNamespace(
    name: String,
    namespace: Option[String]
)

pub fun SanitizerElementNamespace::default(name: String) -> mut SanitizerElementNamespace
    = SanitizerElementNamespace(name, Option::Some("http://www.w3.org/1999/xhtml"))

pub ext fun SanitizerElementNamespace::from_js(value: JsValue) -> mut SanitizerElementNamespace = "
    const r = {};
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_namespace = #fun(Option::from_js[String])(#var(value).namespace);
    return r;
"

pub ext fun SanitizerElementNamespace::as_js(self: SanitizerElementNamespace) -> JsValue = "
    const r = {};
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.namespace = #fun(Option::as_js_undef[String])(#var(self).m_namespace);
    return r;
"

pub struct SanitizerElementNamespaceWithAttributes(
    attributes: Option[List[JsValue]],
    remove_attributes: Option[List[JsValue]],
    name: String,
    namespace: Option[String]
)

pub fun SanitizerElementNamespaceWithAttributes::default(name: String) -> mut SanitizerElementNamespaceWithAttributes
    = SanitizerElementNamespaceWithAttributes(Option::None, Option::None, name, Option::Some("http://www.w3.org/1999/xhtml"))

/// Converts a reference to 'SanitizerElementNamespaceWithAttributes' to a reference to 'SanitizerElementNamespace'.
/// This does not involve manipulating the object or reference.
pub ext fun SanitizerElementNamespaceWithAttributes::as_sanitizer_element_namespace(self: SanitizerElementNamespaceWithAttributes) -> SanitizerElementNamespace = "return #var(self);"

/// Converts a mutable reference to 'SanitizerElementNamespaceWithAttributes' to a mutable reference to 'SanitizerElementNamespace'.
/// This does not involve manipulating the object or reference.
pub ext fun SanitizerElementNamespaceWithAttributes::as_msanitizer_element_namespace(self: mut SanitizerElementNamespaceWithAttributes) -> mut SanitizerElementNamespace = "return #var(self);"

/// Attempts to convert a reference to 'SanitizerElementNamespace' to a reference to 'SanitizerElementNamespaceWithAttributes'.
/// A 'base' that is not a reference to 'SanitizerElementNamespaceWithAttributes' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SanitizerElementNamespaceWithAttributes::from_sanitizer_element_namespace_unchecked(base: SanitizerElementNamespace) -> SanitizerElementNamespaceWithAttributes = "return #var(base);"

/// Attempts to convert a mutable reference to 'SanitizerElementNamespace' to a mutable reference to 'SanitizerElementNamespaceWithAttributes'.
/// A 'base' that is not a reference to 'SanitizerElementNamespaceWithAttributes' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SanitizerElementNamespaceWithAttributes::from_msanitizer_element_namespace_unchecked(base: mut SanitizerElementNamespace) -> mut SanitizerElementNamespaceWithAttributes = "return #var(base);"

pub ext fun SanitizerElementNamespaceWithAttributes::from_js(value: JsValue) -> mut SanitizerElementNamespaceWithAttributes = "
    const r = {};
    r.m_attributes = #fun(Option::from_js[List[JsValue]])(#var(value).attributes);
    r.m_remove_attributes = #fun(Option::from_js[List[JsValue]])(#var(value).removeAttributes);
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_namespace = #fun(Option::from_js[String])(#var(value).namespace);
    return r;
"

pub ext fun SanitizerElementNamespaceWithAttributes::as_js(self: SanitizerElementNamespaceWithAttributes) -> JsValue = "
    const r = {};
    r.attributes = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_attributes);
    r.removeAttributes = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_remove_attributes);
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.namespace = #fun(Option::as_js_undef[String])(#var(self).m_namespace);
    return r;
"

pub struct SanitizerAttributeNamespace(
    name: String,
    namespace: Option[String]
)

pub fun SanitizerAttributeNamespace::default(name: String) -> mut SanitizerAttributeNamespace
    = SanitizerAttributeNamespace(name, Option::None)

pub ext fun SanitizerAttributeNamespace::from_js(value: JsValue) -> mut SanitizerAttributeNamespace = "
    const r = {};
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_namespace = #fun(Option::from_js[String])(#var(value).namespace);
    return r;
"

pub ext fun SanitizerAttributeNamespace::as_js(self: SanitizerAttributeNamespace) -> JsValue = "
    const r = {};
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.namespace = #fun(Option::as_js_undef[String])(#var(self).m_namespace);
    return r;
"

pub struct SanitizerConfig(
    elements: Option[List[JsValue]],
    remove_elements: Option[List[JsValue]],
    replace_with_children_elements: Option[List[JsValue]],
    attributes: Option[List[JsValue]],
    remove_attributes: Option[List[JsValue]],
    comments: Option[Bool],
    data_attributes: Option[Bool]
)

pub fun SanitizerConfig::default() -> mut SanitizerConfig
    = SanitizerConfig(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun SanitizerConfig::from_js(value: JsValue) -> mut SanitizerConfig = "
    const r = {};
    r.m_elements = #fun(Option::from_js[List[JsValue]])(#var(value).elements);
    r.m_remove_elements = #fun(Option::from_js[List[JsValue]])(#var(value).removeElements);
    r.m_replace_with_children_elements = #fun(Option::from_js[List[JsValue]])(#var(value).replaceWithChildrenElements);
    r.m_attributes = #fun(Option::from_js[List[JsValue]])(#var(value).attributes);
    r.m_remove_attributes = #fun(Option::from_js[List[JsValue]])(#var(value).removeAttributes);
    r.m_comments = #fun(Option::from_js[Bool])(#var(value).comments);
    r.m_data_attributes = #fun(Option::from_js[Bool])(#var(value).dataAttributes);
    return r;
"

pub ext fun SanitizerConfig::as_js(self: SanitizerConfig) -> JsValue = "
    const r = {};
    r.elements = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_elements);
    r.removeElements = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_remove_elements);
    r.replaceWithChildrenElements = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_replace_with_children_elements);
    r.attributes = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_attributes);
    r.removeAttributes = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_remove_attributes);
    r.comments = #fun(Option::as_js_undef[Bool])(#var(self).m_comments);
    r.dataAttributes = #fun(Option::as_js_undef[Bool])(#var(self).m_data_attributes);
    return r;
"

struct IdleDeadline()

pub ext fun IdleDeadline::did_timeout(self: IdleDeadline) -> Bool
    = "return #fun(Bool::from_js)(#var(self).didTimeout);"

pub ext fun IdleDeadline::time_remaining(__self: mut IdleDeadline) -> Float = "
    const r = #var(__self).timeRemaining();
    return #fun(Float::from_js)(r);
"

pub fun IdleDeadline::as_js(self: IdleDeadline) -> JsValue = JsValue::unsafe_from[IdleDeadline](self)

pub fun IdleDeadline::from_js(v: JsValue) -> mut IdleDeadline = JsValue::unsafe_as[mut IdleDeadline](v)

pub struct IdleRequestOptions(
    timeout: Option[Int]
)

pub fun IdleRequestOptions::default() -> mut IdleRequestOptions
    = IdleRequestOptions(Option::Some(0))

pub ext fun IdleRequestOptions::from_js(value: JsValue) -> mut IdleRequestOptions = "
    const r = {};
    r.m_timeout = #fun(Option::from_js[Int])(#var(value).timeout);
    return r;
"

pub ext fun IdleRequestOptions::as_js(self: IdleRequestOptions) -> JsValue = "
    const r = {};
    r.timeout = #fun(Option::as_js_undef[Int])(#var(self).m_timeout);
    return r;
"

pub val AncestorStatus::Ancestor: String = "ancestor"
pub val AncestorStatus::NotAncestor: String = "not ancestor"
pub val AncestorStatus::Unknown: String = "unknown"

struct Scheduler()

pub ext fun Scheduler::task_id(self: Scheduler) -> Int
    = "return #fun(Int::from_js)(#var(self).taskId);"

pub ext fun Scheduler::set_task_id(self: mut Scheduler, value: Int)
    = "#var(self).taskId = #fun(Int::as_js)(#var(value));"

pub ext fun Scheduler::post_task(__self: mut Scheduler, callback: Fun() -> JsValue, options: mut SchedulerPostTaskOptions) -> Promise[JsValue] = "
    const r = #var(__self).postTask((() => { const r = #var(callback)(); return r; }), #fun(SchedulerPostTaskOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Scheduler::yield(__self: mut Scheduler) -> Promise[Unit] = "
    const r = #var(__self).yield();
    return #fun(Promise::from_js[Unit])(r);
"

pub fun Scheduler::as_js(self: Scheduler) -> JsValue = JsValue::unsafe_from[Scheduler](self)

pub fun Scheduler::from_js(v: JsValue) -> mut Scheduler = JsValue::unsafe_as[mut Scheduler](v)

pub val TaskPriority::UserBlocking: String = "user-blocking"
pub val TaskPriority::UserVisible: String = "user-visible"
pub val TaskPriority::Background: String = "background"

pub struct SchedulerPostTaskOptions(
    signal: Option[mut AbortSignal],
    priority: Option[String],
    delay: Option[Int]
)

pub fun SchedulerPostTaskOptions::default() -> mut SchedulerPostTaskOptions
    = SchedulerPostTaskOptions(Option::None, Option::None, Option::Some(0))

pub ext fun SchedulerPostTaskOptions::from_js(value: JsValue) -> mut SchedulerPostTaskOptions = "
    const r = {};
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    r.m_priority = #fun(Option::from_js[String])(#var(value).priority);
    r.m_delay = #fun(Option::from_js[Int])(#var(value).delay);
    return r;
"

pub ext fun SchedulerPostTaskOptions::as_js(self: SchedulerPostTaskOptions) -> JsValue = "
    const r = {};
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    r.priority = #fun(Option::as_js_undef[String])(#var(self).m_priority);
    r.delay = #fun(Option::as_js_undef[Int])(#var(self).m_delay);
    return r;
"

struct ScriptWrappableTaskState()

pub fun ScriptWrappableTaskState::as_js(self: ScriptWrappableTaskState) -> JsValue = JsValue::unsafe_from[ScriptWrappableTaskState](self)

pub fun ScriptWrappableTaskState::from_js(v: JsValue) -> mut ScriptWrappableTaskState = JsValue::unsafe_as[mut ScriptWrappableTaskState](v)

struct TaskController()

/// Converts a reference to 'TaskController' to a reference to 'AbortController'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskController::as_abort_controller(self: TaskController) -> AbortController = "return #var(self);"

/// Converts a mutable reference to 'TaskController' to a mutable reference to 'AbortController'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskController::as_mabort_controller(self: mut TaskController) -> mut AbortController = "return #var(self);"

/// Attempts to convert a reference to 'AbortController' to a reference to 'TaskController'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskController' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskController::from_abort_controller(base: AbortController) -> TaskController = "
    if(#var(base) instanceof TaskController) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbortController' to 'TaskController'!\");
"

/// Attempts to convert a mutable reference to 'AbortController' to a mutable reference to 'TaskController'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskController' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskController::from_mabort_controller(base: mut AbortController) -> mut TaskController = "
    if(#var(base) instanceof TaskController) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbortController' to 'TaskController'!\");
"

pub ext fun TaskController::from_mtask_controller_init(init: mut TaskControllerInit) -> mut TaskController
    = "return new TaskController(#fun(TaskControllerInit::as_js)(#var(init)));"

pub ext fun TaskController::signal(self: TaskController) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun TaskController::set_priority(__self: mut TaskController, priority: String) -> Unit = "
    const r = #var(__self).setPriority(#var(priority));
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskController::abort(__self: mut TaskController, reason: JsValue) -> Unit = "
    const r = #var(__self).abort(#var(reason));
    return #fun(Unit::from_js)(r);
"

pub fun TaskController::as_js(self: TaskController) -> JsValue = JsValue::unsafe_from[TaskController](self)

pub fun TaskController::from_js(v: JsValue) -> mut TaskController = JsValue::unsafe_as[mut TaskController](v)

pub struct TaskControllerInit(
    priority: Option[String]
)

pub fun TaskControllerInit::default() -> mut TaskControllerInit
    = TaskControllerInit(Option::Some("user-visible"))

pub ext fun TaskControllerInit::from_js(value: JsValue) -> mut TaskControllerInit = "
    const r = {};
    r.m_priority = #fun(Option::from_js[String])(#var(value).priority);
    return r;
"

pub ext fun TaskControllerInit::as_js(self: TaskControllerInit) -> JsValue = "
    const r = {};
    r.priority = #fun(Option::as_js_undef[String])(#var(self).m_priority);
    return r;
"

struct TaskPriorityChangeEvent()

/// Converts a reference to 'TaskPriorityChangeEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEvent::as_event(self: TaskPriorityChangeEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'TaskPriorityChangeEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEvent::as_mevent(self: mut TaskPriorityChangeEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'TaskPriorityChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskPriorityChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEvent::from_event(base: Event) -> TaskPriorityChangeEvent = "
    if(#var(base) instanceof TaskPriorityChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TaskPriorityChangeEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'TaskPriorityChangeEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskPriorityChangeEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEvent::from_mevent(base: mut Event) -> mut TaskPriorityChangeEvent = "
    if(#var(base) instanceof TaskPriorityChangeEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'TaskPriorityChangeEvent'!\");
"

pub ext fun TaskPriorityChangeEvent::from_str_mtask_priority_change_event_init(type: String, event_init_dict: mut TaskPriorityChangeEventInit) -> mut TaskPriorityChangeEvent
    = "return new TaskPriorityChangeEvent(#fun(String::as_js)(#var(type)), #fun(TaskPriorityChangeEventInit::as_js)(#var(event_init_dict)));"

pub ext fun TaskPriorityChangeEvent::previous_priority(self: TaskPriorityChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).previousPriority);"

pub ext fun TaskPriorityChangeEvent::type(self: TaskPriorityChangeEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun TaskPriorityChangeEvent::target(self: TaskPriorityChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun TaskPriorityChangeEvent::current_target(self: TaskPriorityChangeEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun TaskPriorityChangeEvent::event_phase(self: TaskPriorityChangeEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun TaskPriorityChangeEvent::bubbles(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun TaskPriorityChangeEvent::cancelable(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun TaskPriorityChangeEvent::default_prevented(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun TaskPriorityChangeEvent::composed(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun TaskPriorityChangeEvent::is_trusted(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun TaskPriorityChangeEvent::time_stamp(self: TaskPriorityChangeEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun TaskPriorityChangeEvent::src_element(self: TaskPriorityChangeEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun TaskPriorityChangeEvent::return_value(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun TaskPriorityChangeEvent::set_return_value(self: mut TaskPriorityChangeEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun TaskPriorityChangeEvent::cancel_bubble(self: TaskPriorityChangeEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun TaskPriorityChangeEvent::set_cancel_bubble(self: mut TaskPriorityChangeEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun TaskPriorityChangeEvent::composed_path(__self: mut TaskPriorityChangeEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun TaskPriorityChangeEvent::stop_propagation(__self: mut TaskPriorityChangeEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskPriorityChangeEvent::stop_immediate_propagation(__self: mut TaskPriorityChangeEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskPriorityChangeEvent::prevent_default(__self: mut TaskPriorityChangeEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskPriorityChangeEvent::init_event(__self: mut TaskPriorityChangeEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun TaskPriorityChangeEvent::as_js(self: TaskPriorityChangeEvent) -> JsValue = JsValue::unsafe_from[TaskPriorityChangeEvent](self)

pub fun TaskPriorityChangeEvent::from_js(v: JsValue) -> mut TaskPriorityChangeEvent = JsValue::unsafe_as[mut TaskPriorityChangeEvent](v)

pub val TaskPriorityChangeEvent::none: Int = 0
pub val TaskPriorityChangeEvent::capturing_phase: Int = 1
pub val TaskPriorityChangeEvent::at_target: Int = 2
pub val TaskPriorityChangeEvent::bubbling_phase: Int = 3

pub struct TaskPriorityChangeEventInit(
    previous_priority: String,
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun TaskPriorityChangeEventInit::default(previous_priority: String) -> mut TaskPriorityChangeEventInit
    = TaskPriorityChangeEventInit(previous_priority, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'TaskPriorityChangeEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEventInit::as_event_init(self: TaskPriorityChangeEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'TaskPriorityChangeEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEventInit::as_mevent_init(self: mut TaskPriorityChangeEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'TaskPriorityChangeEventInit'.
/// A 'base' that is not a reference to 'TaskPriorityChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEventInit::from_event_init_unchecked(base: EventInit) -> TaskPriorityChangeEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'TaskPriorityChangeEventInit'.
/// A 'base' that is not a reference to 'TaskPriorityChangeEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun TaskPriorityChangeEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut TaskPriorityChangeEventInit = "return #var(base);"

pub ext fun TaskPriorityChangeEventInit::from_js(value: JsValue) -> mut TaskPriorityChangeEventInit = "
    const r = {};
    r.m_previous_priority = #fun(String::from_js)(#var(value).previousPriority);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun TaskPriorityChangeEventInit::as_js(self: TaskPriorityChangeEventInit) -> JsValue = "
    const r = {};
    r.previousPriority = #var(self).m_previous_priority;
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct TaskSignal()

/// Converts a reference to 'TaskSignal' to a reference to 'AbortSignal'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::as_abort_signal(self: TaskSignal) -> AbortSignal = "return #var(self);"

/// Converts a mutable reference to 'TaskSignal' to a mutable reference to 'AbortSignal'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::as_mabort_signal(self: mut TaskSignal) -> mut AbortSignal = "return #var(self);"

/// Attempts to convert a reference to 'AbortSignal' to a reference to 'TaskSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::from_abort_signal(base: AbortSignal) -> TaskSignal = "
    if(#var(base) instanceof TaskSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbortSignal' to 'TaskSignal'!\");
"

/// Attempts to convert a mutable reference to 'AbortSignal' to a mutable reference to 'TaskSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::from_mabort_signal(base: mut AbortSignal) -> mut TaskSignal = "
    if(#var(base) instanceof TaskSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbortSignal' to 'TaskSignal'!\");
"

/// Converts a reference to 'TaskSignal' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::as_event_target(self: TaskSignal) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'TaskSignal' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::as_mevent_target(self: mut TaskSignal) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'TaskSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::from_event_target(base: EventTarget) -> TaskSignal = "
    if(#var(base) instanceof TaskSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TaskSignal'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'TaskSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskSignal::from_mevent_target(base: mut EventTarget) -> mut TaskSignal = "
    if(#var(base) instanceof TaskSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TaskSignal'!\");
"

pub ext fun TaskSignal::priority(self: TaskSignal) -> String
    = "return #fun(String::from_js)(#var(self).priority);"

pub ext fun TaskSignal::onprioritychange(self: TaskSignal) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprioritychange);"

pub ext fun TaskSignal::set_onprioritychange(self: mut TaskSignal, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprioritychange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TaskSignal::aborted(self: TaskSignal) -> Bool
    = "return #fun(Bool::from_js)(#var(self).aborted);"

pub ext fun TaskSignal::reason(self: TaskSignal) -> JsValue
    = "return #var(self).reason;"

pub ext fun TaskSignal::onabort(self: TaskSignal) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun TaskSignal::set_onabort(self: mut TaskSignal, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TaskSignal::any_list_mabort_signal_mtask_signal_any_init(signals: List[mut AbortSignal], init: mut TaskSignalAnyInit) -> mut TaskSignal = "
    const r = TaskSignal.any(#fun(List::as_js[mut AbortSignal])(#var(signals)), #fun(TaskSignalAnyInit::as_js)(#var(init)));
    return #fun(TaskSignal::from_js)(r);
"

pub ext fun TaskSignal::abort(reason: JsValue) -> mut AbortSignal = "
    const r = TaskSignal.abort(#var(reason));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun TaskSignal::timeout(milliseconds: Int) -> mut AbortSignal = "
    const r = TaskSignal.timeout(#fun(Int::as_js)(#var(milliseconds)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun TaskSignal::any_list_mabort_signal(signals: List[mut AbortSignal]) -> mut AbortSignal = "
    const r = TaskSignal.any(#fun(List::as_js[mut AbortSignal])(#var(signals)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun TaskSignal::throw_if_aborted(__self: mut TaskSignal) -> Unit = "
    const r = #var(__self).throwIfAborted();
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskSignal::add_event_listener(__self: mut TaskSignal, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskSignal::remove_event_listener(__self: mut TaskSignal, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TaskSignal::dispatch_event(__self: mut TaskSignal, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun TaskSignal::when(__self: mut TaskSignal, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun TaskSignal::as_js(self: TaskSignal) -> JsValue = JsValue::unsafe_from[TaskSignal](self)

pub fun TaskSignal::from_js(v: JsValue) -> mut TaskSignal = JsValue::unsafe_as[mut TaskSignal](v)

pub struct TaskSignalAnyInit(
    priority: Option[JsValue]
)

pub fun TaskSignalAnyInit::default() -> mut TaskSignalAnyInit
    = TaskSignalAnyInit(Option::Some("user-visible" |> as_js()))

pub ext fun TaskSignalAnyInit::from_js(value: JsValue) -> mut TaskSignalAnyInit = "
    const r = {};
    r.m_priority = #fun(Option::from_js[JsValue])(#var(value).priority);
    return r;
"

pub ext fun TaskSignalAnyInit::as_js(self: TaskSignalAnyInit) -> JsValue = "
    const r = {};
    r.priority = #fun(Option::as_js_undef[JsValue])(#var(self).m_priority);
    return r;
"

pub ext fun Window::request_idle_callback(__self: mut Window, callback: Fun(mut IdleDeadline) -> Unit, options: mut IdleRequestOptions) -> Int = "
    const r = #var(__self).requestIdleCallback(((p0) => { const r = #var(callback)(#fun(IdleDeadline::from_js)(p0)); return #fun(Unit::as_js)(r); }), #fun(IdleRequestOptions::as_js)(#var(options)));
    return #fun(Int::from_js)(r);
"

pub ext fun Window::cancel_idle_callback(__self: mut Window, handle: Int) -> Unit = "
    const r = #var(__self).cancelIdleCallback(#fun(Int::as_js)(#var(handle)));
    return #fun(Unit::from_js)(r);
"

struct SnapEvent()

/// Converts a reference to 'SnapEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEvent::as_event(self: SnapEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'SnapEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEvent::as_mevent(self: mut SnapEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'SnapEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SnapEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEvent::from_event(base: Event) -> SnapEvent = "
    if(#var(base) instanceof SnapEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SnapEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'SnapEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'SnapEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEvent::from_mevent(base: mut Event) -> mut SnapEvent = "
    if(#var(base) instanceof SnapEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'SnapEvent'!\");
"

pub ext fun SnapEvent::from_str_msnap_event_init(type: String, event_init_dict: mut SnapEventInit) -> mut SnapEvent
    = "return new SnapEvent(#fun(String::as_js)(#var(type)), #fun(SnapEventInit::as_js)(#var(event_init_dict)));"

pub ext fun SnapEvent::snap_target_block(self: SnapEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).snapTargetBlock);"

pub ext fun SnapEvent::snap_target_inline(self: SnapEvent) -> mut Node
    = "return #fun(Node::from_js)(#var(self).snapTargetInline);"

pub ext fun SnapEvent::type(self: SnapEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SnapEvent::target(self: SnapEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun SnapEvent::current_target(self: SnapEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun SnapEvent::event_phase(self: SnapEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun SnapEvent::bubbles(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun SnapEvent::cancelable(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun SnapEvent::default_prevented(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun SnapEvent::composed(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun SnapEvent::is_trusted(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun SnapEvent::time_stamp(self: SnapEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun SnapEvent::src_element(self: SnapEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun SnapEvent::return_value(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun SnapEvent::set_return_value(self: mut SnapEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun SnapEvent::cancel_bubble(self: SnapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun SnapEvent::set_cancel_bubble(self: mut SnapEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun SnapEvent::composed_path(__self: mut SnapEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun SnapEvent::stop_propagation(__self: mut SnapEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SnapEvent::stop_immediate_propagation(__self: mut SnapEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun SnapEvent::prevent_default(__self: mut SnapEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun SnapEvent::init_event(__self: mut SnapEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun SnapEvent::as_js(self: SnapEvent) -> JsValue = JsValue::unsafe_from[SnapEvent](self)

pub fun SnapEvent::from_js(v: JsValue) -> mut SnapEvent = JsValue::unsafe_as[mut SnapEvent](v)

pub val SnapEvent::none: Int = 0
pub val SnapEvent::capturing_phase: Int = 1
pub val SnapEvent::at_target: Int = 2
pub val SnapEvent::bubbling_phase: Int = 3

pub struct SnapEventInit(
    snap_target_block: Option[mut Node],
    snap_target_inline: Option[mut Node],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun SnapEventInit::default() -> mut SnapEventInit
    = SnapEventInit(Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'SnapEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEventInit::as_event_init(self: SnapEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'SnapEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEventInit::as_mevent_init(self: mut SnapEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'SnapEventInit'.
/// A 'base' that is not a reference to 'SnapEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEventInit::from_event_init_unchecked(base: EventInit) -> SnapEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'SnapEventInit'.
/// A 'base' that is not a reference to 'SnapEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SnapEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut SnapEventInit = "return #var(base);"

pub ext fun SnapEventInit::from_js(value: JsValue) -> mut SnapEventInit = "
    const r = {};
    r.m_snap_target_block = #fun(Option::from_js[mut Node])(#var(value).snapTargetBlock);
    r.m_snap_target_inline = #fun(Option::from_js[mut Node])(#var(value).snapTargetInline);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun SnapEventInit::as_js(self: SnapEventInit) -> JsValue = "
    const r = {};
    r.snapTargetBlock = #fun(Option::as_js_undef[mut Node])(#var(self).m_snap_target_block);
    r.snapTargetInline = #fun(Option::as_js_undef[mut Node])(#var(self).m_snap_target_inline);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct ShadowRealmGlobalScope()

pub ext fun ShadowRealmGlobalScope::is_secure_context(self: ShadowRealmGlobalScope) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isSecureContext);"

pub ext fun ShadowRealmGlobalScope::report_error(__self: mut ShadowRealmGlobalScope, e: JsValue) -> Unit = "
    const r = #var(__self).reportError(#var(e));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRealmGlobalScope::btoa(__self: mut ShadowRealmGlobalScope, btoa: String) -> String = "
    const r = #var(__self).btoa(#fun(String::as_js)(#var(btoa)));
    return #fun(String::from_js)(r);
"

pub ext fun ShadowRealmGlobalScope::atob(__self: mut ShadowRealmGlobalScope, atob: String) -> String = "
    const r = #var(__self).atob(#fun(String::as_js)(#var(atob)));
    return #fun(String::from_js)(r);
"

pub ext fun ShadowRealmGlobalScope::queue_microtask(__self: mut ShadowRealmGlobalScope, callback: Fun() -> Unit) -> Unit = "
    const r = #var(__self).queueMicrotask((() => { const r = #var(callback)(); return #fun(Unit::as_js)(r); }));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRealmGlobalScope::structured_clone(__self: mut ShadowRealmGlobalScope, value: JsValue, options: mut StructuredSerializeOptions) -> JsValue = "
    const r = #var(__self).structuredClone(#var(value), #fun(StructuredSerializeOptions::as_js)(#var(options)));
    return r;
"

pub fun ShadowRealmGlobalScope::as_js(self: ShadowRealmGlobalScope) -> JsValue = JsValue::unsafe_from[ShadowRealmGlobalScope](self)

pub fun ShadowRealmGlobalScope::from_js(v: JsValue) -> mut ShadowRealmGlobalScope = JsValue::unsafe_as[mut ShadowRealmGlobalScope](v)

struct ByteLengthQueuingStrategy()

pub ext fun ByteLengthQueuingStrategy::from_mqueuing_strategy_init(init: mut QueuingStrategyInit) -> mut ByteLengthQueuingStrategy
    = "return new ByteLengthQueuingStrategy(#fun(QueuingStrategyInit::as_js)(#var(init)));"

pub ext fun ByteLengthQueuingStrategy::high_water_mark(self: ByteLengthQueuingStrategy) -> Float
    = "return #fun(Float::from_js)(#var(self).highWaterMark);"

pub ext fun ByteLengthQueuingStrategy::size(self: ByteLengthQueuingStrategy) -> JsValue
    = "return #var(self).size;"

pub fun ByteLengthQueuingStrategy::as_js(self: ByteLengthQueuingStrategy) -> JsValue = JsValue::unsafe_from[ByteLengthQueuingStrategy](self)

pub fun ByteLengthQueuingStrategy::from_js(v: JsValue) -> mut ByteLengthQueuingStrategy = JsValue::unsafe_as[mut ByteLengthQueuingStrategy](v)

struct CountQueuingStrategy()

pub ext fun CountQueuingStrategy::from_mqueuing_strategy_init(init: mut QueuingStrategyInit) -> mut CountQueuingStrategy
    = "return new CountQueuingStrategy(#fun(QueuingStrategyInit::as_js)(#var(init)));"

pub ext fun CountQueuingStrategy::high_water_mark(self: CountQueuingStrategy) -> Float
    = "return #fun(Float::from_js)(#var(self).highWaterMark);"

pub ext fun CountQueuingStrategy::size(self: CountQueuingStrategy) -> JsValue
    = "return #var(self).size;"

pub fun CountQueuingStrategy::as_js(self: CountQueuingStrategy) -> JsValue = JsValue::unsafe_from[CountQueuingStrategy](self)

pub fun CountQueuingStrategy::from_js(v: JsValue) -> mut CountQueuingStrategy = JsValue::unsafe_as[mut CountQueuingStrategy](v)

pub struct QueuingStrategyInit(
    high_water_mark: Float
)

pub fun QueuingStrategyInit::default(high_water_mark: Float) -> mut QueuingStrategyInit
    = QueuingStrategyInit(high_water_mark)

pub ext fun QueuingStrategyInit::from_js(value: JsValue) -> mut QueuingStrategyInit = "
    const r = {};
    r.m_high_water_mark = #fun(Float::from_js)(#var(value).highWaterMark);
    return r;
"

pub ext fun QueuingStrategyInit::as_js(self: QueuingStrategyInit) -> JsValue = "
    const r = {};
    r.highWaterMark = #fun(Float::as_js)(#var(self).m_high_water_mark);
    return r;
"

struct ReadableByteStreamController()

pub ext fun ReadableByteStreamController::byob_request(self: ReadableByteStreamController) -> Option[mut ReadableStreamBYOBRequest]
    = "return #fun(Option::from_js[mut ReadableStreamBYOBRequest])(#var(self).byobRequest);"

pub ext fun ReadableByteStreamController::desired_size(self: ReadableByteStreamController) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).desiredSize);"

pub ext fun ReadableByteStreamController::close(__self: mut ReadableByteStreamController) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableByteStreamController::enqueue(__self: mut ReadableByteStreamController, chunk: JsValue) -> Unit = "
    const r = #var(__self).enqueue(#var(chunk));
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableByteStreamController::error(__self: mut ReadableByteStreamController, e: JsValue) -> Unit = "
    const r = #var(__self).error(#var(e));
    return #fun(Unit::from_js)(r);
"

pub fun ReadableByteStreamController::as_js(self: ReadableByteStreamController) -> JsValue = JsValue::unsafe_from[ReadableByteStreamController](self)

pub fun ReadableByteStreamController::from_js(v: JsValue) -> mut ReadableByteStreamController = JsValue::unsafe_as[mut ReadableByteStreamController](v)

pub val ReadableStreamReaderMode::Byob: String = "byob"

pub val ReadableStreamType::Bytes: String = "bytes"

struct ReadableStream()

pub ext fun ReadableStream::from_any_any(underlying_source: JsValue, strategy: JsValue) -> mut ReadableStream
    = "return new ReadableStream(#var(underlying_source), #var(strategy));"

pub ext fun ReadableStream::locked(self: ReadableStream) -> Bool
    = "return #fun(Bool::from_js)(#var(self).locked);"

pub ext fun ReadableStream::cancel(__self: mut ReadableStream, reason: JsValue) -> Promise[Unit] = "
    const r = #var(__self).cancel(#var(reason));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun ReadableStream::get_reader(__self: mut ReadableStream, options: mut ReadableStreamGetReaderOptions) -> JsValue = "
    const r = #var(__self).getReader(#fun(ReadableStreamGetReaderOptions::as_js)(#var(options)));
    return r;
"

pub ext fun ReadableStream::pipe_through(__self: mut ReadableStream, transform: mut ReadableWritablePair, options: mut StreamPipeOptions) -> mut ReadableStream = "
    const r = #var(__self).pipeThrough(#fun(ReadableWritablePair::as_js)(#var(transform)), #fun(StreamPipeOptions::as_js)(#var(options)));
    return #fun(ReadableStream::from_js)(r);
"

pub ext fun ReadableStream::pipe_to(__self: mut ReadableStream, destination: mut WritableStream, options: mut StreamPipeOptions) -> Promise[Unit] = "
    const r = #var(__self).pipeTo(#fun(WritableStream::as_js)(#var(destination)), #fun(StreamPipeOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun ReadableStream::tee(__self: mut ReadableStream) -> List[mut ReadableStream] = "
    const r = #var(__self).tee();
    return #fun(List::from_js[mut ReadableStream])(r);
"

pub fun ReadableStream::as_js(self: ReadableStream) -> JsValue = JsValue::unsafe_from[ReadableStream](self)

pub fun ReadableStream::from_js(v: JsValue) -> mut ReadableStream = JsValue::unsafe_as[mut ReadableStream](v)

struct ReadableStreamBYOBReader()

pub ext fun ReadableStreamBYOBReader::from_mreadable_stream(stream: mut ReadableStream) -> mut ReadableStreamBYOBReader
    = "return new ReadableStreamBYOBReader(#fun(ReadableStream::as_js)(#var(stream)));"

pub ext fun ReadableStreamBYOBReader::closed(self: ReadableStreamBYOBReader) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).closed);"

pub ext fun ReadableStreamBYOBReader::read(__self: mut ReadableStreamBYOBReader, view: JsValue, options: mut ReadableStreamBYOBReaderReadOptions) -> Promise[mut ReadableStreamReadResult] = "
    const r = #var(__self).read(#var(view), #fun(ReadableStreamBYOBReaderReadOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[mut ReadableStreamReadResult])(r);
"

pub ext fun ReadableStreamBYOBReader::release_lock(__self: mut ReadableStreamBYOBReader) -> Unit = "
    const r = #var(__self).releaseLock();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableStreamBYOBReader::cancel(__self: mut ReadableStreamBYOBReader, reason: JsValue) -> Promise[Unit] = "
    const r = #var(__self).cancel(#var(reason));
    return #fun(Promise::from_js[Unit])(r);
"

pub fun ReadableStreamBYOBReader::as_js(self: ReadableStreamBYOBReader) -> JsValue = JsValue::unsafe_from[ReadableStreamBYOBReader](self)

pub fun ReadableStreamBYOBReader::from_js(v: JsValue) -> mut ReadableStreamBYOBReader = JsValue::unsafe_as[mut ReadableStreamBYOBReader](v)

pub struct ReadableStreamBYOBReaderReadOptions(
    min: Option[Int]
)

pub fun ReadableStreamBYOBReaderReadOptions::default() -> mut ReadableStreamBYOBReaderReadOptions
    = ReadableStreamBYOBReaderReadOptions(Option::Some(1))

pub ext fun ReadableStreamBYOBReaderReadOptions::from_js(value: JsValue) -> mut ReadableStreamBYOBReaderReadOptions = "
    const r = {};
    r.m_min = #fun(Option::from_js[Int])(#var(value).min);
    return r;
"

pub ext fun ReadableStreamBYOBReaderReadOptions::as_js(self: ReadableStreamBYOBReaderReadOptions) -> JsValue = "
    const r = {};
    r.min = #fun(Option::as_js_undef[Int])(#var(self).m_min);
    return r;
"

struct ReadableStreamBYOBRequest()

pub ext fun ReadableStreamBYOBRequest::view(self: ReadableStreamBYOBRequest) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).view);"

pub ext fun ReadableStreamBYOBRequest::respond(__self: mut ReadableStreamBYOBRequest, bytes_written: Int) -> Unit = "
    const r = #var(__self).respond(#fun(Int::as_js)(#var(bytes_written)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableStreamBYOBRequest::respond_with_new_view(__self: mut ReadableStreamBYOBRequest, view: JsValue) -> Unit = "
    const r = #var(__self).respondWithNewView(#var(view));
    return #fun(Unit::from_js)(r);
"

pub fun ReadableStreamBYOBRequest::as_js(self: ReadableStreamBYOBRequest) -> JsValue = JsValue::unsafe_from[ReadableStreamBYOBRequest](self)

pub fun ReadableStreamBYOBRequest::from_js(v: JsValue) -> mut ReadableStreamBYOBRequest = JsValue::unsafe_as[mut ReadableStreamBYOBRequest](v)

struct ReadableStreamDefaultController()

pub ext fun ReadableStreamDefaultController::desired_size(self: ReadableStreamDefaultController) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).desiredSize);"

pub ext fun ReadableStreamDefaultController::close(__self: mut ReadableStreamDefaultController) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableStreamDefaultController::enqueue(__self: mut ReadableStreamDefaultController, chunk: JsValue) -> Unit = "
    const r = #var(__self).enqueue(#var(chunk));
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableStreamDefaultController::error(__self: mut ReadableStreamDefaultController, e: JsValue) -> Unit = "
    const r = #var(__self).error(#var(e));
    return #fun(Unit::from_js)(r);
"

pub fun ReadableStreamDefaultController::as_js(self: ReadableStreamDefaultController) -> JsValue = JsValue::unsafe_from[ReadableStreamDefaultController](self)

pub fun ReadableStreamDefaultController::from_js(v: JsValue) -> mut ReadableStreamDefaultController = JsValue::unsafe_as[mut ReadableStreamDefaultController](v)

struct ReadableStreamDefaultReader()

pub ext fun ReadableStreamDefaultReader::from_mreadable_stream(stream: mut ReadableStream) -> mut ReadableStreamDefaultReader
    = "return new ReadableStreamDefaultReader(#fun(ReadableStream::as_js)(#var(stream)));"

pub ext fun ReadableStreamDefaultReader::closed(self: ReadableStreamDefaultReader) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).closed);"

pub ext fun ReadableStreamDefaultReader::read(__self: mut ReadableStreamDefaultReader) -> Promise[mut ReadableStreamReadResult] = "
    const r = #var(__self).read();
    return #fun(Promise::from_js[mut ReadableStreamReadResult])(r);
"

pub ext fun ReadableStreamDefaultReader::release_lock(__self: mut ReadableStreamDefaultReader) -> Unit = "
    const r = #var(__self).releaseLock();
    return #fun(Unit::from_js)(r);
"

pub ext fun ReadableStreamDefaultReader::cancel(__self: mut ReadableStreamDefaultReader, reason: JsValue) -> Promise[Unit] = "
    const r = #var(__self).cancel(#var(reason));
    return #fun(Promise::from_js[Unit])(r);
"

pub fun ReadableStreamDefaultReader::as_js(self: ReadableStreamDefaultReader) -> JsValue = JsValue::unsafe_from[ReadableStreamDefaultReader](self)

pub fun ReadableStreamDefaultReader::from_js(v: JsValue) -> mut ReadableStreamDefaultReader = JsValue::unsafe_as[mut ReadableStreamDefaultReader](v)

pub struct ReadableStreamGetReaderOptions(
    mode: Option[String]
)

pub fun ReadableStreamGetReaderOptions::default() -> mut ReadableStreamGetReaderOptions
    = ReadableStreamGetReaderOptions(Option::None)

pub ext fun ReadableStreamGetReaderOptions::from_js(value: JsValue) -> mut ReadableStreamGetReaderOptions = "
    const r = {};
    r.m_mode = #fun(Option::from_js[String])(#var(value).mode);
    return r;
"

pub ext fun ReadableStreamGetReaderOptions::as_js(self: ReadableStreamGetReaderOptions) -> JsValue = "
    const r = {};
    r.mode = #fun(Option::as_js_undef[String])(#var(self).m_mode);
    return r;
"

pub struct ReadableStreamIteratorOptions(
    prevent_cancel: Option[Bool]
)

pub fun ReadableStreamIteratorOptions::default() -> mut ReadableStreamIteratorOptions
    = ReadableStreamIteratorOptions(Option::Some(false))

pub ext fun ReadableStreamIteratorOptions::from_js(value: JsValue) -> mut ReadableStreamIteratorOptions = "
    const r = {};
    r.m_prevent_cancel = #fun(Option::from_js[Bool])(#var(value).preventCancel);
    return r;
"

pub ext fun ReadableStreamIteratorOptions::as_js(self: ReadableStreamIteratorOptions) -> JsValue = "
    const r = {};
    r.preventCancel = #fun(Option::as_js_undef[Bool])(#var(self).m_prevent_cancel);
    return r;
"

pub struct ReadableStreamReadResult(
    value: Option[JsValue],
    done: Option[Bool]
)

pub fun ReadableStreamReadResult::default() -> mut ReadableStreamReadResult
    = ReadableStreamReadResult(Option::None, Option::None)

pub ext fun ReadableStreamReadResult::from_js(value: JsValue) -> mut ReadableStreamReadResult = "
    const r = {};
    r.m_value = #fun(Option::from_js[JsValue])(#var(value).value);
    r.m_done = #fun(Option::from_js[Bool])(#var(value).done);
    return r;
"

pub ext fun ReadableStreamReadResult::as_js(self: ReadableStreamReadResult) -> JsValue = "
    const r = {};
    r.value = #fun(Option::as_js_undef[JsValue])(#var(self).m_value);
    r.done = #fun(Option::as_js_undef[Bool])(#var(self).m_done);
    return r;
"

pub struct ReadableWritablePair(
    readable: mut ReadableStream,
    writable: mut WritableStream
)

pub fun ReadableWritablePair::default(readable: mut ReadableStream, writable: mut WritableStream) -> mut ReadableWritablePair
    = ReadableWritablePair(readable, writable)

pub ext fun ReadableWritablePair::from_js(value: JsValue) -> mut ReadableWritablePair = "
    const r = {};
    r.m_readable = #fun(ReadableStream::from_js)(#var(value).readable);
    r.m_writable = #fun(WritableStream::from_js)(#var(value).writable);
    return r;
"

pub ext fun ReadableWritablePair::as_js(self: ReadableWritablePair) -> JsValue = "
    const r = {};
    r.readable = #fun(ReadableStream::as_js)(#var(self).m_readable);
    r.writable = #fun(WritableStream::as_js)(#var(self).m_writable);
    return r;
"

pub struct StreamPipeOptions(
    prevent_close: Option[Bool],
    prevent_abort: Option[Bool],
    prevent_cancel: Option[Bool],
    signal: Option[mut AbortSignal]
)

pub fun StreamPipeOptions::default() -> mut StreamPipeOptions
    = StreamPipeOptions(Option::Some(false), Option::Some(false), Option::Some(false), Option::None)

pub ext fun StreamPipeOptions::from_js(value: JsValue) -> mut StreamPipeOptions = "
    const r = {};
    r.m_prevent_close = #fun(Option::from_js[Bool])(#var(value).preventClose);
    r.m_prevent_abort = #fun(Option::from_js[Bool])(#var(value).preventAbort);
    r.m_prevent_cancel = #fun(Option::from_js[Bool])(#var(value).preventCancel);
    r.m_signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    return r;
"

pub ext fun StreamPipeOptions::as_js(self: StreamPipeOptions) -> JsValue = "
    const r = {};
    r.preventClose = #fun(Option::as_js_undef[Bool])(#var(self).m_prevent_close);
    r.preventAbort = #fun(Option::as_js_undef[Bool])(#var(self).m_prevent_abort);
    r.preventCancel = #fun(Option::as_js_undef[Bool])(#var(self).m_prevent_cancel);
    r.signal = #fun(Option::as_js_undef[mut AbortSignal])(#var(self).m_signal);
    return r;
"

struct TransformStream()

pub ext fun TransformStream::from_any_any_any(transformer: JsValue, writable_strategy: JsValue, readable_strategy: JsValue) -> mut TransformStream
    = "return new TransformStream(#var(transformer), #var(writable_strategy), #var(readable_strategy));"

pub ext fun TransformStream::readable(self: TransformStream) -> mut ReadableStream
    = "return #fun(ReadableStream::from_js)(#var(self).readable);"

pub ext fun TransformStream::writable(self: TransformStream) -> mut WritableStream
    = "return #fun(WritableStream::from_js)(#var(self).writable);"

pub fun TransformStream::as_js(self: TransformStream) -> JsValue = JsValue::unsafe_from[TransformStream](self)

pub fun TransformStream::from_js(v: JsValue) -> mut TransformStream = JsValue::unsafe_as[mut TransformStream](v)

struct TransformStreamDefaultController()

pub ext fun TransformStreamDefaultController::desired_size(self: TransformStreamDefaultController) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).desiredSize);"

pub ext fun TransformStreamDefaultController::enqueue(__self: mut TransformStreamDefaultController, chunk: JsValue) -> Unit = "
    const r = #var(__self).enqueue(#var(chunk));
    return #fun(Unit::from_js)(r);
"

pub ext fun TransformStreamDefaultController::error(__self: mut TransformStreamDefaultController, reason: JsValue) -> Unit = "
    const r = #var(__self).error(#var(reason));
    return #fun(Unit::from_js)(r);
"

pub ext fun TransformStreamDefaultController::terminate(__self: mut TransformStreamDefaultController) -> Unit = "
    const r = #var(__self).terminate();
    return #fun(Unit::from_js)(r);
"

pub fun TransformStreamDefaultController::as_js(self: TransformStreamDefaultController) -> JsValue = JsValue::unsafe_from[TransformStreamDefaultController](self)

pub fun TransformStreamDefaultController::from_js(v: JsValue) -> mut TransformStreamDefaultController = JsValue::unsafe_as[mut TransformStreamDefaultController](v)

pub struct UnderlyingSource(
    start: Option[Fun(JsValue) -> JsValue],
    pull: Option[Fun(JsValue) -> Promise[Unit]],
    cancel: Option[Fun(JsValue) -> Promise[Unit]],
    type: Option[String],
    auto_allocate_chunk_size: Option[Int]
)

pub fun UnderlyingSource::default() -> mut UnderlyingSource
    = UnderlyingSource(Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun UnderlyingSource::from_js(value: JsValue) -> mut UnderlyingSource = "
    const r = {};
    r.m_start = #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(value).start);
    r.m_pull = #fun(Option::from_js[Fun(JsValue) -> Promise[Unit]])(#var(value).pull);
    r.m_cancel = #fun(Option::from_js[Fun(JsValue) -> Promise[Unit]])(#var(value).cancel);
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_auto_allocate_chunk_size = #fun(Option::from_js[Int])(#var(value).autoAllocateChunkSize);
    return r;
"

pub ext fun UnderlyingSource::as_js(self: UnderlyingSource) -> JsValue = "
    const r = {};
    r.start = #fun(Option::as_js_undef[Fun(JsValue) -> JsValue])(#var(self).m_start);
    r.pull = #fun(Option::as_js_undef[Fun(JsValue) -> Promise[Unit]])(#var(self).m_pull);
    r.cancel = #fun(Option::as_js_undef[Fun(JsValue) -> Promise[Unit]])(#var(self).m_cancel);
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.autoAllocateChunkSize = #fun(Option::as_js_undef[Int])(#var(self).m_auto_allocate_chunk_size);
    return r;
"

struct WritableStream()

pub ext fun WritableStream::from_any_any(underlying_sink: JsValue, strategy: JsValue) -> mut WritableStream
    = "return new WritableStream(#var(underlying_sink), #var(strategy));"

pub ext fun WritableStream::locked(self: WritableStream) -> Bool
    = "return #fun(Bool::from_js)(#var(self).locked);"

pub ext fun WritableStream::abort(__self: mut WritableStream, reason: JsValue) -> Promise[Unit] = "
    const r = #var(__self).abort(#var(reason));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun WritableStream::close(__self: mut WritableStream) -> Promise[Unit] = "
    const r = #var(__self).close();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun WritableStream::get_writer(__self: mut WritableStream) -> mut WritableStreamDefaultWriter = "
    const r = #var(__self).getWriter();
    return #fun(WritableStreamDefaultWriter::from_js)(r);
"

pub fun WritableStream::as_js(self: WritableStream) -> JsValue = JsValue::unsafe_from[WritableStream](self)

pub fun WritableStream::from_js(v: JsValue) -> mut WritableStream = JsValue::unsafe_as[mut WritableStream](v)

struct WritableStreamDefaultController()

pub ext fun WritableStreamDefaultController::signal(self: WritableStreamDefaultController) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun WritableStreamDefaultController::error(__self: mut WritableStreamDefaultController, e: JsValue) -> Unit = "
    const r = #var(__self).error(#var(e));
    return #fun(Unit::from_js)(r);
"

pub fun WritableStreamDefaultController::as_js(self: WritableStreamDefaultController) -> JsValue = JsValue::unsafe_from[WritableStreamDefaultController](self)

pub fun WritableStreamDefaultController::from_js(v: JsValue) -> mut WritableStreamDefaultController = JsValue::unsafe_as[mut WritableStreamDefaultController](v)

struct WritableStreamDefaultWriter()

pub ext fun WritableStreamDefaultWriter::from_mwritable_stream(stream: mut WritableStream) -> mut WritableStreamDefaultWriter
    = "return new WritableStreamDefaultWriter(#fun(WritableStream::as_js)(#var(stream)));"

pub ext fun WritableStreamDefaultWriter::closed(self: WritableStreamDefaultWriter) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).closed);"

pub ext fun WritableStreamDefaultWriter::desired_size(self: WritableStreamDefaultWriter) -> JsValue
    = "return #var(self).desiredSize;"

pub ext fun WritableStreamDefaultWriter::ready(self: WritableStreamDefaultWriter) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).ready);"

pub ext fun WritableStreamDefaultWriter::abort(__self: mut WritableStreamDefaultWriter, reason: JsValue) -> Promise[Unit] = "
    const r = #var(__self).abort(#var(reason));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun WritableStreamDefaultWriter::close(__self: mut WritableStreamDefaultWriter) -> Promise[Unit] = "
    const r = #var(__self).close();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun WritableStreamDefaultWriter::release_lock(__self: mut WritableStreamDefaultWriter) -> Unit = "
    const r = #var(__self).releaseLock();
    return #fun(Unit::from_js)(r);
"

pub ext fun WritableStreamDefaultWriter::write(__self: mut WritableStreamDefaultWriter, chunk: JsValue) -> Promise[Unit] = "
    const r = #var(__self).write(#var(chunk));
    return #fun(Promise::from_js[Unit])(r);
"

pub fun WritableStreamDefaultWriter::as_js(self: WritableStreamDefaultWriter) -> JsValue = JsValue::unsafe_from[WritableStreamDefaultWriter](self)

pub fun WritableStreamDefaultWriter::from_js(v: JsValue) -> mut WritableStreamDefaultWriter = JsValue::unsafe_as[mut WritableStreamDefaultWriter](v)

struct SVGAElement()

/// Converts a reference to 'SVGAElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_svg_graphics_element(self: SVGAElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_msvg_graphics_element(self: mut SVGAElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGAElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGAElement'!\");
"

/// Converts a reference to 'SVGAElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_svg_element(self: SVGAElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_msvg_element(self: mut SVGAElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_svg_element(base: SVGElement) -> SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_msvg_element(base: mut SVGElement) -> mut SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAElement'!\");
"

/// Converts a reference to 'SVGAElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_element(self: SVGAElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGAElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::as_melement(self: mut SVGAElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_element(base: Element) -> SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAElement::from_melement(base: mut Element) -> mut SVGAElement = "
    if(#var(base) instanceof SVGAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAElement'!\");
"

pub ext fun SVGAElement::target(self: SVGAElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).target);"

pub ext fun SVGAElement::rel(self: SVGAElement) -> String
    = "return #fun(String::from_js)(#var(self).rel);"

pub ext fun SVGAElement::set_rel(self: mut SVGAElement, value: String)
    = "#var(self).rel = #fun(String::as_js)(#var(value));"

pub ext fun SVGAElement::rel_list(self: SVGAElement) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).relList);"

pub ext fun SVGAElement::transform(self: SVGAElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGAElement::nearest_viewport_element(self: SVGAElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGAElement::farthest_viewport_element(self: SVGAElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGAElement::class_name(self: SVGAElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGAElement::owner_svg_element(self: SVGAElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGAElement::viewport_element(self: SVGAElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGAElement::href(self: SVGAElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGAElement::interest_for_element(self: SVGAElement) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).interestForElement);"

pub ext fun SVGAElement::set_interest_for_element(self: mut SVGAElement, value: Option[mut Element])
    = "#var(self).interestForElement = #fun(Option::as_js[mut Element])(#var(value));"

pub ext fun SVGAElement::get_b_box(__self: mut SVGAElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGAElement::get_ctm(__self: mut SVGAElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGAElement::get_screen_ctm(__self: mut SVGAElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGAElement::start_view_transition(__self: mut SVGAElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAElement::start_view_transition_f_prom_unit(__self: mut SVGAElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAElement::start_view_transition_mview_transition_options(__self: mut SVGAElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGAElement::as_js(self: SVGAElement) -> JsValue = JsValue::unsafe_from[SVGAElement](self)

pub fun SVGAElement::from_js(v: JsValue) -> mut SVGAElement = JsValue::unsafe_as[mut SVGAElement](v)

struct SVGAngle()

pub ext fun SVGAngle::unit_type(self: SVGAngle) -> Int
    = "return #fun(Int::from_js)(#var(self).unitType);"

pub ext fun SVGAngle::value(self: SVGAngle) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun SVGAngle::set_value(self: mut SVGAngle, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub ext fun SVGAngle::value_in_specified_units(self: SVGAngle) -> Float
    = "return #fun(Float::from_js)(#var(self).valueInSpecifiedUnits);"

pub ext fun SVGAngle::set_value_in_specified_units(self: mut SVGAngle, value: Float)
    = "#var(self).valueInSpecifiedUnits = #fun(Float::as_js)(#var(value));"

pub ext fun SVGAngle::value_as_string(self: SVGAngle) -> String
    = "return #fun(String::from_js)(#var(self).valueAsString);"

pub ext fun SVGAngle::set_value_as_string(self: mut SVGAngle, value: String)
    = "#var(self).valueAsString = #fun(String::as_js)(#var(value));"

pub ext fun SVGAngle::new_value_specified_units(__self: mut SVGAngle, unit_type: Int, value_in_specified_units: Float) -> Unit = "
    const r = #var(__self).newValueSpecifiedUnits(#fun(Int::as_js)(#var(unit_type)), #fun(Float::as_js)(#var(value_in_specified_units)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAngle::convert_to_specified_units(__self: mut SVGAngle, unit_type: Int) -> Unit = "
    const r = #var(__self).convertToSpecifiedUnits(#fun(Int::as_js)(#var(unit_type)));
    return #fun(Unit::from_js)(r);
"

pub fun SVGAngle::as_js(self: SVGAngle) -> JsValue = JsValue::unsafe_from[SVGAngle](self)

pub fun SVGAngle::from_js(v: JsValue) -> mut SVGAngle = JsValue::unsafe_as[mut SVGAngle](v)

pub val SVGAngle::svg_angletype_unknown: Int = 0
pub val SVGAngle::svg_angletype_unspecified: Int = 1
pub val SVGAngle::svg_angletype_deg: Int = 2
pub val SVGAngle::svg_angletype_rad: Int = 3
pub val SVGAngle::svg_angletype_grad: Int = 4

struct SVGAnimateElement()

/// Converts a reference to 'SVGAnimateElement' to a reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_svg_animation_element(self: SVGAnimateElement) -> SVGAnimationElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateElement' to a mutable reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_msvg_animation_element(self: mut SVGAnimateElement) -> mut SVGAnimationElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGAnimationElement' to a reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_svg_animation_element(base: SVGAnimationElement) -> SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGAnimationElement' to a mutable reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_msvg_animation_element(base: mut SVGAnimationElement) -> mut SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateElement'!\");
"

/// Converts a reference to 'SVGAnimateElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_svg_element(self: SVGAnimateElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_msvg_element(self: mut SVGAnimateElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_svg_element(base: SVGElement) -> SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_msvg_element(base: mut SVGElement) -> mut SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateElement'!\");
"

/// Converts a reference to 'SVGAnimateElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_element(self: SVGAnimateElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::as_melement(self: mut SVGAnimateElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_element(base: Element) -> SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGAnimateElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateElement::from_melement(base: mut Element) -> mut SVGAnimateElement = "
    if(#var(base) instanceof SVGAnimateElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateElement'!\");
"

pub ext fun SVGAnimateElement::target_element(self: SVGAnimateElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).targetElement);"

pub ext fun SVGAnimateElement::onbegin(self: SVGAnimateElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbegin);"

pub ext fun SVGAnimateElement::set_onbegin(self: mut SVGAnimateElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbegin = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateElement::onend(self: SVGAnimateElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onend);"

pub ext fun SVGAnimateElement::set_onend(self: mut SVGAnimateElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateElement::onrepeat(self: SVGAnimateElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrepeat);"

pub ext fun SVGAnimateElement::set_onrepeat(self: mut SVGAnimateElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrepeat = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateElement::class_name(self: SVGAnimateElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGAnimateElement::owner_svg_element(self: SVGAnimateElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGAnimateElement::viewport_element(self: SVGAnimateElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGAnimateElement::get_start_time(__self: mut SVGAnimateElement) -> Float = "
    const r = #var(__self).getStartTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateElement::get_current_time(__self: mut SVGAnimateElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateElement::get_simple_duration(__self: mut SVGAnimateElement) -> Float = "
    const r = #var(__self).getSimpleDuration();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateElement::begin_element(__self: mut SVGAnimateElement) -> Unit = "
    const r = #var(__self).beginElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateElement::begin_element_at(__self: mut SVGAnimateElement, offset: Float) -> Unit = "
    const r = #var(__self).beginElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateElement::end_element(__self: mut SVGAnimateElement) -> Unit = "
    const r = #var(__self).endElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateElement::end_element_at(__self: mut SVGAnimateElement, offset: Float) -> Unit = "
    const r = #var(__self).endElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateElement::start_view_transition(__self: mut SVGAnimateElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateElement::start_view_transition_f_prom_unit(__self: mut SVGAnimateElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateElement::start_view_transition_mview_transition_options(__self: mut SVGAnimateElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGAnimateElement::as_js(self: SVGAnimateElement) -> JsValue = JsValue::unsafe_from[SVGAnimateElement](self)

pub fun SVGAnimateElement::from_js(v: JsValue) -> mut SVGAnimateElement = JsValue::unsafe_as[mut SVGAnimateElement](v)

struct SVGAnimateMotionElement()

/// Converts a reference to 'SVGAnimateMotionElement' to a reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_svg_animation_element(self: SVGAnimateMotionElement) -> SVGAnimationElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateMotionElement' to a mutable reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_msvg_animation_element(self: mut SVGAnimateMotionElement) -> mut SVGAnimationElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGAnimationElement' to a reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_svg_animation_element(base: SVGAnimationElement) -> SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateMotionElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGAnimationElement' to a mutable reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_msvg_animation_element(base: mut SVGAnimationElement) -> mut SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateMotionElement'!\");
"

/// Converts a reference to 'SVGAnimateMotionElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_svg_element(self: SVGAnimateMotionElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateMotionElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_msvg_element(self: mut SVGAnimateMotionElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_svg_element(base: SVGElement) -> SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateMotionElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_msvg_element(base: mut SVGElement) -> mut SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateMotionElement'!\");
"

/// Converts a reference to 'SVGAnimateMotionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_element(self: SVGAnimateMotionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateMotionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::as_melement(self: mut SVGAnimateMotionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_element(base: Element) -> SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateMotionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGAnimateMotionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateMotionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateMotionElement::from_melement(base: mut Element) -> mut SVGAnimateMotionElement = "
    if(#var(base) instanceof SVGAnimateMotionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateMotionElement'!\");
"

pub ext fun SVGAnimateMotionElement::target_element(self: SVGAnimateMotionElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).targetElement);"

pub ext fun SVGAnimateMotionElement::onbegin(self: SVGAnimateMotionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbegin);"

pub ext fun SVGAnimateMotionElement::set_onbegin(self: mut SVGAnimateMotionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbegin = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateMotionElement::onend(self: SVGAnimateMotionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onend);"

pub ext fun SVGAnimateMotionElement::set_onend(self: mut SVGAnimateMotionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateMotionElement::onrepeat(self: SVGAnimateMotionElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrepeat);"

pub ext fun SVGAnimateMotionElement::set_onrepeat(self: mut SVGAnimateMotionElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrepeat = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateMotionElement::class_name(self: SVGAnimateMotionElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGAnimateMotionElement::owner_svg_element(self: SVGAnimateMotionElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGAnimateMotionElement::viewport_element(self: SVGAnimateMotionElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGAnimateMotionElement::get_start_time(__self: mut SVGAnimateMotionElement) -> Float = "
    const r = #var(__self).getStartTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::get_current_time(__self: mut SVGAnimateMotionElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::get_simple_duration(__self: mut SVGAnimateMotionElement) -> Float = "
    const r = #var(__self).getSimpleDuration();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::begin_element(__self: mut SVGAnimateMotionElement) -> Unit = "
    const r = #var(__self).beginElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::begin_element_at(__self: mut SVGAnimateMotionElement, offset: Float) -> Unit = "
    const r = #var(__self).beginElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::end_element(__self: mut SVGAnimateMotionElement) -> Unit = "
    const r = #var(__self).endElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::end_element_at(__self: mut SVGAnimateMotionElement, offset: Float) -> Unit = "
    const r = #var(__self).endElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::start_view_transition(__self: mut SVGAnimateMotionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::start_view_transition_f_prom_unit(__self: mut SVGAnimateMotionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateMotionElement::start_view_transition_mview_transition_options(__self: mut SVGAnimateMotionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGAnimateMotionElement::as_js(self: SVGAnimateMotionElement) -> JsValue = JsValue::unsafe_from[SVGAnimateMotionElement](self)

pub fun SVGAnimateMotionElement::from_js(v: JsValue) -> mut SVGAnimateMotionElement = JsValue::unsafe_as[mut SVGAnimateMotionElement](v)

struct SVGAnimateTransformElement()

/// Converts a reference to 'SVGAnimateTransformElement' to a reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_svg_animation_element(self: SVGAnimateTransformElement) -> SVGAnimationElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateTransformElement' to a mutable reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_msvg_animation_element(self: mut SVGAnimateTransformElement) -> mut SVGAnimationElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGAnimationElement' to a reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_svg_animation_element(base: SVGAnimationElement) -> SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateTransformElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGAnimationElement' to a mutable reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_msvg_animation_element(base: mut SVGAnimationElement) -> mut SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGAnimateTransformElement'!\");
"

/// Converts a reference to 'SVGAnimateTransformElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_svg_element(self: SVGAnimateTransformElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateTransformElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_msvg_element(self: mut SVGAnimateTransformElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_svg_element(base: SVGElement) -> SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateTransformElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_msvg_element(base: mut SVGElement) -> mut SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimateTransformElement'!\");
"

/// Converts a reference to 'SVGAnimateTransformElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_element(self: SVGAnimateTransformElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimateTransformElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::as_melement(self: mut SVGAnimateTransformElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_element(base: Element) -> SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateTransformElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGAnimateTransformElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimateTransformElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimateTransformElement::from_melement(base: mut Element) -> mut SVGAnimateTransformElement = "
    if(#var(base) instanceof SVGAnimateTransformElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimateTransformElement'!\");
"

pub ext fun SVGAnimateTransformElement::target_element(self: SVGAnimateTransformElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).targetElement);"

pub ext fun SVGAnimateTransformElement::onbegin(self: SVGAnimateTransformElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbegin);"

pub ext fun SVGAnimateTransformElement::set_onbegin(self: mut SVGAnimateTransformElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbegin = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateTransformElement::onend(self: SVGAnimateTransformElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onend);"

pub ext fun SVGAnimateTransformElement::set_onend(self: mut SVGAnimateTransformElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateTransformElement::onrepeat(self: SVGAnimateTransformElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrepeat);"

pub ext fun SVGAnimateTransformElement::set_onrepeat(self: mut SVGAnimateTransformElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrepeat = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimateTransformElement::class_name(self: SVGAnimateTransformElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGAnimateTransformElement::owner_svg_element(self: SVGAnimateTransformElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGAnimateTransformElement::viewport_element(self: SVGAnimateTransformElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGAnimateTransformElement::get_start_time(__self: mut SVGAnimateTransformElement) -> Float = "
    const r = #var(__self).getStartTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::get_current_time(__self: mut SVGAnimateTransformElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::get_simple_duration(__self: mut SVGAnimateTransformElement) -> Float = "
    const r = #var(__self).getSimpleDuration();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::begin_element(__self: mut SVGAnimateTransformElement) -> Unit = "
    const r = #var(__self).beginElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::begin_element_at(__self: mut SVGAnimateTransformElement, offset: Float) -> Unit = "
    const r = #var(__self).beginElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::end_element(__self: mut SVGAnimateTransformElement) -> Unit = "
    const r = #var(__self).endElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::end_element_at(__self: mut SVGAnimateTransformElement, offset: Float) -> Unit = "
    const r = #var(__self).endElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::start_view_transition(__self: mut SVGAnimateTransformElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::start_view_transition_f_prom_unit(__self: mut SVGAnimateTransformElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimateTransformElement::start_view_transition_mview_transition_options(__self: mut SVGAnimateTransformElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGAnimateTransformElement::as_js(self: SVGAnimateTransformElement) -> JsValue = JsValue::unsafe_from[SVGAnimateTransformElement](self)

pub fun SVGAnimateTransformElement::from_js(v: JsValue) -> mut SVGAnimateTransformElement = JsValue::unsafe_as[mut SVGAnimateTransformElement](v)

struct SVGAnimatedAngle()

pub ext fun SVGAnimatedAngle::base_val(self: SVGAnimatedAngle) -> mut SVGAngle
    = "return #fun(SVGAngle::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedAngle::anim_val(self: SVGAnimatedAngle) -> mut SVGAngle
    = "return #fun(SVGAngle::from_js)(#var(self).animVal);"

pub fun SVGAnimatedAngle::as_js(self: SVGAnimatedAngle) -> JsValue = JsValue::unsafe_from[SVGAnimatedAngle](self)

pub fun SVGAnimatedAngle::from_js(v: JsValue) -> mut SVGAnimatedAngle = JsValue::unsafe_as[mut SVGAnimatedAngle](v)

struct SVGAnimatedBoolean()

pub ext fun SVGAnimatedBoolean::base_val(self: SVGAnimatedBoolean) -> Bool
    = "return #fun(Bool::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedBoolean::set_base_val(self: mut SVGAnimatedBoolean, value: Bool)
    = "#var(self).baseVal = #fun(Bool::as_js)(#var(value));"

pub ext fun SVGAnimatedBoolean::anim_val(self: SVGAnimatedBoolean) -> Bool
    = "return #fun(Bool::from_js)(#var(self).animVal);"

pub fun SVGAnimatedBoolean::as_js(self: SVGAnimatedBoolean) -> JsValue = JsValue::unsafe_from[SVGAnimatedBoolean](self)

pub fun SVGAnimatedBoolean::from_js(v: JsValue) -> mut SVGAnimatedBoolean = JsValue::unsafe_as[mut SVGAnimatedBoolean](v)

struct SVGAnimatedEnumeration()

pub ext fun SVGAnimatedEnumeration::base_val(self: SVGAnimatedEnumeration) -> Int
    = "return #fun(Int::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedEnumeration::set_base_val(self: mut SVGAnimatedEnumeration, value: Int)
    = "#var(self).baseVal = #fun(Int::as_js)(#var(value));"

pub ext fun SVGAnimatedEnumeration::anim_val(self: SVGAnimatedEnumeration) -> Int
    = "return #fun(Int::from_js)(#var(self).animVal);"

pub fun SVGAnimatedEnumeration::as_js(self: SVGAnimatedEnumeration) -> JsValue = JsValue::unsafe_from[SVGAnimatedEnumeration](self)

pub fun SVGAnimatedEnumeration::from_js(v: JsValue) -> mut SVGAnimatedEnumeration = JsValue::unsafe_as[mut SVGAnimatedEnumeration](v)

struct SVGAnimatedInteger()

pub ext fun SVGAnimatedInteger::base_val(self: SVGAnimatedInteger) -> Int
    = "return #fun(Int::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedInteger::set_base_val(self: mut SVGAnimatedInteger, value: Int)
    = "#var(self).baseVal = #fun(Int::as_js)(#var(value));"

pub ext fun SVGAnimatedInteger::anim_val(self: SVGAnimatedInteger) -> Int
    = "return #fun(Int::from_js)(#var(self).animVal);"

pub fun SVGAnimatedInteger::as_js(self: SVGAnimatedInteger) -> JsValue = JsValue::unsafe_from[SVGAnimatedInteger](self)

pub fun SVGAnimatedInteger::from_js(v: JsValue) -> mut SVGAnimatedInteger = JsValue::unsafe_as[mut SVGAnimatedInteger](v)

struct SVGAnimatedLength()

pub ext fun SVGAnimatedLength::base_val(self: SVGAnimatedLength) -> mut SVGLength
    = "return #fun(SVGLength::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedLength::anim_val(self: SVGAnimatedLength) -> mut SVGLength
    = "return #fun(SVGLength::from_js)(#var(self).animVal);"

pub fun SVGAnimatedLength::as_js(self: SVGAnimatedLength) -> JsValue = JsValue::unsafe_from[SVGAnimatedLength](self)

pub fun SVGAnimatedLength::from_js(v: JsValue) -> mut SVGAnimatedLength = JsValue::unsafe_as[mut SVGAnimatedLength](v)

struct SVGAnimatedLengthList()

pub ext fun SVGAnimatedLengthList::base_val(self: SVGAnimatedLengthList) -> mut SVGLengthList
    = "return #fun(SVGLengthList::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedLengthList::anim_val(self: SVGAnimatedLengthList) -> mut SVGLengthList
    = "return #fun(SVGLengthList::from_js)(#var(self).animVal);"

pub fun SVGAnimatedLengthList::as_js(self: SVGAnimatedLengthList) -> JsValue = JsValue::unsafe_from[SVGAnimatedLengthList](self)

pub fun SVGAnimatedLengthList::from_js(v: JsValue) -> mut SVGAnimatedLengthList = JsValue::unsafe_as[mut SVGAnimatedLengthList](v)

struct SVGAnimatedNumber()

pub ext fun SVGAnimatedNumber::base_val(self: SVGAnimatedNumber) -> Float
    = "return #fun(Float::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedNumber::set_base_val(self: mut SVGAnimatedNumber, value: Float)
    = "#var(self).baseVal = #fun(Float::as_js)(#var(value));"

pub ext fun SVGAnimatedNumber::anim_val(self: SVGAnimatedNumber) -> Float
    = "return #fun(Float::from_js)(#var(self).animVal);"

pub fun SVGAnimatedNumber::as_js(self: SVGAnimatedNumber) -> JsValue = JsValue::unsafe_from[SVGAnimatedNumber](self)

pub fun SVGAnimatedNumber::from_js(v: JsValue) -> mut SVGAnimatedNumber = JsValue::unsafe_as[mut SVGAnimatedNumber](v)

struct SVGAnimatedNumberList()

pub ext fun SVGAnimatedNumberList::base_val(self: SVGAnimatedNumberList) -> mut SVGNumberList
    = "return #fun(SVGNumberList::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedNumberList::anim_val(self: SVGAnimatedNumberList) -> mut SVGNumberList
    = "return #fun(SVGNumberList::from_js)(#var(self).animVal);"

pub fun SVGAnimatedNumberList::as_js(self: SVGAnimatedNumberList) -> JsValue = JsValue::unsafe_from[SVGAnimatedNumberList](self)

pub fun SVGAnimatedNumberList::from_js(v: JsValue) -> mut SVGAnimatedNumberList = JsValue::unsafe_as[mut SVGAnimatedNumberList](v)

struct SVGAnimatedPreserveAspectRatio()

pub ext fun SVGAnimatedPreserveAspectRatio::base_val(self: SVGAnimatedPreserveAspectRatio) -> mut SVGPreserveAspectRatio
    = "return #fun(SVGPreserveAspectRatio::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedPreserveAspectRatio::anim_val(self: SVGAnimatedPreserveAspectRatio) -> mut SVGPreserveAspectRatio
    = "return #fun(SVGPreserveAspectRatio::from_js)(#var(self).animVal);"

pub fun SVGAnimatedPreserveAspectRatio::as_js(self: SVGAnimatedPreserveAspectRatio) -> JsValue = JsValue::unsafe_from[SVGAnimatedPreserveAspectRatio](self)

pub fun SVGAnimatedPreserveAspectRatio::from_js(v: JsValue) -> mut SVGAnimatedPreserveAspectRatio = JsValue::unsafe_as[mut SVGAnimatedPreserveAspectRatio](v)

struct SVGAnimatedRect()

pub ext fun SVGAnimatedRect::base_val(self: SVGAnimatedRect) -> mut SVGRect
    = "return #fun(SVGRect::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedRect::anim_val(self: SVGAnimatedRect) -> mut SVGRect
    = "return #fun(SVGRect::from_js)(#var(self).animVal);"

pub fun SVGAnimatedRect::as_js(self: SVGAnimatedRect) -> JsValue = JsValue::unsafe_from[SVGAnimatedRect](self)

pub fun SVGAnimatedRect::from_js(v: JsValue) -> mut SVGAnimatedRect = JsValue::unsafe_as[mut SVGAnimatedRect](v)

struct SVGAnimatedString()

pub ext fun SVGAnimatedString::base_val(self: SVGAnimatedString) -> JsValue
    = "return #var(self).baseVal;"

pub ext fun SVGAnimatedString::set_base_val(self: mut SVGAnimatedString, value: JsValue)
    = "#var(self).baseVal = #var(value);"

pub ext fun SVGAnimatedString::anim_val(self: SVGAnimatedString) -> String
    = "return #fun(String::from_js)(#var(self).animVal);"

pub fun SVGAnimatedString::as_js(self: SVGAnimatedString) -> JsValue = JsValue::unsafe_from[SVGAnimatedString](self)

pub fun SVGAnimatedString::from_js(v: JsValue) -> mut SVGAnimatedString = JsValue::unsafe_as[mut SVGAnimatedString](v)

struct SVGAnimatedTransformList()

pub ext fun SVGAnimatedTransformList::base_val(self: SVGAnimatedTransformList) -> mut SVGTransformList
    = "return #fun(SVGTransformList::from_js)(#var(self).baseVal);"

pub ext fun SVGAnimatedTransformList::anim_val(self: SVGAnimatedTransformList) -> mut SVGTransformList
    = "return #fun(SVGTransformList::from_js)(#var(self).animVal);"

pub fun SVGAnimatedTransformList::as_js(self: SVGAnimatedTransformList) -> JsValue = JsValue::unsafe_from[SVGAnimatedTransformList](self)

pub fun SVGAnimatedTransformList::from_js(v: JsValue) -> mut SVGAnimatedTransformList = JsValue::unsafe_as[mut SVGAnimatedTransformList](v)

struct SVGAnimationElement()

/// Converts a reference to 'SVGAnimationElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::as_svg_element(self: SVGAnimationElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimationElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::as_msvg_element(self: mut SVGAnimationElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGAnimationElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimationElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::from_svg_element(base: SVGElement) -> SVGAnimationElement = "
    if(#var(base) instanceof SVGAnimationElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimationElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGAnimationElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimationElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::from_msvg_element(base: mut SVGElement) -> mut SVGAnimationElement = "
    if(#var(base) instanceof SVGAnimationElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGAnimationElement'!\");
"

/// Converts a reference to 'SVGAnimationElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::as_element(self: SVGAnimationElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGAnimationElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::as_melement(self: mut SVGAnimationElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGAnimationElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimationElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::from_element(base: Element) -> SVGAnimationElement = "
    if(#var(base) instanceof SVGAnimationElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimationElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGAnimationElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGAnimationElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGAnimationElement::from_melement(base: mut Element) -> mut SVGAnimationElement = "
    if(#var(base) instanceof SVGAnimationElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGAnimationElement'!\");
"

pub ext fun SVGAnimationElement::target_element(self: SVGAnimationElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).targetElement);"

pub ext fun SVGAnimationElement::onbegin(self: SVGAnimationElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbegin);"

pub ext fun SVGAnimationElement::set_onbegin(self: mut SVGAnimationElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbegin = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimationElement::onend(self: SVGAnimationElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onend);"

pub ext fun SVGAnimationElement::set_onend(self: mut SVGAnimationElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimationElement::onrepeat(self: SVGAnimationElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrepeat);"

pub ext fun SVGAnimationElement::set_onrepeat(self: mut SVGAnimationElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrepeat = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGAnimationElement::class_name(self: SVGAnimationElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGAnimationElement::owner_svg_element(self: SVGAnimationElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGAnimationElement::viewport_element(self: SVGAnimationElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGAnimationElement::required_extensions(self: SVGAnimationElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).requiredExtensions);"

pub ext fun SVGAnimationElement::system_language(self: SVGAnimationElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).systemLanguage);"

pub ext fun SVGAnimationElement::get_start_time(__self: mut SVGAnimationElement) -> Float = "
    const r = #var(__self).getStartTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimationElement::get_current_time(__self: mut SVGAnimationElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimationElement::get_simple_duration(__self: mut SVGAnimationElement) -> Float = "
    const r = #var(__self).getSimpleDuration();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGAnimationElement::begin_element(__self: mut SVGAnimationElement) -> Unit = "
    const r = #var(__self).beginElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimationElement::begin_element_at(__self: mut SVGAnimationElement, offset: Float) -> Unit = "
    const r = #var(__self).beginElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimationElement::end_element(__self: mut SVGAnimationElement) -> Unit = "
    const r = #var(__self).endElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimationElement::end_element_at(__self: mut SVGAnimationElement, offset: Float) -> Unit = "
    const r = #var(__self).endElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGAnimationElement::start_view_transition(__self: mut SVGAnimationElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimationElement::start_view_transition_f_prom_unit(__self: mut SVGAnimationElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGAnimationElement::start_view_transition_mview_transition_options(__self: mut SVGAnimationElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGAnimationElement::as_js(self: SVGAnimationElement) -> JsValue = JsValue::unsafe_from[SVGAnimationElement](self)

pub fun SVGAnimationElement::from_js(v: JsValue) -> mut SVGAnimationElement = JsValue::unsafe_as[mut SVGAnimationElement](v)

struct SVGCircleElement()

/// Converts a reference to 'SVGCircleElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_svg_geometry_element(self: SVGCircleElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGCircleElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_msvg_geometry_element(self: mut SVGCircleElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGCircleElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGCircleElement'!\");
"

/// Converts a reference to 'SVGCircleElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_svg_graphics_element(self: SVGCircleElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGCircleElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_msvg_graphics_element(self: mut SVGCircleElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGCircleElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGCircleElement'!\");
"

/// Converts a reference to 'SVGCircleElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_svg_element(self: SVGCircleElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGCircleElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_msvg_element(self: mut SVGCircleElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_svg_element(base: SVGElement) -> SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGCircleElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_msvg_element(base: mut SVGElement) -> mut SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGCircleElement'!\");
"

/// Converts a reference to 'SVGCircleElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_element(self: SVGCircleElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGCircleElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::as_melement(self: mut SVGCircleElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_element(base: Element) -> SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGCircleElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGCircleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGCircleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGCircleElement::from_melement(base: mut Element) -> mut SVGCircleElement = "
    if(#var(base) instanceof SVGCircleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGCircleElement'!\");
"

pub ext fun SVGCircleElement::cx(self: SVGCircleElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cx);"

pub ext fun SVGCircleElement::cy(self: SVGCircleElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cy);"

pub ext fun SVGCircleElement::r(self: SVGCircleElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).r);"

pub ext fun SVGCircleElement::path_length(self: SVGCircleElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGCircleElement::transform(self: SVGCircleElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGCircleElement::nearest_viewport_element(self: SVGCircleElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGCircleElement::farthest_viewport_element(self: SVGCircleElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGCircleElement::class_name(self: SVGCircleElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGCircleElement::owner_svg_element(self: SVGCircleElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGCircleElement::viewport_element(self: SVGCircleElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGCircleElement::is_point_in_fill(__self: mut SVGCircleElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGCircleElement::is_point_in_stroke(__self: mut SVGCircleElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGCircleElement::get_total_length(__self: mut SVGCircleElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGCircleElement::get_point_at_length(__self: mut SVGCircleElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGCircleElement::get_b_box(__self: mut SVGCircleElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGCircleElement::get_ctm(__self: mut SVGCircleElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGCircleElement::get_screen_ctm(__self: mut SVGCircleElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGCircleElement::start_view_transition(__self: mut SVGCircleElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGCircleElement::start_view_transition_f_prom_unit(__self: mut SVGCircleElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGCircleElement::start_view_transition_mview_transition_options(__self: mut SVGCircleElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGCircleElement::as_js(self: SVGCircleElement) -> JsValue = JsValue::unsafe_from[SVGCircleElement](self)

pub fun SVGCircleElement::from_js(v: JsValue) -> mut SVGCircleElement = JsValue::unsafe_as[mut SVGCircleElement](v)

struct SVGClipPathElement()

/// Converts a reference to 'SVGClipPathElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::as_svg_element(self: SVGClipPathElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGClipPathElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::as_msvg_element(self: mut SVGClipPathElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGClipPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGClipPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::from_svg_element(base: SVGElement) -> SVGClipPathElement = "
    if(#var(base) instanceof SVGClipPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGClipPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGClipPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGClipPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::from_msvg_element(base: mut SVGElement) -> mut SVGClipPathElement = "
    if(#var(base) instanceof SVGClipPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGClipPathElement'!\");
"

/// Converts a reference to 'SVGClipPathElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::as_element(self: SVGClipPathElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGClipPathElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::as_melement(self: mut SVGClipPathElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGClipPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGClipPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::from_element(base: Element) -> SVGClipPathElement = "
    if(#var(base) instanceof SVGClipPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGClipPathElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGClipPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGClipPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGClipPathElement::from_melement(base: mut Element) -> mut SVGClipPathElement = "
    if(#var(base) instanceof SVGClipPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGClipPathElement'!\");
"

pub ext fun SVGClipPathElement::clip_path_units(self: SVGClipPathElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).clipPathUnits);"

pub ext fun SVGClipPathElement::transform(self: SVGClipPathElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGClipPathElement::class_name(self: SVGClipPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGClipPathElement::owner_svg_element(self: SVGClipPathElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGClipPathElement::viewport_element(self: SVGClipPathElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGClipPathElement::start_view_transition(__self: mut SVGClipPathElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGClipPathElement::start_view_transition_f_prom_unit(__self: mut SVGClipPathElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGClipPathElement::start_view_transition_mview_transition_options(__self: mut SVGClipPathElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGClipPathElement::as_js(self: SVGClipPathElement) -> JsValue = JsValue::unsafe_from[SVGClipPathElement](self)

pub fun SVGClipPathElement::from_js(v: JsValue) -> mut SVGClipPathElement = JsValue::unsafe_as[mut SVGClipPathElement](v)

struct SVGComponentTransferFunctionElement()

/// Converts a reference to 'SVGComponentTransferFunctionElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::as_svg_element(self: SVGComponentTransferFunctionElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::as_msvg_element(self: mut SVGComponentTransferFunctionElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGComponentTransferFunctionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGComponentTransferFunctionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::from_svg_element(base: SVGElement) -> SVGComponentTransferFunctionElement = "
    if(#var(base) instanceof SVGComponentTransferFunctionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGComponentTransferFunctionElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGComponentTransferFunctionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::from_msvg_element(base: mut SVGElement) -> mut SVGComponentTransferFunctionElement = "
    if(#var(base) instanceof SVGComponentTransferFunctionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGComponentTransferFunctionElement'!\");
"

/// Converts a reference to 'SVGComponentTransferFunctionElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::as_element(self: SVGComponentTransferFunctionElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::as_melement(self: mut SVGComponentTransferFunctionElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGComponentTransferFunctionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGComponentTransferFunctionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::from_element(base: Element) -> SVGComponentTransferFunctionElement = "
    if(#var(base) instanceof SVGComponentTransferFunctionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGComponentTransferFunctionElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGComponentTransferFunctionElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGComponentTransferFunctionElement::from_melement(base: mut Element) -> mut SVGComponentTransferFunctionElement = "
    if(#var(base) instanceof SVGComponentTransferFunctionElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGComponentTransferFunctionElement'!\");
"

pub ext fun SVGComponentTransferFunctionElement::type(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGComponentTransferFunctionElement::table_values(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).tableValues);"

pub ext fun SVGComponentTransferFunctionElement::slope(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).slope);"

pub ext fun SVGComponentTransferFunctionElement::intercept(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).intercept);"

pub ext fun SVGComponentTransferFunctionElement::amplitude(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).amplitude);"

pub ext fun SVGComponentTransferFunctionElement::exponent(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).exponent);"

pub ext fun SVGComponentTransferFunctionElement::offset(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGComponentTransferFunctionElement::class_name(self: SVGComponentTransferFunctionElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGComponentTransferFunctionElement::owner_svg_element(self: SVGComponentTransferFunctionElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGComponentTransferFunctionElement::viewport_element(self: SVGComponentTransferFunctionElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGComponentTransferFunctionElement::start_view_transition(__self: mut SVGComponentTransferFunctionElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGComponentTransferFunctionElement::start_view_transition_f_prom_unit(__self: mut SVGComponentTransferFunctionElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGComponentTransferFunctionElement::start_view_transition_mview_transition_options(__self: mut SVGComponentTransferFunctionElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGComponentTransferFunctionElement::as_js(self: SVGComponentTransferFunctionElement) -> JsValue = JsValue::unsafe_from[SVGComponentTransferFunctionElement](self)

pub fun SVGComponentTransferFunctionElement::from_js(v: JsValue) -> mut SVGComponentTransferFunctionElement = JsValue::unsafe_as[mut SVGComponentTransferFunctionElement](v)

pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_unknown: Int = 0
pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_identity: Int = 1
pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_table: Int = 2
pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_discrete: Int = 3
pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_linear: Int = 4
pub val SVGComponentTransferFunctionElement::svg_fecomponenttransfer_type_gamma: Int = 5

struct SVGDefsElement()

/// Converts a reference to 'SVGDefsElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_svg_graphics_element(self: SVGDefsElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGDefsElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_msvg_graphics_element(self: mut SVGDefsElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGDefsElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGDefsElement'!\");
"

/// Converts a reference to 'SVGDefsElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_svg_element(self: SVGDefsElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGDefsElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_msvg_element(self: mut SVGDefsElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_svg_element(base: SVGElement) -> SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGDefsElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_msvg_element(base: mut SVGElement) -> mut SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGDefsElement'!\");
"

/// Converts a reference to 'SVGDefsElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_element(self: SVGDefsElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGDefsElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::as_melement(self: mut SVGDefsElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_element(base: Element) -> SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGDefsElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGDefsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDefsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDefsElement::from_melement(base: mut Element) -> mut SVGDefsElement = "
    if(#var(base) instanceof SVGDefsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGDefsElement'!\");
"

pub ext fun SVGDefsElement::transform(self: SVGDefsElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGDefsElement::nearest_viewport_element(self: SVGDefsElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGDefsElement::farthest_viewport_element(self: SVGDefsElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGDefsElement::class_name(self: SVGDefsElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGDefsElement::owner_svg_element(self: SVGDefsElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGDefsElement::viewport_element(self: SVGDefsElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGDefsElement::get_b_box(__self: mut SVGDefsElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGDefsElement::get_ctm(__self: mut SVGDefsElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGDefsElement::get_screen_ctm(__self: mut SVGDefsElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGDefsElement::start_view_transition(__self: mut SVGDefsElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGDefsElement::start_view_transition_f_prom_unit(__self: mut SVGDefsElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGDefsElement::start_view_transition_mview_transition_options(__self: mut SVGDefsElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGDefsElement::as_js(self: SVGDefsElement) -> JsValue = JsValue::unsafe_from[SVGDefsElement](self)

pub fun SVGDefsElement::from_js(v: JsValue) -> mut SVGDefsElement = JsValue::unsafe_as[mut SVGDefsElement](v)

struct SVGDescElement()

/// Converts a reference to 'SVGDescElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::as_svg_element(self: SVGDescElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGDescElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::as_msvg_element(self: mut SVGDescElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGDescElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDescElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::from_svg_element(base: SVGElement) -> SVGDescElement = "
    if(#var(base) instanceof SVGDescElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGDescElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGDescElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDescElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::from_msvg_element(base: mut SVGElement) -> mut SVGDescElement = "
    if(#var(base) instanceof SVGDescElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGDescElement'!\");
"

/// Converts a reference to 'SVGDescElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::as_element(self: SVGDescElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGDescElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::as_melement(self: mut SVGDescElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGDescElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDescElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::from_element(base: Element) -> SVGDescElement = "
    if(#var(base) instanceof SVGDescElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGDescElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGDescElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGDescElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGDescElement::from_melement(base: mut Element) -> mut SVGDescElement = "
    if(#var(base) instanceof SVGDescElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGDescElement'!\");
"

pub ext fun SVGDescElement::class_name(self: SVGDescElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGDescElement::owner_svg_element(self: SVGDescElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGDescElement::viewport_element(self: SVGDescElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGDescElement::start_view_transition(__self: mut SVGDescElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGDescElement::start_view_transition_f_prom_unit(__self: mut SVGDescElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGDescElement::start_view_transition_mview_transition_options(__self: mut SVGDescElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGDescElement::as_js(self: SVGDescElement) -> JsValue = JsValue::unsafe_from[SVGDescElement](self)

pub fun SVGDescElement::from_js(v: JsValue) -> mut SVGDescElement = JsValue::unsafe_as[mut SVGDescElement](v)

pub ext fun Document::root_element(self: Document) -> mut SVGSVGElement
    = "return #fun(SVGSVGElement::from_js)(#var(self).rootElement);"

struct SVGElement()

/// Converts a reference to 'SVGElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGElement::as_element(self: SVGElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGElement::as_melement(self: mut SVGElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGElement::from_element(base: Element) -> SVGElement = "
    if(#var(base) instanceof SVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGElement::from_melement(base: mut Element) -> mut SVGElement = "
    if(#var(base) instanceof SVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGElement'!\");
"

pub ext fun SVGElement::class_name(self: SVGElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGElement::owner_svg_element(self: SVGElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGElement::viewport_element(self: SVGElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGElement::onabort(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun SVGElement::set_onabort(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onbeforeinput(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforeinput);"

pub ext fun SVGElement::set_onbeforeinput(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforeinput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onbeforematch(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforematch);"

pub ext fun SVGElement::set_onbeforematch(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforematch = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onbeforetoggle(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforetoggle);"

pub ext fun SVGElement::set_onbeforetoggle(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforetoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onblur(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onblur);"

pub ext fun SVGElement::set_onblur(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onblur = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncancel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncancel);"

pub ext fun SVGElement::set_oncancel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncanplay(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplay);"

pub ext fun SVGElement::set_oncanplay(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncanplaythrough(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncanplaythrough);"

pub ext fun SVGElement::set_oncanplaythrough(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncanplaythrough = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onchange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onchange);"

pub ext fun SVGElement::set_onchange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onclick(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclick);"

pub ext fun SVGElement::set_onclick(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onclose(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onclose);"

pub ext fun SVGElement::set_onclose(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onclose = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncommand(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncommand);"

pub ext fun SVGElement::set_oncommand(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncommand = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncontentvisibilityautostatechange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontentvisibilityautostatechange);"

pub ext fun SVGElement::set_oncontentvisibilityautostatechange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontentvisibilityautostatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncontextlost(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextlost);"

pub ext fun SVGElement::set_oncontextlost(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextlost = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncontextmenu(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextmenu);"

pub ext fun SVGElement::set_oncontextmenu(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextmenu = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncontextrestored(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncontextrestored);"

pub ext fun SVGElement::set_oncontextrestored(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncontextrestored = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncuechange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncuechange);"

pub ext fun SVGElement::set_oncuechange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncuechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondblclick(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondblclick);"

pub ext fun SVGElement::set_ondblclick(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondblclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondrag(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrag);"

pub ext fun SVGElement::set_ondrag(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrag = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondragend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragend);"

pub ext fun SVGElement::set_ondragend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondragenter(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragenter);"

pub ext fun SVGElement::set_ondragenter(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondragleave(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragleave);"

pub ext fun SVGElement::set_ondragleave(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondragover(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragover);"

pub ext fun SVGElement::set_ondragover(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondragstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondragstart);"

pub ext fun SVGElement::set_ondragstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondragstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondrop(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondrop);"

pub ext fun SVGElement::set_ondrop(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondrop = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ondurationchange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ondurationchange);"

pub ext fun SVGElement::set_ondurationchange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ondurationchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onemptied(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onemptied);"

pub ext fun SVGElement::set_onemptied(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onemptied = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onended(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onended);"

pub ext fun SVGElement::set_onended(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onended = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onerror(self: SVGElement) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun SVGElement::set_onerror(self: mut SVGElement, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onfencedtreeclick(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfencedtreeclick);"

pub ext fun SVGElement::set_onfencedtreeclick(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfencedtreeclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onfocus(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onfocus);"

pub ext fun SVGElement::set_onfocus(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onfocus = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onformdata(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onformdata);"

pub ext fun SVGElement::set_onformdata(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onformdata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oninput(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninput);"

pub ext fun SVGElement::set_oninput(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninput = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oninvalid(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oninvalid);"

pub ext fun SVGElement::set_oninvalid(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oninvalid = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onkeydown(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeydown);"

pub ext fun SVGElement::set_onkeydown(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeydown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onkeypress(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeypress);"

pub ext fun SVGElement::set_onkeypress(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeypress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onkeyup(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onkeyup);"

pub ext fun SVGElement::set_onkeyup(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onkeyup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onload(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun SVGElement::set_onload(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onloadeddata(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadeddata);"

pub ext fun SVGElement::set_onloadeddata(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadeddata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onloadedmetadata(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadedmetadata);"

pub ext fun SVGElement::set_onloadedmetadata(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadedmetadata = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onloadstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun SVGElement::set_onloadstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmousedown(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousedown);"

pub ext fun SVGElement::set_onmousedown(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousedown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmouseenter(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseenter);"

pub ext fun SVGElement::set_onmouseenter(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmouseleave(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseleave);"

pub ext fun SVGElement::set_onmouseleave(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmousemove(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousemove);"

pub ext fun SVGElement::set_onmousemove(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousemove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmouseout(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseout);"

pub ext fun SVGElement::set_onmouseout(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmouseover(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseover);"

pub ext fun SVGElement::set_onmouseover(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmouseup(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmouseup);"

pub ext fun SVGElement::set_onmouseup(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmouseup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onmousewheel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmousewheel);"

pub ext fun SVGElement::set_onmousewheel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmousewheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onoverscroll(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onoverscroll);"

pub ext fun SVGElement::set_onoverscroll(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onoverscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpause(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpause);"

pub ext fun SVGElement::set_onpause(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpause = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onplay(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplay);"

pub ext fun SVGElement::set_onplay(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplay = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onplaying(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onplaying);"

pub ext fun SVGElement::set_onplaying(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onplaying = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onprogress(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun SVGElement::set_onprogress(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onratechange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onratechange);"

pub ext fun SVGElement::set_onratechange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onratechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onreset(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreset);"

pub ext fun SVGElement::set_onreset(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreset = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onresize(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresize);"

pub ext fun SVGElement::set_onresize(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresize = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onscroll(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscroll);"

pub ext fun SVGElement::set_onscroll(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscroll = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onscrollend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollend);"

pub ext fun SVGElement::set_onscrollend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onsecuritypolicyviolation(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsecuritypolicyviolation);"

pub ext fun SVGElement::set_onsecuritypolicyviolation(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsecuritypolicyviolation = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onseeked(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeked);"

pub ext fun SVGElement::set_onseeked(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeked = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onseeking(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onseeking);"

pub ext fun SVGElement::set_onseeking(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onseeking = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onselect(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselect);"

pub ext fun SVGElement::set_onselect(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onslotchange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onslotchange);"

pub ext fun SVGElement::set_onslotchange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onslotchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onscrollsnapchange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchange);"

pub ext fun SVGElement::set_onscrollsnapchange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onscrollsnapchanging(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onscrollsnapchanging);"

pub ext fun SVGElement::set_onscrollsnapchanging(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onscrollsnapchanging = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onstalled(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onstalled);"

pub ext fun SVGElement::set_onstalled(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onstalled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onsubmit(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsubmit);"

pub ext fun SVGElement::set_onsubmit(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsubmit = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onsuspend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onsuspend);"

pub ext fun SVGElement::set_onsuspend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onsuspend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontimeupdate(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeupdate);"

pub ext fun SVGElement::set_ontimeupdate(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontoggle(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontoggle);"

pub ext fun SVGElement::set_ontoggle(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontoggle = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onvolumechange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onvolumechange);"

pub ext fun SVGElement::set_onvolumechange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onvolumechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwaiting(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwaiting);"

pub ext fun SVGElement::set_onwaiting(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwaiting = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwebkitanimationend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationend);"

pub ext fun SVGElement::set_onwebkitanimationend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwebkitanimationiteration(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationiteration);"

pub ext fun SVGElement::set_onwebkitanimationiteration(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwebkitanimationstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkitanimationstart);"

pub ext fun SVGElement::set_onwebkitanimationstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkitanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwebkittransitionend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwebkittransitionend);"

pub ext fun SVGElement::set_onwebkittransitionend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwebkittransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onwheel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onwheel);"

pub ext fun SVGElement::set_onwheel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onwheel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onauxclick(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onauxclick);"

pub ext fun SVGElement::set_onauxclick(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onauxclick = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ongotpointercapture(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ongotpointercapture);"

pub ext fun SVGElement::set_ongotpointercapture(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ongotpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onlostpointercapture(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlostpointercapture);"

pub ext fun SVGElement::set_onlostpointercapture(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlostpointercapture = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerdown(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerdown);"

pub ext fun SVGElement::set_onpointerdown(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerdown = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointermove(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointermove);"

pub ext fun SVGElement::set_onpointermove(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointermove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerrawupdate(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerrawupdate);"

pub ext fun SVGElement::set_onpointerrawupdate(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerrawupdate = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerup(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerup);"

pub ext fun SVGElement::set_onpointerup(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerup = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointercancel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointercancel);"

pub ext fun SVGElement::set_onpointercancel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointercancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerover(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerover);"

pub ext fun SVGElement::set_onpointerover(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerover = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerout(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerout);"

pub ext fun SVGElement::set_onpointerout(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerenter(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerenter);"

pub ext fun SVGElement::set_onpointerenter(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerenter = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpointerleave(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpointerleave);"

pub ext fun SVGElement::set_onpointerleave(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpointerleave = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontouchcancel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchcancel);"

pub ext fun SVGElement::set_ontouchcancel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchcancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontouchend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchend);"

pub ext fun SVGElement::set_ontouchend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontouchmove(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchmove);"

pub ext fun SVGElement::set_ontouchmove(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchmove = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontouchstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontouchstart);"

pub ext fun SVGElement::set_ontouchstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontouchstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onselectstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectstart);"

pub ext fun SVGElement::set_onselectstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onselectionchange(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onselectionchange);"

pub ext fun SVGElement::set_onselectionchange(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onselectionchange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onanimationend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationend);"

pub ext fun SVGElement::set_onanimationend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onanimationiteration(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationiteration);"

pub ext fun SVGElement::set_onanimationiteration(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationiteration = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onanimationstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onanimationstart);"

pub ext fun SVGElement::set_onanimationstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onanimationstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontransitionrun(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionrun);"

pub ext fun SVGElement::set_ontransitionrun(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionrun = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontransitionstart(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionstart);"

pub ext fun SVGElement::set_ontransitionstart(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontransitionend(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitionend);"

pub ext fun SVGElement::set_ontransitionend(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitionend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::ontransitioncancel(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontransitioncancel);"

pub ext fun SVGElement::set_ontransitioncancel(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontransitioncancel = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncopy(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncopy);"

pub ext fun SVGElement::set_oncopy(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncopy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::oncut(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).oncut);"

pub ext fun SVGElement::set_oncut(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).oncut = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::onpaste(self: SVGElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onpaste);"

pub ext fun SVGElement::set_onpaste(self: mut SVGElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onpaste = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGElement::dataset(self: SVGElement) -> mut DOMStringMap
    = "return #fun(DOMStringMap::from_js)(#var(self).dataset);"

pub ext fun SVGElement::nonce(self: SVGElement) -> String
    = "return #fun(String::from_js)(#var(self).nonce);"

pub ext fun SVGElement::set_nonce(self: mut SVGElement, value: String)
    = "#var(self).nonce = #fun(String::as_js)(#var(value));"

pub ext fun SVGElement::autofocus(self: SVGElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).autofocus);"

pub ext fun SVGElement::set_autofocus(self: mut SVGElement, value: Bool)
    = "#var(self).autofocus = #fun(Bool::as_js)(#var(value));"

pub ext fun SVGElement::tab_index(self: SVGElement) -> Int
    = "return #fun(Int::from_js)(#var(self).tabIndex);"

pub ext fun SVGElement::set_tab_index(self: mut SVGElement, value: Int)
    = "#var(self).tabIndex = #fun(Int::as_js)(#var(value));"

pub ext fun SVGElement::focusgroup(self: SVGElement) -> String
    = "return #fun(String::from_js)(#var(self).focusgroup);"

pub ext fun SVGElement::set_focusgroup(self: mut SVGElement, value: String)
    = "#var(self).focusgroup = #fun(String::as_js)(#var(value));"

pub ext fun SVGElement::style(self: SVGElement) -> mut CSSStyleDeclaration
    = "return #fun(CSSStyleDeclaration::from_js)(#var(self).style);"

pub ext fun SVGElement::attribute_style_map(self: SVGElement) -> mut StylePropertyMap
    = "return #fun(StylePropertyMap::from_js)(#var(self).attributeStyleMap);"

pub ext fun SVGElement::start_view_transition(__self: mut SVGElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGElement::start_view_transition_f_prom_unit(__self: mut SVGElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGElement::start_view_transition_mview_transition_options(__self: mut SVGElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGElement::focus(__self: mut SVGElement, options: mut FocusOptions) -> Unit = "
    const r = #var(__self).focus(#fun(FocusOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGElement::blur(__self: mut SVGElement) -> Unit = "
    const r = #var(__self).blur();
    return #fun(Unit::from_js)(r);
"

pub fun SVGElement::as_js(self: SVGElement) -> JsValue = JsValue::unsafe_from[SVGElement](self)

pub fun SVGElement::from_js(v: JsValue) -> mut SVGElement = JsValue::unsafe_as[mut SVGElement](v)

struct SVGEllipseElement()

/// Converts a reference to 'SVGEllipseElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_svg_geometry_element(self: SVGEllipseElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGEllipseElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_msvg_geometry_element(self: mut SVGEllipseElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGEllipseElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGEllipseElement'!\");
"

/// Converts a reference to 'SVGEllipseElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_svg_graphics_element(self: SVGEllipseElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGEllipseElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_msvg_graphics_element(self: mut SVGEllipseElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGEllipseElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGEllipseElement'!\");
"

/// Converts a reference to 'SVGEllipseElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_svg_element(self: SVGEllipseElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGEllipseElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_msvg_element(self: mut SVGEllipseElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_svg_element(base: SVGElement) -> SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGEllipseElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_msvg_element(base: mut SVGElement) -> mut SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGEllipseElement'!\");
"

/// Converts a reference to 'SVGEllipseElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_element(self: SVGEllipseElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGEllipseElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::as_melement(self: mut SVGEllipseElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_element(base: Element) -> SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGEllipseElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGEllipseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGEllipseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGEllipseElement::from_melement(base: mut Element) -> mut SVGEllipseElement = "
    if(#var(base) instanceof SVGEllipseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGEllipseElement'!\");
"

pub ext fun SVGEllipseElement::cx(self: SVGEllipseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cx);"

pub ext fun SVGEllipseElement::cy(self: SVGEllipseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cy);"

pub ext fun SVGEllipseElement::rx(self: SVGEllipseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).rx);"

pub ext fun SVGEllipseElement::ry(self: SVGEllipseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).ry);"

pub ext fun SVGEllipseElement::path_length(self: SVGEllipseElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGEllipseElement::transform(self: SVGEllipseElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGEllipseElement::nearest_viewport_element(self: SVGEllipseElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGEllipseElement::farthest_viewport_element(self: SVGEllipseElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGEllipseElement::class_name(self: SVGEllipseElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGEllipseElement::owner_svg_element(self: SVGEllipseElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGEllipseElement::viewport_element(self: SVGEllipseElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGEllipseElement::is_point_in_fill(__self: mut SVGEllipseElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGEllipseElement::is_point_in_stroke(__self: mut SVGEllipseElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGEllipseElement::get_total_length(__self: mut SVGEllipseElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGEllipseElement::get_point_at_length(__self: mut SVGEllipseElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGEllipseElement::get_b_box(__self: mut SVGEllipseElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGEllipseElement::get_ctm(__self: mut SVGEllipseElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGEllipseElement::get_screen_ctm(__self: mut SVGEllipseElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGEllipseElement::start_view_transition(__self: mut SVGEllipseElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGEllipseElement::start_view_transition_f_prom_unit(__self: mut SVGEllipseElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGEllipseElement::start_view_transition_mview_transition_options(__self: mut SVGEllipseElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGEllipseElement::as_js(self: SVGEllipseElement) -> JsValue = JsValue::unsafe_from[SVGEllipseElement](self)

pub fun SVGEllipseElement::from_js(v: JsValue) -> mut SVGEllipseElement = JsValue::unsafe_as[mut SVGEllipseElement](v)

struct SVGFEBlendElement()

/// Converts a reference to 'SVGFEBlendElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::as_svg_element(self: SVGFEBlendElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEBlendElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::as_msvg_element(self: mut SVGFEBlendElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEBlendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEBlendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::from_svg_element(base: SVGElement) -> SVGFEBlendElement = "
    if(#var(base) instanceof SVGFEBlendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEBlendElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEBlendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEBlendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEBlendElement = "
    if(#var(base) instanceof SVGFEBlendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEBlendElement'!\");
"

/// Converts a reference to 'SVGFEBlendElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::as_element(self: SVGFEBlendElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEBlendElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::as_melement(self: mut SVGFEBlendElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEBlendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEBlendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::from_element(base: Element) -> SVGFEBlendElement = "
    if(#var(base) instanceof SVGFEBlendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEBlendElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEBlendElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEBlendElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEBlendElement::from_melement(base: mut Element) -> mut SVGFEBlendElement = "
    if(#var(base) instanceof SVGFEBlendElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEBlendElement'!\");
"

pub ext fun SVGFEBlendElement::in_1(self: SVGFEBlendElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEBlendElement::in_2(self: SVGFEBlendElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in2);"

pub ext fun SVGFEBlendElement::mode(self: SVGFEBlendElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).mode);"

pub ext fun SVGFEBlendElement::class_name(self: SVGFEBlendElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEBlendElement::owner_svg_element(self: SVGFEBlendElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEBlendElement::viewport_element(self: SVGFEBlendElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEBlendElement::x(self: SVGFEBlendElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEBlendElement::y(self: SVGFEBlendElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEBlendElement::width(self: SVGFEBlendElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEBlendElement::height(self: SVGFEBlendElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEBlendElement::result(self: SVGFEBlendElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEBlendElement::start_view_transition(__self: mut SVGFEBlendElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEBlendElement::start_view_transition_f_prom_unit(__self: mut SVGFEBlendElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEBlendElement::start_view_transition_mview_transition_options(__self: mut SVGFEBlendElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEBlendElement::as_js(self: SVGFEBlendElement) -> JsValue = JsValue::unsafe_from[SVGFEBlendElement](self)

pub fun SVGFEBlendElement::from_js(v: JsValue) -> mut SVGFEBlendElement = JsValue::unsafe_as[mut SVGFEBlendElement](v)

pub val SVGFEBlendElement::svg_feblend_mode_unknown: Int = 0
pub val SVGFEBlendElement::svg_feblend_mode_normal: Int = 1
pub val SVGFEBlendElement::svg_feblend_mode_multiply: Int = 2
pub val SVGFEBlendElement::svg_feblend_mode_screen: Int = 3
pub val SVGFEBlendElement::svg_feblend_mode_darken: Int = 4
pub val SVGFEBlendElement::svg_feblend_mode_lighten: Int = 5
pub val SVGFEBlendElement::svg_feblend_mode_overlay: Int = 6
pub val SVGFEBlendElement::svg_feblend_mode_color_dodge: Int = 7
pub val SVGFEBlendElement::svg_feblend_mode_color_burn: Int = 8
pub val SVGFEBlendElement::svg_feblend_mode_hard_light: Int = 9
pub val SVGFEBlendElement::svg_feblend_mode_soft_light: Int = 10
pub val SVGFEBlendElement::svg_feblend_mode_difference: Int = 11
pub val SVGFEBlendElement::svg_feblend_mode_exclusion: Int = 12
pub val SVGFEBlendElement::svg_feblend_mode_hue: Int = 13
pub val SVGFEBlendElement::svg_feblend_mode_saturation: Int = 14
pub val SVGFEBlendElement::svg_feblend_mode_color: Int = 15
pub val SVGFEBlendElement::svg_feblend_mode_luminosity: Int = 16

struct SVGFEColorMatrixElement()

/// Converts a reference to 'SVGFEColorMatrixElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::as_svg_element(self: SVGFEColorMatrixElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEColorMatrixElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::as_msvg_element(self: mut SVGFEColorMatrixElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEColorMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEColorMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::from_svg_element(base: SVGElement) -> SVGFEColorMatrixElement = "
    if(#var(base) instanceof SVGFEColorMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEColorMatrixElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEColorMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEColorMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEColorMatrixElement = "
    if(#var(base) instanceof SVGFEColorMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEColorMatrixElement'!\");
"

/// Converts a reference to 'SVGFEColorMatrixElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::as_element(self: SVGFEColorMatrixElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEColorMatrixElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::as_melement(self: mut SVGFEColorMatrixElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEColorMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEColorMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::from_element(base: Element) -> SVGFEColorMatrixElement = "
    if(#var(base) instanceof SVGFEColorMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEColorMatrixElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEColorMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEColorMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEColorMatrixElement::from_melement(base: mut Element) -> mut SVGFEColorMatrixElement = "
    if(#var(base) instanceof SVGFEColorMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEColorMatrixElement'!\");
"

pub ext fun SVGFEColorMatrixElement::in_1(self: SVGFEColorMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEColorMatrixElement::type(self: SVGFEColorMatrixElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFEColorMatrixElement::values(self: SVGFEColorMatrixElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).values);"

pub ext fun SVGFEColorMatrixElement::class_name(self: SVGFEColorMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEColorMatrixElement::owner_svg_element(self: SVGFEColorMatrixElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEColorMatrixElement::viewport_element(self: SVGFEColorMatrixElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEColorMatrixElement::x(self: SVGFEColorMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEColorMatrixElement::y(self: SVGFEColorMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEColorMatrixElement::width(self: SVGFEColorMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEColorMatrixElement::height(self: SVGFEColorMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEColorMatrixElement::result(self: SVGFEColorMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEColorMatrixElement::start_view_transition(__self: mut SVGFEColorMatrixElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEColorMatrixElement::start_view_transition_f_prom_unit(__self: mut SVGFEColorMatrixElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEColorMatrixElement::start_view_transition_mview_transition_options(__self: mut SVGFEColorMatrixElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEColorMatrixElement::as_js(self: SVGFEColorMatrixElement) -> JsValue = JsValue::unsafe_from[SVGFEColorMatrixElement](self)

pub fun SVGFEColorMatrixElement::from_js(v: JsValue) -> mut SVGFEColorMatrixElement = JsValue::unsafe_as[mut SVGFEColorMatrixElement](v)

pub val SVGFEColorMatrixElement::svg_fecolormatrix_type_unknown: Int = 0
pub val SVGFEColorMatrixElement::svg_fecolormatrix_type_matrix: Int = 1
pub val SVGFEColorMatrixElement::svg_fecolormatrix_type_saturate: Int = 2
pub val SVGFEColorMatrixElement::svg_fecolormatrix_type_huerotate: Int = 3
pub val SVGFEColorMatrixElement::svg_fecolormatrix_type_luminancetoalpha: Int = 4

struct SVGFEComponentTransferElement()

/// Converts a reference to 'SVGFEComponentTransferElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::as_svg_element(self: SVGFEComponentTransferElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEComponentTransferElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::as_msvg_element(self: mut SVGFEComponentTransferElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEComponentTransferElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEComponentTransferElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::from_svg_element(base: SVGElement) -> SVGFEComponentTransferElement = "
    if(#var(base) instanceof SVGFEComponentTransferElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEComponentTransferElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEComponentTransferElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEComponentTransferElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEComponentTransferElement = "
    if(#var(base) instanceof SVGFEComponentTransferElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEComponentTransferElement'!\");
"

/// Converts a reference to 'SVGFEComponentTransferElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::as_element(self: SVGFEComponentTransferElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEComponentTransferElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::as_melement(self: mut SVGFEComponentTransferElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEComponentTransferElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEComponentTransferElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::from_element(base: Element) -> SVGFEComponentTransferElement = "
    if(#var(base) instanceof SVGFEComponentTransferElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEComponentTransferElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEComponentTransferElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEComponentTransferElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEComponentTransferElement::from_melement(base: mut Element) -> mut SVGFEComponentTransferElement = "
    if(#var(base) instanceof SVGFEComponentTransferElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEComponentTransferElement'!\");
"

pub ext fun SVGFEComponentTransferElement::in_1(self: SVGFEComponentTransferElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEComponentTransferElement::class_name(self: SVGFEComponentTransferElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEComponentTransferElement::owner_svg_element(self: SVGFEComponentTransferElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEComponentTransferElement::viewport_element(self: SVGFEComponentTransferElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEComponentTransferElement::x(self: SVGFEComponentTransferElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEComponentTransferElement::y(self: SVGFEComponentTransferElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEComponentTransferElement::width(self: SVGFEComponentTransferElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEComponentTransferElement::height(self: SVGFEComponentTransferElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEComponentTransferElement::result(self: SVGFEComponentTransferElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEComponentTransferElement::start_view_transition(__self: mut SVGFEComponentTransferElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEComponentTransferElement::start_view_transition_f_prom_unit(__self: mut SVGFEComponentTransferElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEComponentTransferElement::start_view_transition_mview_transition_options(__self: mut SVGFEComponentTransferElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEComponentTransferElement::as_js(self: SVGFEComponentTransferElement) -> JsValue = JsValue::unsafe_from[SVGFEComponentTransferElement](self)

pub fun SVGFEComponentTransferElement::from_js(v: JsValue) -> mut SVGFEComponentTransferElement = JsValue::unsafe_as[mut SVGFEComponentTransferElement](v)

struct SVGFECompositeElement()

/// Converts a reference to 'SVGFECompositeElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::as_svg_element(self: SVGFECompositeElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFECompositeElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::as_msvg_element(self: mut SVGFECompositeElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFECompositeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFECompositeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::from_svg_element(base: SVGElement) -> SVGFECompositeElement = "
    if(#var(base) instanceof SVGFECompositeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFECompositeElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFECompositeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFECompositeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::from_msvg_element(base: mut SVGElement) -> mut SVGFECompositeElement = "
    if(#var(base) instanceof SVGFECompositeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFECompositeElement'!\");
"

/// Converts a reference to 'SVGFECompositeElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::as_element(self: SVGFECompositeElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFECompositeElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::as_melement(self: mut SVGFECompositeElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFECompositeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFECompositeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::from_element(base: Element) -> SVGFECompositeElement = "
    if(#var(base) instanceof SVGFECompositeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFECompositeElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFECompositeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFECompositeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFECompositeElement::from_melement(base: mut Element) -> mut SVGFECompositeElement = "
    if(#var(base) instanceof SVGFECompositeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFECompositeElement'!\");
"

pub ext fun SVGFECompositeElement::in_2(self: SVGFECompositeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in2);"

pub ext fun SVGFECompositeElement::in_1(self: SVGFECompositeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFECompositeElement::operator(self: SVGFECompositeElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).operator);"

pub ext fun SVGFECompositeElement::k_1(self: SVGFECompositeElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).k1);"

pub ext fun SVGFECompositeElement::k_2(self: SVGFECompositeElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).k2);"

pub ext fun SVGFECompositeElement::k_3(self: SVGFECompositeElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).k3);"

pub ext fun SVGFECompositeElement::k_4(self: SVGFECompositeElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).k4);"

pub ext fun SVGFECompositeElement::class_name(self: SVGFECompositeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFECompositeElement::owner_svg_element(self: SVGFECompositeElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFECompositeElement::viewport_element(self: SVGFECompositeElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFECompositeElement::x(self: SVGFECompositeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFECompositeElement::y(self: SVGFECompositeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFECompositeElement::width(self: SVGFECompositeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFECompositeElement::height(self: SVGFECompositeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFECompositeElement::result(self: SVGFECompositeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFECompositeElement::start_view_transition(__self: mut SVGFECompositeElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFECompositeElement::start_view_transition_f_prom_unit(__self: mut SVGFECompositeElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFECompositeElement::start_view_transition_mview_transition_options(__self: mut SVGFECompositeElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFECompositeElement::as_js(self: SVGFECompositeElement) -> JsValue = JsValue::unsafe_from[SVGFECompositeElement](self)

pub fun SVGFECompositeElement::from_js(v: JsValue) -> mut SVGFECompositeElement = JsValue::unsafe_as[mut SVGFECompositeElement](v)

pub val SVGFECompositeElement::svg_fecomposite_operator_unknown: Int = 0
pub val SVGFECompositeElement::svg_fecomposite_operator_over: Int = 1
pub val SVGFECompositeElement::svg_fecomposite_operator_in: Int = 2
pub val SVGFECompositeElement::svg_fecomposite_operator_out: Int = 3
pub val SVGFECompositeElement::svg_fecomposite_operator_atop: Int = 4
pub val SVGFECompositeElement::svg_fecomposite_operator_xor: Int = 5
pub val SVGFECompositeElement::svg_fecomposite_operator_arithmetic: Int = 6

struct SVGFEConvolveMatrixElement()

/// Converts a reference to 'SVGFEConvolveMatrixElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::as_svg_element(self: SVGFEConvolveMatrixElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEConvolveMatrixElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::as_msvg_element(self: mut SVGFEConvolveMatrixElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEConvolveMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEConvolveMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::from_svg_element(base: SVGElement) -> SVGFEConvolveMatrixElement = "
    if(#var(base) instanceof SVGFEConvolveMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEConvolveMatrixElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEConvolveMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEConvolveMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEConvolveMatrixElement = "
    if(#var(base) instanceof SVGFEConvolveMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEConvolveMatrixElement'!\");
"

/// Converts a reference to 'SVGFEConvolveMatrixElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::as_element(self: SVGFEConvolveMatrixElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEConvolveMatrixElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::as_melement(self: mut SVGFEConvolveMatrixElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEConvolveMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEConvolveMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::from_element(base: Element) -> SVGFEConvolveMatrixElement = "
    if(#var(base) instanceof SVGFEConvolveMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEConvolveMatrixElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEConvolveMatrixElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEConvolveMatrixElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEConvolveMatrixElement::from_melement(base: mut Element) -> mut SVGFEConvolveMatrixElement = "
    if(#var(base) instanceof SVGFEConvolveMatrixElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEConvolveMatrixElement'!\");
"

pub ext fun SVGFEConvolveMatrixElement::in_1(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEConvolveMatrixElement::order_x(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedInteger
    = "return #fun(SVGAnimatedInteger::from_js)(#var(self).orderX);"

pub ext fun SVGFEConvolveMatrixElement::order_y(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedInteger
    = "return #fun(SVGAnimatedInteger::from_js)(#var(self).orderY);"

pub ext fun SVGFEConvolveMatrixElement::kernel_matrix(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).kernelMatrix);"

pub ext fun SVGFEConvolveMatrixElement::divisor(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).divisor);"

pub ext fun SVGFEConvolveMatrixElement::bias(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).bias);"

pub ext fun SVGFEConvolveMatrixElement::target_x(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedInteger
    = "return #fun(SVGAnimatedInteger::from_js)(#var(self).targetX);"

pub ext fun SVGFEConvolveMatrixElement::target_y(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedInteger
    = "return #fun(SVGAnimatedInteger::from_js)(#var(self).targetY);"

pub ext fun SVGFEConvolveMatrixElement::edge_mode(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).edgeMode);"

pub ext fun SVGFEConvolveMatrixElement::kernel_unit_length_x(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthX);"

pub ext fun SVGFEConvolveMatrixElement::kernel_unit_length_y(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthY);"

pub ext fun SVGFEConvolveMatrixElement::preserve_alpha(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedBoolean
    = "return #fun(SVGAnimatedBoolean::from_js)(#var(self).preserveAlpha);"

pub ext fun SVGFEConvolveMatrixElement::class_name(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEConvolveMatrixElement::owner_svg_element(self: SVGFEConvolveMatrixElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEConvolveMatrixElement::viewport_element(self: SVGFEConvolveMatrixElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEConvolveMatrixElement::x(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEConvolveMatrixElement::y(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEConvolveMatrixElement::width(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEConvolveMatrixElement::height(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEConvolveMatrixElement::result(self: SVGFEConvolveMatrixElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEConvolveMatrixElement::start_view_transition(__self: mut SVGFEConvolveMatrixElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEConvolveMatrixElement::start_view_transition_f_prom_unit(__self: mut SVGFEConvolveMatrixElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEConvolveMatrixElement::start_view_transition_mview_transition_options(__self: mut SVGFEConvolveMatrixElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEConvolveMatrixElement::as_js(self: SVGFEConvolveMatrixElement) -> JsValue = JsValue::unsafe_from[SVGFEConvolveMatrixElement](self)

pub fun SVGFEConvolveMatrixElement::from_js(v: JsValue) -> mut SVGFEConvolveMatrixElement = JsValue::unsafe_as[mut SVGFEConvolveMatrixElement](v)

pub val SVGFEConvolveMatrixElement::svg_edgemode_unknown: Int = 0
pub val SVGFEConvolveMatrixElement::svg_edgemode_duplicate: Int = 1
pub val SVGFEConvolveMatrixElement::svg_edgemode_wrap: Int = 2
pub val SVGFEConvolveMatrixElement::svg_edgemode_none: Int = 3

struct SVGFEDiffuseLightingElement()

/// Converts a reference to 'SVGFEDiffuseLightingElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::as_svg_element(self: SVGFEDiffuseLightingElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDiffuseLightingElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::as_msvg_element(self: mut SVGFEDiffuseLightingElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEDiffuseLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDiffuseLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::from_svg_element(base: SVGElement) -> SVGFEDiffuseLightingElement = "
    if(#var(base) instanceof SVGFEDiffuseLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDiffuseLightingElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEDiffuseLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDiffuseLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEDiffuseLightingElement = "
    if(#var(base) instanceof SVGFEDiffuseLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDiffuseLightingElement'!\");
"

/// Converts a reference to 'SVGFEDiffuseLightingElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::as_element(self: SVGFEDiffuseLightingElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDiffuseLightingElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::as_melement(self: mut SVGFEDiffuseLightingElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEDiffuseLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDiffuseLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::from_element(base: Element) -> SVGFEDiffuseLightingElement = "
    if(#var(base) instanceof SVGFEDiffuseLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDiffuseLightingElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEDiffuseLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDiffuseLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDiffuseLightingElement::from_melement(base: mut Element) -> mut SVGFEDiffuseLightingElement = "
    if(#var(base) instanceof SVGFEDiffuseLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDiffuseLightingElement'!\");
"

pub ext fun SVGFEDiffuseLightingElement::in_1(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEDiffuseLightingElement::surface_scale(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).surfaceScale);"

pub ext fun SVGFEDiffuseLightingElement::diffuse_constant(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).diffuseConstant);"

pub ext fun SVGFEDiffuseLightingElement::kernel_unit_length_x(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthX);"

pub ext fun SVGFEDiffuseLightingElement::kernel_unit_length_y(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthY);"

pub ext fun SVGFEDiffuseLightingElement::class_name(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEDiffuseLightingElement::owner_svg_element(self: SVGFEDiffuseLightingElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEDiffuseLightingElement::viewport_element(self: SVGFEDiffuseLightingElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEDiffuseLightingElement::x(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEDiffuseLightingElement::y(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEDiffuseLightingElement::width(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEDiffuseLightingElement::height(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEDiffuseLightingElement::result(self: SVGFEDiffuseLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEDiffuseLightingElement::start_view_transition(__self: mut SVGFEDiffuseLightingElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDiffuseLightingElement::start_view_transition_f_prom_unit(__self: mut SVGFEDiffuseLightingElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDiffuseLightingElement::start_view_transition_mview_transition_options(__self: mut SVGFEDiffuseLightingElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEDiffuseLightingElement::as_js(self: SVGFEDiffuseLightingElement) -> JsValue = JsValue::unsafe_from[SVGFEDiffuseLightingElement](self)

pub fun SVGFEDiffuseLightingElement::from_js(v: JsValue) -> mut SVGFEDiffuseLightingElement = JsValue::unsafe_as[mut SVGFEDiffuseLightingElement](v)

struct SVGFEDisplacementMapElement()

/// Converts a reference to 'SVGFEDisplacementMapElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::as_svg_element(self: SVGFEDisplacementMapElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDisplacementMapElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::as_msvg_element(self: mut SVGFEDisplacementMapElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEDisplacementMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDisplacementMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::from_svg_element(base: SVGElement) -> SVGFEDisplacementMapElement = "
    if(#var(base) instanceof SVGFEDisplacementMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDisplacementMapElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEDisplacementMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDisplacementMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEDisplacementMapElement = "
    if(#var(base) instanceof SVGFEDisplacementMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDisplacementMapElement'!\");
"

/// Converts a reference to 'SVGFEDisplacementMapElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::as_element(self: SVGFEDisplacementMapElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDisplacementMapElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::as_melement(self: mut SVGFEDisplacementMapElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEDisplacementMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDisplacementMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::from_element(base: Element) -> SVGFEDisplacementMapElement = "
    if(#var(base) instanceof SVGFEDisplacementMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDisplacementMapElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEDisplacementMapElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDisplacementMapElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDisplacementMapElement::from_melement(base: mut Element) -> mut SVGFEDisplacementMapElement = "
    if(#var(base) instanceof SVGFEDisplacementMapElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDisplacementMapElement'!\");
"

pub ext fun SVGFEDisplacementMapElement::in_1(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEDisplacementMapElement::in_2(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in2);"

pub ext fun SVGFEDisplacementMapElement::scale(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).scale);"

pub ext fun SVGFEDisplacementMapElement::x_channel_selector(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).xChannelSelector);"

pub ext fun SVGFEDisplacementMapElement::y_channel_selector(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).yChannelSelector);"

pub ext fun SVGFEDisplacementMapElement::class_name(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEDisplacementMapElement::owner_svg_element(self: SVGFEDisplacementMapElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEDisplacementMapElement::viewport_element(self: SVGFEDisplacementMapElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEDisplacementMapElement::x(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEDisplacementMapElement::y(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEDisplacementMapElement::width(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEDisplacementMapElement::height(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEDisplacementMapElement::result(self: SVGFEDisplacementMapElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEDisplacementMapElement::start_view_transition(__self: mut SVGFEDisplacementMapElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDisplacementMapElement::start_view_transition_f_prom_unit(__self: mut SVGFEDisplacementMapElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDisplacementMapElement::start_view_transition_mview_transition_options(__self: mut SVGFEDisplacementMapElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEDisplacementMapElement::as_js(self: SVGFEDisplacementMapElement) -> JsValue = JsValue::unsafe_from[SVGFEDisplacementMapElement](self)

pub fun SVGFEDisplacementMapElement::from_js(v: JsValue) -> mut SVGFEDisplacementMapElement = JsValue::unsafe_as[mut SVGFEDisplacementMapElement](v)

pub val SVGFEDisplacementMapElement::svg_channel_unknown: Int = 0
pub val SVGFEDisplacementMapElement::svg_channel_r: Int = 1
pub val SVGFEDisplacementMapElement::svg_channel_g: Int = 2
pub val SVGFEDisplacementMapElement::svg_channel_b: Int = 3
pub val SVGFEDisplacementMapElement::svg_channel_a: Int = 4

struct SVGFEDistantLightElement()

/// Converts a reference to 'SVGFEDistantLightElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::as_svg_element(self: SVGFEDistantLightElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDistantLightElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::as_msvg_element(self: mut SVGFEDistantLightElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEDistantLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDistantLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::from_svg_element(base: SVGElement) -> SVGFEDistantLightElement = "
    if(#var(base) instanceof SVGFEDistantLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDistantLightElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEDistantLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDistantLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEDistantLightElement = "
    if(#var(base) instanceof SVGFEDistantLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDistantLightElement'!\");
"

/// Converts a reference to 'SVGFEDistantLightElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::as_element(self: SVGFEDistantLightElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDistantLightElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::as_melement(self: mut SVGFEDistantLightElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEDistantLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDistantLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::from_element(base: Element) -> SVGFEDistantLightElement = "
    if(#var(base) instanceof SVGFEDistantLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDistantLightElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEDistantLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDistantLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDistantLightElement::from_melement(base: mut Element) -> mut SVGFEDistantLightElement = "
    if(#var(base) instanceof SVGFEDistantLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDistantLightElement'!\");
"

pub ext fun SVGFEDistantLightElement::azimuth(self: SVGFEDistantLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).azimuth);"

pub ext fun SVGFEDistantLightElement::elevation(self: SVGFEDistantLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).elevation);"

pub ext fun SVGFEDistantLightElement::class_name(self: SVGFEDistantLightElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEDistantLightElement::owner_svg_element(self: SVGFEDistantLightElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEDistantLightElement::viewport_element(self: SVGFEDistantLightElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEDistantLightElement::start_view_transition(__self: mut SVGFEDistantLightElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDistantLightElement::start_view_transition_f_prom_unit(__self: mut SVGFEDistantLightElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDistantLightElement::start_view_transition_mview_transition_options(__self: mut SVGFEDistantLightElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEDistantLightElement::as_js(self: SVGFEDistantLightElement) -> JsValue = JsValue::unsafe_from[SVGFEDistantLightElement](self)

pub fun SVGFEDistantLightElement::from_js(v: JsValue) -> mut SVGFEDistantLightElement = JsValue::unsafe_as[mut SVGFEDistantLightElement](v)

struct SVGFEDropShadowElement()

/// Converts a reference to 'SVGFEDropShadowElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::as_svg_element(self: SVGFEDropShadowElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDropShadowElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::as_msvg_element(self: mut SVGFEDropShadowElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEDropShadowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDropShadowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::from_svg_element(base: SVGElement) -> SVGFEDropShadowElement = "
    if(#var(base) instanceof SVGFEDropShadowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDropShadowElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEDropShadowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDropShadowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEDropShadowElement = "
    if(#var(base) instanceof SVGFEDropShadowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEDropShadowElement'!\");
"

/// Converts a reference to 'SVGFEDropShadowElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::as_element(self: SVGFEDropShadowElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEDropShadowElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::as_melement(self: mut SVGFEDropShadowElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEDropShadowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDropShadowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::from_element(base: Element) -> SVGFEDropShadowElement = "
    if(#var(base) instanceof SVGFEDropShadowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDropShadowElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEDropShadowElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEDropShadowElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEDropShadowElement::from_melement(base: mut Element) -> mut SVGFEDropShadowElement = "
    if(#var(base) instanceof SVGFEDropShadowElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEDropShadowElement'!\");
"

pub ext fun SVGFEDropShadowElement::in_1(self: SVGFEDropShadowElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEDropShadowElement::dx(self: SVGFEDropShadowElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).dx);"

pub ext fun SVGFEDropShadowElement::dy(self: SVGFEDropShadowElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).dy);"

pub ext fun SVGFEDropShadowElement::std_deviation_x(self: SVGFEDropShadowElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).stdDeviationX);"

pub ext fun SVGFEDropShadowElement::std_deviation_y(self: SVGFEDropShadowElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).stdDeviationY);"

pub ext fun SVGFEDropShadowElement::class_name(self: SVGFEDropShadowElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEDropShadowElement::owner_svg_element(self: SVGFEDropShadowElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEDropShadowElement::viewport_element(self: SVGFEDropShadowElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEDropShadowElement::x(self: SVGFEDropShadowElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEDropShadowElement::y(self: SVGFEDropShadowElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEDropShadowElement::width(self: SVGFEDropShadowElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEDropShadowElement::height(self: SVGFEDropShadowElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEDropShadowElement::result(self: SVGFEDropShadowElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEDropShadowElement::set_std_deviation(__self: mut SVGFEDropShadowElement, std_deviation_x: Float, std_deviation_y: Float) -> Unit = "
    const r = #var(__self).setStdDeviation(#fun(Float::as_js)(#var(std_deviation_x)), #fun(Float::as_js)(#var(std_deviation_y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGFEDropShadowElement::start_view_transition(__self: mut SVGFEDropShadowElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDropShadowElement::start_view_transition_f_prom_unit(__self: mut SVGFEDropShadowElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEDropShadowElement::start_view_transition_mview_transition_options(__self: mut SVGFEDropShadowElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEDropShadowElement::as_js(self: SVGFEDropShadowElement) -> JsValue = JsValue::unsafe_from[SVGFEDropShadowElement](self)

pub fun SVGFEDropShadowElement::from_js(v: JsValue) -> mut SVGFEDropShadowElement = JsValue::unsafe_as[mut SVGFEDropShadowElement](v)

struct SVGFEFloodElement()

/// Converts a reference to 'SVGFEFloodElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::as_svg_element(self: SVGFEFloodElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFloodElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::as_msvg_element(self: mut SVGFEFloodElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEFloodElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFloodElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::from_svg_element(base: SVGElement) -> SVGFEFloodElement = "
    if(#var(base) instanceof SVGFEFloodElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFloodElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEFloodElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFloodElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEFloodElement = "
    if(#var(base) instanceof SVGFEFloodElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFloodElement'!\");
"

/// Converts a reference to 'SVGFEFloodElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::as_element(self: SVGFEFloodElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFloodElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::as_melement(self: mut SVGFEFloodElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEFloodElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFloodElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::from_element(base: Element) -> SVGFEFloodElement = "
    if(#var(base) instanceof SVGFEFloodElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFloodElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEFloodElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFloodElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFloodElement::from_melement(base: mut Element) -> mut SVGFEFloodElement = "
    if(#var(base) instanceof SVGFEFloodElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFloodElement'!\");
"

pub ext fun SVGFEFloodElement::class_name(self: SVGFEFloodElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEFloodElement::owner_svg_element(self: SVGFEFloodElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEFloodElement::viewport_element(self: SVGFEFloodElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEFloodElement::x(self: SVGFEFloodElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEFloodElement::y(self: SVGFEFloodElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEFloodElement::width(self: SVGFEFloodElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEFloodElement::height(self: SVGFEFloodElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEFloodElement::result(self: SVGFEFloodElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEFloodElement::start_view_transition(__self: mut SVGFEFloodElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFloodElement::start_view_transition_f_prom_unit(__self: mut SVGFEFloodElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFloodElement::start_view_transition_mview_transition_options(__self: mut SVGFEFloodElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEFloodElement::as_js(self: SVGFEFloodElement) -> JsValue = JsValue::unsafe_from[SVGFEFloodElement](self)

pub fun SVGFEFloodElement::from_js(v: JsValue) -> mut SVGFEFloodElement = JsValue::unsafe_as[mut SVGFEFloodElement](v)

struct SVGFEFuncAElement()

/// Converts a reference to 'SVGFEFuncAElement' to a reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_svg_component_transfer_function_element(self: SVGFEFuncAElement) -> SVGComponentTransferFunctionElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncAElement' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_msvg_component_transfer_function_element(self: mut SVGFEFuncAElement) -> mut SVGComponentTransferFunctionElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGComponentTransferFunctionElement' to a reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_svg_component_transfer_function_element(base: SVGComponentTransferFunctionElement) -> SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncAElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_msvg_component_transfer_function_element(base: mut SVGComponentTransferFunctionElement) -> mut SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncAElement'!\");
"

/// Converts a reference to 'SVGFEFuncAElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_svg_element(self: SVGFEFuncAElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncAElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_msvg_element(self: mut SVGFEFuncAElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_svg_element(base: SVGElement) -> SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncAElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncAElement'!\");
"

/// Converts a reference to 'SVGFEFuncAElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_element(self: SVGFEFuncAElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncAElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::as_melement(self: mut SVGFEFuncAElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_element(base: Element) -> SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncAElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEFuncAElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncAElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncAElement::from_melement(base: mut Element) -> mut SVGFEFuncAElement = "
    if(#var(base) instanceof SVGFEFuncAElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncAElement'!\");
"

pub ext fun SVGFEFuncAElement::type(self: SVGFEFuncAElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFEFuncAElement::table_values(self: SVGFEFuncAElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).tableValues);"

pub ext fun SVGFEFuncAElement::slope(self: SVGFEFuncAElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).slope);"

pub ext fun SVGFEFuncAElement::intercept(self: SVGFEFuncAElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).intercept);"

pub ext fun SVGFEFuncAElement::amplitude(self: SVGFEFuncAElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).amplitude);"

pub ext fun SVGFEFuncAElement::exponent(self: SVGFEFuncAElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).exponent);"

pub ext fun SVGFEFuncAElement::offset(self: SVGFEFuncAElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGFEFuncAElement::class_name(self: SVGFEFuncAElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEFuncAElement::owner_svg_element(self: SVGFEFuncAElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEFuncAElement::viewport_element(self: SVGFEFuncAElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEFuncAElement::start_view_transition(__self: mut SVGFEFuncAElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncAElement::start_view_transition_f_prom_unit(__self: mut SVGFEFuncAElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncAElement::start_view_transition_mview_transition_options(__self: mut SVGFEFuncAElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEFuncAElement::as_js(self: SVGFEFuncAElement) -> JsValue = JsValue::unsafe_from[SVGFEFuncAElement](self)

pub fun SVGFEFuncAElement::from_js(v: JsValue) -> mut SVGFEFuncAElement = JsValue::unsafe_as[mut SVGFEFuncAElement](v)

pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_unknown: Int = 0
pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_identity: Int = 1
pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_table: Int = 2
pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_discrete: Int = 3
pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_linear: Int = 4
pub val SVGFEFuncAElement::svg_fecomponenttransfer_type_gamma: Int = 5

struct SVGFEFuncBElement()

/// Converts a reference to 'SVGFEFuncBElement' to a reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_svg_component_transfer_function_element(self: SVGFEFuncBElement) -> SVGComponentTransferFunctionElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncBElement' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_msvg_component_transfer_function_element(self: mut SVGFEFuncBElement) -> mut SVGComponentTransferFunctionElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGComponentTransferFunctionElement' to a reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_svg_component_transfer_function_element(base: SVGComponentTransferFunctionElement) -> SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncBElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_msvg_component_transfer_function_element(base: mut SVGComponentTransferFunctionElement) -> mut SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncBElement'!\");
"

/// Converts a reference to 'SVGFEFuncBElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_svg_element(self: SVGFEFuncBElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncBElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_msvg_element(self: mut SVGFEFuncBElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_svg_element(base: SVGElement) -> SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncBElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncBElement'!\");
"

/// Converts a reference to 'SVGFEFuncBElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_element(self: SVGFEFuncBElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncBElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::as_melement(self: mut SVGFEFuncBElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_element(base: Element) -> SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncBElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEFuncBElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncBElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncBElement::from_melement(base: mut Element) -> mut SVGFEFuncBElement = "
    if(#var(base) instanceof SVGFEFuncBElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncBElement'!\");
"

pub ext fun SVGFEFuncBElement::type(self: SVGFEFuncBElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFEFuncBElement::table_values(self: SVGFEFuncBElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).tableValues);"

pub ext fun SVGFEFuncBElement::slope(self: SVGFEFuncBElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).slope);"

pub ext fun SVGFEFuncBElement::intercept(self: SVGFEFuncBElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).intercept);"

pub ext fun SVGFEFuncBElement::amplitude(self: SVGFEFuncBElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).amplitude);"

pub ext fun SVGFEFuncBElement::exponent(self: SVGFEFuncBElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).exponent);"

pub ext fun SVGFEFuncBElement::offset(self: SVGFEFuncBElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGFEFuncBElement::class_name(self: SVGFEFuncBElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEFuncBElement::owner_svg_element(self: SVGFEFuncBElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEFuncBElement::viewport_element(self: SVGFEFuncBElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEFuncBElement::start_view_transition(__self: mut SVGFEFuncBElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncBElement::start_view_transition_f_prom_unit(__self: mut SVGFEFuncBElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncBElement::start_view_transition_mview_transition_options(__self: mut SVGFEFuncBElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEFuncBElement::as_js(self: SVGFEFuncBElement) -> JsValue = JsValue::unsafe_from[SVGFEFuncBElement](self)

pub fun SVGFEFuncBElement::from_js(v: JsValue) -> mut SVGFEFuncBElement = JsValue::unsafe_as[mut SVGFEFuncBElement](v)

pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_unknown: Int = 0
pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_identity: Int = 1
pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_table: Int = 2
pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_discrete: Int = 3
pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_linear: Int = 4
pub val SVGFEFuncBElement::svg_fecomponenttransfer_type_gamma: Int = 5

struct SVGFEFuncGElement()

/// Converts a reference to 'SVGFEFuncGElement' to a reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_svg_component_transfer_function_element(self: SVGFEFuncGElement) -> SVGComponentTransferFunctionElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncGElement' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_msvg_component_transfer_function_element(self: mut SVGFEFuncGElement) -> mut SVGComponentTransferFunctionElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGComponentTransferFunctionElement' to a reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_svg_component_transfer_function_element(base: SVGComponentTransferFunctionElement) -> SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_msvg_component_transfer_function_element(base: mut SVGComponentTransferFunctionElement) -> mut SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncGElement'!\");
"

/// Converts a reference to 'SVGFEFuncGElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_svg_element(self: SVGFEFuncGElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncGElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_msvg_element(self: mut SVGFEFuncGElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_svg_element(base: SVGElement) -> SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncGElement'!\");
"

/// Converts a reference to 'SVGFEFuncGElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_element(self: SVGFEFuncGElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncGElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::as_melement(self: mut SVGFEFuncGElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_element(base: Element) -> SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncGElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEFuncGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncGElement::from_melement(base: mut Element) -> mut SVGFEFuncGElement = "
    if(#var(base) instanceof SVGFEFuncGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncGElement'!\");
"

pub ext fun SVGFEFuncGElement::type(self: SVGFEFuncGElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFEFuncGElement::table_values(self: SVGFEFuncGElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).tableValues);"

pub ext fun SVGFEFuncGElement::slope(self: SVGFEFuncGElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).slope);"

pub ext fun SVGFEFuncGElement::intercept(self: SVGFEFuncGElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).intercept);"

pub ext fun SVGFEFuncGElement::amplitude(self: SVGFEFuncGElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).amplitude);"

pub ext fun SVGFEFuncGElement::exponent(self: SVGFEFuncGElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).exponent);"

pub ext fun SVGFEFuncGElement::offset(self: SVGFEFuncGElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGFEFuncGElement::class_name(self: SVGFEFuncGElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEFuncGElement::owner_svg_element(self: SVGFEFuncGElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEFuncGElement::viewport_element(self: SVGFEFuncGElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEFuncGElement::start_view_transition(__self: mut SVGFEFuncGElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncGElement::start_view_transition_f_prom_unit(__self: mut SVGFEFuncGElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncGElement::start_view_transition_mview_transition_options(__self: mut SVGFEFuncGElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEFuncGElement::as_js(self: SVGFEFuncGElement) -> JsValue = JsValue::unsafe_from[SVGFEFuncGElement](self)

pub fun SVGFEFuncGElement::from_js(v: JsValue) -> mut SVGFEFuncGElement = JsValue::unsafe_as[mut SVGFEFuncGElement](v)

pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_unknown: Int = 0
pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_identity: Int = 1
pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_table: Int = 2
pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_discrete: Int = 3
pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_linear: Int = 4
pub val SVGFEFuncGElement::svg_fecomponenttransfer_type_gamma: Int = 5

struct SVGFEFuncRElement()

/// Converts a reference to 'SVGFEFuncRElement' to a reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_svg_component_transfer_function_element(self: SVGFEFuncRElement) -> SVGComponentTransferFunctionElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncRElement' to a mutable reference to 'SVGComponentTransferFunctionElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_msvg_component_transfer_function_element(self: mut SVGFEFuncRElement) -> mut SVGComponentTransferFunctionElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGComponentTransferFunctionElement' to a reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_svg_component_transfer_function_element(base: SVGComponentTransferFunctionElement) -> SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncRElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGComponentTransferFunctionElement' to a mutable reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_msvg_component_transfer_function_element(base: mut SVGComponentTransferFunctionElement) -> mut SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGComponentTransferFunctionElement' to 'SVGFEFuncRElement'!\");
"

/// Converts a reference to 'SVGFEFuncRElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_svg_element(self: SVGFEFuncRElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncRElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_msvg_element(self: mut SVGFEFuncRElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_svg_element(base: SVGElement) -> SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncRElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEFuncRElement'!\");
"

/// Converts a reference to 'SVGFEFuncRElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_element(self: SVGFEFuncRElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEFuncRElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::as_melement(self: mut SVGFEFuncRElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_element(base: Element) -> SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncRElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEFuncRElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEFuncRElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEFuncRElement::from_melement(base: mut Element) -> mut SVGFEFuncRElement = "
    if(#var(base) instanceof SVGFEFuncRElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEFuncRElement'!\");
"

pub ext fun SVGFEFuncRElement::type(self: SVGFEFuncRElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFEFuncRElement::table_values(self: SVGFEFuncRElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).tableValues);"

pub ext fun SVGFEFuncRElement::slope(self: SVGFEFuncRElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).slope);"

pub ext fun SVGFEFuncRElement::intercept(self: SVGFEFuncRElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).intercept);"

pub ext fun SVGFEFuncRElement::amplitude(self: SVGFEFuncRElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).amplitude);"

pub ext fun SVGFEFuncRElement::exponent(self: SVGFEFuncRElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).exponent);"

pub ext fun SVGFEFuncRElement::offset(self: SVGFEFuncRElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGFEFuncRElement::class_name(self: SVGFEFuncRElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEFuncRElement::owner_svg_element(self: SVGFEFuncRElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEFuncRElement::viewport_element(self: SVGFEFuncRElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEFuncRElement::start_view_transition(__self: mut SVGFEFuncRElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncRElement::start_view_transition_f_prom_unit(__self: mut SVGFEFuncRElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEFuncRElement::start_view_transition_mview_transition_options(__self: mut SVGFEFuncRElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEFuncRElement::as_js(self: SVGFEFuncRElement) -> JsValue = JsValue::unsafe_from[SVGFEFuncRElement](self)

pub fun SVGFEFuncRElement::from_js(v: JsValue) -> mut SVGFEFuncRElement = JsValue::unsafe_as[mut SVGFEFuncRElement](v)

pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_unknown: Int = 0
pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_identity: Int = 1
pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_table: Int = 2
pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_discrete: Int = 3
pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_linear: Int = 4
pub val SVGFEFuncRElement::svg_fecomponenttransfer_type_gamma: Int = 5

struct SVGFEGaussianBlurElement()

/// Converts a reference to 'SVGFEGaussianBlurElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::as_svg_element(self: SVGFEGaussianBlurElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEGaussianBlurElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::as_msvg_element(self: mut SVGFEGaussianBlurElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEGaussianBlurElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEGaussianBlurElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::from_svg_element(base: SVGElement) -> SVGFEGaussianBlurElement = "
    if(#var(base) instanceof SVGFEGaussianBlurElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEGaussianBlurElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEGaussianBlurElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEGaussianBlurElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEGaussianBlurElement = "
    if(#var(base) instanceof SVGFEGaussianBlurElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEGaussianBlurElement'!\");
"

/// Converts a reference to 'SVGFEGaussianBlurElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::as_element(self: SVGFEGaussianBlurElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEGaussianBlurElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::as_melement(self: mut SVGFEGaussianBlurElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEGaussianBlurElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEGaussianBlurElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::from_element(base: Element) -> SVGFEGaussianBlurElement = "
    if(#var(base) instanceof SVGFEGaussianBlurElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEGaussianBlurElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEGaussianBlurElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEGaussianBlurElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEGaussianBlurElement::from_melement(base: mut Element) -> mut SVGFEGaussianBlurElement = "
    if(#var(base) instanceof SVGFEGaussianBlurElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEGaussianBlurElement'!\");
"

pub ext fun SVGFEGaussianBlurElement::in_1(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEGaussianBlurElement::std_deviation_x(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).stdDeviationX);"

pub ext fun SVGFEGaussianBlurElement::std_deviation_y(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).stdDeviationY);"

pub ext fun SVGFEGaussianBlurElement::class_name(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEGaussianBlurElement::owner_svg_element(self: SVGFEGaussianBlurElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEGaussianBlurElement::viewport_element(self: SVGFEGaussianBlurElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEGaussianBlurElement::x(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEGaussianBlurElement::y(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEGaussianBlurElement::width(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEGaussianBlurElement::height(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEGaussianBlurElement::result(self: SVGFEGaussianBlurElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEGaussianBlurElement::set_std_deviation(__self: mut SVGFEGaussianBlurElement, std_deviation_x: Float, std_deviation_y: Float) -> Unit = "
    const r = #var(__self).setStdDeviation(#fun(Float::as_js)(#var(std_deviation_x)), #fun(Float::as_js)(#var(std_deviation_y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGFEGaussianBlurElement::start_view_transition(__self: mut SVGFEGaussianBlurElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEGaussianBlurElement::start_view_transition_f_prom_unit(__self: mut SVGFEGaussianBlurElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEGaussianBlurElement::start_view_transition_mview_transition_options(__self: mut SVGFEGaussianBlurElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEGaussianBlurElement::as_js(self: SVGFEGaussianBlurElement) -> JsValue = JsValue::unsafe_from[SVGFEGaussianBlurElement](self)

pub fun SVGFEGaussianBlurElement::from_js(v: JsValue) -> mut SVGFEGaussianBlurElement = JsValue::unsafe_as[mut SVGFEGaussianBlurElement](v)

struct SVGFEImageElement()

/// Converts a reference to 'SVGFEImageElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::as_svg_element(self: SVGFEImageElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEImageElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::as_msvg_element(self: mut SVGFEImageElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::from_svg_element(base: SVGElement) -> SVGFEImageElement = "
    if(#var(base) instanceof SVGFEImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEImageElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEImageElement = "
    if(#var(base) instanceof SVGFEImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEImageElement'!\");
"

/// Converts a reference to 'SVGFEImageElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::as_element(self: SVGFEImageElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEImageElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::as_melement(self: mut SVGFEImageElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::from_element(base: Element) -> SVGFEImageElement = "
    if(#var(base) instanceof SVGFEImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEImageElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEImageElement::from_melement(base: mut Element) -> mut SVGFEImageElement = "
    if(#var(base) instanceof SVGFEImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEImageElement'!\");
"

pub ext fun SVGFEImageElement::preserve_aspect_ratio(self: SVGFEImageElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGFEImageElement::class_name(self: SVGFEImageElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEImageElement::owner_svg_element(self: SVGFEImageElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEImageElement::viewport_element(self: SVGFEImageElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEImageElement::x(self: SVGFEImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEImageElement::y(self: SVGFEImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEImageElement::width(self: SVGFEImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEImageElement::height(self: SVGFEImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEImageElement::result(self: SVGFEImageElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEImageElement::href(self: SVGFEImageElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGFEImageElement::start_view_transition(__self: mut SVGFEImageElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEImageElement::start_view_transition_f_prom_unit(__self: mut SVGFEImageElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEImageElement::start_view_transition_mview_transition_options(__self: mut SVGFEImageElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEImageElement::as_js(self: SVGFEImageElement) -> JsValue = JsValue::unsafe_from[SVGFEImageElement](self)

pub fun SVGFEImageElement::from_js(v: JsValue) -> mut SVGFEImageElement = JsValue::unsafe_as[mut SVGFEImageElement](v)

struct SVGFEMergeElement()

/// Converts a reference to 'SVGFEMergeElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::as_svg_element(self: SVGFEMergeElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMergeElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::as_msvg_element(self: mut SVGFEMergeElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEMergeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::from_svg_element(base: SVGElement) -> SVGFEMergeElement = "
    if(#var(base) instanceof SVGFEMergeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMergeElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEMergeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEMergeElement = "
    if(#var(base) instanceof SVGFEMergeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMergeElement'!\");
"

/// Converts a reference to 'SVGFEMergeElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::as_element(self: SVGFEMergeElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMergeElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::as_melement(self: mut SVGFEMergeElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEMergeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::from_element(base: Element) -> SVGFEMergeElement = "
    if(#var(base) instanceof SVGFEMergeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMergeElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEMergeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeElement::from_melement(base: mut Element) -> mut SVGFEMergeElement = "
    if(#var(base) instanceof SVGFEMergeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMergeElement'!\");
"

pub ext fun SVGFEMergeElement::class_name(self: SVGFEMergeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEMergeElement::owner_svg_element(self: SVGFEMergeElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEMergeElement::viewport_element(self: SVGFEMergeElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEMergeElement::x(self: SVGFEMergeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEMergeElement::y(self: SVGFEMergeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEMergeElement::width(self: SVGFEMergeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEMergeElement::height(self: SVGFEMergeElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEMergeElement::result(self: SVGFEMergeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEMergeElement::start_view_transition(__self: mut SVGFEMergeElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMergeElement::start_view_transition_f_prom_unit(__self: mut SVGFEMergeElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMergeElement::start_view_transition_mview_transition_options(__self: mut SVGFEMergeElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEMergeElement::as_js(self: SVGFEMergeElement) -> JsValue = JsValue::unsafe_from[SVGFEMergeElement](self)

pub fun SVGFEMergeElement::from_js(v: JsValue) -> mut SVGFEMergeElement = JsValue::unsafe_as[mut SVGFEMergeElement](v)

struct SVGFEMergeNodeElement()

/// Converts a reference to 'SVGFEMergeNodeElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::as_svg_element(self: SVGFEMergeNodeElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMergeNodeElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::as_msvg_element(self: mut SVGFEMergeNodeElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEMergeNodeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeNodeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::from_svg_element(base: SVGElement) -> SVGFEMergeNodeElement = "
    if(#var(base) instanceof SVGFEMergeNodeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMergeNodeElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEMergeNodeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeNodeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEMergeNodeElement = "
    if(#var(base) instanceof SVGFEMergeNodeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMergeNodeElement'!\");
"

/// Converts a reference to 'SVGFEMergeNodeElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::as_element(self: SVGFEMergeNodeElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMergeNodeElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::as_melement(self: mut SVGFEMergeNodeElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEMergeNodeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeNodeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::from_element(base: Element) -> SVGFEMergeNodeElement = "
    if(#var(base) instanceof SVGFEMergeNodeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMergeNodeElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEMergeNodeElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMergeNodeElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMergeNodeElement::from_melement(base: mut Element) -> mut SVGFEMergeNodeElement = "
    if(#var(base) instanceof SVGFEMergeNodeElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMergeNodeElement'!\");
"

pub ext fun SVGFEMergeNodeElement::in_1(self: SVGFEMergeNodeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEMergeNodeElement::class_name(self: SVGFEMergeNodeElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEMergeNodeElement::owner_svg_element(self: SVGFEMergeNodeElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEMergeNodeElement::viewport_element(self: SVGFEMergeNodeElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEMergeNodeElement::start_view_transition(__self: mut SVGFEMergeNodeElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMergeNodeElement::start_view_transition_f_prom_unit(__self: mut SVGFEMergeNodeElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMergeNodeElement::start_view_transition_mview_transition_options(__self: mut SVGFEMergeNodeElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEMergeNodeElement::as_js(self: SVGFEMergeNodeElement) -> JsValue = JsValue::unsafe_from[SVGFEMergeNodeElement](self)

pub fun SVGFEMergeNodeElement::from_js(v: JsValue) -> mut SVGFEMergeNodeElement = JsValue::unsafe_as[mut SVGFEMergeNodeElement](v)

struct SVGFEMorphologyElement()

/// Converts a reference to 'SVGFEMorphologyElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::as_svg_element(self: SVGFEMorphologyElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMorphologyElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::as_msvg_element(self: mut SVGFEMorphologyElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEMorphologyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMorphologyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::from_svg_element(base: SVGElement) -> SVGFEMorphologyElement = "
    if(#var(base) instanceof SVGFEMorphologyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMorphologyElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEMorphologyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMorphologyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEMorphologyElement = "
    if(#var(base) instanceof SVGFEMorphologyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEMorphologyElement'!\");
"

/// Converts a reference to 'SVGFEMorphologyElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::as_element(self: SVGFEMorphologyElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEMorphologyElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::as_melement(self: mut SVGFEMorphologyElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEMorphologyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMorphologyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::from_element(base: Element) -> SVGFEMorphologyElement = "
    if(#var(base) instanceof SVGFEMorphologyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMorphologyElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEMorphologyElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEMorphologyElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEMorphologyElement::from_melement(base: mut Element) -> mut SVGFEMorphologyElement = "
    if(#var(base) instanceof SVGFEMorphologyElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEMorphologyElement'!\");
"

pub ext fun SVGFEMorphologyElement::in_1(self: SVGFEMorphologyElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEMorphologyElement::operator(self: SVGFEMorphologyElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).operator);"

pub ext fun SVGFEMorphologyElement::radius_x(self: SVGFEMorphologyElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).radiusX);"

pub ext fun SVGFEMorphologyElement::radius_y(self: SVGFEMorphologyElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).radiusY);"

pub ext fun SVGFEMorphologyElement::class_name(self: SVGFEMorphologyElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEMorphologyElement::owner_svg_element(self: SVGFEMorphologyElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEMorphologyElement::viewport_element(self: SVGFEMorphologyElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEMorphologyElement::x(self: SVGFEMorphologyElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEMorphologyElement::y(self: SVGFEMorphologyElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEMorphologyElement::width(self: SVGFEMorphologyElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEMorphologyElement::height(self: SVGFEMorphologyElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEMorphologyElement::result(self: SVGFEMorphologyElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEMorphologyElement::start_view_transition(__self: mut SVGFEMorphologyElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMorphologyElement::start_view_transition_f_prom_unit(__self: mut SVGFEMorphologyElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEMorphologyElement::start_view_transition_mview_transition_options(__self: mut SVGFEMorphologyElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEMorphologyElement::as_js(self: SVGFEMorphologyElement) -> JsValue = JsValue::unsafe_from[SVGFEMorphologyElement](self)

pub fun SVGFEMorphologyElement::from_js(v: JsValue) -> mut SVGFEMorphologyElement = JsValue::unsafe_as[mut SVGFEMorphologyElement](v)

pub val SVGFEMorphologyElement::svg_morphology_operator_unknown: Int = 0
pub val SVGFEMorphologyElement::svg_morphology_operator_erode: Int = 1
pub val SVGFEMorphologyElement::svg_morphology_operator_dilate: Int = 2

struct SVGFEOffsetElement()

/// Converts a reference to 'SVGFEOffsetElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::as_svg_element(self: SVGFEOffsetElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEOffsetElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::as_msvg_element(self: mut SVGFEOffsetElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEOffsetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEOffsetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::from_svg_element(base: SVGElement) -> SVGFEOffsetElement = "
    if(#var(base) instanceof SVGFEOffsetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEOffsetElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEOffsetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEOffsetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEOffsetElement = "
    if(#var(base) instanceof SVGFEOffsetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEOffsetElement'!\");
"

/// Converts a reference to 'SVGFEOffsetElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::as_element(self: SVGFEOffsetElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEOffsetElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::as_melement(self: mut SVGFEOffsetElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEOffsetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEOffsetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::from_element(base: Element) -> SVGFEOffsetElement = "
    if(#var(base) instanceof SVGFEOffsetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEOffsetElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEOffsetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEOffsetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEOffsetElement::from_melement(base: mut Element) -> mut SVGFEOffsetElement = "
    if(#var(base) instanceof SVGFEOffsetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEOffsetElement'!\");
"

pub ext fun SVGFEOffsetElement::in_1(self: SVGFEOffsetElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFEOffsetElement::dx(self: SVGFEOffsetElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).dx);"

pub ext fun SVGFEOffsetElement::dy(self: SVGFEOffsetElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).dy);"

pub ext fun SVGFEOffsetElement::class_name(self: SVGFEOffsetElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEOffsetElement::owner_svg_element(self: SVGFEOffsetElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEOffsetElement::viewport_element(self: SVGFEOffsetElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEOffsetElement::x(self: SVGFEOffsetElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFEOffsetElement::y(self: SVGFEOffsetElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFEOffsetElement::width(self: SVGFEOffsetElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFEOffsetElement::height(self: SVGFEOffsetElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFEOffsetElement::result(self: SVGFEOffsetElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFEOffsetElement::start_view_transition(__self: mut SVGFEOffsetElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEOffsetElement::start_view_transition_f_prom_unit(__self: mut SVGFEOffsetElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEOffsetElement::start_view_transition_mview_transition_options(__self: mut SVGFEOffsetElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEOffsetElement::as_js(self: SVGFEOffsetElement) -> JsValue = JsValue::unsafe_from[SVGFEOffsetElement](self)

pub fun SVGFEOffsetElement::from_js(v: JsValue) -> mut SVGFEOffsetElement = JsValue::unsafe_as[mut SVGFEOffsetElement](v)

struct SVGFEPointLightElement()

/// Converts a reference to 'SVGFEPointLightElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::as_svg_element(self: SVGFEPointLightElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFEPointLightElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::as_msvg_element(self: mut SVGFEPointLightElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFEPointLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEPointLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::from_svg_element(base: SVGElement) -> SVGFEPointLightElement = "
    if(#var(base) instanceof SVGFEPointLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEPointLightElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFEPointLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEPointLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::from_msvg_element(base: mut SVGElement) -> mut SVGFEPointLightElement = "
    if(#var(base) instanceof SVGFEPointLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFEPointLightElement'!\");
"

/// Converts a reference to 'SVGFEPointLightElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::as_element(self: SVGFEPointLightElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFEPointLightElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::as_melement(self: mut SVGFEPointLightElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFEPointLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEPointLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::from_element(base: Element) -> SVGFEPointLightElement = "
    if(#var(base) instanceof SVGFEPointLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEPointLightElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFEPointLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFEPointLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFEPointLightElement::from_melement(base: mut Element) -> mut SVGFEPointLightElement = "
    if(#var(base) instanceof SVGFEPointLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFEPointLightElement'!\");
"

pub ext fun SVGFEPointLightElement::x(self: SVGFEPointLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).x);"

pub ext fun SVGFEPointLightElement::y(self: SVGFEPointLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).y);"

pub ext fun SVGFEPointLightElement::z(self: SVGFEPointLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).z);"

pub ext fun SVGFEPointLightElement::class_name(self: SVGFEPointLightElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFEPointLightElement::owner_svg_element(self: SVGFEPointLightElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFEPointLightElement::viewport_element(self: SVGFEPointLightElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFEPointLightElement::start_view_transition(__self: mut SVGFEPointLightElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEPointLightElement::start_view_transition_f_prom_unit(__self: mut SVGFEPointLightElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFEPointLightElement::start_view_transition_mview_transition_options(__self: mut SVGFEPointLightElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFEPointLightElement::as_js(self: SVGFEPointLightElement) -> JsValue = JsValue::unsafe_from[SVGFEPointLightElement](self)

pub fun SVGFEPointLightElement::from_js(v: JsValue) -> mut SVGFEPointLightElement = JsValue::unsafe_as[mut SVGFEPointLightElement](v)

struct SVGFESpecularLightingElement()

/// Converts a reference to 'SVGFESpecularLightingElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::as_svg_element(self: SVGFESpecularLightingElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFESpecularLightingElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::as_msvg_element(self: mut SVGFESpecularLightingElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFESpecularLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpecularLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::from_svg_element(base: SVGElement) -> SVGFESpecularLightingElement = "
    if(#var(base) instanceof SVGFESpecularLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFESpecularLightingElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFESpecularLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpecularLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::from_msvg_element(base: mut SVGElement) -> mut SVGFESpecularLightingElement = "
    if(#var(base) instanceof SVGFESpecularLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFESpecularLightingElement'!\");
"

/// Converts a reference to 'SVGFESpecularLightingElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::as_element(self: SVGFESpecularLightingElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFESpecularLightingElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::as_melement(self: mut SVGFESpecularLightingElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFESpecularLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpecularLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::from_element(base: Element) -> SVGFESpecularLightingElement = "
    if(#var(base) instanceof SVGFESpecularLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFESpecularLightingElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFESpecularLightingElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpecularLightingElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpecularLightingElement::from_melement(base: mut Element) -> mut SVGFESpecularLightingElement = "
    if(#var(base) instanceof SVGFESpecularLightingElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFESpecularLightingElement'!\");
"

pub ext fun SVGFESpecularLightingElement::in_1(self: SVGFESpecularLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFESpecularLightingElement::surface_scale(self: SVGFESpecularLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).surfaceScale);"

pub ext fun SVGFESpecularLightingElement::specular_constant(self: SVGFESpecularLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).specularConstant);"

pub ext fun SVGFESpecularLightingElement::specular_exponent(self: SVGFESpecularLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).specularExponent);"

pub ext fun SVGFESpecularLightingElement::kernel_unit_length_x(self: SVGFESpecularLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthX);"

pub ext fun SVGFESpecularLightingElement::kernel_unit_length_y(self: SVGFESpecularLightingElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).kernelUnitLengthY);"

pub ext fun SVGFESpecularLightingElement::class_name(self: SVGFESpecularLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFESpecularLightingElement::owner_svg_element(self: SVGFESpecularLightingElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFESpecularLightingElement::viewport_element(self: SVGFESpecularLightingElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFESpecularLightingElement::x(self: SVGFESpecularLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFESpecularLightingElement::y(self: SVGFESpecularLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFESpecularLightingElement::width(self: SVGFESpecularLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFESpecularLightingElement::height(self: SVGFESpecularLightingElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFESpecularLightingElement::result(self: SVGFESpecularLightingElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFESpecularLightingElement::start_view_transition(__self: mut SVGFESpecularLightingElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFESpecularLightingElement::start_view_transition_f_prom_unit(__self: mut SVGFESpecularLightingElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFESpecularLightingElement::start_view_transition_mview_transition_options(__self: mut SVGFESpecularLightingElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFESpecularLightingElement::as_js(self: SVGFESpecularLightingElement) -> JsValue = JsValue::unsafe_from[SVGFESpecularLightingElement](self)

pub fun SVGFESpecularLightingElement::from_js(v: JsValue) -> mut SVGFESpecularLightingElement = JsValue::unsafe_as[mut SVGFESpecularLightingElement](v)

struct SVGFESpotLightElement()

/// Converts a reference to 'SVGFESpotLightElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::as_svg_element(self: SVGFESpotLightElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFESpotLightElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::as_msvg_element(self: mut SVGFESpotLightElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFESpotLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpotLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::from_svg_element(base: SVGElement) -> SVGFESpotLightElement = "
    if(#var(base) instanceof SVGFESpotLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFESpotLightElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFESpotLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpotLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::from_msvg_element(base: mut SVGElement) -> mut SVGFESpotLightElement = "
    if(#var(base) instanceof SVGFESpotLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFESpotLightElement'!\");
"

/// Converts a reference to 'SVGFESpotLightElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::as_element(self: SVGFESpotLightElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFESpotLightElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::as_melement(self: mut SVGFESpotLightElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFESpotLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpotLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::from_element(base: Element) -> SVGFESpotLightElement = "
    if(#var(base) instanceof SVGFESpotLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFESpotLightElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFESpotLightElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFESpotLightElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFESpotLightElement::from_melement(base: mut Element) -> mut SVGFESpotLightElement = "
    if(#var(base) instanceof SVGFESpotLightElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFESpotLightElement'!\");
"

pub ext fun SVGFESpotLightElement::x(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).x);"

pub ext fun SVGFESpotLightElement::y(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).y);"

pub ext fun SVGFESpotLightElement::z(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).z);"

pub ext fun SVGFESpotLightElement::points_at_x(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pointsAtX);"

pub ext fun SVGFESpotLightElement::points_at_y(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pointsAtY);"

pub ext fun SVGFESpotLightElement::points_at_z(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pointsAtZ);"

pub ext fun SVGFESpotLightElement::specular_exponent(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).specularExponent);"

pub ext fun SVGFESpotLightElement::limiting_cone_angle(self: SVGFESpotLightElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).limitingConeAngle);"

pub ext fun SVGFESpotLightElement::class_name(self: SVGFESpotLightElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFESpotLightElement::owner_svg_element(self: SVGFESpotLightElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFESpotLightElement::viewport_element(self: SVGFESpotLightElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFESpotLightElement::start_view_transition(__self: mut SVGFESpotLightElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFESpotLightElement::start_view_transition_f_prom_unit(__self: mut SVGFESpotLightElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFESpotLightElement::start_view_transition_mview_transition_options(__self: mut SVGFESpotLightElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFESpotLightElement::as_js(self: SVGFESpotLightElement) -> JsValue = JsValue::unsafe_from[SVGFESpotLightElement](self)

pub fun SVGFESpotLightElement::from_js(v: JsValue) -> mut SVGFESpotLightElement = JsValue::unsafe_as[mut SVGFESpotLightElement](v)

struct SVGFETileElement()

/// Converts a reference to 'SVGFETileElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::as_svg_element(self: SVGFETileElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFETileElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::as_msvg_element(self: mut SVGFETileElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFETileElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETileElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::from_svg_element(base: SVGElement) -> SVGFETileElement = "
    if(#var(base) instanceof SVGFETileElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFETileElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFETileElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETileElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::from_msvg_element(base: mut SVGElement) -> mut SVGFETileElement = "
    if(#var(base) instanceof SVGFETileElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFETileElement'!\");
"

/// Converts a reference to 'SVGFETileElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::as_element(self: SVGFETileElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFETileElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::as_melement(self: mut SVGFETileElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFETileElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETileElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::from_element(base: Element) -> SVGFETileElement = "
    if(#var(base) instanceof SVGFETileElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFETileElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFETileElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETileElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETileElement::from_melement(base: mut Element) -> mut SVGFETileElement = "
    if(#var(base) instanceof SVGFETileElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFETileElement'!\");
"

pub ext fun SVGFETileElement::in_1(self: SVGFETileElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).in1);"

pub ext fun SVGFETileElement::class_name(self: SVGFETileElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFETileElement::owner_svg_element(self: SVGFETileElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFETileElement::viewport_element(self: SVGFETileElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFETileElement::x(self: SVGFETileElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFETileElement::y(self: SVGFETileElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFETileElement::width(self: SVGFETileElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFETileElement::height(self: SVGFETileElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFETileElement::result(self: SVGFETileElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFETileElement::start_view_transition(__self: mut SVGFETileElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFETileElement::start_view_transition_f_prom_unit(__self: mut SVGFETileElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFETileElement::start_view_transition_mview_transition_options(__self: mut SVGFETileElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFETileElement::as_js(self: SVGFETileElement) -> JsValue = JsValue::unsafe_from[SVGFETileElement](self)

pub fun SVGFETileElement::from_js(v: JsValue) -> mut SVGFETileElement = JsValue::unsafe_as[mut SVGFETileElement](v)

struct SVGFETurbulenceElement()

/// Converts a reference to 'SVGFETurbulenceElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::as_svg_element(self: SVGFETurbulenceElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFETurbulenceElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::as_msvg_element(self: mut SVGFETurbulenceElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFETurbulenceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETurbulenceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::from_svg_element(base: SVGElement) -> SVGFETurbulenceElement = "
    if(#var(base) instanceof SVGFETurbulenceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFETurbulenceElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFETurbulenceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETurbulenceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::from_msvg_element(base: mut SVGElement) -> mut SVGFETurbulenceElement = "
    if(#var(base) instanceof SVGFETurbulenceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFETurbulenceElement'!\");
"

/// Converts a reference to 'SVGFETurbulenceElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::as_element(self: SVGFETurbulenceElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFETurbulenceElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::as_melement(self: mut SVGFETurbulenceElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFETurbulenceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETurbulenceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::from_element(base: Element) -> SVGFETurbulenceElement = "
    if(#var(base) instanceof SVGFETurbulenceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFETurbulenceElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFETurbulenceElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFETurbulenceElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFETurbulenceElement::from_melement(base: mut Element) -> mut SVGFETurbulenceElement = "
    if(#var(base) instanceof SVGFETurbulenceElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFETurbulenceElement'!\");
"

pub ext fun SVGFETurbulenceElement::base_frequency_x(self: SVGFETurbulenceElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).baseFrequencyX);"

pub ext fun SVGFETurbulenceElement::base_frequency_y(self: SVGFETurbulenceElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).baseFrequencyY);"

pub ext fun SVGFETurbulenceElement::num_octaves(self: SVGFETurbulenceElement) -> mut SVGAnimatedInteger
    = "return #fun(SVGAnimatedInteger::from_js)(#var(self).numOctaves);"

pub ext fun SVGFETurbulenceElement::seed(self: SVGFETurbulenceElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).seed);"

pub ext fun SVGFETurbulenceElement::stitch_tiles(self: SVGFETurbulenceElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).stitchTiles);"

pub ext fun SVGFETurbulenceElement::type(self: SVGFETurbulenceElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).type);"

pub ext fun SVGFETurbulenceElement::class_name(self: SVGFETurbulenceElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFETurbulenceElement::owner_svg_element(self: SVGFETurbulenceElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFETurbulenceElement::viewport_element(self: SVGFETurbulenceElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFETurbulenceElement::x(self: SVGFETurbulenceElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFETurbulenceElement::y(self: SVGFETurbulenceElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFETurbulenceElement::width(self: SVGFETurbulenceElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFETurbulenceElement::height(self: SVGFETurbulenceElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFETurbulenceElement::result(self: SVGFETurbulenceElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).result);"

pub ext fun SVGFETurbulenceElement::start_view_transition(__self: mut SVGFETurbulenceElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFETurbulenceElement::start_view_transition_f_prom_unit(__self: mut SVGFETurbulenceElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFETurbulenceElement::start_view_transition_mview_transition_options(__self: mut SVGFETurbulenceElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFETurbulenceElement::as_js(self: SVGFETurbulenceElement) -> JsValue = JsValue::unsafe_from[SVGFETurbulenceElement](self)

pub fun SVGFETurbulenceElement::from_js(v: JsValue) -> mut SVGFETurbulenceElement = JsValue::unsafe_as[mut SVGFETurbulenceElement](v)

pub val SVGFETurbulenceElement::svg_turbulence_type_unknown: Int = 0
pub val SVGFETurbulenceElement::svg_turbulence_type_fractalnoise: Int = 1
pub val SVGFETurbulenceElement::svg_turbulence_type_turbulence: Int = 2
pub val SVGFETurbulenceElement::svg_stitchtype_unknown: Int = 0
pub val SVGFETurbulenceElement::svg_stitchtype_stitch: Int = 1
pub val SVGFETurbulenceElement::svg_stitchtype_nostitch: Int = 2

struct SVGFilterElement()

/// Converts a reference to 'SVGFilterElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::as_svg_element(self: SVGFilterElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGFilterElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::as_msvg_element(self: mut SVGFilterElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGFilterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFilterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::from_svg_element(base: SVGElement) -> SVGFilterElement = "
    if(#var(base) instanceof SVGFilterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFilterElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGFilterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFilterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::from_msvg_element(base: mut SVGElement) -> mut SVGFilterElement = "
    if(#var(base) instanceof SVGFilterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGFilterElement'!\");
"

/// Converts a reference to 'SVGFilterElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::as_element(self: SVGFilterElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGFilterElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::as_melement(self: mut SVGFilterElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGFilterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFilterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::from_element(base: Element) -> SVGFilterElement = "
    if(#var(base) instanceof SVGFilterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFilterElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGFilterElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGFilterElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGFilterElement::from_melement(base: mut Element) -> mut SVGFilterElement = "
    if(#var(base) instanceof SVGFilterElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGFilterElement'!\");
"

pub ext fun SVGFilterElement::filter_units(self: SVGFilterElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).filterUnits);"

pub ext fun SVGFilterElement::primitive_units(self: SVGFilterElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).primitiveUnits);"

pub ext fun SVGFilterElement::x(self: SVGFilterElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGFilterElement::y(self: SVGFilterElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGFilterElement::width(self: SVGFilterElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGFilterElement::height(self: SVGFilterElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGFilterElement::class_name(self: SVGFilterElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGFilterElement::owner_svg_element(self: SVGFilterElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGFilterElement::viewport_element(self: SVGFilterElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGFilterElement::href(self: SVGFilterElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGFilterElement::start_view_transition(__self: mut SVGFilterElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFilterElement::start_view_transition_f_prom_unit(__self: mut SVGFilterElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGFilterElement::start_view_transition_mview_transition_options(__self: mut SVGFilterElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGFilterElement::as_js(self: SVGFilterElement) -> JsValue = JsValue::unsafe_from[SVGFilterElement](self)

pub fun SVGFilterElement::from_js(v: JsValue) -> mut SVGFilterElement = JsValue::unsafe_as[mut SVGFilterElement](v)

struct SVGForeignObjectElement()

/// Converts a reference to 'SVGForeignObjectElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_svg_graphics_element(self: SVGForeignObjectElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGForeignObjectElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_msvg_graphics_element(self: mut SVGForeignObjectElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGForeignObjectElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGForeignObjectElement'!\");
"

/// Converts a reference to 'SVGForeignObjectElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_svg_element(self: SVGForeignObjectElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGForeignObjectElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_msvg_element(self: mut SVGForeignObjectElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_svg_element(base: SVGElement) -> SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGForeignObjectElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_msvg_element(base: mut SVGElement) -> mut SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGForeignObjectElement'!\");
"

/// Converts a reference to 'SVGForeignObjectElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_element(self: SVGForeignObjectElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGForeignObjectElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::as_melement(self: mut SVGForeignObjectElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_element(base: Element) -> SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGForeignObjectElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGForeignObjectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGForeignObjectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGForeignObjectElement::from_melement(base: mut Element) -> mut SVGForeignObjectElement = "
    if(#var(base) instanceof SVGForeignObjectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGForeignObjectElement'!\");
"

pub ext fun SVGForeignObjectElement::x(self: SVGForeignObjectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGForeignObjectElement::y(self: SVGForeignObjectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGForeignObjectElement::width(self: SVGForeignObjectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGForeignObjectElement::height(self: SVGForeignObjectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGForeignObjectElement::transform(self: SVGForeignObjectElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGForeignObjectElement::nearest_viewport_element(self: SVGForeignObjectElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGForeignObjectElement::farthest_viewport_element(self: SVGForeignObjectElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGForeignObjectElement::class_name(self: SVGForeignObjectElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGForeignObjectElement::owner_svg_element(self: SVGForeignObjectElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGForeignObjectElement::viewport_element(self: SVGForeignObjectElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGForeignObjectElement::get_b_box(__self: mut SVGForeignObjectElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGForeignObjectElement::get_ctm(__self: mut SVGForeignObjectElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGForeignObjectElement::get_screen_ctm(__self: mut SVGForeignObjectElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGForeignObjectElement::start_view_transition(__self: mut SVGForeignObjectElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGForeignObjectElement::start_view_transition_f_prom_unit(__self: mut SVGForeignObjectElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGForeignObjectElement::start_view_transition_mview_transition_options(__self: mut SVGForeignObjectElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGForeignObjectElement::as_js(self: SVGForeignObjectElement) -> JsValue = JsValue::unsafe_from[SVGForeignObjectElement](self)

pub fun SVGForeignObjectElement::from_js(v: JsValue) -> mut SVGForeignObjectElement = JsValue::unsafe_as[mut SVGForeignObjectElement](v)

struct SVGGElement()

/// Converts a reference to 'SVGGElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_svg_graphics_element(self: SVGGElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_msvg_graphics_element(self: mut SVGGElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGGElement'!\");
"

/// Converts a reference to 'SVGGElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_svg_element(self: SVGGElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_msvg_element(self: mut SVGGElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_svg_element(base: SVGElement) -> SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_msvg_element(base: mut SVGElement) -> mut SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGElement'!\");
"

/// Converts a reference to 'SVGGElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_element(self: SVGGElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGGElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::as_melement(self: mut SVGGElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_element(base: Element) -> SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGElement::from_melement(base: mut Element) -> mut SVGGElement = "
    if(#var(base) instanceof SVGGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGElement'!\");
"

pub ext fun SVGGElement::transform(self: SVGGElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGGElement::nearest_viewport_element(self: SVGGElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGGElement::farthest_viewport_element(self: SVGGElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGGElement::class_name(self: SVGGElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGGElement::owner_svg_element(self: SVGGElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGGElement::viewport_element(self: SVGGElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGGElement::get_b_box(__self: mut SVGGElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGGElement::get_ctm(__self: mut SVGGElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGElement::get_screen_ctm(__self: mut SVGGElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGElement::start_view_transition(__self: mut SVGGElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGElement::start_view_transition_f_prom_unit(__self: mut SVGGElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGElement::start_view_transition_mview_transition_options(__self: mut SVGGElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGGElement::as_js(self: SVGGElement) -> JsValue = JsValue::unsafe_from[SVGGElement](self)

pub fun SVGGElement::from_js(v: JsValue) -> mut SVGGElement = JsValue::unsafe_as[mut SVGGElement](v)

struct SVGGeometryElement()

/// Converts a reference to 'SVGGeometryElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_svg_graphics_element(self: SVGGeometryElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_msvg_graphics_element(self: mut SVGGeometryElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGGeometryElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGGeometryElement'!\");
"

/// Converts a reference to 'SVGGeometryElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_svg_element(self: SVGGeometryElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_msvg_element(self: mut SVGGeometryElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_svg_element(base: SVGElement) -> SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGeometryElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_msvg_element(base: mut SVGElement) -> mut SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGeometryElement'!\");
"

/// Converts a reference to 'SVGGeometryElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_element(self: SVGGeometryElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGGeometryElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::as_melement(self: mut SVGGeometryElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_element(base: Element) -> SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGeometryElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGGeometryElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGeometryElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGeometryElement::from_melement(base: mut Element) -> mut SVGGeometryElement = "
    if(#var(base) instanceof SVGGeometryElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGeometryElement'!\");
"

pub ext fun SVGGeometryElement::path_length(self: SVGGeometryElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGGeometryElement::transform(self: SVGGeometryElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGGeometryElement::nearest_viewport_element(self: SVGGeometryElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGGeometryElement::farthest_viewport_element(self: SVGGeometryElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGGeometryElement::class_name(self: SVGGeometryElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGGeometryElement::owner_svg_element(self: SVGGeometryElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGGeometryElement::viewport_element(self: SVGGeometryElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGGeometryElement::is_point_in_fill(__self: mut SVGGeometryElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGGeometryElement::is_point_in_stroke(__self: mut SVGGeometryElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGGeometryElement::get_total_length(__self: mut SVGGeometryElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGGeometryElement::get_point_at_length(__self: mut SVGGeometryElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGGeometryElement::get_b_box(__self: mut SVGGeometryElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGGeometryElement::get_ctm(__self: mut SVGGeometryElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGeometryElement::get_screen_ctm(__self: mut SVGGeometryElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGeometryElement::start_view_transition(__self: mut SVGGeometryElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGeometryElement::start_view_transition_f_prom_unit(__self: mut SVGGeometryElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGeometryElement::start_view_transition_mview_transition_options(__self: mut SVGGeometryElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGGeometryElement::as_js(self: SVGGeometryElement) -> JsValue = JsValue::unsafe_from[SVGGeometryElement](self)

pub fun SVGGeometryElement::from_js(v: JsValue) -> mut SVGGeometryElement = JsValue::unsafe_as[mut SVGGeometryElement](v)

struct SVGGradientElement()

/// Converts a reference to 'SVGGradientElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::as_svg_element(self: SVGGradientElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGradientElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::as_msvg_element(self: mut SVGGradientElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::from_svg_element(base: SVGElement) -> SVGGradientElement = "
    if(#var(base) instanceof SVGGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::from_msvg_element(base: mut SVGElement) -> mut SVGGradientElement = "
    if(#var(base) instanceof SVGGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGradientElement'!\");
"

/// Converts a reference to 'SVGGradientElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::as_element(self: SVGGradientElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGGradientElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::as_melement(self: mut SVGGradientElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::from_element(base: Element) -> SVGGradientElement = "
    if(#var(base) instanceof SVGGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGradientElement::from_melement(base: mut Element) -> mut SVGGradientElement = "
    if(#var(base) instanceof SVGGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGradientElement'!\");
"

pub ext fun SVGGradientElement::gradient_units(self: SVGGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).gradientUnits);"

pub ext fun SVGGradientElement::gradient_transform(self: SVGGradientElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).gradientTransform);"

pub ext fun SVGGradientElement::spread_method(self: SVGGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).spreadMethod);"

pub ext fun SVGGradientElement::class_name(self: SVGGradientElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGGradientElement::owner_svg_element(self: SVGGradientElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGGradientElement::viewport_element(self: SVGGradientElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGGradientElement::href(self: SVGGradientElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGGradientElement::start_view_transition(__self: mut SVGGradientElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGradientElement::start_view_transition_f_prom_unit(__self: mut SVGGradientElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGradientElement::start_view_transition_mview_transition_options(__self: mut SVGGradientElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGGradientElement::as_js(self: SVGGradientElement) -> JsValue = JsValue::unsafe_from[SVGGradientElement](self)

pub fun SVGGradientElement::from_js(v: JsValue) -> mut SVGGradientElement = JsValue::unsafe_as[mut SVGGradientElement](v)

pub val SVGGradientElement::svg_spreadmethod_unknown: Int = 0
pub val SVGGradientElement::svg_spreadmethod_pad: Int = 1
pub val SVGGradientElement::svg_spreadmethod_reflect: Int = 2
pub val SVGGradientElement::svg_spreadmethod_repeat: Int = 3

struct SVGGraphicsElement()

/// Converts a reference to 'SVGGraphicsElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::as_svg_element(self: SVGGraphicsElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::as_msvg_element(self: mut SVGGraphicsElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGGraphicsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGraphicsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::from_svg_element(base: SVGElement) -> SVGGraphicsElement = "
    if(#var(base) instanceof SVGGraphicsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGraphicsElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGGraphicsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGraphicsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::from_msvg_element(base: mut SVGElement) -> mut SVGGraphicsElement = "
    if(#var(base) instanceof SVGGraphicsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGGraphicsElement'!\");
"

/// Converts a reference to 'SVGGraphicsElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::as_element(self: SVGGraphicsElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::as_melement(self: mut SVGGraphicsElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGGraphicsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGraphicsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::from_element(base: Element) -> SVGGraphicsElement = "
    if(#var(base) instanceof SVGGraphicsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGraphicsElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGGraphicsElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGGraphicsElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGGraphicsElement::from_melement(base: mut Element) -> mut SVGGraphicsElement = "
    if(#var(base) instanceof SVGGraphicsElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGGraphicsElement'!\");
"

pub ext fun SVGGraphicsElement::transform(self: SVGGraphicsElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGGraphicsElement::nearest_viewport_element(self: SVGGraphicsElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGGraphicsElement::farthest_viewport_element(self: SVGGraphicsElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGGraphicsElement::class_name(self: SVGGraphicsElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGGraphicsElement::owner_svg_element(self: SVGGraphicsElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGGraphicsElement::viewport_element(self: SVGGraphicsElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGGraphicsElement::required_extensions(self: SVGGraphicsElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).requiredExtensions);"

pub ext fun SVGGraphicsElement::system_language(self: SVGGraphicsElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).systemLanguage);"

pub ext fun SVGGraphicsElement::get_b_box(__self: mut SVGGraphicsElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGGraphicsElement::get_ctm(__self: mut SVGGraphicsElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGraphicsElement::get_screen_ctm(__self: mut SVGGraphicsElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGGraphicsElement::start_view_transition(__self: mut SVGGraphicsElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGraphicsElement::start_view_transition_f_prom_unit(__self: mut SVGGraphicsElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGGraphicsElement::start_view_transition_mview_transition_options(__self: mut SVGGraphicsElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGGraphicsElement::as_js(self: SVGGraphicsElement) -> JsValue = JsValue::unsafe_from[SVGGraphicsElement](self)

pub fun SVGGraphicsElement::from_js(v: JsValue) -> mut SVGGraphicsElement = JsValue::unsafe_as[mut SVGGraphicsElement](v)

struct SVGImageElement()

/// Converts a reference to 'SVGImageElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_svg_graphics_element(self: SVGImageElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGImageElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_msvg_graphics_element(self: mut SVGImageElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGImageElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGImageElement'!\");
"

/// Converts a reference to 'SVGImageElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_svg_element(self: SVGImageElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGImageElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_msvg_element(self: mut SVGImageElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_svg_element(base: SVGElement) -> SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGImageElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_msvg_element(base: mut SVGElement) -> mut SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGImageElement'!\");
"

/// Converts a reference to 'SVGImageElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_element(self: SVGImageElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGImageElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::as_melement(self: mut SVGImageElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_element(base: Element) -> SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGImageElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGImageElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGImageElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGImageElement::from_melement(base: mut Element) -> mut SVGImageElement = "
    if(#var(base) instanceof SVGImageElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGImageElement'!\");
"

pub ext fun SVGImageElement::x(self: SVGImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGImageElement::y(self: SVGImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGImageElement::width(self: SVGImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGImageElement::height(self: SVGImageElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGImageElement::preserve_aspect_ratio(self: SVGImageElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGImageElement::decoding(self: SVGImageElement) -> String
    = "return #fun(String::from_js)(#var(self).decoding);"

pub ext fun SVGImageElement::set_decoding(self: mut SVGImageElement, value: String)
    = "#var(self).decoding = #fun(String::as_js)(#var(value));"

pub ext fun SVGImageElement::cross_origin(self: SVGImageElement) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).crossOrigin);"

pub ext fun SVGImageElement::set_cross_origin(self: mut SVGImageElement, value: Option[String])
    = "#var(self).crossOrigin = #fun(Option::as_js[String])(#var(value));"

pub ext fun SVGImageElement::transform(self: SVGImageElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGImageElement::nearest_viewport_element(self: SVGImageElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGImageElement::farthest_viewport_element(self: SVGImageElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGImageElement::class_name(self: SVGImageElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGImageElement::owner_svg_element(self: SVGImageElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGImageElement::viewport_element(self: SVGImageElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGImageElement::href(self: SVGImageElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGImageElement::decode(__self: mut SVGImageElement) -> Promise[Unit] = "
    const r = #var(__self).decode();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun SVGImageElement::get_b_box(__self: mut SVGImageElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGImageElement::get_ctm(__self: mut SVGImageElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGImageElement::get_screen_ctm(__self: mut SVGImageElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGImageElement::start_view_transition(__self: mut SVGImageElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGImageElement::start_view_transition_f_prom_unit(__self: mut SVGImageElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGImageElement::start_view_transition_mview_transition_options(__self: mut SVGImageElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGImageElement::as_js(self: SVGImageElement) -> JsValue = JsValue::unsafe_from[SVGImageElement](self)

pub fun SVGImageElement::from_js(v: JsValue) -> mut SVGImageElement = JsValue::unsafe_as[mut SVGImageElement](v)

struct SVGLength()

pub ext fun SVGLength::unit_type(self: SVGLength) -> Int
    = "return #fun(Int::from_js)(#var(self).unitType);"

pub ext fun SVGLength::value(self: SVGLength) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun SVGLength::set_value(self: mut SVGLength, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub ext fun SVGLength::value_in_specified_units(self: SVGLength) -> Float
    = "return #fun(Float::from_js)(#var(self).valueInSpecifiedUnits);"

pub ext fun SVGLength::set_value_in_specified_units(self: mut SVGLength, value: Float)
    = "#var(self).valueInSpecifiedUnits = #fun(Float::as_js)(#var(value));"

pub ext fun SVGLength::value_as_string(self: SVGLength) -> String
    = "return #fun(String::from_js)(#var(self).valueAsString);"

pub ext fun SVGLength::set_value_as_string(self: mut SVGLength, value: String)
    = "#var(self).valueAsString = #fun(String::as_js)(#var(value));"

pub ext fun SVGLength::new_value_specified_units(__self: mut SVGLength, unit_type: Int, value_in_specified_units: Float) -> Unit = "
    const r = #var(__self).newValueSpecifiedUnits(#fun(Int::as_js)(#var(unit_type)), #fun(Float::as_js)(#var(value_in_specified_units)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGLength::convert_to_specified_units(__self: mut SVGLength, unit_type: Int) -> Unit = "
    const r = #var(__self).convertToSpecifiedUnits(#fun(Int::as_js)(#var(unit_type)));
    return #fun(Unit::from_js)(r);
"

pub fun SVGLength::as_js(self: SVGLength) -> JsValue = JsValue::unsafe_from[SVGLength](self)

pub fun SVGLength::from_js(v: JsValue) -> mut SVGLength = JsValue::unsafe_as[mut SVGLength](v)

pub val SVGLength::svg_lengthtype_unknown: Int = 0
pub val SVGLength::svg_lengthtype_number: Int = 1
pub val SVGLength::svg_lengthtype_percentage: Int = 2
pub val SVGLength::svg_lengthtype_ems: Int = 3
pub val SVGLength::svg_lengthtype_exs: Int = 4
pub val SVGLength::svg_lengthtype_px: Int = 5
pub val SVGLength::svg_lengthtype_cm: Int = 6
pub val SVGLength::svg_lengthtype_mm: Int = 7
pub val SVGLength::svg_lengthtype_in: Int = 8
pub val SVGLength::svg_lengthtype_pt: Int = 9
pub val SVGLength::svg_lengthtype_pc: Int = 10

struct SVGLengthList()

pub ext fun SVGLengthList::length(self: SVGLengthList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun SVGLengthList::number_of_items(self: SVGLengthList) -> Int
    = "return #fun(Int::from_js)(#var(self).numberOfItems);"

pub ext fun SVGLengthList::clear(__self: mut SVGLengthList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGLengthList::initialize(__self: mut SVGLengthList, new_item: mut SVGLength) -> mut SVGLength = "
    const r = #var(__self).initialize(#fun(SVGLength::as_js)(#var(new_item)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::get_item(__self: mut SVGLengthList, index: Int) -> mut SVGLength = "
    const r = #var(__self).getItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::insert_item_before(__self: mut SVGLengthList, new_item: mut SVGLength, index: Int) -> mut SVGLength = "
    const r = #var(__self).insertItemBefore(#fun(SVGLength::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::replace_item(__self: mut SVGLengthList, new_item: mut SVGLength, index: Int) -> mut SVGLength = "
    const r = #var(__self).replaceItem(#fun(SVGLength::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::remove_item(__self: mut SVGLengthList, index: Int) -> mut SVGLength = "
    const r = #var(__self).removeItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::append_item(__self: mut SVGLengthList, new_item: mut SVGLength) -> mut SVGLength = "
    const r = #var(__self).appendItem(#fun(SVGLength::as_js)(#var(new_item)));
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGLengthList::set(__self: mut SVGLengthList, index: Int, new_item: mut SVGLength) = "
    SVGLengthList[#fun(Int::as_js)(#var(index))] = #fun(SVGLength::as_js)(#var(new_item));
"

pub fun SVGLengthList::as_js(self: SVGLengthList) -> JsValue = JsValue::unsafe_from[SVGLengthList](self)

pub fun SVGLengthList::from_js(v: JsValue) -> mut SVGLengthList = JsValue::unsafe_as[mut SVGLengthList](v)

struct SVGLineElement()

/// Converts a reference to 'SVGLineElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_svg_geometry_element(self: SVGLineElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGLineElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_msvg_geometry_element(self: mut SVGLineElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGLineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGLineElement'!\");
"

/// Converts a reference to 'SVGLineElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_svg_graphics_element(self: SVGLineElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGLineElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_msvg_graphics_element(self: mut SVGLineElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGLineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGLineElement'!\");
"

/// Converts a reference to 'SVGLineElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_svg_element(self: SVGLineElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGLineElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_msvg_element(self: mut SVGLineElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_svg_element(base: SVGElement) -> SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGLineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_msvg_element(base: mut SVGElement) -> mut SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGLineElement'!\");
"

/// Converts a reference to 'SVGLineElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_element(self: SVGLineElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGLineElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::as_melement(self: mut SVGLineElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_element(base: Element) -> SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGLineElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGLineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLineElement::from_melement(base: mut Element) -> mut SVGLineElement = "
    if(#var(base) instanceof SVGLineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGLineElement'!\");
"

pub ext fun SVGLineElement::x_1(self: SVGLineElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x1);"

pub ext fun SVGLineElement::y_1(self: SVGLineElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y1);"

pub ext fun SVGLineElement::x_2(self: SVGLineElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x2);"

pub ext fun SVGLineElement::y_2(self: SVGLineElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y2);"

pub ext fun SVGLineElement::path_length(self: SVGLineElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGLineElement::transform(self: SVGLineElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGLineElement::nearest_viewport_element(self: SVGLineElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGLineElement::farthest_viewport_element(self: SVGLineElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGLineElement::class_name(self: SVGLineElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGLineElement::owner_svg_element(self: SVGLineElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGLineElement::viewport_element(self: SVGLineElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGLineElement::is_point_in_fill(__self: mut SVGLineElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGLineElement::is_point_in_stroke(__self: mut SVGLineElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGLineElement::get_total_length(__self: mut SVGLineElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGLineElement::get_point_at_length(__self: mut SVGLineElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGLineElement::get_b_box(__self: mut SVGLineElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGLineElement::get_ctm(__self: mut SVGLineElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGLineElement::get_screen_ctm(__self: mut SVGLineElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGLineElement::start_view_transition(__self: mut SVGLineElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGLineElement::start_view_transition_f_prom_unit(__self: mut SVGLineElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGLineElement::start_view_transition_mview_transition_options(__self: mut SVGLineElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGLineElement::as_js(self: SVGLineElement) -> JsValue = JsValue::unsafe_from[SVGLineElement](self)

pub fun SVGLineElement::from_js(v: JsValue) -> mut SVGLineElement = JsValue::unsafe_as[mut SVGLineElement](v)

struct SVGLinearGradientElement()

/// Converts a reference to 'SVGLinearGradientElement' to a reference to 'SVGGradientElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_svg_gradient_element(self: SVGLinearGradientElement) -> SVGGradientElement = "return #var(self);"

/// Converts a mutable reference to 'SVGLinearGradientElement' to a mutable reference to 'SVGGradientElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_msvg_gradient_element(self: mut SVGLinearGradientElement) -> mut SVGGradientElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGradientElement' to a reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_svg_gradient_element(base: SVGGradientElement) -> SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGradientElement' to 'SVGLinearGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGradientElement' to a mutable reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_msvg_gradient_element(base: mut SVGGradientElement) -> mut SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGradientElement' to 'SVGLinearGradientElement'!\");
"

/// Converts a reference to 'SVGLinearGradientElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_svg_element(self: SVGLinearGradientElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGLinearGradientElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_msvg_element(self: mut SVGLinearGradientElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_svg_element(base: SVGElement) -> SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGLinearGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_msvg_element(base: mut SVGElement) -> mut SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGLinearGradientElement'!\");
"

/// Converts a reference to 'SVGLinearGradientElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_element(self: SVGLinearGradientElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGLinearGradientElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::as_melement(self: mut SVGLinearGradientElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_element(base: Element) -> SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGLinearGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGLinearGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGLinearGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGLinearGradientElement::from_melement(base: mut Element) -> mut SVGLinearGradientElement = "
    if(#var(base) instanceof SVGLinearGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGLinearGradientElement'!\");
"

pub ext fun SVGLinearGradientElement::x_1(self: SVGLinearGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x1);"

pub ext fun SVGLinearGradientElement::y_1(self: SVGLinearGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y1);"

pub ext fun SVGLinearGradientElement::x_2(self: SVGLinearGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x2);"

pub ext fun SVGLinearGradientElement::y_2(self: SVGLinearGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y2);"

pub ext fun SVGLinearGradientElement::gradient_units(self: SVGLinearGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).gradientUnits);"

pub ext fun SVGLinearGradientElement::gradient_transform(self: SVGLinearGradientElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).gradientTransform);"

pub ext fun SVGLinearGradientElement::spread_method(self: SVGLinearGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).spreadMethod);"

pub ext fun SVGLinearGradientElement::class_name(self: SVGLinearGradientElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGLinearGradientElement::owner_svg_element(self: SVGLinearGradientElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGLinearGradientElement::viewport_element(self: SVGLinearGradientElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGLinearGradientElement::start_view_transition(__self: mut SVGLinearGradientElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGLinearGradientElement::start_view_transition_f_prom_unit(__self: mut SVGLinearGradientElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGLinearGradientElement::start_view_transition_mview_transition_options(__self: mut SVGLinearGradientElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGLinearGradientElement::as_js(self: SVGLinearGradientElement) -> JsValue = JsValue::unsafe_from[SVGLinearGradientElement](self)

pub fun SVGLinearGradientElement::from_js(v: JsValue) -> mut SVGLinearGradientElement = JsValue::unsafe_as[mut SVGLinearGradientElement](v)

pub val SVGLinearGradientElement::svg_spreadmethod_unknown: Int = 0
pub val SVGLinearGradientElement::svg_spreadmethod_pad: Int = 1
pub val SVGLinearGradientElement::svg_spreadmethod_reflect: Int = 2
pub val SVGLinearGradientElement::svg_spreadmethod_repeat: Int = 3

struct SVGMarkerElement()

/// Converts a reference to 'SVGMarkerElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::as_svg_element(self: SVGMarkerElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGMarkerElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::as_msvg_element(self: mut SVGMarkerElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGMarkerElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMarkerElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::from_svg_element(base: SVGElement) -> SVGMarkerElement = "
    if(#var(base) instanceof SVGMarkerElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMarkerElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGMarkerElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMarkerElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::from_msvg_element(base: mut SVGElement) -> mut SVGMarkerElement = "
    if(#var(base) instanceof SVGMarkerElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMarkerElement'!\");
"

/// Converts a reference to 'SVGMarkerElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::as_element(self: SVGMarkerElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGMarkerElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::as_melement(self: mut SVGMarkerElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGMarkerElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMarkerElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::from_element(base: Element) -> SVGMarkerElement = "
    if(#var(base) instanceof SVGMarkerElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMarkerElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGMarkerElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMarkerElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMarkerElement::from_melement(base: mut Element) -> mut SVGMarkerElement = "
    if(#var(base) instanceof SVGMarkerElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMarkerElement'!\");
"

pub ext fun SVGMarkerElement::ref_x(self: SVGMarkerElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).refX);"

pub ext fun SVGMarkerElement::ref_y(self: SVGMarkerElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).refY);"

pub ext fun SVGMarkerElement::marker_units(self: SVGMarkerElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).markerUnits);"

pub ext fun SVGMarkerElement::marker_width(self: SVGMarkerElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).markerWidth);"

pub ext fun SVGMarkerElement::marker_height(self: SVGMarkerElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).markerHeight);"

pub ext fun SVGMarkerElement::orient_type(self: SVGMarkerElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).orientType);"

pub ext fun SVGMarkerElement::orient_angle(self: SVGMarkerElement) -> mut SVGAnimatedAngle
    = "return #fun(SVGAnimatedAngle::from_js)(#var(self).orientAngle);"

pub ext fun SVGMarkerElement::class_name(self: SVGMarkerElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGMarkerElement::owner_svg_element(self: SVGMarkerElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGMarkerElement::viewport_element(self: SVGMarkerElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGMarkerElement::view_box(self: SVGMarkerElement) -> mut SVGAnimatedRect
    = "return #fun(SVGAnimatedRect::from_js)(#var(self).viewBox);"

pub ext fun SVGMarkerElement::preserve_aspect_ratio(self: SVGMarkerElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGMarkerElement::set_orient_to_auto(__self: mut SVGMarkerElement) -> Unit = "
    const r = #var(__self).setOrientToAuto();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGMarkerElement::set_orient_to_angle(__self: mut SVGMarkerElement, angle: mut SVGAngle) -> Unit = "
    const r = #var(__self).setOrientToAngle(#fun(SVGAngle::as_js)(#var(angle)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGMarkerElement::start_view_transition(__self: mut SVGMarkerElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMarkerElement::start_view_transition_f_prom_unit(__self: mut SVGMarkerElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMarkerElement::start_view_transition_mview_transition_options(__self: mut SVGMarkerElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGMarkerElement::as_js(self: SVGMarkerElement) -> JsValue = JsValue::unsafe_from[SVGMarkerElement](self)

pub fun SVGMarkerElement::from_js(v: JsValue) -> mut SVGMarkerElement = JsValue::unsafe_as[mut SVGMarkerElement](v)

pub val SVGMarkerElement::svg_markerunits_unknown: Int = 0
pub val SVGMarkerElement::svg_markerunits_userspaceonuse: Int = 1
pub val SVGMarkerElement::svg_markerunits_strokewidth: Int = 2
pub val SVGMarkerElement::svg_marker_orient_unknown: Int = 0
pub val SVGMarkerElement::svg_marker_orient_auto: Int = 1
pub val SVGMarkerElement::svg_marker_orient_angle: Int = 2

struct SVGMaskElement()

/// Converts a reference to 'SVGMaskElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::as_svg_element(self: SVGMaskElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGMaskElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::as_msvg_element(self: mut SVGMaskElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGMaskElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMaskElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::from_svg_element(base: SVGElement) -> SVGMaskElement = "
    if(#var(base) instanceof SVGMaskElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMaskElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGMaskElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMaskElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::from_msvg_element(base: mut SVGElement) -> mut SVGMaskElement = "
    if(#var(base) instanceof SVGMaskElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMaskElement'!\");
"

/// Converts a reference to 'SVGMaskElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::as_element(self: SVGMaskElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGMaskElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::as_melement(self: mut SVGMaskElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGMaskElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMaskElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::from_element(base: Element) -> SVGMaskElement = "
    if(#var(base) instanceof SVGMaskElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMaskElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGMaskElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMaskElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMaskElement::from_melement(base: mut Element) -> mut SVGMaskElement = "
    if(#var(base) instanceof SVGMaskElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMaskElement'!\");
"

pub ext fun SVGMaskElement::mask_units(self: SVGMaskElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).maskUnits);"

pub ext fun SVGMaskElement::mask_content_units(self: SVGMaskElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).maskContentUnits);"

pub ext fun SVGMaskElement::x(self: SVGMaskElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGMaskElement::y(self: SVGMaskElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGMaskElement::width(self: SVGMaskElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGMaskElement::height(self: SVGMaskElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGMaskElement::class_name(self: SVGMaskElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGMaskElement::owner_svg_element(self: SVGMaskElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGMaskElement::viewport_element(self: SVGMaskElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGMaskElement::required_extensions(self: SVGMaskElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).requiredExtensions);"

pub ext fun SVGMaskElement::system_language(self: SVGMaskElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).systemLanguage);"

pub ext fun SVGMaskElement::start_view_transition(__self: mut SVGMaskElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMaskElement::start_view_transition_f_prom_unit(__self: mut SVGMaskElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMaskElement::start_view_transition_mview_transition_options(__self: mut SVGMaskElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGMaskElement::as_js(self: SVGMaskElement) -> JsValue = JsValue::unsafe_from[SVGMaskElement](self)

pub fun SVGMaskElement::from_js(v: JsValue) -> mut SVGMaskElement = JsValue::unsafe_as[mut SVGMaskElement](v)

struct SVGMatrix()

pub ext fun SVGMatrix::a(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).a);"

pub ext fun SVGMatrix::set_a(self: mut SVGMatrix, value: Float)
    = "#var(self).a = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::b(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).b);"

pub ext fun SVGMatrix::set_b(self: mut SVGMatrix, value: Float)
    = "#var(self).b = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::c(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).c);"

pub ext fun SVGMatrix::set_c(self: mut SVGMatrix, value: Float)
    = "#var(self).c = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::d(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).d);"

pub ext fun SVGMatrix::set_d(self: mut SVGMatrix, value: Float)
    = "#var(self).d = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::e(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).e);"

pub ext fun SVGMatrix::set_e(self: mut SVGMatrix, value: Float)
    = "#var(self).e = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::f(self: SVGMatrix) -> Float
    = "return #fun(Float::from_js)(#var(self).f);"

pub ext fun SVGMatrix::set_f(self: mut SVGMatrix, value: Float)
    = "#var(self).f = #fun(Float::as_js)(#var(value));"

pub ext fun SVGMatrix::multiply(__self: mut SVGMatrix, second_matrix: mut SVGMatrix) -> mut SVGMatrix = "
    const r = #var(__self).multiply(#fun(SVGMatrix::as_js)(#var(second_matrix)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::inverse(__self: mut SVGMatrix) -> mut SVGMatrix = "
    const r = #var(__self).inverse();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::translate(__self: mut SVGMatrix, x: Float, y: Float) -> mut SVGMatrix = "
    const r = #var(__self).translate(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::scale(__self: mut SVGMatrix, scale_factor: Float) -> mut SVGMatrix = "
    const r = #var(__self).scale(#fun(Float::as_js)(#var(scale_factor)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::scale_non_uniform(__self: mut SVGMatrix, scale_factor_x: Float, scale_factor_y: Float) -> mut SVGMatrix = "
    const r = #var(__self).scaleNonUniform(#fun(Float::as_js)(#var(scale_factor_x)), #fun(Float::as_js)(#var(scale_factor_y)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::rotate(__self: mut SVGMatrix, angle: Float) -> mut SVGMatrix = "
    const r = #var(__self).rotate(#fun(Float::as_js)(#var(angle)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::rotate_from_vector(__self: mut SVGMatrix, x: Float, y: Float) -> mut SVGMatrix = "
    const r = #var(__self).rotateFromVector(#fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::flip_x(__self: mut SVGMatrix) -> mut SVGMatrix = "
    const r = #var(__self).flipX();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::flip_y(__self: mut SVGMatrix) -> mut SVGMatrix = "
    const r = #var(__self).flipY();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::skew_x(__self: mut SVGMatrix, angle: Float) -> mut SVGMatrix = "
    const r = #var(__self).skewX(#fun(Float::as_js)(#var(angle)));
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGMatrix::skew_y(__self: mut SVGMatrix, angle: Float) -> mut SVGMatrix = "
    const r = #var(__self).skewY(#fun(Float::as_js)(#var(angle)));
    return #fun(SVGMatrix::from_js)(r);
"

pub fun SVGMatrix::as_js(self: SVGMatrix) -> JsValue = JsValue::unsafe_from[SVGMatrix](self)

pub fun SVGMatrix::from_js(v: JsValue) -> mut SVGMatrix = JsValue::unsafe_as[mut SVGMatrix](v)

struct SVGMetadataElement()

/// Converts a reference to 'SVGMetadataElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::as_svg_element(self: SVGMetadataElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGMetadataElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::as_msvg_element(self: mut SVGMetadataElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGMetadataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMetadataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::from_svg_element(base: SVGElement) -> SVGMetadataElement = "
    if(#var(base) instanceof SVGMetadataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMetadataElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGMetadataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMetadataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::from_msvg_element(base: mut SVGElement) -> mut SVGMetadataElement = "
    if(#var(base) instanceof SVGMetadataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMetadataElement'!\");
"

/// Converts a reference to 'SVGMetadataElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::as_element(self: SVGMetadataElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGMetadataElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::as_melement(self: mut SVGMetadataElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGMetadataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMetadataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::from_element(base: Element) -> SVGMetadataElement = "
    if(#var(base) instanceof SVGMetadataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMetadataElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGMetadataElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMetadataElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMetadataElement::from_melement(base: mut Element) -> mut SVGMetadataElement = "
    if(#var(base) instanceof SVGMetadataElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMetadataElement'!\");
"

pub ext fun SVGMetadataElement::class_name(self: SVGMetadataElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGMetadataElement::owner_svg_element(self: SVGMetadataElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGMetadataElement::viewport_element(self: SVGMetadataElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGMetadataElement::start_view_transition(__self: mut SVGMetadataElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMetadataElement::start_view_transition_f_prom_unit(__self: mut SVGMetadataElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMetadataElement::start_view_transition_mview_transition_options(__self: mut SVGMetadataElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGMetadataElement::as_js(self: SVGMetadataElement) -> JsValue = JsValue::unsafe_from[SVGMetadataElement](self)

pub fun SVGMetadataElement::from_js(v: JsValue) -> mut SVGMetadataElement = JsValue::unsafe_as[mut SVGMetadataElement](v)

struct SVGMPathElement()

/// Converts a reference to 'SVGMPathElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::as_svg_element(self: SVGMPathElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGMPathElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::as_msvg_element(self: mut SVGMPathElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGMPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::from_svg_element(base: SVGElement) -> SVGMPathElement = "
    if(#var(base) instanceof SVGMPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGMPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::from_msvg_element(base: mut SVGElement) -> mut SVGMPathElement = "
    if(#var(base) instanceof SVGMPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGMPathElement'!\");
"

/// Converts a reference to 'SVGMPathElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::as_element(self: SVGMPathElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGMPathElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::as_melement(self: mut SVGMPathElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGMPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::from_element(base: Element) -> SVGMPathElement = "
    if(#var(base) instanceof SVGMPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMPathElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGMPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGMPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGMPathElement::from_melement(base: mut Element) -> mut SVGMPathElement = "
    if(#var(base) instanceof SVGMPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGMPathElement'!\");
"

pub ext fun SVGMPathElement::class_name(self: SVGMPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGMPathElement::owner_svg_element(self: SVGMPathElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGMPathElement::viewport_element(self: SVGMPathElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGMPathElement::href(self: SVGMPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGMPathElement::start_view_transition(__self: mut SVGMPathElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMPathElement::start_view_transition_f_prom_unit(__self: mut SVGMPathElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGMPathElement::start_view_transition_mview_transition_options(__self: mut SVGMPathElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGMPathElement::as_js(self: SVGMPathElement) -> JsValue = JsValue::unsafe_from[SVGMPathElement](self)

pub fun SVGMPathElement::from_js(v: JsValue) -> mut SVGMPathElement = JsValue::unsafe_as[mut SVGMPathElement](v)

struct SVGNumber()

pub ext fun SVGNumber::value(self: SVGNumber) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun SVGNumber::set_value(self: mut SVGNumber, value: Float)
    = "#var(self).value = #fun(Float::as_js)(#var(value));"

pub fun SVGNumber::as_js(self: SVGNumber) -> JsValue = JsValue::unsafe_from[SVGNumber](self)

pub fun SVGNumber::from_js(v: JsValue) -> mut SVGNumber = JsValue::unsafe_as[mut SVGNumber](v)

struct SVGNumberList()

pub ext fun SVGNumberList::length(self: SVGNumberList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun SVGNumberList::number_of_items(self: SVGNumberList) -> Int
    = "return #fun(Int::from_js)(#var(self).numberOfItems);"

pub ext fun SVGNumberList::clear(__self: mut SVGNumberList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGNumberList::initialize(__self: mut SVGNumberList, new_item: mut SVGNumber) -> mut SVGNumber = "
    const r = #var(__self).initialize(#fun(SVGNumber::as_js)(#var(new_item)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::get_item(__self: mut SVGNumberList, index: Int) -> mut SVGNumber = "
    const r = #var(__self).getItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::insert_item_before(__self: mut SVGNumberList, new_item: mut SVGNumber, index: Int) -> mut SVGNumber = "
    const r = #var(__self).insertItemBefore(#fun(SVGNumber::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::replace_item(__self: mut SVGNumberList, new_item: mut SVGNumber, index: Int) -> mut SVGNumber = "
    const r = #var(__self).replaceItem(#fun(SVGNumber::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::remove_item(__self: mut SVGNumberList, index: Int) -> mut SVGNumber = "
    const r = #var(__self).removeItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::append_item(__self: mut SVGNumberList, new_item: mut SVGNumber) -> mut SVGNumber = "
    const r = #var(__self).appendItem(#fun(SVGNumber::as_js)(#var(new_item)));
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGNumberList::set(__self: mut SVGNumberList, index: Int, new_item: mut SVGNumber) = "
    SVGNumberList[#fun(Int::as_js)(#var(index))] = #fun(SVGNumber::as_js)(#var(new_item));
"

pub fun SVGNumberList::as_js(self: SVGNumberList) -> JsValue = JsValue::unsafe_from[SVGNumberList](self)

pub fun SVGNumberList::from_js(v: JsValue) -> mut SVGNumberList = JsValue::unsafe_as[mut SVGNumberList](v)

struct SVGPathElement()

/// Converts a reference to 'SVGPathElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_svg_geometry_element(self: SVGPathElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPathElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_msvg_geometry_element(self: mut SVGPathElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPathElement'!\");
"

/// Converts a reference to 'SVGPathElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_svg_graphics_element(self: SVGPathElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPathElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_msvg_graphics_element(self: mut SVGPathElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPathElement'!\");
"

/// Converts a reference to 'SVGPathElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_svg_element(self: SVGPathElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPathElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_msvg_element(self: mut SVGPathElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_svg_element(base: SVGElement) -> SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_msvg_element(base: mut SVGElement) -> mut SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPathElement'!\");
"

/// Converts a reference to 'SVGPathElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_element(self: SVGPathElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGPathElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::as_melement(self: mut SVGPathElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_element(base: Element) -> SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPathElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPathElement::from_melement(base: mut Element) -> mut SVGPathElement = "
    if(#var(base) instanceof SVGPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPathElement'!\");
"

pub ext fun SVGPathElement::path_length(self: SVGPathElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGPathElement::transform(self: SVGPathElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGPathElement::nearest_viewport_element(self: SVGPathElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGPathElement::farthest_viewport_element(self: SVGPathElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGPathElement::class_name(self: SVGPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGPathElement::owner_svg_element(self: SVGPathElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGPathElement::viewport_element(self: SVGPathElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGPathElement::is_point_in_fill(__self: mut SVGPathElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPathElement::is_point_in_stroke(__self: mut SVGPathElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPathElement::get_total_length(__self: mut SVGPathElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGPathElement::get_point_at_length(__self: mut SVGPathElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPathElement::get_b_box(__self: mut SVGPathElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGPathElement::get_ctm(__self: mut SVGPathElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPathElement::get_screen_ctm(__self: mut SVGPathElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPathElement::start_view_transition(__self: mut SVGPathElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPathElement::start_view_transition_f_prom_unit(__self: mut SVGPathElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPathElement::start_view_transition_mview_transition_options(__self: mut SVGPathElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGPathElement::as_js(self: SVGPathElement) -> JsValue = JsValue::unsafe_from[SVGPathElement](self)

pub fun SVGPathElement::from_js(v: JsValue) -> mut SVGPathElement = JsValue::unsafe_as[mut SVGPathElement](v)

struct SVGPatternElement()

/// Converts a reference to 'SVGPatternElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::as_svg_element(self: SVGPatternElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPatternElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::as_msvg_element(self: mut SVGPatternElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGPatternElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPatternElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::from_svg_element(base: SVGElement) -> SVGPatternElement = "
    if(#var(base) instanceof SVGPatternElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPatternElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGPatternElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPatternElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::from_msvg_element(base: mut SVGElement) -> mut SVGPatternElement = "
    if(#var(base) instanceof SVGPatternElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPatternElement'!\");
"

/// Converts a reference to 'SVGPatternElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::as_element(self: SVGPatternElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGPatternElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::as_melement(self: mut SVGPatternElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGPatternElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPatternElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::from_element(base: Element) -> SVGPatternElement = "
    if(#var(base) instanceof SVGPatternElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPatternElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGPatternElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPatternElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPatternElement::from_melement(base: mut Element) -> mut SVGPatternElement = "
    if(#var(base) instanceof SVGPatternElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPatternElement'!\");
"

pub ext fun SVGPatternElement::pattern_units(self: SVGPatternElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).patternUnits);"

pub ext fun SVGPatternElement::pattern_content_units(self: SVGPatternElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).patternContentUnits);"

pub ext fun SVGPatternElement::pattern_transform(self: SVGPatternElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).patternTransform);"

pub ext fun SVGPatternElement::x(self: SVGPatternElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGPatternElement::y(self: SVGPatternElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGPatternElement::width(self: SVGPatternElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGPatternElement::height(self: SVGPatternElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGPatternElement::class_name(self: SVGPatternElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGPatternElement::owner_svg_element(self: SVGPatternElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGPatternElement::viewport_element(self: SVGPatternElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGPatternElement::view_box(self: SVGPatternElement) -> mut SVGAnimatedRect
    = "return #fun(SVGAnimatedRect::from_js)(#var(self).viewBox);"

pub ext fun SVGPatternElement::preserve_aspect_ratio(self: SVGPatternElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGPatternElement::href(self: SVGPatternElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGPatternElement::required_extensions(self: SVGPatternElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).requiredExtensions);"

pub ext fun SVGPatternElement::system_language(self: SVGPatternElement) -> mut SVGStringList
    = "return #fun(SVGStringList::from_js)(#var(self).systemLanguage);"

pub ext fun SVGPatternElement::start_view_transition(__self: mut SVGPatternElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPatternElement::start_view_transition_f_prom_unit(__self: mut SVGPatternElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPatternElement::start_view_transition_mview_transition_options(__self: mut SVGPatternElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGPatternElement::as_js(self: SVGPatternElement) -> JsValue = JsValue::unsafe_from[SVGPatternElement](self)

pub fun SVGPatternElement::from_js(v: JsValue) -> mut SVGPatternElement = JsValue::unsafe_as[mut SVGPatternElement](v)

struct SVGPoint()

pub ext fun SVGPoint::x(self: SVGPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun SVGPoint::set_x(self: mut SVGPoint, value: Float)
    = "#var(self).x = #fun(Float::as_js)(#var(value));"

pub ext fun SVGPoint::y(self: SVGPoint) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun SVGPoint::set_y(self: mut SVGPoint, value: Float)
    = "#var(self).y = #fun(Float::as_js)(#var(value));"

pub ext fun SVGPoint::matrix_transform(__self: mut SVGPoint, matrix: mut SVGMatrix) -> mut SVGPoint = "
    const r = #var(__self).matrixTransform(#fun(SVGMatrix::as_js)(#var(matrix)));
    return #fun(SVGPoint::from_js)(r);
"

pub fun SVGPoint::as_js(self: SVGPoint) -> JsValue = JsValue::unsafe_from[SVGPoint](self)

pub fun SVGPoint::from_js(v: JsValue) -> mut SVGPoint = JsValue::unsafe_as[mut SVGPoint](v)

struct SVGPointList()

pub ext fun SVGPointList::length(self: SVGPointList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun SVGPointList::number_of_items(self: SVGPointList) -> Int
    = "return #fun(Int::from_js)(#var(self).numberOfItems);"

pub ext fun SVGPointList::clear(__self: mut SVGPointList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGPointList::initialize(__self: mut SVGPointList, new_item: mut SVGPoint) -> mut SVGPoint = "
    const r = #var(__self).initialize(#fun(SVGPoint::as_js)(#var(new_item)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::get_item(__self: mut SVGPointList, index: Int) -> mut SVGPoint = "
    const r = #var(__self).getItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::insert_item_before(__self: mut SVGPointList, new_item: mut SVGPoint, index: Int) -> mut SVGPoint = "
    const r = #var(__self).insertItemBefore(#fun(SVGPoint::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::replace_item(__self: mut SVGPointList, new_item: mut SVGPoint, index: Int) -> mut SVGPoint = "
    const r = #var(__self).replaceItem(#fun(SVGPoint::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::remove_item(__self: mut SVGPointList, index: Int) -> mut SVGPoint = "
    const r = #var(__self).removeItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::append_item(__self: mut SVGPointList, new_item: mut SVGPoint) -> mut SVGPoint = "
    const r = #var(__self).appendItem(#fun(SVGPoint::as_js)(#var(new_item)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPointList::set(__self: mut SVGPointList, index: Int, new_item: mut SVGPoint) = "
    SVGPointList[#fun(Int::as_js)(#var(index))] = #fun(SVGPoint::as_js)(#var(new_item));
"

pub fun SVGPointList::as_js(self: SVGPointList) -> JsValue = JsValue::unsafe_from[SVGPointList](self)

pub fun SVGPointList::from_js(v: JsValue) -> mut SVGPointList = JsValue::unsafe_as[mut SVGPointList](v)

struct SVGPolygonElement()

/// Converts a reference to 'SVGPolygonElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_svg_geometry_element(self: SVGPolygonElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolygonElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_msvg_geometry_element(self: mut SVGPolygonElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPolygonElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPolygonElement'!\");
"

/// Converts a reference to 'SVGPolygonElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_svg_graphics_element(self: SVGPolygonElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolygonElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_msvg_graphics_element(self: mut SVGPolygonElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPolygonElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPolygonElement'!\");
"

/// Converts a reference to 'SVGPolygonElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_svg_element(self: SVGPolygonElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolygonElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_msvg_element(self: mut SVGPolygonElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_svg_element(base: SVGElement) -> SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPolygonElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_msvg_element(base: mut SVGElement) -> mut SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPolygonElement'!\");
"

/// Converts a reference to 'SVGPolygonElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_element(self: SVGPolygonElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGPolygonElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::as_melement(self: mut SVGPolygonElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_element(base: Element) -> SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPolygonElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGPolygonElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolygonElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolygonElement::from_melement(base: mut Element) -> mut SVGPolygonElement = "
    if(#var(base) instanceof SVGPolygonElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPolygonElement'!\");
"

pub ext fun SVGPolygonElement::points(self: SVGPolygonElement) -> mut SVGPointList
    = "return #fun(SVGPointList::from_js)(#var(self).points);"

pub ext fun SVGPolygonElement::animated_points(self: SVGPolygonElement) -> mut SVGPointList
    = "return #fun(SVGPointList::from_js)(#var(self).animatedPoints);"

pub ext fun SVGPolygonElement::path_length(self: SVGPolygonElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGPolygonElement::transform(self: SVGPolygonElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGPolygonElement::nearest_viewport_element(self: SVGPolygonElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGPolygonElement::farthest_viewport_element(self: SVGPolygonElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGPolygonElement::class_name(self: SVGPolygonElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGPolygonElement::owner_svg_element(self: SVGPolygonElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGPolygonElement::viewport_element(self: SVGPolygonElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGPolygonElement::is_point_in_fill(__self: mut SVGPolygonElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPolygonElement::is_point_in_stroke(__self: mut SVGPolygonElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPolygonElement::get_total_length(__self: mut SVGPolygonElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGPolygonElement::get_point_at_length(__self: mut SVGPolygonElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPolygonElement::get_b_box(__self: mut SVGPolygonElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGPolygonElement::get_ctm(__self: mut SVGPolygonElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPolygonElement::get_screen_ctm(__self: mut SVGPolygonElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPolygonElement::start_view_transition(__self: mut SVGPolygonElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPolygonElement::start_view_transition_f_prom_unit(__self: mut SVGPolygonElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPolygonElement::start_view_transition_mview_transition_options(__self: mut SVGPolygonElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGPolygonElement::as_js(self: SVGPolygonElement) -> JsValue = JsValue::unsafe_from[SVGPolygonElement](self)

pub fun SVGPolygonElement::from_js(v: JsValue) -> mut SVGPolygonElement = JsValue::unsafe_as[mut SVGPolygonElement](v)

struct SVGPolylineElement()

/// Converts a reference to 'SVGPolylineElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_svg_geometry_element(self: SVGPolylineElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolylineElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_msvg_geometry_element(self: mut SVGPolylineElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPolylineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGPolylineElement'!\");
"

/// Converts a reference to 'SVGPolylineElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_svg_graphics_element(self: SVGPolylineElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolylineElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_msvg_graphics_element(self: mut SVGPolylineElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPolylineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGPolylineElement'!\");
"

/// Converts a reference to 'SVGPolylineElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_svg_element(self: SVGPolylineElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGPolylineElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_msvg_element(self: mut SVGPolylineElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_svg_element(base: SVGElement) -> SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPolylineElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_msvg_element(base: mut SVGElement) -> mut SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGPolylineElement'!\");
"

/// Converts a reference to 'SVGPolylineElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_element(self: SVGPolylineElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGPolylineElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::as_melement(self: mut SVGPolylineElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_element(base: Element) -> SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPolylineElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGPolylineElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGPolylineElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGPolylineElement::from_melement(base: mut Element) -> mut SVGPolylineElement = "
    if(#var(base) instanceof SVGPolylineElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGPolylineElement'!\");
"

pub ext fun SVGPolylineElement::points(self: SVGPolylineElement) -> mut SVGPointList
    = "return #fun(SVGPointList::from_js)(#var(self).points);"

pub ext fun SVGPolylineElement::animated_points(self: SVGPolylineElement) -> mut SVGPointList
    = "return #fun(SVGPointList::from_js)(#var(self).animatedPoints);"

pub ext fun SVGPolylineElement::path_length(self: SVGPolylineElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGPolylineElement::transform(self: SVGPolylineElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGPolylineElement::nearest_viewport_element(self: SVGPolylineElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGPolylineElement::farthest_viewport_element(self: SVGPolylineElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGPolylineElement::class_name(self: SVGPolylineElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGPolylineElement::owner_svg_element(self: SVGPolylineElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGPolylineElement::viewport_element(self: SVGPolylineElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGPolylineElement::is_point_in_fill(__self: mut SVGPolylineElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPolylineElement::is_point_in_stroke(__self: mut SVGPolylineElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGPolylineElement::get_total_length(__self: mut SVGPolylineElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGPolylineElement::get_point_at_length(__self: mut SVGPolylineElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGPolylineElement::get_b_box(__self: mut SVGPolylineElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGPolylineElement::get_ctm(__self: mut SVGPolylineElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPolylineElement::get_screen_ctm(__self: mut SVGPolylineElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGPolylineElement::start_view_transition(__self: mut SVGPolylineElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPolylineElement::start_view_transition_f_prom_unit(__self: mut SVGPolylineElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGPolylineElement::start_view_transition_mview_transition_options(__self: mut SVGPolylineElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGPolylineElement::as_js(self: SVGPolylineElement) -> JsValue = JsValue::unsafe_from[SVGPolylineElement](self)

pub fun SVGPolylineElement::from_js(v: JsValue) -> mut SVGPolylineElement = JsValue::unsafe_as[mut SVGPolylineElement](v)

struct SVGPreserveAspectRatio()

pub ext fun SVGPreserveAspectRatio::align(self: SVGPreserveAspectRatio) -> Int
    = "return #fun(Int::from_js)(#var(self).align);"

pub ext fun SVGPreserveAspectRatio::set_align(self: mut SVGPreserveAspectRatio, value: Int)
    = "#var(self).align = #fun(Int::as_js)(#var(value));"

pub ext fun SVGPreserveAspectRatio::meet_or_slice(self: SVGPreserveAspectRatio) -> Int
    = "return #fun(Int::from_js)(#var(self).meetOrSlice);"

pub ext fun SVGPreserveAspectRatio::set_meet_or_slice(self: mut SVGPreserveAspectRatio, value: Int)
    = "#var(self).meetOrSlice = #fun(Int::as_js)(#var(value));"

pub fun SVGPreserveAspectRatio::as_js(self: SVGPreserveAspectRatio) -> JsValue = JsValue::unsafe_from[SVGPreserveAspectRatio](self)

pub fun SVGPreserveAspectRatio::from_js(v: JsValue) -> mut SVGPreserveAspectRatio = JsValue::unsafe_as[mut SVGPreserveAspectRatio](v)

pub val SVGPreserveAspectRatio::svg_preserveaspectratio_unknown: Int = 0
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_none: Int = 1
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xminymin: Int = 2
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmidymin: Int = 3
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmaxymin: Int = 4
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xminymid: Int = 5
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmidymid: Int = 6
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmaxymid: Int = 7
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xminymax: Int = 8
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmidymax: Int = 9
pub val SVGPreserveAspectRatio::svg_preserveaspectratio_xmaxymax: Int = 10
pub val SVGPreserveAspectRatio::svg_meetorslice_unknown: Int = 0
pub val SVGPreserveAspectRatio::svg_meetorslice_meet: Int = 1
pub val SVGPreserveAspectRatio::svg_meetorslice_slice: Int = 2

struct SVGRadialGradientElement()

/// Converts a reference to 'SVGRadialGradientElement' to a reference to 'SVGGradientElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_svg_gradient_element(self: SVGRadialGradientElement) -> SVGGradientElement = "return #var(self);"

/// Converts a mutable reference to 'SVGRadialGradientElement' to a mutable reference to 'SVGGradientElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_msvg_gradient_element(self: mut SVGRadialGradientElement) -> mut SVGGradientElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGradientElement' to a reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_svg_gradient_element(base: SVGGradientElement) -> SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGradientElement' to 'SVGRadialGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGradientElement' to a mutable reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_msvg_gradient_element(base: mut SVGGradientElement) -> mut SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGradientElement' to 'SVGRadialGradientElement'!\");
"

/// Converts a reference to 'SVGRadialGradientElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_svg_element(self: SVGRadialGradientElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGRadialGradientElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_msvg_element(self: mut SVGRadialGradientElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_svg_element(base: SVGElement) -> SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGRadialGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_msvg_element(base: mut SVGElement) -> mut SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGRadialGradientElement'!\");
"

/// Converts a reference to 'SVGRadialGradientElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_element(self: SVGRadialGradientElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGRadialGradientElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::as_melement(self: mut SVGRadialGradientElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_element(base: Element) -> SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGRadialGradientElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGRadialGradientElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRadialGradientElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRadialGradientElement::from_melement(base: mut Element) -> mut SVGRadialGradientElement = "
    if(#var(base) instanceof SVGRadialGradientElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGRadialGradientElement'!\");
"

pub ext fun SVGRadialGradientElement::cx(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cx);"

pub ext fun SVGRadialGradientElement::cy(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).cy);"

pub ext fun SVGRadialGradientElement::r(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).r);"

pub ext fun SVGRadialGradientElement::fx(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).fx);"

pub ext fun SVGRadialGradientElement::fy(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).fy);"

pub ext fun SVGRadialGradientElement::fr(self: SVGRadialGradientElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).fr);"

pub ext fun SVGRadialGradientElement::gradient_units(self: SVGRadialGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).gradientUnits);"

pub ext fun SVGRadialGradientElement::gradient_transform(self: SVGRadialGradientElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).gradientTransform);"

pub ext fun SVGRadialGradientElement::spread_method(self: SVGRadialGradientElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).spreadMethod);"

pub ext fun SVGRadialGradientElement::class_name(self: SVGRadialGradientElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGRadialGradientElement::owner_svg_element(self: SVGRadialGradientElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGRadialGradientElement::viewport_element(self: SVGRadialGradientElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGRadialGradientElement::start_view_transition(__self: mut SVGRadialGradientElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGRadialGradientElement::start_view_transition_f_prom_unit(__self: mut SVGRadialGradientElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGRadialGradientElement::start_view_transition_mview_transition_options(__self: mut SVGRadialGradientElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGRadialGradientElement::as_js(self: SVGRadialGradientElement) -> JsValue = JsValue::unsafe_from[SVGRadialGradientElement](self)

pub fun SVGRadialGradientElement::from_js(v: JsValue) -> mut SVGRadialGradientElement = JsValue::unsafe_as[mut SVGRadialGradientElement](v)

pub val SVGRadialGradientElement::svg_spreadmethod_unknown: Int = 0
pub val SVGRadialGradientElement::svg_spreadmethod_pad: Int = 1
pub val SVGRadialGradientElement::svg_spreadmethod_reflect: Int = 2
pub val SVGRadialGradientElement::svg_spreadmethod_repeat: Int = 3

struct SVGRect()

pub ext fun SVGRect::x(self: SVGRect) -> Float
    = "return #fun(Float::from_js)(#var(self).x);"

pub ext fun SVGRect::set_x(self: mut SVGRect, value: Float)
    = "#var(self).x = #fun(Float::as_js)(#var(value));"

pub ext fun SVGRect::y(self: SVGRect) -> Float
    = "return #fun(Float::from_js)(#var(self).y);"

pub ext fun SVGRect::set_y(self: mut SVGRect, value: Float)
    = "#var(self).y = #fun(Float::as_js)(#var(value));"

pub ext fun SVGRect::width(self: SVGRect) -> Float
    = "return #fun(Float::from_js)(#var(self).width);"

pub ext fun SVGRect::set_width(self: mut SVGRect, value: Float)
    = "#var(self).width = #fun(Float::as_js)(#var(value));"

pub ext fun SVGRect::height(self: SVGRect) -> Float
    = "return #fun(Float::from_js)(#var(self).height);"

pub ext fun SVGRect::set_height(self: mut SVGRect, value: Float)
    = "#var(self).height = #fun(Float::as_js)(#var(value));"

pub fun SVGRect::as_js(self: SVGRect) -> JsValue = JsValue::unsafe_from[SVGRect](self)

pub fun SVGRect::from_js(v: JsValue) -> mut SVGRect = JsValue::unsafe_as[mut SVGRect](v)

struct SVGRectElement()

/// Converts a reference to 'SVGRectElement' to a reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_svg_geometry_element(self: SVGRectElement) -> SVGGeometryElement = "return #var(self);"

/// Converts a mutable reference to 'SVGRectElement' to a mutable reference to 'SVGGeometryElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_msvg_geometry_element(self: mut SVGRectElement) -> mut SVGGeometryElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGeometryElement' to a reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_svg_geometry_element(base: SVGGeometryElement) -> SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGRectElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGeometryElement' to a mutable reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_msvg_geometry_element(base: mut SVGGeometryElement) -> mut SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGeometryElement' to 'SVGRectElement'!\");
"

/// Converts a reference to 'SVGRectElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_svg_graphics_element(self: SVGRectElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGRectElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_msvg_graphics_element(self: mut SVGRectElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGRectElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGRectElement'!\");
"

/// Converts a reference to 'SVGRectElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_svg_element(self: SVGRectElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGRectElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_msvg_element(self: mut SVGRectElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_svg_element(base: SVGElement) -> SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGRectElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_msvg_element(base: mut SVGElement) -> mut SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGRectElement'!\");
"

/// Converts a reference to 'SVGRectElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_element(self: SVGRectElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGRectElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::as_melement(self: mut SVGRectElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_element(base: Element) -> SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGRectElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGRectElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGRectElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGRectElement::from_melement(base: mut Element) -> mut SVGRectElement = "
    if(#var(base) instanceof SVGRectElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGRectElement'!\");
"

pub ext fun SVGRectElement::x(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGRectElement::y(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGRectElement::width(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGRectElement::height(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGRectElement::rx(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).rx);"

pub ext fun SVGRectElement::ry(self: SVGRectElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).ry);"

pub ext fun SVGRectElement::path_length(self: SVGRectElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).pathLength);"

pub ext fun SVGRectElement::transform(self: SVGRectElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGRectElement::nearest_viewport_element(self: SVGRectElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGRectElement::farthest_viewport_element(self: SVGRectElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGRectElement::class_name(self: SVGRectElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGRectElement::owner_svg_element(self: SVGRectElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGRectElement::viewport_element(self: SVGRectElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGRectElement::is_point_in_fill(__self: mut SVGRectElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInFill(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGRectElement::is_point_in_stroke(__self: mut SVGRectElement, point: mut DOMPointInit) -> Bool = "
    const r = #var(__self).isPointInStroke(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGRectElement::get_total_length(__self: mut SVGRectElement) -> Float = "
    const r = #var(__self).getTotalLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGRectElement::get_point_at_length(__self: mut SVGRectElement, distance: Float) -> mut SVGPoint = "
    const r = #var(__self).getPointAtLength(#fun(Float::as_js)(#var(distance)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGRectElement::get_b_box(__self: mut SVGRectElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGRectElement::get_ctm(__self: mut SVGRectElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGRectElement::get_screen_ctm(__self: mut SVGRectElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGRectElement::start_view_transition(__self: mut SVGRectElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGRectElement::start_view_transition_f_prom_unit(__self: mut SVGRectElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGRectElement::start_view_transition_mview_transition_options(__self: mut SVGRectElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGRectElement::as_js(self: SVGRectElement) -> JsValue = JsValue::unsafe_from[SVGRectElement](self)

pub fun SVGRectElement::from_js(v: JsValue) -> mut SVGRectElement = JsValue::unsafe_as[mut SVGRectElement](v)

struct SVGScriptElement()

/// Converts a reference to 'SVGScriptElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::as_svg_element(self: SVGScriptElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGScriptElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::as_msvg_element(self: mut SVGScriptElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::from_svg_element(base: SVGElement) -> SVGScriptElement = "
    if(#var(base) instanceof SVGScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGScriptElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::from_msvg_element(base: mut SVGElement) -> mut SVGScriptElement = "
    if(#var(base) instanceof SVGScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGScriptElement'!\");
"

/// Converts a reference to 'SVGScriptElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::as_element(self: SVGScriptElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGScriptElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::as_melement(self: mut SVGScriptElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::from_element(base: Element) -> SVGScriptElement = "
    if(#var(base) instanceof SVGScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGScriptElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGScriptElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGScriptElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGScriptElement::from_melement(base: mut Element) -> mut SVGScriptElement = "
    if(#var(base) instanceof SVGScriptElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGScriptElement'!\");
"

pub ext fun SVGScriptElement::type(self: SVGScriptElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SVGScriptElement::set_type(self: mut SVGScriptElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun SVGScriptElement::async(self: SVGScriptElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).async);"

pub ext fun SVGScriptElement::set_async(self: mut SVGScriptElement, value: Bool)
    = "#var(self).async = #fun(Bool::as_js)(#var(value));"

pub ext fun SVGScriptElement::class_name(self: SVGScriptElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGScriptElement::owner_svg_element(self: SVGScriptElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGScriptElement::viewport_element(self: SVGScriptElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGScriptElement::href(self: SVGScriptElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGScriptElement::start_view_transition(__self: mut SVGScriptElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGScriptElement::start_view_transition_f_prom_unit(__self: mut SVGScriptElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGScriptElement::start_view_transition_mview_transition_options(__self: mut SVGScriptElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGScriptElement::as_js(self: SVGScriptElement) -> JsValue = JsValue::unsafe_from[SVGScriptElement](self)

pub fun SVGScriptElement::from_js(v: JsValue) -> mut SVGScriptElement = JsValue::unsafe_as[mut SVGScriptElement](v)

struct SVGSetElement()

/// Converts a reference to 'SVGSetElement' to a reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_svg_animation_element(self: SVGSetElement) -> SVGAnimationElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSetElement' to a mutable reference to 'SVGAnimationElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_msvg_animation_element(self: mut SVGSetElement) -> mut SVGAnimationElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGAnimationElement' to a reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_svg_animation_element(base: SVGAnimationElement) -> SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGSetElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGAnimationElement' to a mutable reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_msvg_animation_element(base: mut SVGAnimationElement) -> mut SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGAnimationElement' to 'SVGSetElement'!\");
"

/// Converts a reference to 'SVGSetElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_svg_element(self: SVGSetElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSetElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_msvg_element(self: mut SVGSetElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_svg_element(base: SVGElement) -> SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSetElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_msvg_element(base: mut SVGElement) -> mut SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSetElement'!\");
"

/// Converts a reference to 'SVGSetElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_element(self: SVGSetElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGSetElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::as_melement(self: mut SVGSetElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_element(base: Element) -> SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSetElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGSetElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSetElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSetElement::from_melement(base: mut Element) -> mut SVGSetElement = "
    if(#var(base) instanceof SVGSetElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSetElement'!\");
"

pub ext fun SVGSetElement::target_element(self: SVGSetElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).targetElement);"

pub ext fun SVGSetElement::onbegin(self: SVGSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbegin);"

pub ext fun SVGSetElement::set_onbegin(self: mut SVGSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbegin = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGSetElement::onend(self: SVGSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onend);"

pub ext fun SVGSetElement::set_onend(self: mut SVGSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGSetElement::onrepeat(self: SVGSetElement) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrepeat);"

pub ext fun SVGSetElement::set_onrepeat(self: mut SVGSetElement, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrepeat = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SVGSetElement::class_name(self: SVGSetElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGSetElement::owner_svg_element(self: SVGSetElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGSetElement::viewport_element(self: SVGSetElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGSetElement::get_start_time(__self: mut SVGSetElement) -> Float = "
    const r = #var(__self).getStartTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGSetElement::get_current_time(__self: mut SVGSetElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGSetElement::get_simple_duration(__self: mut SVGSetElement) -> Float = "
    const r = #var(__self).getSimpleDuration();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGSetElement::begin_element(__self: mut SVGSetElement) -> Unit = "
    const r = #var(__self).beginElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSetElement::begin_element_at(__self: mut SVGSetElement, offset: Float) -> Unit = "
    const r = #var(__self).beginElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSetElement::end_element(__self: mut SVGSetElement) -> Unit = "
    const r = #var(__self).endElement();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSetElement::end_element_at(__self: mut SVGSetElement, offset: Float) -> Unit = "
    const r = #var(__self).endElementAt(#fun(Float::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSetElement::start_view_transition(__self: mut SVGSetElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSetElement::start_view_transition_f_prom_unit(__self: mut SVGSetElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSetElement::start_view_transition_mview_transition_options(__self: mut SVGSetElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGSetElement::as_js(self: SVGSetElement) -> JsValue = JsValue::unsafe_from[SVGSetElement](self)

pub fun SVGSetElement::from_js(v: JsValue) -> mut SVGSetElement = JsValue::unsafe_as[mut SVGSetElement](v)

struct SVGStopElement()

/// Converts a reference to 'SVGStopElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::as_svg_element(self: SVGStopElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGStopElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::as_msvg_element(self: mut SVGStopElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGStopElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStopElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::from_svg_element(base: SVGElement) -> SVGStopElement = "
    if(#var(base) instanceof SVGStopElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGStopElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGStopElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStopElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::from_msvg_element(base: mut SVGElement) -> mut SVGStopElement = "
    if(#var(base) instanceof SVGStopElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGStopElement'!\");
"

/// Converts a reference to 'SVGStopElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::as_element(self: SVGStopElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGStopElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::as_melement(self: mut SVGStopElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGStopElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStopElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::from_element(base: Element) -> SVGStopElement = "
    if(#var(base) instanceof SVGStopElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGStopElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGStopElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStopElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStopElement::from_melement(base: mut Element) -> mut SVGStopElement = "
    if(#var(base) instanceof SVGStopElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGStopElement'!\");
"

pub ext fun SVGStopElement::offset(self: SVGStopElement) -> mut SVGAnimatedNumber
    = "return #fun(SVGAnimatedNumber::from_js)(#var(self).offset);"

pub ext fun SVGStopElement::class_name(self: SVGStopElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGStopElement::owner_svg_element(self: SVGStopElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGStopElement::viewport_element(self: SVGStopElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGStopElement::start_view_transition(__self: mut SVGStopElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGStopElement::start_view_transition_f_prom_unit(__self: mut SVGStopElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGStopElement::start_view_transition_mview_transition_options(__self: mut SVGStopElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGStopElement::as_js(self: SVGStopElement) -> JsValue = JsValue::unsafe_from[SVGStopElement](self)

pub fun SVGStopElement::from_js(v: JsValue) -> mut SVGStopElement = JsValue::unsafe_as[mut SVGStopElement](v)

struct SVGStringList()

pub ext fun SVGStringList::length(self: SVGStringList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun SVGStringList::number_of_items(self: SVGStringList) -> Int
    = "return #fun(Int::from_js)(#var(self).numberOfItems);"

pub ext fun SVGStringList::clear(__self: mut SVGStringList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGStringList::initialize(__self: mut SVGStringList, new_item: String) -> String = "
    const r = #var(__self).initialize(#fun(String::as_js)(#var(new_item)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::get_item(__self: mut SVGStringList, index: Int) -> String = "
    const r = #var(__self).getItem(#fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::insert_item_before(__self: mut SVGStringList, item: String, index: Int) -> String = "
    const r = #var(__self).insertItemBefore(#fun(String::as_js)(#var(item)), #fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::replace_item(__self: mut SVGStringList, new_item: String, index: Int) -> String = "
    const r = #var(__self).replaceItem(#fun(String::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::remove_item(__self: mut SVGStringList, index: Int) -> String = "
    const r = #var(__self).removeItem(#fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::append_item(__self: mut SVGStringList, new_item: String) -> String = "
    const r = #var(__self).appendItem(#fun(String::as_js)(#var(new_item)));
    return #fun(String::from_js)(r);
"

pub ext fun SVGStringList::set(__self: mut SVGStringList, index: Int, new_item: String) = "
    SVGStringList[#fun(Int::as_js)(#var(index))] = #fun(String::as_js)(#var(new_item));
"

pub fun SVGStringList::as_js(self: SVGStringList) -> JsValue = JsValue::unsafe_from[SVGStringList](self)

pub fun SVGStringList::from_js(v: JsValue) -> mut SVGStringList = JsValue::unsafe_as[mut SVGStringList](v)

struct SVGStyleElement()

/// Converts a reference to 'SVGStyleElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::as_svg_element(self: SVGStyleElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGStyleElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::as_msvg_element(self: mut SVGStyleElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::from_svg_element(base: SVGElement) -> SVGStyleElement = "
    if(#var(base) instanceof SVGStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGStyleElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::from_msvg_element(base: mut SVGElement) -> mut SVGStyleElement = "
    if(#var(base) instanceof SVGStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGStyleElement'!\");
"

/// Converts a reference to 'SVGStyleElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::as_element(self: SVGStyleElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGStyleElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::as_melement(self: mut SVGStyleElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::from_element(base: Element) -> SVGStyleElement = "
    if(#var(base) instanceof SVGStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGStyleElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGStyleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGStyleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGStyleElement::from_melement(base: mut Element) -> mut SVGStyleElement = "
    if(#var(base) instanceof SVGStyleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGStyleElement'!\");
"

pub ext fun SVGStyleElement::type(self: SVGStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun SVGStyleElement::set_type(self: mut SVGStyleElement, value: String)
    = "#var(self).type = #fun(String::as_js)(#var(value));"

pub ext fun SVGStyleElement::media(self: SVGStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).media);"

pub ext fun SVGStyleElement::set_media(self: mut SVGStyleElement, value: String)
    = "#var(self).media = #fun(String::as_js)(#var(value));"

pub ext fun SVGStyleElement::title(self: SVGStyleElement) -> String
    = "return #fun(String::from_js)(#var(self).title);"

pub ext fun SVGStyleElement::set_title(self: mut SVGStyleElement, value: String)
    = "#var(self).title = #fun(String::as_js)(#var(value));"

pub ext fun SVGStyleElement::sheet(self: SVGStyleElement) -> Option[mut StyleSheet]
    = "return #fun(Option::from_js[mut StyleSheet])(#var(self).sheet);"

pub ext fun SVGStyleElement::disabled(self: SVGStyleElement) -> Bool
    = "return #fun(Bool::from_js)(#var(self).disabled);"

pub ext fun SVGStyleElement::set_disabled(self: mut SVGStyleElement, value: Bool)
    = "#var(self).disabled = #fun(Bool::as_js)(#var(value));"

pub ext fun SVGStyleElement::class_name(self: SVGStyleElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGStyleElement::owner_svg_element(self: SVGStyleElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGStyleElement::viewport_element(self: SVGStyleElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGStyleElement::start_view_transition(__self: mut SVGStyleElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGStyleElement::start_view_transition_f_prom_unit(__self: mut SVGStyleElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGStyleElement::start_view_transition_mview_transition_options(__self: mut SVGStyleElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGStyleElement::as_js(self: SVGStyleElement) -> JsValue = JsValue::unsafe_from[SVGStyleElement](self)

pub fun SVGStyleElement::from_js(v: JsValue) -> mut SVGStyleElement = JsValue::unsafe_as[mut SVGStyleElement](v)

struct SVGSVGElement()

/// Converts a reference to 'SVGSVGElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_svg_graphics_element(self: SVGSVGElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSVGElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_msvg_graphics_element(self: mut SVGSVGElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGSVGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGSVGElement'!\");
"

/// Converts a reference to 'SVGSVGElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_svg_element(self: SVGSVGElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSVGElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_msvg_element(self: mut SVGSVGElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_svg_element(base: SVGElement) -> SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSVGElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_msvg_element(base: mut SVGElement) -> mut SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSVGElement'!\");
"

/// Converts a reference to 'SVGSVGElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_element(self: SVGSVGElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGSVGElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::as_melement(self: mut SVGSVGElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_element(base: Element) -> SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSVGElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGSVGElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSVGElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSVGElement::from_melement(base: mut Element) -> mut SVGSVGElement = "
    if(#var(base) instanceof SVGSVGElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSVGElement'!\");
"

pub ext fun SVGSVGElement::x(self: SVGSVGElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGSVGElement::y(self: SVGSVGElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGSVGElement::width(self: SVGSVGElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGSVGElement::height(self: SVGSVGElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGSVGElement::current_scale(self: SVGSVGElement) -> Float
    = "return #fun(Float::from_js)(#var(self).currentScale);"

pub ext fun SVGSVGElement::set_current_scale(self: mut SVGSVGElement, value: Float)
    = "#var(self).currentScale = #fun(Float::as_js)(#var(value));"

pub ext fun SVGSVGElement::current_translate(self: SVGSVGElement) -> mut SVGPoint
    = "return #fun(SVGPoint::from_js)(#var(self).currentTranslate);"

pub ext fun SVGSVGElement::transform(self: SVGSVGElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGSVGElement::nearest_viewport_element(self: SVGSVGElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGSVGElement::farthest_viewport_element(self: SVGSVGElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGSVGElement::class_name(self: SVGSVGElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGSVGElement::owner_svg_element(self: SVGSVGElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGSVGElement::viewport_element(self: SVGSVGElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGSVGElement::view_box(self: SVGSVGElement) -> mut SVGAnimatedRect
    = "return #fun(SVGAnimatedRect::from_js)(#var(self).viewBox);"

pub ext fun SVGSVGElement::preserve_aspect_ratio(self: SVGSVGElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGSVGElement::zoom_and_pan(self: SVGSVGElement) -> Int
    = "return #fun(Int::from_js)(#var(self).zoomAndPan);"

pub ext fun SVGSVGElement::set_zoom_and_pan(self: mut SVGSVGElement, value: Int)
    = "#var(self).zoomAndPan = #fun(Int::as_js)(#var(value));"

pub ext fun SVGSVGElement::get_intersection_list(__self: mut SVGSVGElement, rect: mut SVGRect, reference_element: Option[mut SVGElement]) -> mut NodeList = "
    const r = #var(__self).getIntersectionList(#fun(SVGRect::as_js)(#var(rect)), #fun(Option::as_js[mut SVGElement])(#var(reference_element)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun SVGSVGElement::get_enclosure_list(__self: mut SVGSVGElement, rect: mut SVGRect, reference_element: Option[mut SVGElement]) -> mut NodeList = "
    const r = #var(__self).getEnclosureList(#fun(SVGRect::as_js)(#var(rect)), #fun(Option::as_js[mut SVGElement])(#var(reference_element)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun SVGSVGElement::check_intersection(__self: mut SVGSVGElement, element: mut SVGElement, rect: mut SVGRect) -> Bool = "
    const r = #var(__self).checkIntersection(#fun(SVGElement::as_js)(#var(element)), #fun(SVGRect::as_js)(#var(rect)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGSVGElement::check_enclosure(__self: mut SVGSVGElement, element: mut SVGElement, rect: mut SVGRect) -> Bool = "
    const r = #var(__self).checkEnclosure(#fun(SVGElement::as_js)(#var(element)), #fun(SVGRect::as_js)(#var(rect)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGSVGElement::deselect_all(__self: mut SVGSVGElement) -> Unit = "
    const r = #var(__self).deselectAll();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_number(__self: mut SVGSVGElement) -> mut SVGNumber = "
    const r = #var(__self).createSVGNumber();
    return #fun(SVGNumber::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_length(__self: mut SVGSVGElement) -> mut SVGLength = "
    const r = #var(__self).createSVGLength();
    return #fun(SVGLength::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_angle(__self: mut SVGSVGElement) -> mut SVGAngle = "
    const r = #var(__self).createSVGAngle();
    return #fun(SVGAngle::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_point(__self: mut SVGSVGElement) -> mut SVGPoint = "
    const r = #var(__self).createSVGPoint();
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_matrix(__self: mut SVGSVGElement) -> mut SVGMatrix = "
    const r = #var(__self).createSVGMatrix();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_rect(__self: mut SVGSVGElement) -> mut SVGRect = "
    const r = #var(__self).createSVGRect();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_transform(__self: mut SVGSVGElement) -> mut SVGTransform = "
    const r = #var(__self).createSVGTransform();
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGSVGElement::create_svg_transform_from_matrix(__self: mut SVGSVGElement, matrix: mut SVGMatrix) -> mut SVGTransform = "
    const r = #var(__self).createSVGTransformFromMatrix(#fun(SVGMatrix::as_js)(#var(matrix)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGSVGElement::get_element_by_id(__self: mut SVGSVGElement, element_id: String) -> mut Element = "
    const r = #var(__self).getElementById(#fun(String::as_js)(#var(element_id)));
    return #fun(Element::from_js)(r);
"

pub ext fun SVGSVGElement::suspend_redraw(__self: mut SVGSVGElement, max_wait_milliseconds: Int) -> Int = "
    const r = #var(__self).suspendRedraw(#fun(Int::as_js)(#var(max_wait_milliseconds)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGSVGElement::unsuspend_redraw(__self: mut SVGSVGElement, suspend_handle_id: Int) -> Unit = "
    const r = #var(__self).unsuspendRedraw(#fun(Int::as_js)(#var(suspend_handle_id)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::unsuspend_redraw_all(__self: mut SVGSVGElement) -> Unit = "
    const r = #var(__self).unsuspendRedrawAll();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::force_redraw(__self: mut SVGSVGElement) -> Unit = "
    const r = #var(__self).forceRedraw();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::pause_animations(__self: mut SVGSVGElement) -> Unit = "
    const r = #var(__self).pauseAnimations();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::unpause_animations(__self: mut SVGSVGElement) -> Unit = "
    const r = #var(__self).unpauseAnimations();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::animations_paused(__self: mut SVGSVGElement) -> Bool = "
    const r = #var(__self).animationsPaused();
    return #fun(Bool::from_js)(r);
"

pub ext fun SVGSVGElement::get_current_time(__self: mut SVGSVGElement) -> Float = "
    const r = #var(__self).getCurrentTime();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGSVGElement::set_current_time(__self: mut SVGSVGElement, seconds: Float) -> Unit = "
    const r = #var(__self).setCurrentTime(#fun(Float::as_js)(#var(seconds)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGSVGElement::get_b_box(__self: mut SVGSVGElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGSVGElement::get_ctm(__self: mut SVGSVGElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGSVGElement::get_screen_ctm(__self: mut SVGSVGElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGSVGElement::start_view_transition(__self: mut SVGSVGElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSVGElement::start_view_transition_f_prom_unit(__self: mut SVGSVGElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSVGElement::start_view_transition_mview_transition_options(__self: mut SVGSVGElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGSVGElement::as_js(self: SVGSVGElement) -> JsValue = JsValue::unsafe_from[SVGSVGElement](self)

pub fun SVGSVGElement::from_js(v: JsValue) -> mut SVGSVGElement = JsValue::unsafe_as[mut SVGSVGElement](v)

pub val SVGSVGElement::svg_zoomandpan_unknown: Int = 0
pub val SVGSVGElement::svg_zoomandpan_disable: Int = 1
pub val SVGSVGElement::svg_zoomandpan_magnify: Int = 2

struct SVGSwitchElement()

/// Converts a reference to 'SVGSwitchElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_svg_graphics_element(self: SVGSwitchElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSwitchElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_msvg_graphics_element(self: mut SVGSwitchElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGSwitchElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGSwitchElement'!\");
"

/// Converts a reference to 'SVGSwitchElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_svg_element(self: SVGSwitchElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSwitchElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_msvg_element(self: mut SVGSwitchElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_svg_element(base: SVGElement) -> SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSwitchElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_msvg_element(base: mut SVGElement) -> mut SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSwitchElement'!\");
"

/// Converts a reference to 'SVGSwitchElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_element(self: SVGSwitchElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGSwitchElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::as_melement(self: mut SVGSwitchElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_element(base: Element) -> SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSwitchElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGSwitchElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSwitchElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSwitchElement::from_melement(base: mut Element) -> mut SVGSwitchElement = "
    if(#var(base) instanceof SVGSwitchElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSwitchElement'!\");
"

pub ext fun SVGSwitchElement::transform(self: SVGSwitchElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGSwitchElement::nearest_viewport_element(self: SVGSwitchElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGSwitchElement::farthest_viewport_element(self: SVGSwitchElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGSwitchElement::class_name(self: SVGSwitchElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGSwitchElement::owner_svg_element(self: SVGSwitchElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGSwitchElement::viewport_element(self: SVGSwitchElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGSwitchElement::get_b_box(__self: mut SVGSwitchElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGSwitchElement::get_ctm(__self: mut SVGSwitchElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGSwitchElement::get_screen_ctm(__self: mut SVGSwitchElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGSwitchElement::start_view_transition(__self: mut SVGSwitchElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSwitchElement::start_view_transition_f_prom_unit(__self: mut SVGSwitchElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSwitchElement::start_view_transition_mview_transition_options(__self: mut SVGSwitchElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGSwitchElement::as_js(self: SVGSwitchElement) -> JsValue = JsValue::unsafe_from[SVGSwitchElement](self)

pub fun SVGSwitchElement::from_js(v: JsValue) -> mut SVGSwitchElement = JsValue::unsafe_as[mut SVGSwitchElement](v)

struct SVGSymbolElement()

/// Converts a reference to 'SVGSymbolElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::as_svg_element(self: SVGSymbolElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGSymbolElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::as_msvg_element(self: mut SVGSymbolElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGSymbolElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSymbolElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::from_svg_element(base: SVGElement) -> SVGSymbolElement = "
    if(#var(base) instanceof SVGSymbolElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSymbolElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGSymbolElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSymbolElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::from_msvg_element(base: mut SVGElement) -> mut SVGSymbolElement = "
    if(#var(base) instanceof SVGSymbolElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGSymbolElement'!\");
"

/// Converts a reference to 'SVGSymbolElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::as_element(self: SVGSymbolElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGSymbolElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::as_melement(self: mut SVGSymbolElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGSymbolElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSymbolElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::from_element(base: Element) -> SVGSymbolElement = "
    if(#var(base) instanceof SVGSymbolElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSymbolElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGSymbolElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGSymbolElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGSymbolElement::from_melement(base: mut Element) -> mut SVGSymbolElement = "
    if(#var(base) instanceof SVGSymbolElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGSymbolElement'!\");
"

pub ext fun SVGSymbolElement::class_name(self: SVGSymbolElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGSymbolElement::owner_svg_element(self: SVGSymbolElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGSymbolElement::viewport_element(self: SVGSymbolElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGSymbolElement::view_box(self: SVGSymbolElement) -> mut SVGAnimatedRect
    = "return #fun(SVGAnimatedRect::from_js)(#var(self).viewBox);"

pub ext fun SVGSymbolElement::preserve_aspect_ratio(self: SVGSymbolElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGSymbolElement::start_view_transition(__self: mut SVGSymbolElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSymbolElement::start_view_transition_f_prom_unit(__self: mut SVGSymbolElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGSymbolElement::start_view_transition_mview_transition_options(__self: mut SVGSymbolElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGSymbolElement::as_js(self: SVGSymbolElement) -> JsValue = JsValue::unsafe_from[SVGSymbolElement](self)

pub fun SVGSymbolElement::from_js(v: JsValue) -> mut SVGSymbolElement = JsValue::unsafe_as[mut SVGSymbolElement](v)

struct SVGTextContentElement()

/// Converts a reference to 'SVGTextContentElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_svg_graphics_element(self: SVGTextContentElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_msvg_graphics_element(self: mut SVGTextContentElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextContentElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextContentElement'!\");
"

/// Converts a reference to 'SVGTextContentElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_svg_element(self: SVGTextContentElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_msvg_element(self: mut SVGTextContentElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_svg_element(base: SVGElement) -> SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextContentElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_msvg_element(base: mut SVGElement) -> mut SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextContentElement'!\");
"

/// Converts a reference to 'SVGTextContentElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_element(self: SVGTextContentElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTextContentElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::as_melement(self: mut SVGTextContentElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_element(base: Element) -> SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextContentElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTextContentElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextContentElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextContentElement::from_melement(base: mut Element) -> mut SVGTextContentElement = "
    if(#var(base) instanceof SVGTextContentElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextContentElement'!\");
"

pub ext fun SVGTextContentElement::text_length(self: SVGTextContentElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).textLength);"

pub ext fun SVGTextContentElement::length_adjust(self: SVGTextContentElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).lengthAdjust);"

pub ext fun SVGTextContentElement::transform(self: SVGTextContentElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGTextContentElement::nearest_viewport_element(self: SVGTextContentElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGTextContentElement::farthest_viewport_element(self: SVGTextContentElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGTextContentElement::class_name(self: SVGTextContentElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTextContentElement::owner_svg_element(self: SVGTextContentElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTextContentElement::viewport_element(self: SVGTextContentElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTextContentElement::get_number_of_chars(__self: mut SVGTextContentElement) -> Int = "
    const r = #var(__self).getNumberOfChars();
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextContentElement::get_computed_text_length(__self: mut SVGTextContentElement) -> Float = "
    const r = #var(__self).getComputedTextLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextContentElement::get_sub_string_length(__self: mut SVGTextContentElement, charnum: Int, nchars: Int) -> Float = "
    const r = #var(__self).getSubStringLength(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextContentElement::get_start_position_of_char(__self: mut SVGTextContentElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getStartPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextContentElement::get_end_position_of_char(__self: mut SVGTextContentElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getEndPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextContentElement::get_extent_of_char(__self: mut SVGTextContentElement, charnum: Int) -> mut SVGRect = "
    const r = #var(__self).getExtentOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextContentElement::get_rotation_of_char(__self: mut SVGTextContentElement, charnum: Int) -> Float = "
    const r = #var(__self).getRotationOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextContentElement::get_char_num_at_position(__self: mut SVGTextContentElement, point: mut DOMPointInit) -> Int = "
    const r = #var(__self).getCharNumAtPosition(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextContentElement::select_sub_string(__self: mut SVGTextContentElement, charnum: Int, nchars: Int) -> Unit = "
    const r = #var(__self).selectSubString(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTextContentElement::get_b_box(__self: mut SVGTextContentElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextContentElement::get_ctm(__self: mut SVGTextContentElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextContentElement::get_screen_ctm(__self: mut SVGTextContentElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextContentElement::start_view_transition(__self: mut SVGTextContentElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextContentElement::start_view_transition_f_prom_unit(__self: mut SVGTextContentElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextContentElement::start_view_transition_mview_transition_options(__self: mut SVGTextContentElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTextContentElement::as_js(self: SVGTextContentElement) -> JsValue = JsValue::unsafe_from[SVGTextContentElement](self)

pub fun SVGTextContentElement::from_js(v: JsValue) -> mut SVGTextContentElement = JsValue::unsafe_as[mut SVGTextContentElement](v)

pub val SVGTextContentElement::lengthadjust_unknown: Int = 0
pub val SVGTextContentElement::lengthadjust_spacing: Int = 1
pub val SVGTextContentElement::lengthadjust_spacingandglyphs: Int = 2

struct SVGTextElement()

/// Converts a reference to 'SVGTextElement' to a reference to 'SVGTextPositioningElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_svg_text_positioning_element(self: SVGTextElement) -> SVGTextPositioningElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextElement' to a mutable reference to 'SVGTextPositioningElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_msvg_text_positioning_element(self: mut SVGTextElement) -> mut SVGTextPositioningElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextPositioningElement' to a reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_svg_text_positioning_element(base: SVGTextPositioningElement) -> SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextPositioningElement' to 'SVGTextElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_msvg_text_positioning_element(base: mut SVGTextPositioningElement) -> mut SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextPositioningElement' to 'SVGTextElement'!\");
"

/// Converts a reference to 'SVGTextElement' to a reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_svg_text_content_element(self: SVGTextElement) -> SVGTextContentElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextElement' to a mutable reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_msvg_text_content_element(self: mut SVGTextElement) -> mut SVGTextContentElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextContentElement' to a reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_svg_text_content_element(base: SVGTextContentElement) -> SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_msvg_text_content_element(base: mut SVGTextContentElement) -> mut SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextElement'!\");
"

/// Converts a reference to 'SVGTextElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_svg_graphics_element(self: SVGTextElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_msvg_graphics_element(self: mut SVGTextElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextElement'!\");
"

/// Converts a reference to 'SVGTextElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_svg_element(self: SVGTextElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_msvg_element(self: mut SVGTextElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_svg_element(base: SVGElement) -> SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_msvg_element(base: mut SVGElement) -> mut SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextElement'!\");
"

/// Converts a reference to 'SVGTextElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_element(self: SVGTextElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTextElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::as_melement(self: mut SVGTextElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_element(base: Element) -> SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTextElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextElement::from_melement(base: mut Element) -> mut SVGTextElement = "
    if(#var(base) instanceof SVGTextElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextElement'!\");
"

pub ext fun SVGTextElement::x(self: SVGTextElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).x);"

pub ext fun SVGTextElement::y(self: SVGTextElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).y);"

pub ext fun SVGTextElement::dx(self: SVGTextElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dx);"

pub ext fun SVGTextElement::dy(self: SVGTextElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dy);"

pub ext fun SVGTextElement::rotate(self: SVGTextElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).rotate);"

pub ext fun SVGTextElement::text_length(self: SVGTextElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).textLength);"

pub ext fun SVGTextElement::length_adjust(self: SVGTextElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).lengthAdjust);"

pub ext fun SVGTextElement::transform(self: SVGTextElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGTextElement::nearest_viewport_element(self: SVGTextElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGTextElement::farthest_viewport_element(self: SVGTextElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGTextElement::class_name(self: SVGTextElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTextElement::owner_svg_element(self: SVGTextElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTextElement::viewport_element(self: SVGTextElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTextElement::get_number_of_chars(__self: mut SVGTextElement) -> Int = "
    const r = #var(__self).getNumberOfChars();
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextElement::get_computed_text_length(__self: mut SVGTextElement) -> Float = "
    const r = #var(__self).getComputedTextLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextElement::get_sub_string_length(__self: mut SVGTextElement, charnum: Int, nchars: Int) -> Float = "
    const r = #var(__self).getSubStringLength(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextElement::get_start_position_of_char(__self: mut SVGTextElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getStartPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextElement::get_end_position_of_char(__self: mut SVGTextElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getEndPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextElement::get_extent_of_char(__self: mut SVGTextElement, charnum: Int) -> mut SVGRect = "
    const r = #var(__self).getExtentOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextElement::get_rotation_of_char(__self: mut SVGTextElement, charnum: Int) -> Float = "
    const r = #var(__self).getRotationOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextElement::get_char_num_at_position(__self: mut SVGTextElement, point: mut DOMPointInit) -> Int = "
    const r = #var(__self).getCharNumAtPosition(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextElement::select_sub_string(__self: mut SVGTextElement, charnum: Int, nchars: Int) -> Unit = "
    const r = #var(__self).selectSubString(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTextElement::get_b_box(__self: mut SVGTextElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextElement::get_ctm(__self: mut SVGTextElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextElement::get_screen_ctm(__self: mut SVGTextElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextElement::start_view_transition(__self: mut SVGTextElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextElement::start_view_transition_f_prom_unit(__self: mut SVGTextElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextElement::start_view_transition_mview_transition_options(__self: mut SVGTextElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTextElement::as_js(self: SVGTextElement) -> JsValue = JsValue::unsafe_from[SVGTextElement](self)

pub fun SVGTextElement::from_js(v: JsValue) -> mut SVGTextElement = JsValue::unsafe_as[mut SVGTextElement](v)

pub val SVGTextElement::lengthadjust_unknown: Int = 0
pub val SVGTextElement::lengthadjust_spacing: Int = 1
pub val SVGTextElement::lengthadjust_spacingandglyphs: Int = 2

struct SVGTextPathElement()

/// Converts a reference to 'SVGTextPathElement' to a reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_svg_text_content_element(self: SVGTextPathElement) -> SVGTextContentElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPathElement' to a mutable reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_msvg_text_content_element(self: mut SVGTextPathElement) -> mut SVGTextContentElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextContentElement' to a reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_svg_text_content_element(base: SVGTextContentElement) -> SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_msvg_text_content_element(base: mut SVGTextContentElement) -> mut SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextPathElement'!\");
"

/// Converts a reference to 'SVGTextPathElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_svg_graphics_element(self: SVGTextPathElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPathElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_msvg_graphics_element(self: mut SVGTextPathElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextPathElement'!\");
"

/// Converts a reference to 'SVGTextPathElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_svg_element(self: SVGTextPathElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPathElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_msvg_element(self: mut SVGTextPathElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_svg_element(base: SVGElement) -> SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextPathElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_msvg_element(base: mut SVGElement) -> mut SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextPathElement'!\");
"

/// Converts a reference to 'SVGTextPathElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_element(self: SVGTextPathElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPathElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::as_melement(self: mut SVGTextPathElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_element(base: Element) -> SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextPathElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTextPathElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPathElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPathElement::from_melement(base: mut Element) -> mut SVGTextPathElement = "
    if(#var(base) instanceof SVGTextPathElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextPathElement'!\");
"

pub ext fun SVGTextPathElement::start_offset(self: SVGTextPathElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).startOffset);"

pub ext fun SVGTextPathElement::method(self: SVGTextPathElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).method);"

pub ext fun SVGTextPathElement::spacing(self: SVGTextPathElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).spacing);"

pub ext fun SVGTextPathElement::text_length(self: SVGTextPathElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).textLength);"

pub ext fun SVGTextPathElement::length_adjust(self: SVGTextPathElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).lengthAdjust);"

pub ext fun SVGTextPathElement::transform(self: SVGTextPathElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGTextPathElement::nearest_viewport_element(self: SVGTextPathElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGTextPathElement::farthest_viewport_element(self: SVGTextPathElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGTextPathElement::class_name(self: SVGTextPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTextPathElement::owner_svg_element(self: SVGTextPathElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTextPathElement::viewport_element(self: SVGTextPathElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTextPathElement::href(self: SVGTextPathElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGTextPathElement::get_number_of_chars(__self: mut SVGTextPathElement) -> Int = "
    const r = #var(__self).getNumberOfChars();
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextPathElement::get_computed_text_length(__self: mut SVGTextPathElement) -> Float = "
    const r = #var(__self).getComputedTextLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPathElement::get_sub_string_length(__self: mut SVGTextPathElement, charnum: Int, nchars: Int) -> Float = "
    const r = #var(__self).getSubStringLength(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPathElement::get_start_position_of_char(__self: mut SVGTextPathElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getStartPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextPathElement::get_end_position_of_char(__self: mut SVGTextPathElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getEndPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextPathElement::get_extent_of_char(__self: mut SVGTextPathElement, charnum: Int) -> mut SVGRect = "
    const r = #var(__self).getExtentOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextPathElement::get_rotation_of_char(__self: mut SVGTextPathElement, charnum: Int) -> Float = "
    const r = #var(__self).getRotationOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPathElement::get_char_num_at_position(__self: mut SVGTextPathElement, point: mut DOMPointInit) -> Int = "
    const r = #var(__self).getCharNumAtPosition(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextPathElement::select_sub_string(__self: mut SVGTextPathElement, charnum: Int, nchars: Int) -> Unit = "
    const r = #var(__self).selectSubString(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTextPathElement::get_b_box(__self: mut SVGTextPathElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextPathElement::get_ctm(__self: mut SVGTextPathElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextPathElement::get_screen_ctm(__self: mut SVGTextPathElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextPathElement::start_view_transition(__self: mut SVGTextPathElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextPathElement::start_view_transition_f_prom_unit(__self: mut SVGTextPathElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextPathElement::start_view_transition_mview_transition_options(__self: mut SVGTextPathElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTextPathElement::as_js(self: SVGTextPathElement) -> JsValue = JsValue::unsafe_from[SVGTextPathElement](self)

pub fun SVGTextPathElement::from_js(v: JsValue) -> mut SVGTextPathElement = JsValue::unsafe_as[mut SVGTextPathElement](v)

pub val SVGTextPathElement::textpath_methodtype_unknown: Int = 0
pub val SVGTextPathElement::textpath_methodtype_align: Int = 1
pub val SVGTextPathElement::textpath_methodtype_stretch: Int = 2
pub val SVGTextPathElement::textpath_spacingtype_unknown: Int = 0
pub val SVGTextPathElement::textpath_spacingtype_auto: Int = 1
pub val SVGTextPathElement::textpath_spacingtype_exact: Int = 2
pub val SVGTextPathElement::lengthadjust_unknown: Int = 0
pub val SVGTextPathElement::lengthadjust_spacing: Int = 1
pub val SVGTextPathElement::lengthadjust_spacingandglyphs: Int = 2

struct SVGTextPositioningElement()

/// Converts a reference to 'SVGTextPositioningElement' to a reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_svg_text_content_element(self: SVGTextPositioningElement) -> SVGTextContentElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_msvg_text_content_element(self: mut SVGTextPositioningElement) -> mut SVGTextContentElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextContentElement' to a reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_svg_text_content_element(base: SVGTextContentElement) -> SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextPositioningElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_msvg_text_content_element(base: mut SVGTextContentElement) -> mut SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTextPositioningElement'!\");
"

/// Converts a reference to 'SVGTextPositioningElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_svg_graphics_element(self: SVGTextPositioningElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_msvg_graphics_element(self: mut SVGTextPositioningElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextPositioningElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTextPositioningElement'!\");
"

/// Converts a reference to 'SVGTextPositioningElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_svg_element(self: SVGTextPositioningElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_msvg_element(self: mut SVGTextPositioningElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_svg_element(base: SVGElement) -> SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextPositioningElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_msvg_element(base: mut SVGElement) -> mut SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTextPositioningElement'!\");
"

/// Converts a reference to 'SVGTextPositioningElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_element(self: SVGTextPositioningElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::as_melement(self: mut SVGTextPositioningElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_element(base: Element) -> SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextPositioningElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTextPositioningElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTextPositioningElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTextPositioningElement::from_melement(base: mut Element) -> mut SVGTextPositioningElement = "
    if(#var(base) instanceof SVGTextPositioningElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTextPositioningElement'!\");
"

pub ext fun SVGTextPositioningElement::x(self: SVGTextPositioningElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).x);"

pub ext fun SVGTextPositioningElement::y(self: SVGTextPositioningElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).y);"

pub ext fun SVGTextPositioningElement::dx(self: SVGTextPositioningElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dx);"

pub ext fun SVGTextPositioningElement::dy(self: SVGTextPositioningElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dy);"

pub ext fun SVGTextPositioningElement::rotate(self: SVGTextPositioningElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).rotate);"

pub ext fun SVGTextPositioningElement::text_length(self: SVGTextPositioningElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).textLength);"

pub ext fun SVGTextPositioningElement::length_adjust(self: SVGTextPositioningElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).lengthAdjust);"

pub ext fun SVGTextPositioningElement::transform(self: SVGTextPositioningElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGTextPositioningElement::nearest_viewport_element(self: SVGTextPositioningElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGTextPositioningElement::farthest_viewport_element(self: SVGTextPositioningElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGTextPositioningElement::class_name(self: SVGTextPositioningElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTextPositioningElement::owner_svg_element(self: SVGTextPositioningElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTextPositioningElement::viewport_element(self: SVGTextPositioningElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTextPositioningElement::get_number_of_chars(__self: mut SVGTextPositioningElement) -> Int = "
    const r = #var(__self).getNumberOfChars();
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_computed_text_length(__self: mut SVGTextPositioningElement) -> Float = "
    const r = #var(__self).getComputedTextLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_sub_string_length(__self: mut SVGTextPositioningElement, charnum: Int, nchars: Int) -> Float = "
    const r = #var(__self).getSubStringLength(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_start_position_of_char(__self: mut SVGTextPositioningElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getStartPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_end_position_of_char(__self: mut SVGTextPositioningElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getEndPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_extent_of_char(__self: mut SVGTextPositioningElement, charnum: Int) -> mut SVGRect = "
    const r = #var(__self).getExtentOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_rotation_of_char(__self: mut SVGTextPositioningElement, charnum: Int) -> Float = "
    const r = #var(__self).getRotationOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_char_num_at_position(__self: mut SVGTextPositioningElement, point: mut DOMPointInit) -> Int = "
    const r = #var(__self).getCharNumAtPosition(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTextPositioningElement::select_sub_string(__self: mut SVGTextPositioningElement, charnum: Int, nchars: Int) -> Unit = "
    const r = #var(__self).selectSubString(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_b_box(__self: mut SVGTextPositioningElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_ctm(__self: mut SVGTextPositioningElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextPositioningElement::get_screen_ctm(__self: mut SVGTextPositioningElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTextPositioningElement::start_view_transition(__self: mut SVGTextPositioningElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextPositioningElement::start_view_transition_f_prom_unit(__self: mut SVGTextPositioningElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTextPositioningElement::start_view_transition_mview_transition_options(__self: mut SVGTextPositioningElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTextPositioningElement::as_js(self: SVGTextPositioningElement) -> JsValue = JsValue::unsafe_from[SVGTextPositioningElement](self)

pub fun SVGTextPositioningElement::from_js(v: JsValue) -> mut SVGTextPositioningElement = JsValue::unsafe_as[mut SVGTextPositioningElement](v)

pub val SVGTextPositioningElement::lengthadjust_unknown: Int = 0
pub val SVGTextPositioningElement::lengthadjust_spacing: Int = 1
pub val SVGTextPositioningElement::lengthadjust_spacingandglyphs: Int = 2

struct SVGTitleElement()

/// Converts a reference to 'SVGTitleElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::as_svg_element(self: SVGTitleElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTitleElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::as_msvg_element(self: mut SVGTitleElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::from_svg_element(base: SVGElement) -> SVGTitleElement = "
    if(#var(base) instanceof SVGTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTitleElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::from_msvg_element(base: mut SVGElement) -> mut SVGTitleElement = "
    if(#var(base) instanceof SVGTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTitleElement'!\");
"

/// Converts a reference to 'SVGTitleElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::as_element(self: SVGTitleElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTitleElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::as_melement(self: mut SVGTitleElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::from_element(base: Element) -> SVGTitleElement = "
    if(#var(base) instanceof SVGTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTitleElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTitleElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTitleElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTitleElement::from_melement(base: mut Element) -> mut SVGTitleElement = "
    if(#var(base) instanceof SVGTitleElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTitleElement'!\");
"

pub ext fun SVGTitleElement::class_name(self: SVGTitleElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTitleElement::owner_svg_element(self: SVGTitleElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTitleElement::viewport_element(self: SVGTitleElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTitleElement::start_view_transition(__self: mut SVGTitleElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTitleElement::start_view_transition_f_prom_unit(__self: mut SVGTitleElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTitleElement::start_view_transition_mview_transition_options(__self: mut SVGTitleElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTitleElement::as_js(self: SVGTitleElement) -> JsValue = JsValue::unsafe_from[SVGTitleElement](self)

pub fun SVGTitleElement::from_js(v: JsValue) -> mut SVGTitleElement = JsValue::unsafe_as[mut SVGTitleElement](v)

struct SVGTransform()

pub ext fun SVGTransform::type(self: SVGTransform) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun SVGTransform::matrix(self: SVGTransform) -> mut SVGMatrix
    = "return #fun(SVGMatrix::from_js)(#var(self).matrix);"

pub ext fun SVGTransform::angle(self: SVGTransform) -> Float
    = "return #fun(Float::from_js)(#var(self).angle);"

pub ext fun SVGTransform::set_matrix(__self: mut SVGTransform, matrix: mut SVGMatrix) -> Unit = "
    const r = #var(__self).setMatrix(#fun(SVGMatrix::as_js)(#var(matrix)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransform::set_translate(__self: mut SVGTransform, tx: Float, ty: Float) -> Unit = "
    const r = #var(__self).setTranslate(#fun(Float::as_js)(#var(tx)), #fun(Float::as_js)(#var(ty)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransform::set_scale(__self: mut SVGTransform, sx: Float, sy: Float) -> Unit = "
    const r = #var(__self).setScale(#fun(Float::as_js)(#var(sx)), #fun(Float::as_js)(#var(sy)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransform::set_rotate(__self: mut SVGTransform, angle: Float, cx: Float, cy: Float) -> Unit = "
    const r = #var(__self).setRotate(#fun(Float::as_js)(#var(angle)), #fun(Float::as_js)(#var(cx)), #fun(Float::as_js)(#var(cy)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransform::set_skew_x(__self: mut SVGTransform, angle: Float) -> Unit = "
    const r = #var(__self).setSkewX(#fun(Float::as_js)(#var(angle)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransform::set_skew_y(__self: mut SVGTransform, angle: Float) -> Unit = "
    const r = #var(__self).setSkewY(#fun(Float::as_js)(#var(angle)));
    return #fun(Unit::from_js)(r);
"

pub fun SVGTransform::as_js(self: SVGTransform) -> JsValue = JsValue::unsafe_from[SVGTransform](self)

pub fun SVGTransform::from_js(v: JsValue) -> mut SVGTransform = JsValue::unsafe_as[mut SVGTransform](v)

pub val SVGTransform::svg_transform_unknown: Int = 0
pub val SVGTransform::svg_transform_matrix: Int = 1
pub val SVGTransform::svg_transform_translate: Int = 2
pub val SVGTransform::svg_transform_scale: Int = 3
pub val SVGTransform::svg_transform_rotate: Int = 4
pub val SVGTransform::svg_transform_skewx: Int = 5
pub val SVGTransform::svg_transform_skewy: Int = 6

struct SVGTransformList()

pub ext fun SVGTransformList::length(self: SVGTransformList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun SVGTransformList::number_of_items(self: SVGTransformList) -> Int
    = "return #fun(Int::from_js)(#var(self).numberOfItems);"

pub ext fun SVGTransformList::clear(__self: mut SVGTransformList) -> Unit = "
    const r = #var(__self).clear();
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTransformList::initialize(__self: mut SVGTransformList, new_item: mut SVGTransform) -> mut SVGTransform = "
    const r = #var(__self).initialize(#fun(SVGTransform::as_js)(#var(new_item)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::get_item(__self: mut SVGTransformList, index: Int) -> mut SVGTransform = "
    const r = #var(__self).getItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::insert_item_before(__self: mut SVGTransformList, new_item: mut SVGTransform, index: Int) -> mut SVGTransform = "
    const r = #var(__self).insertItemBefore(#fun(SVGTransform::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::replace_item(__self: mut SVGTransformList, new_item: mut SVGTransform, index: Int) -> mut SVGTransform = "
    const r = #var(__self).replaceItem(#fun(SVGTransform::as_js)(#var(new_item)), #fun(Int::as_js)(#var(index)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::remove_item(__self: mut SVGTransformList, index: Int) -> mut SVGTransform = "
    const r = #var(__self).removeItem(#fun(Int::as_js)(#var(index)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::append_item(__self: mut SVGTransformList, new_item: mut SVGTransform) -> mut SVGTransform = "
    const r = #var(__self).appendItem(#fun(SVGTransform::as_js)(#var(new_item)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::create_svg_transform_from_matrix(__self: mut SVGTransformList, matrix: mut SVGMatrix) -> mut SVGTransform = "
    const r = #var(__self).createSVGTransformFromMatrix(#fun(SVGMatrix::as_js)(#var(matrix)));
    return #fun(SVGTransform::from_js)(r);
"

pub ext fun SVGTransformList::consolidate(__self: mut SVGTransformList) -> Option[mut SVGTransform] = "
    const r = #var(__self).consolidate();
    return #fun(Option::from_js[mut SVGTransform])(r);
"

pub ext fun SVGTransformList::set(__self: mut SVGTransformList, index: Int, new_item: mut SVGTransform) = "
    SVGTransformList[#fun(Int::as_js)(#var(index))] = #fun(SVGTransform::as_js)(#var(new_item));
"

pub fun SVGTransformList::as_js(self: SVGTransformList) -> JsValue = JsValue::unsafe_from[SVGTransformList](self)

pub fun SVGTransformList::from_js(v: JsValue) -> mut SVGTransformList = JsValue::unsafe_as[mut SVGTransformList](v)

struct SVGTSpanElement()

/// Converts a reference to 'SVGTSpanElement' to a reference to 'SVGTextPositioningElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_svg_text_positioning_element(self: SVGTSpanElement) -> SVGTextPositioningElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTSpanElement' to a mutable reference to 'SVGTextPositioningElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_msvg_text_positioning_element(self: mut SVGTSpanElement) -> mut SVGTextPositioningElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextPositioningElement' to a reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_svg_text_positioning_element(base: SVGTextPositioningElement) -> SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextPositioningElement' to 'SVGTSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextPositioningElement' to a mutable reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_msvg_text_positioning_element(base: mut SVGTextPositioningElement) -> mut SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextPositioningElement' to 'SVGTSpanElement'!\");
"

/// Converts a reference to 'SVGTSpanElement' to a reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_svg_text_content_element(self: SVGTSpanElement) -> SVGTextContentElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTSpanElement' to a mutable reference to 'SVGTextContentElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_msvg_text_content_element(self: mut SVGTSpanElement) -> mut SVGTextContentElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGTextContentElement' to a reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_svg_text_content_element(base: SVGTextContentElement) -> SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGTextContentElement' to a mutable reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_msvg_text_content_element(base: mut SVGTextContentElement) -> mut SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGTextContentElement' to 'SVGTSpanElement'!\");
"

/// Converts a reference to 'SVGTSpanElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_svg_graphics_element(self: SVGTSpanElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTSpanElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_msvg_graphics_element(self: mut SVGTSpanElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGTSpanElement'!\");
"

/// Converts a reference to 'SVGTSpanElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_svg_element(self: SVGTSpanElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGTSpanElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_msvg_element(self: mut SVGTSpanElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_svg_element(base: SVGElement) -> SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_msvg_element(base: mut SVGElement) -> mut SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGTSpanElement'!\");
"

/// Converts a reference to 'SVGTSpanElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_element(self: SVGTSpanElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGTSpanElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::as_melement(self: mut SVGTSpanElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_element(base: Element) -> SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTSpanElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGTSpanElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGTSpanElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGTSpanElement::from_melement(base: mut Element) -> mut SVGTSpanElement = "
    if(#var(base) instanceof SVGTSpanElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGTSpanElement'!\");
"

pub ext fun SVGTSpanElement::x(self: SVGTSpanElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).x);"

pub ext fun SVGTSpanElement::y(self: SVGTSpanElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).y);"

pub ext fun SVGTSpanElement::dx(self: SVGTSpanElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dx);"

pub ext fun SVGTSpanElement::dy(self: SVGTSpanElement) -> mut SVGAnimatedLengthList
    = "return #fun(SVGAnimatedLengthList::from_js)(#var(self).dy);"

pub ext fun SVGTSpanElement::rotate(self: SVGTSpanElement) -> mut SVGAnimatedNumberList
    = "return #fun(SVGAnimatedNumberList::from_js)(#var(self).rotate);"

pub ext fun SVGTSpanElement::text_length(self: SVGTSpanElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).textLength);"

pub ext fun SVGTSpanElement::length_adjust(self: SVGTSpanElement) -> mut SVGAnimatedEnumeration
    = "return #fun(SVGAnimatedEnumeration::from_js)(#var(self).lengthAdjust);"

pub ext fun SVGTSpanElement::transform(self: SVGTSpanElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGTSpanElement::nearest_viewport_element(self: SVGTSpanElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGTSpanElement::farthest_viewport_element(self: SVGTSpanElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGTSpanElement::class_name(self: SVGTSpanElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGTSpanElement::owner_svg_element(self: SVGTSpanElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGTSpanElement::viewport_element(self: SVGTSpanElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGTSpanElement::get_number_of_chars(__self: mut SVGTSpanElement) -> Int = "
    const r = #var(__self).getNumberOfChars();
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTSpanElement::get_computed_text_length(__self: mut SVGTSpanElement) -> Float = "
    const r = #var(__self).getComputedTextLength();
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTSpanElement::get_sub_string_length(__self: mut SVGTSpanElement, charnum: Int, nchars: Int) -> Float = "
    const r = #var(__self).getSubStringLength(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTSpanElement::get_start_position_of_char(__self: mut SVGTSpanElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getStartPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTSpanElement::get_end_position_of_char(__self: mut SVGTSpanElement, charnum: Int) -> mut SVGPoint = "
    const r = #var(__self).getEndPositionOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGPoint::from_js)(r);
"

pub ext fun SVGTSpanElement::get_extent_of_char(__self: mut SVGTSpanElement, charnum: Int) -> mut SVGRect = "
    const r = #var(__self).getExtentOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTSpanElement::get_rotation_of_char(__self: mut SVGTSpanElement, charnum: Int) -> Float = "
    const r = #var(__self).getRotationOfChar(#fun(Int::as_js)(#var(charnum)));
    return #fun(Float::from_js)(r);
"

pub ext fun SVGTSpanElement::get_char_num_at_position(__self: mut SVGTSpanElement, point: mut DOMPointInit) -> Int = "
    const r = #var(__self).getCharNumAtPosition(#fun(DOMPointInit::as_js)(#var(point)));
    return #fun(Int::from_js)(r);
"

pub ext fun SVGTSpanElement::select_sub_string(__self: mut SVGTSpanElement, charnum: Int, nchars: Int) -> Unit = "
    const r = #var(__self).selectSubString(#fun(Int::as_js)(#var(charnum)), #fun(Int::as_js)(#var(nchars)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SVGTSpanElement::get_b_box(__self: mut SVGTSpanElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGTSpanElement::get_ctm(__self: mut SVGTSpanElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTSpanElement::get_screen_ctm(__self: mut SVGTSpanElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGTSpanElement::start_view_transition(__self: mut SVGTSpanElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTSpanElement::start_view_transition_f_prom_unit(__self: mut SVGTSpanElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGTSpanElement::start_view_transition_mview_transition_options(__self: mut SVGTSpanElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGTSpanElement::as_js(self: SVGTSpanElement) -> JsValue = JsValue::unsafe_from[SVGTSpanElement](self)

pub fun SVGTSpanElement::from_js(v: JsValue) -> mut SVGTSpanElement = JsValue::unsafe_as[mut SVGTSpanElement](v)

pub val SVGTSpanElement::lengthadjust_unknown: Int = 0
pub val SVGTSpanElement::lengthadjust_spacing: Int = 1
pub val SVGTSpanElement::lengthadjust_spacingandglyphs: Int = 2

struct SVGUnitTypes()

pub fun SVGUnitTypes::as_js(self: SVGUnitTypes) -> JsValue = JsValue::unsafe_from[SVGUnitTypes](self)

pub fun SVGUnitTypes::from_js(v: JsValue) -> mut SVGUnitTypes = JsValue::unsafe_as[mut SVGUnitTypes](v)

pub val SVGUnitTypes::svg_unit_type_unknown: Int = 0
pub val SVGUnitTypes::svg_unit_type_userspaceonuse: Int = 1
pub val SVGUnitTypes::svg_unit_type_objectboundingbox: Int = 2

struct SVGUseElement()

/// Converts a reference to 'SVGUseElement' to a reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_svg_graphics_element(self: SVGUseElement) -> SVGGraphicsElement = "return #var(self);"

/// Converts a mutable reference to 'SVGUseElement' to a mutable reference to 'SVGGraphicsElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_msvg_graphics_element(self: mut SVGUseElement) -> mut SVGGraphicsElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGGraphicsElement' to a reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_svg_graphics_element(base: SVGGraphicsElement) -> SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGUseElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGGraphicsElement' to a mutable reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_msvg_graphics_element(base: mut SVGGraphicsElement) -> mut SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGGraphicsElement' to 'SVGUseElement'!\");
"

/// Converts a reference to 'SVGUseElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_svg_element(self: SVGUseElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGUseElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_msvg_element(self: mut SVGUseElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_svg_element(base: SVGElement) -> SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGUseElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_msvg_element(base: mut SVGElement) -> mut SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGUseElement'!\");
"

/// Converts a reference to 'SVGUseElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_element(self: SVGUseElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGUseElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::as_melement(self: mut SVGUseElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_element(base: Element) -> SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGUseElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGUseElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGUseElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGUseElement::from_melement(base: mut Element) -> mut SVGUseElement = "
    if(#var(base) instanceof SVGUseElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGUseElement'!\");
"

pub ext fun SVGUseElement::x(self: SVGUseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).x);"

pub ext fun SVGUseElement::y(self: SVGUseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).y);"

pub ext fun SVGUseElement::width(self: SVGUseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).width);"

pub ext fun SVGUseElement::height(self: SVGUseElement) -> mut SVGAnimatedLength
    = "return #fun(SVGAnimatedLength::from_js)(#var(self).height);"

pub ext fun SVGUseElement::transform(self: SVGUseElement) -> mut SVGAnimatedTransformList
    = "return #fun(SVGAnimatedTransformList::from_js)(#var(self).transform);"

pub ext fun SVGUseElement::nearest_viewport_element(self: SVGUseElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).nearestViewportElement);"

pub ext fun SVGUseElement::farthest_viewport_element(self: SVGUseElement) -> mut SVGElement
    = "return #fun(SVGElement::from_js)(#var(self).farthestViewportElement);"

pub ext fun SVGUseElement::class_name(self: SVGUseElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGUseElement::owner_svg_element(self: SVGUseElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGUseElement::viewport_element(self: SVGUseElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGUseElement::href(self: SVGUseElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).href);"

pub ext fun SVGUseElement::get_b_box(__self: mut SVGUseElement) -> mut SVGRect = "
    const r = #var(__self).getBBox();
    return #fun(SVGRect::from_js)(r);
"

pub ext fun SVGUseElement::get_ctm(__self: mut SVGUseElement) -> mut SVGMatrix = "
    const r = #var(__self).getCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGUseElement::get_screen_ctm(__self: mut SVGUseElement) -> mut SVGMatrix = "
    const r = #var(__self).getScreenCTM();
    return #fun(SVGMatrix::from_js)(r);
"

pub ext fun SVGUseElement::start_view_transition(__self: mut SVGUseElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGUseElement::start_view_transition_f_prom_unit(__self: mut SVGUseElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGUseElement::start_view_transition_mview_transition_options(__self: mut SVGUseElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGUseElement::as_js(self: SVGUseElement) -> JsValue = JsValue::unsafe_from[SVGUseElement](self)

pub fun SVGUseElement::from_js(v: JsValue) -> mut SVGUseElement = JsValue::unsafe_as[mut SVGUseElement](v)

struct SVGViewElement()

/// Converts a reference to 'SVGViewElement' to a reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::as_svg_element(self: SVGViewElement) -> SVGElement = "return #var(self);"

/// Converts a mutable reference to 'SVGViewElement' to a mutable reference to 'SVGElement'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::as_msvg_element(self: mut SVGViewElement) -> mut SVGElement = "return #var(self);"

/// Attempts to convert a reference to 'SVGElement' to a reference to 'SVGViewElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGViewElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::from_svg_element(base: SVGElement) -> SVGViewElement = "
    if(#var(base) instanceof SVGViewElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGViewElement'!\");
"

/// Attempts to convert a mutable reference to 'SVGElement' to a mutable reference to 'SVGViewElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGViewElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::from_msvg_element(base: mut SVGElement) -> mut SVGViewElement = "
    if(#var(base) instanceof SVGViewElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'SVGElement' to 'SVGViewElement'!\");
"

/// Converts a reference to 'SVGViewElement' to a reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::as_element(self: SVGViewElement) -> Element = "return #var(self);"

/// Converts a mutable reference to 'SVGViewElement' to a mutable reference to 'Element'.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::as_melement(self: mut SVGViewElement) -> mut Element = "return #var(self);"

/// Attempts to convert a reference to 'Element' to a reference to 'SVGViewElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGViewElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::from_element(base: Element) -> SVGViewElement = "
    if(#var(base) instanceof SVGViewElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGViewElement'!\");
"

/// Attempts to convert a mutable reference to 'Element' to a mutable reference to 'SVGViewElement'.
/// The conversion may fail and panic if 'base' is not a reference to 'SVGViewElement' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SVGViewElement::from_melement(base: mut Element) -> mut SVGViewElement = "
    if(#var(base) instanceof SVGViewElement) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Element' to 'SVGViewElement'!\");
"

pub ext fun SVGViewElement::class_name(self: SVGViewElement) -> mut SVGAnimatedString
    = "return #fun(SVGAnimatedString::from_js)(#var(self).className);"

pub ext fun SVGViewElement::owner_svg_element(self: SVGViewElement) -> Option[mut SVGSVGElement]
    = "return #fun(Option::from_js[mut SVGSVGElement])(#var(self).ownerSVGElement);"

pub ext fun SVGViewElement::viewport_element(self: SVGViewElement) -> Option[mut SVGElement]
    = "return #fun(Option::from_js[mut SVGElement])(#var(self).viewportElement);"

pub ext fun SVGViewElement::view_box(self: SVGViewElement) -> mut SVGAnimatedRect
    = "return #fun(SVGAnimatedRect::from_js)(#var(self).viewBox);"

pub ext fun SVGViewElement::preserve_aspect_ratio(self: SVGViewElement) -> mut SVGAnimatedPreserveAspectRatio
    = "return #fun(SVGAnimatedPreserveAspectRatio::from_js)(#var(self).preserveAspectRatio);"

pub ext fun SVGViewElement::zoom_and_pan(self: SVGViewElement) -> Int
    = "return #fun(Int::from_js)(#var(self).zoomAndPan);"

pub ext fun SVGViewElement::set_zoom_and_pan(self: mut SVGViewElement, value: Int)
    = "#var(self).zoomAndPan = #fun(Int::as_js)(#var(value));"

pub ext fun SVGViewElement::start_view_transition(__self: mut SVGViewElement) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGViewElement::start_view_transition_f_prom_unit(__self: mut SVGViewElement, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun SVGViewElement::start_view_transition_mview_transition_options(__self: mut SVGViewElement, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

pub fun SVGViewElement::as_js(self: SVGViewElement) -> JsValue = JsValue::unsafe_from[SVGViewElement](self)

pub fun SVGViewElement::from_js(v: JsValue) -> mut SVGViewElement = JsValue::unsafe_as[mut SVGViewElement](v)

pub val SVGViewElement::svg_zoomandpan_unknown: Int = 0
pub val SVGViewElement::svg_zoomandpan_disable: Int = 1
pub val SVGViewElement::svg_zoomandpan_magnify: Int = 2

struct CallbackFunctionTest()

pub ext fun CallbackFunctionTest::test_callback(__self: mut CallbackFunctionTest, callback: Fun(String, String) -> String, message_1: String, message_2: String) -> String = "
    const r = #var(__self).testCallback(((p0, p1) => { const r = #var(callback)(#fun(String::from_js)(p0), #fun(String::from_js)(p1)); return #fun(String::as_js)(r); }), #fun(String::as_js)(#var(message_1)), #fun(String::as_js)(#var(message_2)));
    return #fun(String::from_js)(r);
"

pub ext fun CallbackFunctionTest::test_nullable_callback(__self: mut CallbackFunctionTest, callback: Option[Fun(String, String) -> String], message_1: String, message_2: String) -> String = "
    const r = #var(__self).testNullableCallback(#fun(Option::as_js[Fun(String, String) -> String])(#var(callback)), #fun(String::as_js)(#var(message_1)), #fun(String::as_js)(#var(message_2)));
    return #fun(String::from_js)(r);
"

pub ext fun CallbackFunctionTest::test_interface_callback(__self: mut CallbackFunctionTest, callback: Fun(mut HTMLDivElement) -> Unit, div_element: mut HTMLDivElement) -> Unit = "
    const r = #var(__self).testInterfaceCallback(((p0) => { const r = #var(callback)(#fun(HTMLDivElement::from_js)(p0)); return #fun(Unit::as_js)(r); }), #fun(HTMLDivElement::as_js)(#var(div_element)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CallbackFunctionTest::test_receiver_object_callback(__self: mut CallbackFunctionTest, callback: Fun() -> Unit) -> Unit = "
    const r = #var(__self).testReceiverObjectCallback((() => { const r = #var(callback)(); return #fun(Unit::as_js)(r); }));
    return #fun(Unit::from_js)(r);
"

pub ext fun CallbackFunctionTest::test_sequence_callback(__self: mut CallbackFunctionTest, callback: Fun(List[Int]) -> List[String], numbers: List[Int]) -> List[String] = "
    const r = #var(__self).testSequenceCallback(((p0) => { const r = #var(callback)(#fun(List::from_js[Int])(p0)); return #fun(List::as_js[String])(r); }), #fun(List::as_js[Int])(#var(numbers)));
    return #fun(List::from_js[String])(r);
"

pub ext fun CallbackFunctionTest::test_enum_callback(__self: mut CallbackFunctionTest, callback: Fun(String) -> Unit, enum__value: String) -> Unit = "
    const r = #var(__self).testEnumCallback(((p0) => { const r = #var(callback)(#fun(String::from_js)(p0)); return #fun(Unit::as_js)(r); }), #var(enum__value));
    return #fun(Unit::from_js)(r);
"

pub fun CallbackFunctionTest::as_js(self: CallbackFunctionTest) -> JsValue = JsValue::unsafe_from[CallbackFunctionTest](self)

pub fun CallbackFunctionTest::from_js(v: JsValue) -> mut CallbackFunctionTest = JsValue::unsafe_as[mut CallbackFunctionTest](v)

struct DictionaryTest()

pub ext fun DictionaryTest::set(__self: mut DictionaryTest, testing_dictionary: mut InternalDictionary) -> Unit = "
    const r = #var(__self).set(#fun(InternalDictionary::as_js)(#var(testing_dictionary)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DictionaryTest::get(__self: mut DictionaryTest) -> mut InternalDictionary = "
    const r = #var(__self).get();
    return #fun(InternalDictionary::from_js)(r);
"

pub ext fun DictionaryTest::set_derived(__self: mut DictionaryTest, derived: mut InternalDictionaryDerived) -> Unit = "
    const r = #var(__self).setDerived(#fun(InternalDictionaryDerived::as_js)(#var(derived)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DictionaryTest::get_derived(__self: mut DictionaryTest) -> mut InternalDictionaryDerived = "
    const r = #var(__self).getDerived();
    return #fun(InternalDictionaryDerived::from_js)(r);
"

pub ext fun DictionaryTest::set_derived_derived(__self: mut DictionaryTest, derived: mut InternalDictionaryDerivedDerived) -> Unit = "
    const r = #var(__self).setDerivedDerived(#fun(InternalDictionaryDerivedDerived::as_js)(#var(derived)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DictionaryTest::get_derived_derived(__self: mut DictionaryTest) -> mut InternalDictionaryDerivedDerived = "
    const r = #var(__self).getDerivedDerived();
    return #fun(InternalDictionaryDerivedDerived::from_js)(r);
"

pub fun DictionaryTest::as_js(self: DictionaryTest) -> JsValue = JsValue::unsafe_from[DictionaryTest](self)

pub fun DictionaryTest::from_js(v: JsValue) -> mut DictionaryTest = JsValue::unsafe_as[mut DictionaryTest](v)

struct GarbageCollectedScriptWrappable()

pub fun GarbageCollectedScriptWrappable::as_js(self: GarbageCollectedScriptWrappable) -> JsValue = JsValue::unsafe_from[GarbageCollectedScriptWrappable](self)

pub fun GarbageCollectedScriptWrappable::from_js(v: JsValue) -> mut GarbageCollectedScriptWrappable = JsValue::unsafe_as[mut GarbageCollectedScriptWrappable](v)

struct GCObservation()

pub ext fun GCObservation::was_collected(self: GCObservation) -> Bool
    = "return #fun(Bool::from_js)(#var(self).wasCollected);"

pub fun GCObservation::as_js(self: GCObservation) -> JsValue = JsValue::unsafe_from[GCObservation](self)

pub fun GCObservation::from_js(v: JsValue) -> mut GCObservation = JsValue::unsafe_as[mut GCObservation](v)

struct HitTestLayerRect()

pub ext fun HitTestLayerRect::layer_rect(self: HitTestLayerRect) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).layerRect);"

pub ext fun HitTestLayerRect::hit_test_rect(self: HitTestLayerRect) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).hitTestRect);"

pub fun HitTestLayerRect::as_js(self: HitTestLayerRect) -> JsValue = JsValue::unsafe_from[HitTestLayerRect](self)

pub fun HitTestLayerRect::from_js(v: JsValue) -> mut HitTestLayerRect = JsValue::unsafe_as[mut HitTestLayerRect](v)

struct HitTestLayerRectList()

pub ext fun HitTestLayerRectList::length(self: HitTestLayerRectList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HitTestLayerRectList::item(__self: mut HitTestLayerRectList, index: Int) -> mut HitTestLayerRect = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(HitTestLayerRect::from_js)(r);
"

pub fun HitTestLayerRectList::as_js(self: HitTestLayerRectList) -> JsValue = JsValue::unsafe_from[HitTestLayerRectList](self)

pub fun HitTestLayerRectList::from_js(v: JsValue) -> mut HitTestLayerRectList = JsValue::unsafe_as[mut HitTestLayerRectList](v)

pub val InternalEnum::Foo: String = "foo"
pub val InternalEnum::Bar: String = "bar"
pub val InternalEnum::Baz: String = "baz"

pub struct InternalDictionary(
    long_member: Option[Int],
    long_member_with_clamp: Option[Int],
    long_member_with_enforce_range: Option[Int],
    long_member_with_default: Option[Int],
    long_or_null_member: Option[Int],
    long_or_null_member_with_default: Option[Int],
    boolean_member: Option[Bool],
    double_member: Option[Float],
    unrestricted_double_member: Option[Float],
    string_member: Option[String],
    string_member_with_default: Option[String],
    byte_string_member: Option[String],
    usv_string_member: Option[String],
    string_sequence_member: Option[List[String]],
    string_sequence_member_with_default: Option[List[String]],
    string_sequence_or_null_member: Option[List[String]],
    enum_member: Option[String],
    enum_member_with_default: Option[String],
    enum_or_null_member: Option[String],
    element_member: Option[mut Element],
    element_or_null_member: Option[mut Element],
    object_member: Option[JsObject],
    object_or_null_member_with_default: Option[JsObject],
    double_or_string_member: Option[JsValue],
    double_or_string_sequence_member: Option[List[JsValue]],
    event_target_or_null_member: Option[mut EventTarget],
    internal_enum_or_internal_enum_sequence_member: Option[JsValue],
    any_member: Option[JsValue],
    callback_function_member: Option[Fun(String, String) -> String]
)

pub fun InternalDictionary::default() -> mut InternalDictionary
    = InternalDictionary(Option::None, Option::None, Option::None, Option::Some(42), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::Some("defaultStringValue"), Option::None, Option::None, Option::None, Option::Some(List::empty()), Option::None, Option::None, Option::Some("foo"), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun InternalDictionary::from_js(value: JsValue) -> mut InternalDictionary = "
    const r = {};
    r.m_long_member = #fun(Option::from_js[Int])(#var(value).longMember);
    r.m_long_member_with_clamp = #fun(Option::from_js[Int])(#var(value).longMemberWithClamp);
    r.m_long_member_with_enforce_range = #fun(Option::from_js[Int])(#var(value).longMemberWithEnforceRange);
    r.m_long_member_with_default = #fun(Option::from_js[Int])(#var(value).longMemberWithDefault);
    r.m_long_or_null_member = #fun(Option::from_js[Int])(#var(value).longOrNullMember);
    r.m_long_or_null_member_with_default = #fun(Option::from_js[Int])(#var(value).longOrNullMemberWithDefault);
    r.m_boolean_member = #fun(Option::from_js[Bool])(#var(value).booleanMember);
    r.m_double_member = #fun(Option::from_js[Float])(#var(value).doubleMember);
    r.m_unrestricted_double_member = #fun(Option::from_js[Float])(#var(value).unrestrictedDoubleMember);
    r.m_string_member = #fun(Option::from_js[String])(#var(value).stringMember);
    r.m_string_member_with_default = #fun(Option::from_js[String])(#var(value).stringMemberWithDefault);
    r.m_byte_string_member = #fun(Option::from_js[String])(#var(value).byteStringMember);
    r.m_usv_string_member = #fun(Option::from_js[String])(#var(value).usvStringMember);
    r.m_string_sequence_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMember);
    r.m_string_sequence_member_with_default = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMemberWithDefault);
    r.m_string_sequence_or_null_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceOrNullMember);
    r.m_enum_member = #fun(Option::from_js[String])(#var(value).enumMember);
    r.m_enum_member_with_default = #fun(Option::from_js[String])(#var(value).enumMemberWithDefault);
    r.m_enum_or_null_member = #fun(Option::from_js[String])(#var(value).enumOrNullMember);
    r.m_element_member = #fun(Option::from_js[mut Element])(#var(value).elementMember);
    r.m_element_or_null_member = #fun(Option::from_js[mut Element])(#var(value).elementOrNullMember);
    r.m_object_member = #fun(Option::from_js[JsObject])(#var(value).objectMember);
    r.m_object_or_null_member_with_default = #fun(Option::from_js[JsObject])(#var(value).objectOrNullMemberWithDefault);
    r.m_double_or_string_member = #fun(Option::from_js[JsValue])(#var(value).doubleOrStringMember);
    r.m_double_or_string_sequence_member = #fun(Option::from_js[List[JsValue]])(#var(value).doubleOrStringSequenceMember);
    r.m_event_target_or_null_member = #fun(Option::from_js[mut EventTarget])(#var(value).eventTargetOrNullMember);
    r.m_internal_enum_or_internal_enum_sequence_member = #fun(Option::from_js[JsValue])(#var(value).internalEnumOrInternalEnumSequenceMember);
    r.m_any_member = #fun(Option::from_js[JsValue])(#var(value).anyMember);
    r.m_callback_function_member = #fun(Option::from_js[Fun(String, String) -> String])(#var(value).callbackFunctionMember);
    return r;
"

pub ext fun InternalDictionary::as_js(self: InternalDictionary) -> JsValue = "
    const r = {};
    r.longMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_member);
    r.longMemberWithClamp = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_clamp);
    r.longMemberWithEnforceRange = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_enforce_range);
    r.longMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_default);
    r.longOrNullMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member);
    r.longOrNullMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member_with_default);
    r.booleanMember = #fun(Option::as_js_undef[Bool])(#var(self).m_boolean_member);
    r.doubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_double_member);
    r.unrestrictedDoubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_unrestricted_double_member);
    r.stringMember = #fun(Option::as_js_undef[String])(#var(self).m_string_member);
    r.stringMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_string_member_with_default);
    r.byteStringMember = #fun(Option::as_js_undef[String])(#var(self).m_byte_string_member);
    r.usvStringMember = #fun(Option::as_js_undef[String])(#var(self).m_usv_string_member);
    r.stringSequenceMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member);
    r.stringSequenceMemberWithDefault = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member_with_default);
    r.stringSequenceOrNullMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_or_null_member);
    r.enumMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_member);
    r.enumMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_enum_member_with_default);
    r.enumOrNullMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_or_null_member);
    r.elementMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_member);
    r.elementOrNullMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_or_null_member);
    r.objectMember = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_member);
    r.objectOrNullMemberWithDefault = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_or_null_member_with_default);
    r.doubleOrStringMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_double_or_string_member);
    r.doubleOrStringSequenceMember = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_double_or_string_sequence_member);
    r.eventTargetOrNullMember = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_event_target_or_null_member);
    r.internalEnumOrInternalEnumSequenceMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_internal_enum_or_internal_enum_sequence_member);
    r.anyMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_any_member);
    r.callbackFunctionMember = #fun(Option::as_js_undef[Fun(String, String) -> String])(#var(self).m_callback_function_member);
    return r;
"

pub struct InternalDictionaryDerived(
    derived_string_member: Option[String],
    derived_string_member_with_default: Option[String],
    required_boolean_member: Bool,
    long_member: Option[Int],
    long_member_with_clamp: Option[Int],
    long_member_with_enforce_range: Option[Int],
    long_member_with_default: Option[Int],
    long_or_null_member: Option[Int],
    long_or_null_member_with_default: Option[Int],
    boolean_member: Option[Bool],
    double_member: Option[Float],
    unrestricted_double_member: Option[Float],
    string_member: Option[String],
    string_member_with_default: Option[String],
    byte_string_member: Option[String],
    usv_string_member: Option[String],
    string_sequence_member: Option[List[String]],
    string_sequence_member_with_default: Option[List[String]],
    string_sequence_or_null_member: Option[List[String]],
    enum_member: Option[String],
    enum_member_with_default: Option[String],
    enum_or_null_member: Option[String],
    element_member: Option[mut Element],
    element_or_null_member: Option[mut Element],
    object_member: Option[JsObject],
    object_or_null_member_with_default: Option[JsObject],
    double_or_string_member: Option[JsValue],
    double_or_string_sequence_member: Option[List[JsValue]],
    event_target_or_null_member: Option[mut EventTarget],
    internal_enum_or_internal_enum_sequence_member: Option[JsValue],
    any_member: Option[JsValue],
    callback_function_member: Option[Fun(String, String) -> String]
)

pub fun InternalDictionaryDerived::default(required_boolean_member: Bool) -> mut InternalDictionaryDerived
    = InternalDictionaryDerived(Option::None, Option::Some("derivedDefaultStringValue"), required_boolean_member, Option::None, Option::None, Option::None, Option::Some(42), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::Some("defaultStringValue"), Option::None, Option::None, Option::None, Option::Some(List::empty()), Option::None, Option::None, Option::Some("foo"), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

/// Converts a reference to 'InternalDictionaryDerived' to a reference to 'InternalDictionary'.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerived::as_internal_dictionary(self: InternalDictionaryDerived) -> InternalDictionary = "return #var(self);"

/// Converts a mutable reference to 'InternalDictionaryDerived' to a mutable reference to 'InternalDictionary'.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerived::as_minternal_dictionary(self: mut InternalDictionaryDerived) -> mut InternalDictionary = "return #var(self);"

/// Attempts to convert a reference to 'InternalDictionary' to a reference to 'InternalDictionaryDerived'.
/// A 'base' that is not a reference to 'InternalDictionaryDerived' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerived::from_internal_dictionary_unchecked(base: InternalDictionary) -> InternalDictionaryDerived = "return #var(base);"

/// Attempts to convert a mutable reference to 'InternalDictionary' to a mutable reference to 'InternalDictionaryDerived'.
/// A 'base' that is not a reference to 'InternalDictionaryDerived' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerived::from_minternal_dictionary_unchecked(base: mut InternalDictionary) -> mut InternalDictionaryDerived = "return #var(base);"

pub ext fun InternalDictionaryDerived::from_js(value: JsValue) -> mut InternalDictionaryDerived = "
    const r = {};
    r.m_derived_string_member = #fun(Option::from_js[String])(#var(value).derivedStringMember);
    r.m_derived_string_member_with_default = #fun(Option::from_js[String])(#var(value).derivedStringMemberWithDefault);
    r.m_required_boolean_member = #fun(Bool::from_js)(#var(value).requiredBooleanMember);
    r.m_long_member = #fun(Option::from_js[Int])(#var(value).longMember);
    r.m_long_member_with_clamp = #fun(Option::from_js[Int])(#var(value).longMemberWithClamp);
    r.m_long_member_with_enforce_range = #fun(Option::from_js[Int])(#var(value).longMemberWithEnforceRange);
    r.m_long_member_with_default = #fun(Option::from_js[Int])(#var(value).longMemberWithDefault);
    r.m_long_or_null_member = #fun(Option::from_js[Int])(#var(value).longOrNullMember);
    r.m_long_or_null_member_with_default = #fun(Option::from_js[Int])(#var(value).longOrNullMemberWithDefault);
    r.m_boolean_member = #fun(Option::from_js[Bool])(#var(value).booleanMember);
    r.m_double_member = #fun(Option::from_js[Float])(#var(value).doubleMember);
    r.m_unrestricted_double_member = #fun(Option::from_js[Float])(#var(value).unrestrictedDoubleMember);
    r.m_string_member = #fun(Option::from_js[String])(#var(value).stringMember);
    r.m_string_member_with_default = #fun(Option::from_js[String])(#var(value).stringMemberWithDefault);
    r.m_byte_string_member = #fun(Option::from_js[String])(#var(value).byteStringMember);
    r.m_usv_string_member = #fun(Option::from_js[String])(#var(value).usvStringMember);
    r.m_string_sequence_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMember);
    r.m_string_sequence_member_with_default = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMemberWithDefault);
    r.m_string_sequence_or_null_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceOrNullMember);
    r.m_enum_member = #fun(Option::from_js[String])(#var(value).enumMember);
    r.m_enum_member_with_default = #fun(Option::from_js[String])(#var(value).enumMemberWithDefault);
    r.m_enum_or_null_member = #fun(Option::from_js[String])(#var(value).enumOrNullMember);
    r.m_element_member = #fun(Option::from_js[mut Element])(#var(value).elementMember);
    r.m_element_or_null_member = #fun(Option::from_js[mut Element])(#var(value).elementOrNullMember);
    r.m_object_member = #fun(Option::from_js[JsObject])(#var(value).objectMember);
    r.m_object_or_null_member_with_default = #fun(Option::from_js[JsObject])(#var(value).objectOrNullMemberWithDefault);
    r.m_double_or_string_member = #fun(Option::from_js[JsValue])(#var(value).doubleOrStringMember);
    r.m_double_or_string_sequence_member = #fun(Option::from_js[List[JsValue]])(#var(value).doubleOrStringSequenceMember);
    r.m_event_target_or_null_member = #fun(Option::from_js[mut EventTarget])(#var(value).eventTargetOrNullMember);
    r.m_internal_enum_or_internal_enum_sequence_member = #fun(Option::from_js[JsValue])(#var(value).internalEnumOrInternalEnumSequenceMember);
    r.m_any_member = #fun(Option::from_js[JsValue])(#var(value).anyMember);
    r.m_callback_function_member = #fun(Option::from_js[Fun(String, String) -> String])(#var(value).callbackFunctionMember);
    return r;
"

pub ext fun InternalDictionaryDerived::as_js(self: InternalDictionaryDerived) -> JsValue = "
    const r = {};
    r.derivedStringMember = #fun(Option::as_js_undef[String])(#var(self).m_derived_string_member);
    r.derivedStringMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_derived_string_member_with_default);
    r.requiredBooleanMember = #fun(Bool::as_js)(#var(self).m_required_boolean_member);
    r.longMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_member);
    r.longMemberWithClamp = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_clamp);
    r.longMemberWithEnforceRange = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_enforce_range);
    r.longMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_default);
    r.longOrNullMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member);
    r.longOrNullMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member_with_default);
    r.booleanMember = #fun(Option::as_js_undef[Bool])(#var(self).m_boolean_member);
    r.doubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_double_member);
    r.unrestrictedDoubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_unrestricted_double_member);
    r.stringMember = #fun(Option::as_js_undef[String])(#var(self).m_string_member);
    r.stringMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_string_member_with_default);
    r.byteStringMember = #fun(Option::as_js_undef[String])(#var(self).m_byte_string_member);
    r.usvStringMember = #fun(Option::as_js_undef[String])(#var(self).m_usv_string_member);
    r.stringSequenceMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member);
    r.stringSequenceMemberWithDefault = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member_with_default);
    r.stringSequenceOrNullMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_or_null_member);
    r.enumMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_member);
    r.enumMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_enum_member_with_default);
    r.enumOrNullMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_or_null_member);
    r.elementMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_member);
    r.elementOrNullMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_or_null_member);
    r.objectMember = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_member);
    r.objectOrNullMemberWithDefault = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_or_null_member_with_default);
    r.doubleOrStringMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_double_or_string_member);
    r.doubleOrStringSequenceMember = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_double_or_string_sequence_member);
    r.eventTargetOrNullMember = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_event_target_or_null_member);
    r.internalEnumOrInternalEnumSequenceMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_internal_enum_or_internal_enum_sequence_member);
    r.anyMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_any_member);
    r.callbackFunctionMember = #fun(Option::as_js_undef[Fun(String, String) -> String])(#var(self).m_callback_function_member);
    return r;
"

pub struct InternalDictionaryDerivedDerived(
    derived_derived_string_member: Option[String],
    derived_string_member: Option[String],
    derived_string_member_with_default: Option[String],
    required_boolean_member: Bool,
    long_member: Option[Int],
    long_member_with_clamp: Option[Int],
    long_member_with_enforce_range: Option[Int],
    long_member_with_default: Option[Int],
    long_or_null_member: Option[Int],
    long_or_null_member_with_default: Option[Int],
    boolean_member: Option[Bool],
    double_member: Option[Float],
    unrestricted_double_member: Option[Float],
    string_member: Option[String],
    string_member_with_default: Option[String],
    byte_string_member: Option[String],
    usv_string_member: Option[String],
    string_sequence_member: Option[List[String]],
    string_sequence_member_with_default: Option[List[String]],
    string_sequence_or_null_member: Option[List[String]],
    enum_member: Option[String],
    enum_member_with_default: Option[String],
    enum_or_null_member: Option[String],
    element_member: Option[mut Element],
    element_or_null_member: Option[mut Element],
    object_member: Option[JsObject],
    object_or_null_member_with_default: Option[JsObject],
    double_or_string_member: Option[JsValue],
    double_or_string_sequence_member: Option[List[JsValue]],
    event_target_or_null_member: Option[mut EventTarget],
    internal_enum_or_internal_enum_sequence_member: Option[JsValue],
    any_member: Option[JsValue],
    callback_function_member: Option[Fun(String, String) -> String]
)

pub fun InternalDictionaryDerivedDerived::default(required_boolean_member: Bool) -> mut InternalDictionaryDerivedDerived
    = InternalDictionaryDerivedDerived(Option::None, Option::None, Option::Some("derivedDefaultStringValue"), required_boolean_member, Option::None, Option::None, Option::None, Option::Some(42), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::Some("defaultStringValue"), Option::None, Option::None, Option::None, Option::Some(List::empty()), Option::None, Option::None, Option::Some("foo"), Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

/// Converts a reference to 'InternalDictionaryDerivedDerived' to a reference to 'InternalDictionaryDerived'.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerivedDerived::as_internal_dictionary_derived(self: InternalDictionaryDerivedDerived) -> InternalDictionaryDerived = "return #var(self);"

/// Converts a mutable reference to 'InternalDictionaryDerivedDerived' to a mutable reference to 'InternalDictionaryDerived'.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerivedDerived::as_minternal_dictionary_derived(self: mut InternalDictionaryDerivedDerived) -> mut InternalDictionaryDerived = "return #var(self);"

/// Attempts to convert a reference to 'InternalDictionaryDerived' to a reference to 'InternalDictionaryDerivedDerived'.
/// A 'base' that is not a reference to 'InternalDictionaryDerivedDerived' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerivedDerived::from_internal_dictionary_derived_unchecked(base: InternalDictionaryDerived) -> InternalDictionaryDerivedDerived = "return #var(base);"

/// Attempts to convert a mutable reference to 'InternalDictionaryDerived' to a mutable reference to 'InternalDictionaryDerivedDerived'.
/// A 'base' that is not a reference to 'InternalDictionaryDerivedDerived' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun InternalDictionaryDerivedDerived::from_minternal_dictionary_derived_unchecked(base: mut InternalDictionaryDerived) -> mut InternalDictionaryDerivedDerived = "return #var(base);"

pub ext fun InternalDictionaryDerivedDerived::from_js(value: JsValue) -> mut InternalDictionaryDerivedDerived = "
    const r = {};
    r.m_derived_derived_string_member = #fun(Option::from_js[String])(#var(value).derivedDerivedStringMember);
    r.m_derived_string_member = #fun(Option::from_js[String])(#var(value).derivedStringMember);
    r.m_derived_string_member_with_default = #fun(Option::from_js[String])(#var(value).derivedStringMemberWithDefault);
    r.m_required_boolean_member = #fun(Bool::from_js)(#var(value).requiredBooleanMember);
    r.m_long_member = #fun(Option::from_js[Int])(#var(value).longMember);
    r.m_long_member_with_clamp = #fun(Option::from_js[Int])(#var(value).longMemberWithClamp);
    r.m_long_member_with_enforce_range = #fun(Option::from_js[Int])(#var(value).longMemberWithEnforceRange);
    r.m_long_member_with_default = #fun(Option::from_js[Int])(#var(value).longMemberWithDefault);
    r.m_long_or_null_member = #fun(Option::from_js[Int])(#var(value).longOrNullMember);
    r.m_long_or_null_member_with_default = #fun(Option::from_js[Int])(#var(value).longOrNullMemberWithDefault);
    r.m_boolean_member = #fun(Option::from_js[Bool])(#var(value).booleanMember);
    r.m_double_member = #fun(Option::from_js[Float])(#var(value).doubleMember);
    r.m_unrestricted_double_member = #fun(Option::from_js[Float])(#var(value).unrestrictedDoubleMember);
    r.m_string_member = #fun(Option::from_js[String])(#var(value).stringMember);
    r.m_string_member_with_default = #fun(Option::from_js[String])(#var(value).stringMemberWithDefault);
    r.m_byte_string_member = #fun(Option::from_js[String])(#var(value).byteStringMember);
    r.m_usv_string_member = #fun(Option::from_js[String])(#var(value).usvStringMember);
    r.m_string_sequence_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMember);
    r.m_string_sequence_member_with_default = #fun(Option::from_js[List[String]])(#var(value).stringSequenceMemberWithDefault);
    r.m_string_sequence_or_null_member = #fun(Option::from_js[List[String]])(#var(value).stringSequenceOrNullMember);
    r.m_enum_member = #fun(Option::from_js[String])(#var(value).enumMember);
    r.m_enum_member_with_default = #fun(Option::from_js[String])(#var(value).enumMemberWithDefault);
    r.m_enum_or_null_member = #fun(Option::from_js[String])(#var(value).enumOrNullMember);
    r.m_element_member = #fun(Option::from_js[mut Element])(#var(value).elementMember);
    r.m_element_or_null_member = #fun(Option::from_js[mut Element])(#var(value).elementOrNullMember);
    r.m_object_member = #fun(Option::from_js[JsObject])(#var(value).objectMember);
    r.m_object_or_null_member_with_default = #fun(Option::from_js[JsObject])(#var(value).objectOrNullMemberWithDefault);
    r.m_double_or_string_member = #fun(Option::from_js[JsValue])(#var(value).doubleOrStringMember);
    r.m_double_or_string_sequence_member = #fun(Option::from_js[List[JsValue]])(#var(value).doubleOrStringSequenceMember);
    r.m_event_target_or_null_member = #fun(Option::from_js[mut EventTarget])(#var(value).eventTargetOrNullMember);
    r.m_internal_enum_or_internal_enum_sequence_member = #fun(Option::from_js[JsValue])(#var(value).internalEnumOrInternalEnumSequenceMember);
    r.m_any_member = #fun(Option::from_js[JsValue])(#var(value).anyMember);
    r.m_callback_function_member = #fun(Option::from_js[Fun(String, String) -> String])(#var(value).callbackFunctionMember);
    return r;
"

pub ext fun InternalDictionaryDerivedDerived::as_js(self: InternalDictionaryDerivedDerived) -> JsValue = "
    const r = {};
    r.derivedDerivedStringMember = #fun(Option::as_js_undef[String])(#var(self).m_derived_derived_string_member);
    r.derivedStringMember = #fun(Option::as_js_undef[String])(#var(self).m_derived_string_member);
    r.derivedStringMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_derived_string_member_with_default);
    r.requiredBooleanMember = #fun(Bool::as_js)(#var(self).m_required_boolean_member);
    r.longMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_member);
    r.longMemberWithClamp = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_clamp);
    r.longMemberWithEnforceRange = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_enforce_range);
    r.longMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_member_with_default);
    r.longOrNullMember = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member);
    r.longOrNullMemberWithDefault = #fun(Option::as_js_undef[Int])(#var(self).m_long_or_null_member_with_default);
    r.booleanMember = #fun(Option::as_js_undef[Bool])(#var(self).m_boolean_member);
    r.doubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_double_member);
    r.unrestrictedDoubleMember = #fun(Option::as_js_undef[Float])(#var(self).m_unrestricted_double_member);
    r.stringMember = #fun(Option::as_js_undef[String])(#var(self).m_string_member);
    r.stringMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_string_member_with_default);
    r.byteStringMember = #fun(Option::as_js_undef[String])(#var(self).m_byte_string_member);
    r.usvStringMember = #fun(Option::as_js_undef[String])(#var(self).m_usv_string_member);
    r.stringSequenceMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member);
    r.stringSequenceMemberWithDefault = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_member_with_default);
    r.stringSequenceOrNullMember = #fun(Option::as_js_undef[List[String]])(#var(self).m_string_sequence_or_null_member);
    r.enumMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_member);
    r.enumMemberWithDefault = #fun(Option::as_js_undef[String])(#var(self).m_enum_member_with_default);
    r.enumOrNullMember = #fun(Option::as_js_undef[String])(#var(self).m_enum_or_null_member);
    r.elementMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_member);
    r.elementOrNullMember = #fun(Option::as_js_undef[mut Element])(#var(self).m_element_or_null_member);
    r.objectMember = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_member);
    r.objectOrNullMemberWithDefault = #fun(Option::as_js_undef[JsObject])(#var(self).m_object_or_null_member_with_default);
    r.doubleOrStringMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_double_or_string_member);
    r.doubleOrStringSequenceMember = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_double_or_string_sequence_member);
    r.eventTargetOrNullMember = #fun(Option::as_js_undef[mut EventTarget])(#var(self).m_event_target_or_null_member);
    r.internalEnumOrInternalEnumSequenceMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_internal_enum_or_internal_enum_sequence_member);
    r.anyMember = #fun(Option::as_js_undef[JsValue])(#var(self).m_any_member);
    r.callbackFunctionMember = #fun(Option::as_js_undef[Fun(String, String) -> String])(#var(self).m_callback_function_member);
    return r;
"

struct InternalSettings()

pub ext fun InternalSettings::set_standard_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setStandardFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_serif_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setSerifFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_sans_serif_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setSansSerifFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_fixed_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setFixedFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_cursive_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setCursiveFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_fantasy_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setFantasyFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_math_font_family(__self: mut InternalSettings, family: String, script: String) -> Unit = "
    const r = #var(__self).setMathFontFamily(#fun(String::as_js)(#var(family)), #fun(String::as_js)(#var(script)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_text_autosizing_window_size_override(__self: mut InternalSettings, width: Int, height: Int) -> Unit = "
    const r = #var(__self).setTextAutosizingWindowSizeOverride(#fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_text_track_kind_user_preference(__self: mut InternalSettings, preference: String) -> Unit = "
    const r = #var(__self).setTextTrackKindUserPreference(#fun(String::as_js)(#var(preference)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_display_mode_override(__self: mut InternalSettings, display_mode_override: String) -> Unit = "
    const r = #var(__self).setDisplayModeOverride(#fun(String::as_js)(#var(display_mode_override)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_editing_behavior(__self: mut InternalSettings, behavior: String) -> Unit = "
    const r = #var(__self).setEditingBehavior(#fun(String::as_js)(#var(behavior)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_viewport_style(__self: mut InternalSettings, style: String) -> Unit = "
    const r = #var(__self).setViewportStyle(#fun(String::as_js)(#var(style)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_available_pointer_types(__self: mut InternalSettings, pointers: String) -> Unit = "
    const r = #var(__self).setAvailablePointerTypes(#fun(String::as_js)(#var(pointers)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_primary_pointer_type(__self: mut InternalSettings, pointer: String) -> Unit = "
    const r = #var(__self).setPrimaryPointerType(#fun(String::as_js)(#var(pointer)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_available_hover_types(__self: mut InternalSettings, types: String) -> Unit = "
    const r = #var(__self).setAvailableHoverTypes(#fun(String::as_js)(#var(types)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_primary_hover_type(__self: mut InternalSettings, type: String) -> Unit = "
    const r = #var(__self).setPrimaryHoverType(#fun(String::as_js)(#var(type)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_image_animation_policy(__self: mut InternalSettings, policy: String) -> Unit = "
    const r = #var(__self).setImageAnimationPolicy(#fun(String::as_js)(#var(policy)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_autoplay_policy(__self: mut InternalSettings, policy: String) -> Unit = "
    const r = #var(__self).setAutoplayPolicy(#fun(String::as_js)(#var(policy)));
    return #fun(Unit::from_js)(r);
"

pub ext fun InternalSettings::set_prefer_compositing_to_lcd_text_enabled(__self: mut InternalSettings, enabled: Bool) -> Unit = "
    const r = #var(__self).setPreferCompositingToLCDTextEnabled(#fun(Bool::as_js)(#var(enabled)));
    return #fun(Unit::from_js)(r);
"

pub fun InternalSettings::as_js(self: InternalSettings) -> JsValue = JsValue::unsafe_from[InternalSettings](self)

pub fun InternalSettings::from_js(v: JsValue) -> mut InternalSettings = JsValue::unsafe_as[mut InternalSettings](v)

pub ext fun Internals::page_popup_window(self: Internals) -> mut Window
    = "return #fun(Window::from_js)(#var(self).pagePopupWindow);"

pub ext fun Internals::settings(self: Internals) -> mut InternalSettings
    = "return #fun(InternalSettings::from_js)(#var(self).settings);"

pub ext fun Internals::runtime_flags(self: Internals) -> JsValue
    = "return #var(self).runtimeFlags;"

pub ext fun Internals::worker_thread_count(self: Internals) -> Int
    = "return #fun(Int::from_js)(#var(self).workerThreadCount);"

pub ext fun Internals::cursor_update_pending(self: Internals) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cursorUpdatePending);"

pub ext fun Internals::visible_selection_anchor_node(self: Internals) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).visibleSelectionAnchorNode);"

pub ext fun Internals::visible_selection_anchor_offset(self: Internals) -> Int
    = "return #fun(Int::from_js)(#var(self).visibleSelectionAnchorOffset);"

pub ext fun Internals::visible_selection_focus_node(self: Internals) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).visibleSelectionFocusNode);"

pub ext fun Internals::visible_selection_focus_offset(self: Internals) -> Int
    = "return #fun(Int::from_js)(#var(self).visibleSelectionFocusOffset);"

pub ext fun Internals::text_affinity(self: Internals) -> String
    = "return #fun(String::from_js)(#var(self).textAffinity);"

pub ext fun Internals::length(self: Internals) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Internals::unscopable_attribute(self: Internals) -> String
    = "return #fun(String::from_js)(#var(self).unscopableAttribute);"

pub ext fun Internals::overlay_scrollbars_enabled(self: Internals) -> Bool
    = "return #fun(Bool::from_js)(#var(self).overlayScrollbarsEnabled);"

pub ext fun Internals::observe_gc(__self: mut Internals, observed: JsValue) -> mut GCObservation = "
    const r = #var(__self).observeGC(#var(observed));
    return #fun(GCObservation::from_js)(r);
"

pub ext fun Internals::element_layout_tree_as_text(__self: mut Internals, element: mut Element) -> String = "
    const r = #var(__self).elementLayoutTreeAsText(#fun(Element::as_js)(#var(element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::is_preloaded(__self: mut Internals, url: String) -> Bool = "
    const r = #var(__self).isPreloaded(#fun(String::as_js)(#var(url)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_preloaded_by(__self: mut Internals, url: String, document: mut Document) -> Bool = "
    const r = #var(__self).isPreloadedBy(#fun(String::as_js)(#var(url)), #fun(Document::as_js)(#var(document)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_loading(__self: mut Internals, url: String) -> Bool = "
    const r = #var(__self).isLoading(#fun(String::as_js)(#var(url)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_loading_from_memory_cache(__self: mut Internals, url: String) -> Bool = "
    const r = #var(__self).isLoadingFromMemoryCache(#fun(String::as_js)(#var(url)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::get_initial_resource_priority(__self: mut Internals, url: String, document: mut Document) -> Promise[Int] = "
    const r = #var(__self).getInitialResourcePriority(#fun(String::as_js)(#var(url)), #fun(Document::as_js)(#var(document)));
    return #fun(Promise::from_js[Int])(r);
"

pub ext fun Internals::get_initial_resource_priority_of_new_load(__self: mut Internals, url: String, document: mut Document) -> Promise[Int] = "
    const r = #var(__self).getInitialResourcePriorityOfNewLoad(#fun(String::as_js)(#var(url)), #fun(Document::as_js)(#var(document)));
    return #fun(Promise::from_js[Int])(r);
"

pub ext fun Internals::get_resource_header(__self: mut Internals, url: String, header: String, document: mut Document) -> String = "
    const r = #var(__self).getResourceHeader(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(header)), #fun(Document::as_js)(#var(document)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::does_window_have_url_fragment(__self: mut Internals, window: mut Window) -> Bool = "
    const r = #var(__self).doesWindowHaveUrlFragment(#fun(Window::as_js)(#var(window)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::computed_style_including_visited_info(__self: mut Internals, element: mut Element) -> mut CSSStyleDeclaration = "
    const r = #var(__self).computedStyleIncludingVisitedInfo(#fun(Element::as_js)(#var(element)));
    return #fun(CSSStyleDeclaration::from_js)(r);
"

pub ext fun Internals::create_user_agent_shadow_root(__self: mut Internals, host: mut Element) -> mut ShadowRoot = "
    const r = #var(__self).createUserAgentShadowRoot(#fun(Element::as_js)(#var(host)));
    return #fun(ShadowRoot::from_js)(r);
"

pub ext fun Internals::shadow_root(__self: mut Internals, host: mut Element) -> mut ShadowRoot = "
    const r = #var(__self).shadowRoot(#fun(Element::as_js)(#var(host)));
    return #fun(ShadowRoot::from_js)(r);
"

pub ext fun Internals::set_browser_controls_state(__self: mut Internals, top__height: Float, bottom__height: Float, shrinks_layout: Bool) -> Unit = "
    const r = #var(__self).setBrowserControlsState(#fun(Float::as_js)(#var(top__height)), #fun(Float::as_js)(#var(bottom__height)), #fun(Bool::as_js)(#var(shrinks_layout)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_browser_controls_shown_ratio(__self: mut Internals, top__ratio: Float, bottom__ratio: Float) -> Unit = "
    const r = #var(__self).setBrowserControlsShownRatio(#fun(Float::as_js)(#var(top__ratio)), #fun(Float::as_js)(#var(bottom__ratio)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::effective_root_scroller(__self: mut Internals, document: mut Document) -> mut Node = "
    const r = #var(__self).effectiveRootScroller(#fun(Document::as_js)(#var(document)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::shadow_root_mode(__self: mut Internals, root: mut Node) -> String = "
    const r = #var(__self).ShadowRootMode(#fun(Node::as_js)(#var(root)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::count_element_shadow(__self: mut Internals, root: mut Node) -> Int = "
    const r = #var(__self).countElementShadow(#fun(Node::as_js)(#var(root)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::shadow_pseudo_id(__self: mut Internals, element: mut Element) -> String = "
    const r = #var(__self).shadowPseudoId(#fun(Element::as_js)(#var(element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::tree_scope_root_node(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).treeScopeRootNode(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::parent_tree_scope(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).parentTreeScope(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::compare_tree_scope_position(__self: mut Internals, tree_scope_1: mut Node, tree_scope_2: mut Node) -> Int = "
    const r = #var(__self).compareTreeScopePosition(#fun(Node::as_js)(#var(tree_scope_1)), #fun(Node::as_js)(#var(tree_scope_2)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::update_style_and_return_affected_element_count(__self: mut Internals) -> Int = "
    const r = #var(__self).updateStyleAndReturnAffectedElementCount();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::style_for_element_count(__self: mut Internals) -> Int = "
    const r = #var(__self).styleForElementCount();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::needs_layout_count(__self: mut Internals) -> Int = "
    const r = #var(__self).needsLayoutCount();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::layout_count_for_testing(__self: mut Internals) -> Int = "
    const r = #var(__self).layoutCountForTesting();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::node_needs_style_recalc(__self: mut Internals, node: mut Node) -> Bool = "
    const r = #var(__self).nodeNeedsStyleRecalc(#fun(Node::as_js)(#var(node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::hit_test_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).hitTestCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::hit_test_cache_hits(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).hitTestCacheHits(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::element_from_point(__self: mut Internals, document: mut Document, x: Float, y: Float, ignore_clipping: Bool, allow_child_frame_content: Bool) -> Option[mut Element] = "
    const r = #var(__self).elementFromPoint(#fun(Document::as_js)(#var(document)), #fun(Float::as_js)(#var(x)), #fun(Float::as_js)(#var(y)), #fun(Bool::as_js)(#var(ignore_clipping)), #fun(Bool::as_js)(#var(allow_child_frame_content)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Internals::clear_hit_test_cache(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).clearHitTestCache(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::inner_editor_element(__self: mut Internals, container: mut Element) -> Option[mut Element] = "
    const r = #var(__self).innerEditorElement(#fun(Element::as_js)(#var(container)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Internals::pause_animations(__self: mut Internals, pause_time: Float) -> Unit = "
    const r = #var(__self).pauseAnimations(#fun(Float::as_js)(#var(pause_time)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_composited_animation(__self: mut Internals, animation: mut Animation) -> Bool = "
    const r = #var(__self).isCompositedAnimation(#fun(Animation::as_js)(#var(animation)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::disable_composited_animation(__self: mut Internals, animation: mut Animation) -> Unit = "
    const r = #var(__self).disableCompositedAnimation(#fun(Animation::as_js)(#var(animation)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::advance_image_animation(__self: mut Internals, image: mut Element) -> Unit = "
    const r = #var(__self).advanceImageAnimation(#fun(Element::as_js)(#var(image)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::next_sibling_in_flat_tree(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).nextSiblingInFlatTree(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::first_child_in_flat_tree(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).firstChildInFlatTree(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::last_child_in_flat_tree(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).lastChildInFlatTree(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::next_in_flat_tree(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).nextInFlatTree(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::previous_in_flat_tree(__self: mut Internals, node: mut Node) -> mut Node = "
    const r = #var(__self).previousInFlatTree(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::is_validation_message_visible(__self: mut Internals, element: mut Element) -> Bool = "
    const r = #var(__self).isValidationMessageVisible(#fun(Element::as_js)(#var(element)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::select_color_in_color_chooser(__self: mut Internals, element: mut Element, color_value: String) -> Unit = "
    const r = #var(__self).selectColorInColorChooser(#fun(Element::as_js)(#var(element)), #fun(String::as_js)(#var(color_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::end_color_chooser(__self: mut Internals, element: mut Element) -> Unit = "
    const r = #var(__self).endColorChooser(#fun(Element::as_js)(#var(element)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::has_autofocus_request(__self: mut Internals, document: mut Document) -> Bool = "
    const r = #var(__self).hasAutofocusRequest(#fun(Document::as_js)(#var(document)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::form_control_state_of_history_item(__self: mut Internals) -> List[String] = "
    const r = #var(__self).formControlStateOfHistoryItem();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::set_form_control_state_of_history_item(__self: mut Internals, values: List[String]) -> Unit = "
    const r = #var(__self).setFormControlStateOfHistoryItem(#fun(List::as_js[String])(#var(values)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::absolute_caret_bounds(__self: mut Internals) -> mut DOMRectReadOnly = "
    const r = #var(__self).absoluteCaretBounds();
    return #fun(DOMRectReadOnly::from_js)(r);
"

pub ext fun Internals::bounding_box(__self: mut Internals, element: mut Element) -> mut DOMRectReadOnly = "
    const r = #var(__self).boundingBox(#fun(Element::as_js)(#var(element)));
    return #fun(DOMRectReadOnly::from_js)(r);
"

pub ext fun Internals::set_marker(__self: mut Internals, document: mut Document, range: mut Range, marker_type: String) -> Unit = "
    const r = #var(__self).setMarker(#fun(Document::as_js)(#var(document)), #fun(Range::as_js)(#var(range)), #fun(String::as_js)(#var(marker_type)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::remove_marker(__self: mut Internals, document: mut Document, range: mut Range, marker_type: String) -> Unit = "
    const r = #var(__self).removeMarker(#fun(Document::as_js)(#var(document)), #fun(Range::as_js)(#var(range)), #fun(String::as_js)(#var(marker_type)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::marker_count_for_node(__self: mut Internals, text: mut Text, marker_type: String) -> Int = "
    const r = #var(__self).markerCountForNode(#fun(Text::as_js)(#var(text)), #fun(String::as_js)(#var(marker_type)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::active_marker_count_for_node(__self: mut Internals, text: mut Text) -> Int = "
    const r = #var(__self).activeMarkerCountForNode(#fun(Text::as_js)(#var(text)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::marker_range_for_node(__self: mut Internals, text: mut Text, marker_type: String, index: Int) -> mut Range = "
    const r = #var(__self).markerRangeForNode(#fun(Text::as_js)(#var(text)), #fun(String::as_js)(#var(marker_type)), #fun(Int::as_js)(#var(index)));
    return #fun(Range::from_js)(r);
"

pub ext fun Internals::marker_description_for_node(__self: mut Internals, text: mut Text, marker_type: String, index: Int) -> String = "
    const r = #var(__self).markerDescriptionForNode(#fun(Text::as_js)(#var(text)), #fun(String::as_js)(#var(marker_type)), #fun(Int::as_js)(#var(index)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::marker_background_color_for_node(__self: mut Internals, text: mut Text, marker_type: String, index: Int) -> Int = "
    const r = #var(__self).markerBackgroundColorForNode(#fun(Text::as_js)(#var(text)), #fun(String::as_js)(#var(marker_type)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::marker_underline_color_for_node(__self: mut Internals, text: mut Text, marker_type: String, index: Int) -> Int = "
    const r = #var(__self).markerUnderlineColorForNode(#fun(Text::as_js)(#var(text)), #fun(String::as_js)(#var(marker_type)), #fun(Int::as_js)(#var(index)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::add_text_match_marker(__self: mut Internals, range: mut Range, match_status: String) -> Unit = "
    const r = #var(__self).addTextMatchMarker(#fun(Range::as_js)(#var(range)), #fun(String::as_js)(#var(match_status)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::add_composition_marker(__self: mut Internals, range: mut Range, underline_color_value: String, thickness_value: String, underline_style_value: String, text_color_value: String, background_color_value: String) -> Unit = "
    const r = #var(__self).addCompositionMarker(#fun(Range::as_js)(#var(range)), #fun(String::as_js)(#var(underline_color_value)), #fun(String::as_js)(#var(thickness_value)), #fun(String::as_js)(#var(underline_style_value)), #fun(String::as_js)(#var(text_color_value)), #fun(String::as_js)(#var(background_color_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::add_active_suggestion_marker(__self: mut Internals, range: mut Range, underline_color_value: String, thickness_value: String, background_color_value: String) -> Unit = "
    const r = #var(__self).addActiveSuggestionMarker(#fun(Range::as_js)(#var(range)), #fun(String::as_js)(#var(underline_color_value)), #fun(String::as_js)(#var(thickness_value)), #fun(String::as_js)(#var(background_color_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::add_suggestion_marker(__self: mut Internals, range: mut Range, suggestions: List[String], suggestion_highlight_color_value: String, underline_color_value: String, thickness_value: String, background_color_value: String) -> Unit = "
    const r = #var(__self).addSuggestionMarker(#fun(Range::as_js)(#var(range)), #fun(List::as_js[String])(#var(suggestions)), #fun(String::as_js)(#var(suggestion_highlight_color_value)), #fun(String::as_js)(#var(underline_color_value)), #fun(String::as_js)(#var(thickness_value)), #fun(String::as_js)(#var(background_color_value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_text_match_markers_active(__self: mut Internals, node: mut Node, start_offset: Int, end_offset: Int, active: Bool) -> Unit = "
    const r = #var(__self).setTextMatchMarkersActive(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(start_offset)), #fun(Int::as_js)(#var(end_offset)), #fun(Bool::as_js)(#var(active)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::viewport_as_text(__self: mut Internals, document: mut Document, device_pixel_ratio: Float, available_width: Int, available_height: Int) -> String = "
    const r = #var(__self).viewportAsText(#fun(Document::as_js)(#var(document)), #fun(Float::as_js)(#var(device_pixel_ratio)), #fun(Int::as_js)(#var(available_width)), #fun(Int::as_js)(#var(available_height)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::element_should_auto_complete(__self: mut Internals, input_element: mut Element) -> Bool = "
    const r = #var(__self).elementShouldAutoComplete(#fun(Element::as_js)(#var(input_element)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::suggested_value(__self: mut Internals, input_element: mut Element) -> String = "
    const r = #var(__self).suggestedValue(#fun(Element::as_js)(#var(input_element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::set_suggested_value(__self: mut Internals, input_element: mut Element, value: String) -> Unit = "
    const r = #var(__self).setSuggestedValue(#fun(Element::as_js)(#var(input_element)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_autofilled_value(__self: mut Internals, input_element: mut Element, value: String) -> Unit = "
    const r = #var(__self).setAutofilledValue(#fun(Element::as_js)(#var(input_element)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_autofilled(__self: mut Internals, input_element: mut Element, enabled: Bool) -> Unit = "
    const r = #var(__self).setAutofilled(#fun(Element::as_js)(#var(input_element)), #fun(Bool::as_js)(#var(enabled)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_selection_range_for_number_type(__self: mut Internals, input_element: mut Element, start: Int, end: Int) -> Unit = "
    const r = #var(__self).setSelectionRangeForNumberType(#fun(Element::as_js)(#var(input_element)), #fun(Int::as_js)(#var(start)), #fun(Int::as_js)(#var(end)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::range_from_location_and_length(__self: mut Internals, scope: mut Element, range_location: Int, range_length: Int) -> mut Range = "
    const r = #var(__self).rangeFromLocationAndLength(#fun(Element::as_js)(#var(scope)), #fun(Int::as_js)(#var(range_location)), #fun(Int::as_js)(#var(range_length)));
    return #fun(Range::from_js)(r);
"

pub ext fun Internals::location_from_range(__self: mut Internals, scope: mut Element, range: mut Range) -> Int = "
    const r = #var(__self).locationFromRange(#fun(Element::as_js)(#var(scope)), #fun(Range::as_js)(#var(range)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::length_from_range(__self: mut Internals, scope: mut Element, range: mut Range) -> Int = "
    const r = #var(__self).lengthFromRange(#fun(Element::as_js)(#var(scope)), #fun(Range::as_js)(#var(range)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::range_as_text(__self: mut Internals, range: mut Range) -> String = "
    const r = #var(__self).rangeAsText(#fun(Range::as_js)(#var(range)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::touch_position_adjusted_to_best_clickable_node(__self: mut Internals, x: Int, y: Int, width: Int, height: Int, document: mut Document) -> mut DOMPoint = "
    const r = #var(__self).touchPositionAdjustedToBestClickableNode(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Document::as_js)(#var(document)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun Internals::touch_node_adjusted_to_best_clickable_node(__self: mut Internals, x: Int, y: Int, width: Int, height: Int, document: mut Document) -> mut Node = "
    const r = #var(__self).touchNodeAdjustedToBestClickableNode(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Document::as_js)(#var(document)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::touch_position_adjusted_to_best_context_menu_node(__self: mut Internals, x: Int, y: Int, width: Int, height: Int, document: mut Document) -> mut DOMPoint = "
    const r = #var(__self).touchPositionAdjustedToBestContextMenuNode(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Document::as_js)(#var(document)));
    return #fun(DOMPoint::from_js)(r);
"

pub ext fun Internals::touch_node_adjusted_to_best_context_menu_node(__self: mut Internals, x: Int, y: Int, width: Int, height: Int, document: mut Document) -> mut Node = "
    const r = #var(__self).touchNodeAdjustedToBestContextMenuNode(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Document::as_js)(#var(document)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::touch_node_adjusted_to_best_stylus_writable_node(__self: mut Internals, x: Int, y: Int, width: Int, height: Int, document: mut Document) -> mut Node = "
    const r = #var(__self).touchNodeAdjustedToBestStylusWritableNode(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Document::as_js)(#var(document)));
    return #fun(Node::from_js)(r);
"

pub ext fun Internals::last_spell_check_request_sequence(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).lastSpellCheckRequestSequence(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::last_spell_check_processed_sequence(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).lastSpellCheckProcessedSequence(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::spell_checked_text_length(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).spellCheckedTextLength(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::cancel_current_spell_check_request(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).cancelCurrentSpellCheckRequest(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::idle_time_spell_checker_state(__self: mut Internals, document: mut Document) -> String = "
    const r = #var(__self).idleTimeSpellCheckerState(#fun(Document::as_js)(#var(document)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::run_idle_time_spell_checker(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).runIdleTimeSpellChecker(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::has_last_edit_command(__self: mut Internals, document: mut Document) -> Bool = "
    const r = #var(__self).hasLastEditCommand(#fun(Document::as_js)(#var(document)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::user_preferred_languages(__self: mut Internals) -> List[String] = "
    const r = #var(__self).userPreferredLanguages();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::set_user_preferred_languages(__self: mut Internals, languages: List[String]) -> Unit = "
    const r = #var(__self).setUserPreferredLanguages(#fun(List::as_js[String])(#var(languages)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_system_time_zone(__self: mut Internals, timezone: String) -> Unit = "
    const r = #var(__self).setSystemTimeZone(#fun(String::as_js)(#var(timezone)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::media_keys_count(__self: mut Internals) -> Int = "
    const r = #var(__self).mediaKeysCount();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::media_key_session_count(__self: mut Internals) -> Int = "
    const r = #var(__self).mediaKeySessionCount();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::wheel_event_handler_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).wheelEventHandlerCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::scroll_event_handler_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).scrollEventHandlerCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::touch_start_or_move_event_handler_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).touchStartOrMoveEventHandlerCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::touch_end_or_cancel_event_handler_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).touchEndOrCancelEventHandlerCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::pointer_event_handler_count(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).pointerEventHandlerCount(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::touch_event_target_layer_rects(__self: mut Internals, document: mut Document) -> mut HitTestLayerRectList = "
    const r = #var(__self).touchEventTargetLayerRects(#fun(Document::as_js)(#var(document)));
    return #fun(HitTestLayerRectList::from_js)(r);
"

pub ext fun Internals::execute_command(__self: mut Internals, document: mut Document, name: String, value: String) -> Bool = "
    const r = #var(__self).executeCommand(#fun(Document::as_js)(#var(document)), #fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::trigger_test_inspector_issue(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).triggerTestInspectorIssue(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::html_namespace(__self: mut Internals) -> String = "
    const r = #var(__self).htmlNamespace();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::html_tags(__self: mut Internals) -> List[String] = "
    const r = #var(__self).htmlTags();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::svg_namespace(__self: mut Internals) -> String = "
    const r = #var(__self).svgNamespace();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::svg_tags(__self: mut Internals) -> List[String] = "
    const r = #var(__self).svgTags();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::nodes_from_rect(__self: mut Internals, document: mut Document, x: Int, y: Int, width: Int, height: Int, ignore_clipping: Bool, allow_child_frame_content: Bool) -> mut NodeList = "
    const r = #var(__self).nodesFromRect(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)), #fun(Int::as_js)(#var(width)), #fun(Int::as_js)(#var(height)), #fun(Bool::as_js)(#var(ignore_clipping)), #fun(Bool::as_js)(#var(allow_child_frame_content)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Internals::has_spelling_marker(__self: mut Internals, document: mut Document, from: Int, length: Int) -> Bool = "
    const r = #var(__self).hasSpellingMarker(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(from)), #fun(Int::as_js)(#var(length)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::has_grammar_marker(__self: mut Internals, document: mut Document, from: Int, length: Int) -> Bool = "
    const r = #var(__self).hasGrammarMarker(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(from)), #fun(Int::as_js)(#var(length)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::replace_misspelled(__self: mut Internals, document: mut Document, replacement: String) -> Unit = "
    const r = #var(__self).replaceMisspelled(#fun(Document::as_js)(#var(document)), #fun(String::as_js)(#var(replacement)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::can_hyphenate(__self: mut Internals, locale: String) -> Bool = "
    const r = #var(__self).canHyphenate(#fun(String::as_js)(#var(locale)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::set_mock_hyphenation(__self: mut Internals, locale: String) -> Unit = "
    const r = #var(__self).setMockHyphenation(#fun(String::as_js)(#var(locale)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::number_of_scrollable_areas(__self: mut Internals, document: mut Document) -> Int = "
    const r = #var(__self).numberOfScrollableAreas(#fun(Document::as_js)(#var(document)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::layer_tree_as_text(__self: mut Internals, document: mut Document, flags: Int) -> String = "
    const r = #var(__self).layerTreeAsText(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(flags)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::main_thread_scrolling_reasons(__self: mut Internals, document: mut Document) -> String = "
    const r = #var(__self).mainThreadScrollingReasons(#fun(Document::as_js)(#var(document)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::evict_all_resources(__self: mut Internals) -> Unit = "
    const r = #var(__self).evictAllResources();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::number_of_live_nodes(__self: mut Internals) -> Int = "
    const r = #var(__self).numberOfLiveNodes();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::number_of_live_documents(__self: mut Internals) -> Int = "
    const r = #var(__self).numberOfLiveDocuments();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::counter_value(__self: mut Internals, element: mut Element) -> String = "
    const r = #var(__self).counterValue(#fun(Element::as_js)(#var(element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::page_number(__self: mut Internals, element: mut Element, page_width: Float, page_height: Float) -> Int = "
    const r = #var(__self).pageNumber(#fun(Element::as_js)(#var(element)), #fun(Float::as_js)(#var(page_width)), #fun(Float::as_js)(#var(page_height)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::shortcut_icon_ur_ls(__self: mut Internals, document: mut Document) -> List[String] = "
    const r = #var(__self).shortcutIconURLs(#fun(Document::as_js)(#var(document)));
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::all_icon_ur_ls(__self: mut Internals, document: mut Document) -> List[String] = "
    const r = #var(__self).allIconURLs(#fun(Document::as_js)(#var(document)));
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::number_of_pages(__self: mut Internals, page_width_in_pixels: Float, page_height_in_pixels: Float) -> Int = "
    const r = #var(__self).numberOfPages(#fun(Float::as_js)(#var(page_width_in_pixels)), #fun(Float::as_js)(#var(page_height_in_pixels)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::page_scale_factor(__self: mut Internals) -> Float = "
    const r = #var(__self).pageScaleFactor();
    return #fun(Float::from_js)(r);
"

pub ext fun Internals::set_page_scale_factor(__self: mut Internals, scale_factor: Float) -> Unit = "
    const r = #var(__self).setPageScaleFactor(#fun(Float::as_js)(#var(scale_factor)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_page_scale_factor_limits(__self: mut Internals, min_scale_factor: Float, max_scale_factor: Float) -> Unit = "
    const r = #var(__self).setPageScaleFactorLimits(#fun(Float::as_js)(#var(min_scale_factor)), #fun(Float::as_js)(#var(max_scale_factor)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::layout_zoom_factor(__self: mut Internals) -> Float = "
    const r = #var(__self).layoutZoomFactor();
    return #fun(Float::from_js)(r);
"

pub ext fun Internals::set_is_cursor_visible(__self: mut Internals, document: mut Document, is_visible: Bool) -> Unit = "
    const r = #var(__self).setIsCursorVisible(#fun(Document::as_js)(#var(document)), #fun(Bool::as_js)(#var(is_visible)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_max_number_of_frames_to_ten(__self: mut Internals, enable: Bool) -> Unit = "
    const r = #var(__self).setMaxNumberOfFramesToTen(#fun(Bool::as_js)(#var(enable)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::effective_preload(__self: mut Internals, media_element: mut HTMLMediaElement) -> String = "
    const r = #var(__self).effectivePreload(#fun(HTMLMediaElement::as_js)(#var(media_element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::media_player_remote_route_availability_changed(__self: mut Internals, media_element: mut HTMLMediaElement, available: Bool) -> Unit = "
    const r = #var(__self).mediaPlayerRemoteRouteAvailabilityChanged(#fun(HTMLMediaElement::as_js)(#var(media_element)), #fun(Bool::as_js)(#var(available)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::media_player_playing_remotely_changed(__self: mut Internals, media_element: mut HTMLMediaElement, remote: Bool) -> Unit = "
    const r = #var(__self).mediaPlayerPlayingRemotelyChanged(#fun(HTMLMediaElement::as_js)(#var(media_element)), #fun(Bool::as_js)(#var(remote)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_persistent(__self: mut Internals, video: mut HTMLVideoElement, persistent: Bool) -> Unit = "
    const r = #var(__self).setPersistent(#fun(HTMLVideoElement::as_js)(#var(video)), #fun(Bool::as_js)(#var(persistent)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::force_stale_state_for_media_element(__self: mut Internals, media_element: mut HTMLMediaElement, state: Int) -> Unit = "
    const r = #var(__self).forceStaleStateForMediaElement(#fun(HTMLMediaElement::as_js)(#var(media_element)), #fun(Int::as_js)(#var(state)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_media_element_suspended(__self: mut Internals, media_element: mut HTMLMediaElement) -> Bool = "
    const r = #var(__self).isMediaElementSuspended(#fun(HTMLMediaElement::as_js)(#var(media_element)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::set_media_controls_test_mode(__self: mut Internals, media_element: mut HTMLMediaElement, enable: Bool) -> Unit = "
    const r = #var(__self).setMediaControlsTestMode(#fun(HTMLMediaElement::as_js)(#var(media_element)), #fun(Bool::as_js)(#var(enable)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::register_url_scheme_as_bypassing_content_security_policy_str(__self: mut Internals, scheme: String) -> Unit = "
    const r = #var(__self).registerURLSchemeAsBypassingContentSecurityPolicy(#fun(String::as_js)(#var(scheme)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::register_url_scheme_as_bypassing_content_security_policy_str_list_str(__self: mut Internals, scheme: String, policy_areas: List[String]) -> Unit = "
    const r = #var(__self).registerURLSchemeAsBypassingContentSecurityPolicy(#fun(String::as_js)(#var(scheme)), #fun(List::as_js[String])(#var(policy_areas)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::remove_url_scheme_registered_as_bypassing_content_security_policy(__self: mut Internals, scheme: String) -> Unit = "
    const r = #var(__self).removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(#fun(String::as_js)(#var(scheme)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::type_conversions(__self: mut Internals) -> mut TypeConversions = "
    const r = #var(__self).typeConversions();
    return #fun(TypeConversions::from_js)(r);
"

pub ext fun Internals::get_referenced_file_paths(__self: mut Internals) -> List[String] = "
    const r = #var(__self).getReferencedFilePaths();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::disable_referenced_file_paths_verification(__self: mut Internals) -> Unit = "
    const r = #var(__self).disableReferencedFilePathsVerification();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::start_tracking_repaints(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).startTrackingRepaints(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::stop_tracking_repaints(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).stopTrackingRepaints(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::update_layout_and_run_post_layout_tasks(__self: mut Internals, node: Option[mut Node]) -> Unit = "
    const r = #var(__self).updateLayoutAndRunPostLayoutTasks(#fun(Option::as_js[mut Node])(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::force_full_repaint(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).forceFullRepaint(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::draggable_regions(__self: mut Internals, document: mut Document) -> mut DOMRectList = "
    const r = #var(__self).draggableRegions(#fun(Document::as_js)(#var(document)));
    return #fun(DOMRectList::from_js)(r);
"

pub ext fun Internals::non_draggable_regions(__self: mut Internals, document: mut Document) -> mut DOMRectList = "
    const r = #var(__self).nonDraggableRegions(#fun(Document::as_js)(#var(document)));
    return #fun(DOMRectList::from_js)(r);
"

pub ext fun Internals::set_supports_draggable_regions(__self: mut Internals, supports__draggable__regionss: Bool) -> Unit = "
    const r = #var(__self).SetSupportsDraggableRegions(#fun(Bool::as_js)(#var(supports__draggable__regionss)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_current_cursor_info(__self: mut Internals) -> String = "
    const r = #var(__self).getCurrentCursorInfo();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::marker_text_for_list_item(__self: mut Internals, element: mut Element) -> String = "
    const r = #var(__self).markerTextForListItem(#fun(Element::as_js)(#var(element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::serialize_object(__self: mut Internals, obj: JsValue) -> JsValue = "
    const r = #var(__self).serializeObject(#var(obj));
    return r;
"

pub ext fun Internals::deserialize_buffer(__self: mut Internals, buffer: JsValue) -> JsValue = "
    const r = #var(__self).deserializeBuffer(#var(buffer));
    return r;
"

pub ext fun Internals::force_reload(__self: mut Internals, end_to_end: Bool) -> Unit = "
    const r = #var(__self).forceReload(#fun(Bool::as_js)(#var(end_to_end)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_image_source_url(__self: mut Internals, element: mut Element) -> String = "
    const r = #var(__self).getImageSourceURL(#fun(Element::as_js)(#var(element)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::force_image_reload(__self: mut Internals, element: mut Element) -> Unit = "
    const r = #var(__self).forceImageReload(#fun(Element::as_js)(#var(element)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::select_menu_list_text(__self: mut Internals, select: mut HTMLSelectElement) -> String = "
    const r = #var(__self).selectMenuListText(#fun(HTMLSelectElement::as_js)(#var(select)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::is_select_popup_visible(__self: mut Internals, node: mut Node) -> Bool = "
    const r = #var(__self).isSelectPopupVisible(#fun(Node::as_js)(#var(node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::select_popup_item_style_is_rtl(__self: mut Internals, select: mut Node, item_index: Int) -> Bool = "
    const r = #var(__self).selectPopupItemStyleIsRtl(#fun(Node::as_js)(#var(select)), #fun(Int::as_js)(#var(item_index)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::select_popup_item_style_font_height(__self: mut Internals, select: mut Node, item_index: Int) -> Int = "
    const r = #var(__self).selectPopupItemStyleFontHeight(#fun(Node::as_js)(#var(select)), #fun(Int::as_js)(#var(item_index)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::reset_type_ahead_session(__self: mut Internals, select: mut HTMLSelectElement) -> Unit = "
    const r = #var(__self).resetTypeAheadSession(#fun(HTMLSelectElement::as_js)(#var(select)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_drag_caret(__self: mut Internals) -> mut StaticSelection = "
    const r = #var(__self).getDragCaret();
    return #fun(StaticSelection::from_js)(r);
"

pub ext fun Internals::get_selection_in_flat_tree(__self: mut Internals, window: mut Window) -> mut StaticSelection = "
    const r = #var(__self).getSelectionInFlatTree(#fun(Window::as_js)(#var(window)));
    return #fun(StaticSelection::from_js)(r);
"

pub ext fun Internals::selection_bounds(__self: mut Internals) -> mut DOMRect = "
    const r = #var(__self).selectionBounds();
    return #fun(DOMRect::from_js)(r);
"

pub ext fun Internals::force_compositing_update(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).forceCompositingUpdate(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_dark_preferred_color_scheme(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).setDarkPreferredColorScheme(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_dark_preferred_root_scrollbar_color_scheme(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).setDarkPreferredRootScrollbarColorScheme(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_forced_colors_and_dark_preferred_color_scheme(__self: mut Internals, document: mut Document) -> Unit = "
    const r = #var(__self).setForcedColorsAndDarkPreferredColorScheme(#fun(Document::as_js)(#var(document)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_should_reveal_password(__self: mut Internals, element: mut Element, reveal: Bool) -> Unit = "
    const r = #var(__self).setShouldRevealPassword(#fun(Element::as_js)(#var(element)), #fun(Bool::as_js)(#var(reveal)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::create_resolved_promise(__self: mut Internals, value: JsValue) -> Promise[JsValue] = "
    const r = #var(__self).createResolvedPromise(#var(value));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::create_rejected_promise(__self: mut Internals, reason: JsValue) -> Promise[JsValue] = "
    const r = #var(__self).createRejectedPromise(#var(reason));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::add_one_to_promise(__self: mut Internals, promise: Promise[Int]) -> Promise[Int] = "
    const r = #var(__self).addOneToPromise(#fun(Promise::as_js[Int])(#var(promise)));
    return #fun(Promise::from_js[Int])(r);
"

pub ext fun Internals::promise_check(__self: mut Internals, arg_1: Int, arg_2: Bool, arg_3: JsObject, arg_4: String, arg_5: List[String]) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheck(#fun(Int::as_js)(#var(arg_1)), #fun(Bool::as_js)(#var(arg_2)), #var(arg_3), #fun(String::as_js)(#var(arg_4)), #fun(List::as_js[String])(#var(arg_5)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::promise_check_without_exception_state(__self: mut Internals, arg_1: JsObject, arg_2: String, ...variadic: List[String]) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheckWithoutExceptionState(#var(arg_1), #fun(String::as_js)(#var(arg_2)), ...((#var(variadic)).map(v => #fun(String::as_js)(v))));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::promise_check_range(__self: mut Internals, arg_1: Int) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheckRange(#fun(Int::as_js)(#var(arg_1)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::promise_check_overload_mlocation(__self: mut Internals, arg_1: mut Location) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheckOverload(#fun(Location::as_js)(#var(arg_1)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::promise_check_overload_mdocument(__self: mut Internals, arg_1: mut Document) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheckOverload(#fun(Document::as_js)(#var(arg_1)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::promise_check_overload_mlocation_int_int(__self: mut Internals, arg_1: mut Location, arg_2: Int, arg_3: Int) -> Promise[JsValue] = "
    const r = #var(__self).promiseCheckOverload(#fun(Location::as_js)(#var(arg_1)), #fun(Int::as_js)(#var(arg_2)), #fun(Int::as_js)(#var(arg_3)));
    return #fun(Promise::from_js[JsValue])(r);
"

pub ext fun Internals::set_value_for_user(__self: mut Internals, element: mut HTMLInputElement, value: String) -> Unit = "
    const r = #var(__self).setValueForUser(#fun(HTMLInputElement::as_js)(#var(element)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_focused(__self: mut Internals, focused: Bool) -> Unit = "
    const r = #var(__self).setFocused(#fun(Bool::as_js)(#var(focused)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_initial_focus(__self: mut Internals, reverse: Bool) -> Unit = "
    const r = #var(__self).setInitialFocus(#fun(Bool::as_js)(#var(reverse)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_activated(__self: mut Internals) -> Bool = "
    const r = #var(__self).isActivated();
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_in_canvas_font_cache(__self: mut Internals, document: mut Document, font_string: String) -> Bool = "
    const r = #var(__self).isInCanvasFontCache(#fun(Document::as_js)(#var(document)), #fun(String::as_js)(#var(font_string)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::canvas_font_cache_max_fonts(__self: mut Internals) -> Int = "
    const r = #var(__self).canvasFontCacheMaxFonts();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::force_lose_canvas_context_any(__self: mut Internals, ctx: JsValue) -> Unit = "
    const r = #var(__self).forceLoseCanvasContext(#var(ctx));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::disable_canvas_acceleration_for_canvas_2d(__self: mut Internals, canvas: mut HTMLCanvasElement) -> Unit = "
    const r = #var(__self).disableCanvasAccelerationForCanvas2D(#fun(HTMLCanvasElement::as_js)(#var(canvas)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_canvas_image_source_accelerated_mhtml_canvas_element(__self: mut Internals, image_source: mut HTMLCanvasElement) -> Bool = "
    const r = #var(__self).isCanvasImageSourceAccelerated(#fun(HTMLCanvasElement::as_js)(#var(image_source)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_canvas_image_source_accelerated_moffscreen_canvas(__self: mut Internals, image_source: mut OffscreenCanvas) -> Bool = "
    const r = #var(__self).isCanvasImageSourceAccelerated(#fun(OffscreenCanvas::as_js)(#var(image_source)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::dictionary_test(__self: mut Internals) -> mut DictionaryTest = "
    const r = #var(__self).dictionaryTest();
    return #fun(DictionaryTest::from_js)(r);
"

pub ext fun Internals::record_test(__self: mut Internals) -> mut RecordTest = "
    const r = #var(__self).recordTest();
    return #fun(RecordTest::from_js)(r);
"

pub ext fun Internals::sequence_test(__self: mut Internals) -> mut SequenceTest = "
    const r = #var(__self).sequenceTest();
    return #fun(SequenceTest::from_js)(r);
"

pub ext fun Internals::union_types_test(__self: mut Internals) -> mut UnionTypesTest = "
    const r = #var(__self).unionTypesTest();
    return #fun(UnionTypesTest::from_js)(r);
"

pub ext fun Internals::initialize_ukm_recorder(__self: mut Internals) -> mut InternalsUkmRecorder = "
    const r = #var(__self).initializeUKMRecorder();
    return #fun(InternalsUkmRecorder::from_js)(r);
"

pub ext fun Internals::callback_function_test(__self: mut Internals) -> mut CallbackFunctionTest = "
    const r = #var(__self).callbackFunctionTest();
    return #fun(CallbackFunctionTest::from_js)(r);
"

pub ext fun Internals::nadc_attribute_test(__self: mut Internals) -> mut NADCAttributeTest = "
    const r = #var(__self).nadcAttributeTest();
    return #fun(NADCAttributeTest::from_js)(r);
"

pub ext fun Internals::selected_html_for_clipboard(__self: mut Internals) -> String = "
    const r = #var(__self).selectedHTMLForClipboard();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::selected_text_for_clipboard(__self: mut Internals) -> String = "
    const r = #var(__self).selectedTextForClipboard();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::set_visual_viewport_offset(__self: mut Internals, x: Int, y: Int) -> Unit = "
    const r = #var(__self).setVisualViewportOffset(#fun(Int::as_js)(#var(x)), #fun(Int::as_js)(#var(y)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_use_counted(__self: mut Internals, document: mut Document, feature: Int) -> Bool = "
    const r = #var(__self).isUseCounted(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(feature)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_web_dx_feature_use_counted(__self: mut Internals, document: mut Document, feature: Int) -> Bool = "
    const r = #var(__self).isWebDXFeatureUseCounted(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(feature)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_css_property_use_counted(__self: mut Internals, document: mut Document, property_name: String) -> Bool = "
    const r = #var(__self).isCSSPropertyUseCounted(#fun(Document::as_js)(#var(document)), #fun(String::as_js)(#var(property_name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_animated_css_property_use_counted(__self: mut Internals, document: mut Document, property_name: String) -> Bool = "
    const r = #var(__self).isAnimatedCSSPropertyUseCounted(#fun(Document::as_js)(#var(document)), #fun(String::as_js)(#var(property_name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::clear_use_counter(__self: mut Internals, document: mut Document, feature: Int) -> Unit = "
    const r = #var(__self).clearUseCounter(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(feature)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_css_property_longhands(__self: mut Internals) -> List[String] = "
    const r = #var(__self).getCSSPropertyLonghands();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::get_css_property_shorthands(__self: mut Internals) -> List[String] = "
    const r = #var(__self).getCSSPropertyShorthands();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::get_css_property_aliases(__self: mut Internals) -> List[String] = "
    const r = #var(__self).getCSSPropertyAliases();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::observe_use_counter(__self: mut Internals, document: mut Document, feature: Int) -> Promise[Unit] = "
    const r = #var(__self).observeUseCounter(#fun(Document::as_js)(#var(document)), #fun(Int::as_js)(#var(feature)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Internals::get(__self: Internals, index: Int) -> Int = "
    const r = Internals[#fun(Int::as_js)(#var(index))];
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::unscopable_method(__self: mut Internals) -> String = "
    const r = #var(__self).unscopableMethod();
    return #fun(String::from_js)(r);
"

pub ext fun Internals::set_caps_lock_state(__self: mut Internals, enabled: Bool) -> Unit = "
    const r = #var(__self).setCapsLockState(#fun(Bool::as_js)(#var(enabled)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_pseudo_class_state(__self: mut Internals, element: mut Element, pseudo: String, enabled: Bool) -> Unit = "
    const r = #var(__self).setPseudoClassState(#fun(Element::as_js)(#var(element)), #fun(String::as_js)(#var(pseudo)), #fun(Bool::as_js)(#var(enabled)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_scrollbar_visibility_in_scrollable_area(__self: mut Internals, node: mut Node, visible: Bool) -> Bool = "
    const r = #var(__self).setScrollbarVisibilityInScrollableArea(#fun(Node::as_js)(#var(node)), #fun(Bool::as_js)(#var(visible)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::monotonic_time_to_zero_based_document_time(__self: mut Internals, platform_time: Float) -> Float = "
    const r = #var(__self).monotonicTimeToZeroBasedDocumentTime(#fun(Float::as_js)(#var(platform_time)));
    return #fun(Float::from_js)(r);
"

pub ext fun Internals::zero_based_document_time_to_monotonic_time(__self: mut Internals, dom_high_res_time_stamp: Float) -> Int = "
    const r = #var(__self).zeroBasedDocumentTimeToMonotonicTime(#fun(Float::as_js)(#var(dom_high_res_time_stamp)));
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::current_time_ticks(__self: mut Internals) -> Int = "
    const r = #var(__self).currentTimeTicks();
    return #fun(Int::from_js)(r);
"

pub ext fun Internals::get_scroll_animation_state(__self: mut Internals, node: mut Node) -> String = "
    const r = #var(__self).getScrollAnimationState(#fun(Node::as_js)(#var(node)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::get_programmatic_scroll_animation_state(__self: mut Internals, node: mut Node) -> String = "
    const r = #var(__self).getProgrammaticScrollAnimationState(#fun(Node::as_js)(#var(node)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::origin_trials_test(__self: mut Internals) -> mut OriginTrialsTest = "
    const r = #var(__self).originTrialsTest();
    return #fun(OriginTrialsTest::from_js)(r);
"

pub ext fun Internals::crash(__self: mut Internals) -> Unit = "
    const r = #var(__self).crash();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::evaluate_in_inspector_overlay(__self: mut Internals, script: String) -> String = "
    const r = #var(__self).evaluateInInspectorOverlay(#fun(String::as_js)(#var(script)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::set_is_low_end_device(__self: mut Internals, is_low_end_device: Bool) -> Unit = "
    const r = #var(__self).setIsLowEndDevice(#fun(Bool::as_js)(#var(is_low_end_device)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_low_end_device(__self: mut Internals) -> Bool = "
    const r = #var(__self).isLowEndDevice();
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::supported_text_encoding_labels(__self: mut Internals) -> List[String] = "
    const r = #var(__self).supportedTextEncodingLabels();
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::simulate_raster_under_invalidations(__self: mut Internals, enable: Bool) -> Unit = "
    const r = #var(__self).simulateRasterUnderInvalidations(#fun(Bool::as_js)(#var(enable)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::disable_intersection_observer_throttle_delay(__self: mut Internals) -> Unit = "
    const r = #var(__self).DisableIntersectionObserverThrottleDelay();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::is_site_isolated(__self: mut Internals, iframe: mut HTMLIFrameElement) -> Bool = "
    const r = #var(__self).isSiteIsolated(#fun(HTMLIFrameElement::as_js)(#var(iframe)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::is_tracking_occlusion_for_i_frame(__self: mut Internals, iframe: mut HTMLIFrameElement) -> Bool = "
    const r = #var(__self).isTrackingOcclusionForIFrame(#fun(HTMLIFrameElement::as_js)(#var(iframe)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Internals::add_embedder_custom_element_name(__self: mut Internals, name: String) -> Unit = "
    const r = #var(__self).addEmbedderCustomElementName(#fun(String::as_js)(#var(name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_parsed_import_map(__self: mut Internals, document: mut Document) -> String = "
    const r = #var(__self).getParsedImportMap(#fun(Document::as_js)(#var(document)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::set_device_emulation_scale(__self: mut Internals, scale: Float) -> Unit = "
    const r = #var(__self).setDeviceEmulationScale(#fun(Float::as_js)(#var(scale)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_agent_id(__self: mut Internals, window: mut Window) -> String = "
    const r = #var(__self).getAgentId(#fun(Window::as_js)(#var(window)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::use_mock_overlay_scrollbars(__self: mut Internals) -> Unit = "
    const r = #var(__self).useMockOverlayScrollbars();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::generate_test_report(__self: mut Internals, message: String) -> Unit = "
    const r = #var(__self).generateTestReport(#fun(String::as_js)(#var(message)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_is_ad_frame(__self: mut Internals, target__doc: mut Document) -> Unit = "
    const r = #var(__self).setIsAdFrame(#fun(Document::as_js)(#var(target__doc)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::create_readable_stream(__self: mut Internals, queue_size: Int, optimizer: String) -> mut ReadableStream = "
    const r = #var(__self).createReadableStream(#fun(Int::as_js)(#var(queue_size)), #fun(String::as_js)(#var(optimizer)));
    return #fun(ReadableStream::from_js)(r);
"

pub ext fun Internals::create_writable_stream_and_sink(__self: mut Internals, queue_size: Int, optimizer: String) -> JsValue = "
    const r = #var(__self).createWritableStreamAndSink(#fun(Int::as_js)(#var(queue_size)), #fun(String::as_js)(#var(optimizer)));
    return r;
"

pub ext fun Internals::set_allow_per_chunk_transferring(__self: mut Internals, stream: mut ReadableStream) -> Unit = "
    const r = #var(__self).setAllowPerChunkTransferring(#fun(ReadableStream::as_js)(#var(stream)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_back_forward_cache_restoration_buffer_size(__self: mut Internals, max_size: Int) -> Unit = "
    const r = #var(__self).setBackForwardCacheRestorationBufferSize(#fun(Int::as_js)(#var(max_size)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::set_event_timing_buffer_size(__self: mut Internals, max_size: Int) -> Unit = "
    const r = #var(__self).setEventTimingBufferSize(#fun(Int::as_js)(#var(max_size)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::stop_responsiveness_metrics_ukm_sampling(__self: mut Internals) -> Unit = "
    const r = #var(__self).stopResponsivenessMetricsUkmSampling();
    return #fun(Unit::from_js)(r);
"

pub ext fun Internals::get_creator_scripts(__self: mut Internals, img: mut HTMLImageElement) -> List[String] = "
    const r = #var(__self).getCreatorScripts(#fun(HTMLImageElement::as_js)(#var(img)));
    return #fun(List::from_js[String])(r);
"

pub ext fun Internals::lcp_prediction(__self: mut Internals, document: mut Document) -> Promise[String] = "
    const r = #var(__self).LCPPrediction(#fun(Document::as_js)(#var(document)));
    return #fun(Promise::from_js[String])(r);
"

pub ext fun Internals::exempt_url_from_network_revocation(__self: mut Internals, url: String) -> Promise[Unit] = "
    const r = #var(__self).exemptUrlFromNetworkRevocation(#fun(String::as_js)(#var(url)));
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Internals::last_compiled_script_file_name(__self: mut Internals, document: mut Document) -> String = "
    const r = #var(__self).lastCompiledScriptFileName(#fun(Document::as_js)(#var(document)));
    return #fun(String::from_js)(r);
"

pub ext fun Internals::last_compiled_script_used_code_cache(__self: mut Internals, document: mut Document) -> Bool = "
    const r = #var(__self).lastCompiledScriptUsedCodeCache(#fun(Document::as_js)(#var(document)));
    return #fun(Bool::from_js)(r);
"

pub val Internals::layer_tree_includes_invalidations: Int = 2
pub val Internals::layer_tree_includes_detailed_invalidations: Int = 4

pub val InternalCookieSameSite::None: String = "None"
pub val InternalCookieSameSite::Lax: String = "Lax"
pub val InternalCookieSameSite::Strict: String = "Strict"

pub struct InternalCookie(
    name: Option[String],
    value: Option[String],
    path: Option[String],
    domain: Option[String],
    secure: Option[Bool],
    http_only: Option[Bool],
    expiry: Option[Int],
    same_site: Option[String]
)

pub fun InternalCookie::default() -> mut InternalCookie
    = InternalCookie(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun InternalCookie::from_js(value: JsValue) -> mut InternalCookie = "
    const r = {};
    r.m_name = #fun(Option::from_js[String])(#var(value).name);
    r.m_value = #fun(Option::from_js[String])(#var(value).value);
    r.m_path = #fun(Option::from_js[String])(#var(value).path);
    r.m_domain = #fun(Option::from_js[String])(#var(value).domain);
    r.m_secure = #fun(Option::from_js[Bool])(#var(value).secure);
    r.m_http_only = #fun(Option::from_js[Bool])(#var(value).httpOnly);
    r.m_expiry = #fun(Option::from_js[Int])(#var(value).expiry);
    r.m_same_site = #fun(Option::from_js[String])(#var(value).sameSite);
    return r;
"

pub ext fun InternalCookie::as_js(self: InternalCookie) -> JsValue = "
    const r = {};
    r.name = #fun(Option::as_js_undef[String])(#var(self).m_name);
    r.value = #fun(Option::as_js_undef[String])(#var(self).m_value);
    r.path = #fun(Option::as_js_undef[String])(#var(self).m_path);
    r.domain = #fun(Option::as_js_undef[String])(#var(self).m_domain);
    r.secure = #fun(Option::as_js_undef[Bool])(#var(self).m_secure);
    r.httpOnly = #fun(Option::as_js_undef[Bool])(#var(self).m_http_only);
    r.expiry = #fun(Option::as_js_undef[Int])(#var(self).m_expiry);
    r.sameSite = #fun(Option::as_js_undef[String])(#var(self).m_same_site);
    return r;
"

pub ext fun Internals::delete_all_cookies(__self: mut Internals) -> Promise[Unit] = "
    const r = #var(__self).deleteAllCookies();
    return #fun(Promise::from_js[Unit])(r);
"

pub ext fun Internals::get_all_cookies(__self: mut Internals) -> Promise[List[mut InternalCookie]] = "
    const r = #var(__self).getAllCookies();
    return #fun(Promise::from_js[List[mut InternalCookie]])(r);
"

pub ext fun Internals::get_named_cookie(__self: mut Internals, name: String) -> Promise[Option[mut InternalCookie]] = "
    const r = #var(__self).getNamedCookie(#fun(String::as_js)(#var(name)));
    return #fun(Promise::from_js[Option[mut InternalCookie]])(r);
"

struct InternalsUkmRecorder()

pub ext fun InternalsUkmRecorder::get_metrics(__self: mut InternalsUkmRecorder, entry_name: String, metric__names: List[String]) -> List[JsObject] = "
    const r = #var(__self).getMetrics(#fun(String::as_js)(#var(entry_name)), #fun(List::as_js[String])(#var(metric__names)));
    return #fun(List::from_js[JsObject])(r);
"

pub fun InternalsUkmRecorder::as_js(self: InternalsUkmRecorder) -> JsValue = JsValue::unsafe_from[InternalsUkmRecorder](self)

pub fun InternalsUkmRecorder::from_js(v: JsValue) -> mut InternalsUkmRecorder = JsValue::unsafe_as[mut InternalsUkmRecorder](v)

struct NADCAttributeTest()

pub ext fun NADCAttributeTest::float_64_value(self: NADCAttributeTest) -> Float
    = "return #fun(Float::from_js)(#var(self).float64Value);"

pub ext fun NADCAttributeTest::set_float_64_value(self: mut NADCAttributeTest, value: Float)
    = "#var(self).float64Value = #fun(Float::as_js)(#var(value));"

pub fun NADCAttributeTest::as_js(self: NADCAttributeTest) -> JsValue = JsValue::unsafe_from[NADCAttributeTest](self)

pub fun NADCAttributeTest::from_js(v: JsValue) -> mut NADCAttributeTest = JsValue::unsafe_as[mut NADCAttributeTest](v)

struct OriginTrialsTest()

pub ext fun OriginTrialsTest::new() -> mut OriginTrialsTest
    = "return new OriginTrialsTest();"

pub ext fun OriginTrialsTest::normal_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).normalAttribute);"

pub ext fun OriginTrialsTest::static_attribute() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.staticAttribute);"

pub ext fun OriginTrialsTest::throwing_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).throwingAttribute);"

pub ext fun OriginTrialsTest::unconditional_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).unconditionalAttribute);"

pub ext fun OriginTrialsTest::static_unconditional_attribute() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.staticUnconditionalAttribute);"

pub ext fun OriginTrialsTest::secure_unconditional_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).secureUnconditionalAttribute);"

pub ext fun OriginTrialsTest::secure_static_unconditional_attribute() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.secureStaticUnconditionalAttribute);"

pub ext fun OriginTrialsTest::secure_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).secureAttribute);"

pub ext fun OriginTrialsTest::secure_static_attribute() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.secureStaticAttribute);"

pub ext fun OriginTrialsTest::deprecation_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).deprecationAttribute);"

pub ext fun OriginTrialsTest::implied_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).impliedAttribute);"

pub ext fun OriginTrialsTest::invalid_os_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).invalidOSAttribute);"

pub ext fun OriginTrialsTest::third_party_attribute(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).thirdPartyAttribute);"

pub ext fun OriginTrialsTest::normal_method(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).normalMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::static_method() -> Bool = "
    const r = OriginTrialsTest.staticMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::get_dictionary_method(__self: mut OriginTrialsTest) -> mut OriginTrialsTestDictionary = "
    const r = #var(__self).getDictionaryMethod();
    return #fun(OriginTrialsTestDictionary::from_js)(r);
"

pub ext fun OriginTrialsTest::check_dictionary_method(__self: mut OriginTrialsTest, dict: mut OriginTrialsTestDictionary) -> Unit = "
    const r = #var(__self).checkDictionaryMethod(#fun(OriginTrialsTestDictionary::as_js)(#var(dict)));
    return #fun(Unit::from_js)(r);
"

pub ext fun OriginTrialsTest::unconditional_method(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).unconditionalMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::unconditional_dictionary_method(__self: mut OriginTrialsTest, dict: mut OriginTrialsTestDictionary) -> Unit = "
    const r = #var(__self).unconditionalDictionaryMethod(#fun(OriginTrialsTestDictionary::as_js)(#var(dict)));
    return #fun(Unit::from_js)(r);
"

pub ext fun OriginTrialsTest::static_unconditional_method() -> Bool = "
    const r = OriginTrialsTest.staticUnconditionalMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_unconditional_method(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).secureUnconditionalMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_static_unconditional_method() -> Bool = "
    const r = OriginTrialsTest.secureStaticUnconditionalMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_method(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).secureMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_static_method() -> Bool = "
    const r = OriginTrialsTest.secureStaticMethod();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::navigation_method(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).navigationMethod();
    return #fun(Bool::from_js)(r);
"

pub fun OriginTrialsTest::as_js(self: OriginTrialsTest) -> JsValue = JsValue::unsafe_from[OriginTrialsTest](self)

pub fun OriginTrialsTest::from_js(v: JsValue) -> mut OriginTrialsTest = JsValue::unsafe_as[mut OriginTrialsTest](v)

pub struct OriginTrialsTestDictionary(
    unconditional_bool: Option[Bool],
    normal_bool: Option[Bool]
)

pub fun OriginTrialsTestDictionary::default() -> mut OriginTrialsTestDictionary
    = OriginTrialsTestDictionary(Option::Some(true), Option::Some(true))

pub ext fun OriginTrialsTestDictionary::from_js(value: JsValue) -> mut OriginTrialsTestDictionary = "
    const r = {};
    r.m_unconditional_bool = #fun(Option::from_js[Bool])(#var(value).unconditionalBool);
    r.m_normal_bool = #fun(Option::from_js[Bool])(#var(value).normalBool);
    return r;
"

pub ext fun OriginTrialsTestDictionary::as_js(self: OriginTrialsTestDictionary) -> JsValue = "
    const r = {};
    r.unconditionalBool = #fun(Option::as_js_undef[Bool])(#var(self).m_unconditional_bool);
    r.normalBool = #fun(Option::as_js_undef[Bool])(#var(self).m_normal_bool);
    return r;
"

pub ext fun OriginTrialsTest::normal_attribute_partial(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).normalAttributePartial);"

pub ext fun OriginTrialsTest::static_attribute_partial() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.staticAttributePartial);"

pub ext fun OriginTrialsTest::secure_attribute_partial(self: OriginTrialsTest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).secureAttributePartial);"

pub ext fun OriginTrialsTest::secure_static_attribute_partial() -> Bool
    = "return #fun(Bool::from_js)(OriginTrialsTest.secureStaticAttributePartial);"

pub ext fun OriginTrialsTest::normal_method_partial(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).normalMethodPartial();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::static_method_partial() -> Bool = "
    const r = OriginTrialsTest.staticMethodPartial();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_method_partial(__self: mut OriginTrialsTest) -> Bool = "
    const r = #var(__self).secureMethodPartial();
    return #fun(Bool::from_js)(r);
"

pub ext fun OriginTrialsTest::secure_static_method_partial() -> Bool = "
    const r = OriginTrialsTest.secureStaticMethodPartial();
    return #fun(Bool::from_js)(r);
"

pub ext fun Window::test_origin_trial_global_attribute(self: Window) -> Bool
    = "return #fun(Bool::from_js)(#var(self).testOriginTrialGlobalAttribute);"

struct RecordTest()

pub ext fun RecordTest::set_string_long_record(__self: mut RecordTest, arg: Record[Int]) -> Unit = "
    const r = #var(__self).setStringLongRecord(#fun(Record::as_js[Int])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun RecordTest::get_string_long_record(__self: mut RecordTest) -> Record[Int] = "
    const r = #var(__self).getStringLongRecord();
    return #fun(Record::from_js[Int])(r);
"

pub ext fun RecordTest::set_nullable_string_long_record(__self: mut RecordTest, arg: Option[Record[Int]]) -> Unit = "
    const r = #var(__self).setNullableStringLongRecord(#fun(Option::as_js[Record[Int]])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun RecordTest::get_nullable_string_long_record(__self: mut RecordTest) -> Option[Record[Int]] = "
    const r = #var(__self).getNullableStringLongRecord();
    return #fun(Option::from_js[Record[Int]])(r);
"

pub ext fun RecordTest::set_byte_string_byte_string_record(__self: mut RecordTest, arg: Record[String]) -> Unit = "
    const r = #var(__self).setByteStringByteStringRecord(#fun(Record::as_js[String])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun RecordTest::set_string_element_record(__self: mut RecordTest, arg: Record[mut Element]) -> Unit = "
    const r = #var(__self).setStringElementRecord(#fun(Record::as_js[mut Element])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun RecordTest::get_string_element_record(__self: mut RecordTest) -> Record[mut Element] = "
    const r = #var(__self).getStringElementRecord();
    return #fun(Record::from_js[mut Element])(r);
"

pub ext fun RecordTest::set_usv_string_usv_string_boolean_record_record(__self: mut RecordTest, arg: Record[Record[Bool]]) -> Unit = "
    const r = #var(__self).setUSVStringUSVStringBooleanRecordRecord(#fun(Record::as_js[Record[Bool]])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun RecordTest::get_usv_string_usv_string_boolean_record_record(__self: mut RecordTest) -> Record[Record[Bool]] = "
    const r = #var(__self).getUSVStringUSVStringBooleanRecordRecord();
    return #fun(Record::from_js[Record[Bool]])(r);
"

pub ext fun RecordTest::return_string_byte_string_sequence_record(__self: mut RecordTest) -> Record[List[String]] = "
    const r = #var(__self).returnStringByteStringSequenceRecord();
    return #fun(Record::from_js[List[String]])(r);
"

pub ext fun RecordTest::union_received_a_record(__self: mut RecordTest, arg: JsValue) -> Bool = "
    const r = #var(__self).unionReceivedARecord(#var(arg));
    return #fun(Bool::from_js)(r);
"

pub ext fun RecordTest::set_float_or_string_element_record(__self: mut RecordTest, arg: JsValue) -> Unit = "
    const r = #var(__self).setFloatOrStringElementRecord(#var(arg));
    return #fun(Unit::from_js)(r);
"

pub fun RecordTest::as_js(self: RecordTest) -> JsValue = JsValue::unsafe_from[RecordTest](self)

pub fun RecordTest::from_js(v: JsValue) -> mut RecordTest = JsValue::unsafe_as[mut RecordTest](v)

pub val FoodEnum::Bread: String = "Bread"
pub val FoodEnum::Spaghetti: String = "Spaghetti"
pub val FoodEnum::Sushi: String = "Sushi"

struct SequenceTest()

pub ext fun SequenceTest::identity_byte_string_sequence_sequence(__self: mut SequenceTest, arg: List[List[String]]) -> List[List[String]] = "
    const r = #var(__self).identityByteStringSequenceSequence(#fun(List::as_js[List[String]])(#var(arg)));
    return #fun(List::from_js[List[String]])(r);
"

pub ext fun SequenceTest::identity_double_sequence(__self: mut SequenceTest, arg: List[Float]) -> List[Float] = "
    const r = #var(__self).identityDoubleSequence(#fun(List::as_js[Float])(#var(arg)));
    return #fun(List::from_js[Float])(r);
"

pub ext fun SequenceTest::identity_food_enum_sequence(__self: mut SequenceTest, arg: List[String]) -> List[String] = "
    const r = #var(__self).identityFoodEnumSequence(#fun(List::as_js[String])(#var(arg)));
    return #fun(List::from_js[String])(r);
"

pub ext fun SequenceTest::identity_long_sequence(__self: mut SequenceTest, arg: List[Int]) -> List[Int] = "
    const r = #var(__self).identityLongSequence(#fun(List::as_js[Int])(#var(arg)));
    return #fun(List::from_js[Int])(r);
"

pub ext fun SequenceTest::identity_octet_sequence_or_null(__self: mut SequenceTest, arg: Option[List[Int]]) -> Option[List[Int]] = "
    const r = #var(__self).identityOctetSequenceOrNull(#fun(Option::as_js[List[Int]])(#var(arg)));
    return #fun(Option::from_js[List[Int]])(r);
"

pub ext fun SequenceTest::get_element_sequence(__self: mut SequenceTest) -> List[mut Element] = "
    const r = #var(__self).getElementSequence();
    return #fun(List::from_js[mut Element])(r);
"

pub ext fun SequenceTest::set_element_sequence(__self: mut SequenceTest, arg: List[mut Element]) -> Unit = "
    const r = #var(__self).setElementSequence(#fun(List::as_js[mut Element])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SequenceTest::set_element_sequence_of_sequences(__self: mut SequenceTest, arg: List[List[mut Element]]) -> Unit = "
    const r = #var(__self).setElementSequenceOfSequences(#fun(List::as_js[List[mut Element]])(#var(arg)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SequenceTest::union_received_sequence(__self: mut SequenceTest, arg: JsValue) -> Bool = "
    const r = #var(__self).unionReceivedSequence(#var(arg));
    return #fun(Bool::from_js)(r);
"

pub fun SequenceTest::as_js(self: SequenceTest) -> JsValue = JsValue::unsafe_from[SequenceTest](self)

pub fun SequenceTest::from_js(v: JsValue) -> mut SequenceTest = JsValue::unsafe_as[mut SequenceTest](v)

struct StaticSelection()

pub ext fun StaticSelection::anchor_node(self: StaticSelection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).anchorNode);"

pub ext fun StaticSelection::anchor_offset(self: StaticSelection) -> Int
    = "return #fun(Int::from_js)(#var(self).anchorOffset);"

pub ext fun StaticSelection::focus_node(self: StaticSelection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).focusNode);"

pub ext fun StaticSelection::focus_offset(self: StaticSelection) -> Int
    = "return #fun(Int::from_js)(#var(self).focusOffset);"

pub ext fun StaticSelection::is_collapsed(self: StaticSelection) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isCollapsed);"

pub fun StaticSelection::as_js(self: StaticSelection) -> JsValue = JsValue::unsafe_from[StaticSelection](self)

pub fun StaticSelection::from_js(v: JsValue) -> mut StaticSelection = JsValue::unsafe_as[mut StaticSelection](v)

struct TypeConversions()

pub ext fun TypeConversions::test_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testLong);"

pub ext fun TypeConversions::set_test_long(self: mut TypeConversions, value: Int)
    = "#var(self).testLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeLong);"

pub ext fun TypeConversions::set_test_enforce_range_long(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_unsigned_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testUnsignedLong);"

pub ext fun TypeConversions::set_test_unsigned_long(self: mut TypeConversions, value: Int)
    = "#var(self).testUnsignedLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_unsigned_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeUnsignedLong);"

pub ext fun TypeConversions::set_test_enforce_range_unsigned_long(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeUnsignedLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_long_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testLongLong);"

pub ext fun TypeConversions::set_test_long_long(self: mut TypeConversions, value: Int)
    = "#var(self).testLongLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_long_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeLongLong);"

pub ext fun TypeConversions::set_test_enforce_range_long_long(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeLongLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_unsigned_long_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testUnsignedLongLong);"

pub ext fun TypeConversions::set_test_unsigned_long_long(self: mut TypeConversions, value: Int)
    = "#var(self).testUnsignedLongLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_unsigned_long_long(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeUnsignedLongLong);"

pub ext fun TypeConversions::set_test_enforce_range_unsigned_long_long(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeUnsignedLongLong = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_byte(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testByte);"

pub ext fun TypeConversions::set_test_byte(self: mut TypeConversions, value: Int)
    = "#var(self).testByte = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_byte(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeByte);"

pub ext fun TypeConversions::set_test_enforce_range_byte(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeByte = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_octet(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testOctet);"

pub ext fun TypeConversions::set_test_octet(self: mut TypeConversions, value: Int)
    = "#var(self).testOctet = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_octet(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeOctet);"

pub ext fun TypeConversions::set_test_enforce_range_octet(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeOctet = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_short(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testShort);"

pub ext fun TypeConversions::set_test_short(self: mut TypeConversions, value: Int)
    = "#var(self).testShort = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_short(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeShort);"

pub ext fun TypeConversions::set_test_enforce_range_short(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeShort = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_unsigned_short(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testUnsignedShort);"

pub ext fun TypeConversions::set_test_unsigned_short(self: mut TypeConversions, value: Int)
    = "#var(self).testUnsignedShort = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_enforce_range_unsigned_short(self: TypeConversions) -> Int
    = "return #fun(Int::from_js)(#var(self).testEnforceRangeUnsignedShort);"

pub ext fun TypeConversions::set_test_enforce_range_unsigned_short(self: mut TypeConversions, value: Int)
    = "#var(self).testEnforceRangeUnsignedShort = #fun(Int::as_js)(#var(value));"

pub ext fun TypeConversions::test_byte_string(self: TypeConversions) -> String
    = "return #fun(String::from_js)(#var(self).testByteString);"

pub ext fun TypeConversions::set_test_byte_string(self: mut TypeConversions, value: String)
    = "#var(self).testByteString = #fun(String::as_js)(#var(value));"

pub ext fun TypeConversions::test_usv_string(self: TypeConversions) -> String
    = "return #fun(String::from_js)(#var(self).testUSVString);"

pub ext fun TypeConversions::set_test_usv_string(self: mut TypeConversions, value: String)
    = "#var(self).testUSVString = #fun(String::as_js)(#var(value));"

pub ext fun TypeConversions::test_usv_string_or_null(self: TypeConversions) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).testUSVStringOrNull);"

pub ext fun TypeConversions::set_test_usv_string_or_null(self: mut TypeConversions, value: Option[String])
    = "#var(self).testUSVStringOrNull = #fun(Option::as_js[String])(#var(value));"

pub fun TypeConversions::as_js(self: TypeConversions) -> JsValue = JsValue::unsafe_from[TypeConversions](self)

pub fun TypeConversions::from_js(v: JsValue) -> mut TypeConversions = JsValue::unsafe_as[mut TypeConversions](v)

struct UnionTypesTest()

pub ext fun UnionTypesTest::double_or_string_or_string_sequence_attribute(self: UnionTypesTest) -> JsValue
    = "return #var(self).doubleOrStringOrStringSequenceAttribute;"

pub ext fun UnionTypesTest::set_double_or_string_or_string_sequence_attribute(self: mut UnionTypesTest, value: JsValue)
    = "#var(self).doubleOrStringOrStringSequenceAttribute = #var(value);"

pub ext fun UnionTypesTest::double_or_string_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).doubleOrStringArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_internal_enum_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).doubleOrInternalEnumArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_default_double_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).doubleOrStringDefaultDoubleArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_default_string_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).doubleOrStringDefaultStringArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_default_null_arg(__self: mut UnionTypesTest, arg: Option[JsValue]) -> String = "
    const r = #var(__self).doubleOrStringDefaultNullArg(#fun(Option::as_js[JsValue])(#var(arg)));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_sequence_arg(__self: mut UnionTypesTest, arg: List[JsValue]) -> String = "
    const r = #var(__self).doubleOrStringSequenceArg(#fun(List::as_js[JsValue])(#var(arg)));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::node_list_or_element_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).nodeListOrElementArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::node_list_or_element_or_null_arg(__self: mut UnionTypesTest, arg: Option[JsValue]) -> String = "
    const r = #var(__self).nodeListOrElementOrNullArg(#fun(Option::as_js[JsValue])(#var(arg)));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_or_string_sequence_arg(__self: mut UnionTypesTest, arg: JsValue) -> String = "
    const r = #var(__self).doubleOrStringOrStringSequenceArg(#var(arg));
    return #fun(String::from_js)(r);
"

pub ext fun UnionTypesTest::double_or_string_or_string_sequence_nullable_arg(__self: mut UnionTypesTest, arg: Option[JsValue]) -> String = "
    const r = #var(__self).doubleOrStringOrStringSequenceNullableArg(#fun(Option::as_js[JsValue])(#var(arg)));
    return #fun(String::from_js)(r);
"

pub fun UnionTypesTest::as_js(self: UnionTypesTest) -> JsValue = JsValue::unsafe_from[UnionTypesTest](self)

pub fun UnionTypesTest::from_js(v: JsValue) -> mut UnionTypesTest = JsValue::unsafe_as[mut UnionTypesTest](v)

pub ext fun WorkerInternals::origin_trials_test(__self: mut WorkerInternals) -> mut OriginTrialsTest = "
    const r = #var(__self).originTrialsTest();
    return #fun(OriginTrialsTest::from_js)(r);
"

pub ext fun WorkerInternals::count_feature(__self: mut WorkerInternals, feature: Int) -> Unit = "
    const r = #var(__self).countFeature(#fun(Int::as_js)(#var(feature)));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerInternals::count_deprecation(__self: mut WorkerInternals, feature: Int) -> Unit = "
    const r = #var(__self).countDeprecation(#fun(Int::as_js)(#var(feature)));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerInternals::collect_garbage(__self: mut WorkerInternals) -> Unit = "
    const r = #var(__self).collectGarbage();
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerInternals::force_lose_canvas_context(__self: mut WorkerInternals, ctx: JsValue) -> Unit = "
    const r = #var(__self).forceLoseCanvasContext(#var(ctx));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerInternals::is_canvas_image_source_accelerated_mhtml_canvas_element(__self: mut WorkerInternals, image_source: mut HTMLCanvasElement) -> Bool = "
    const r = #var(__self).isCanvasImageSourceAccelerated(#fun(HTMLCanvasElement::as_js)(#var(image_source)));
    return #fun(Bool::from_js)(r);
"

pub ext fun WorkerInternals::is_canvas_image_source_accelerated_moffscreen_canvas(__self: mut WorkerInternals, image_source: mut OffscreenCanvas) -> Bool = "
    const r = #var(__self).isCanvasImageSourceAccelerated(#fun(OffscreenCanvas::as_js)(#var(image_source)));
    return #fun(Bool::from_js)(r);
"

struct BackForwardCacheRestoration()

/// Converts a reference to 'BackForwardCacheRestoration' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun BackForwardCacheRestoration::as_performance_entry(self: BackForwardCacheRestoration) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'BackForwardCacheRestoration' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun BackForwardCacheRestoration::as_mperformance_entry(self: mut BackForwardCacheRestoration) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'BackForwardCacheRestoration'.
/// The conversion may fail and panic if 'base' is not a reference to 'BackForwardCacheRestoration' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BackForwardCacheRestoration::from_performance_entry(base: PerformanceEntry) -> BackForwardCacheRestoration = "
    if(#var(base) instanceof BackForwardCacheRestoration) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'BackForwardCacheRestoration'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'BackForwardCacheRestoration'.
/// The conversion may fail and panic if 'base' is not a reference to 'BackForwardCacheRestoration' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun BackForwardCacheRestoration::from_mperformance_entry(base: mut PerformanceEntry) -> mut BackForwardCacheRestoration = "
    if(#var(base) instanceof BackForwardCacheRestoration) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'BackForwardCacheRestoration'!\");
"

pub ext fun BackForwardCacheRestoration::pageshow_event_start(self: BackForwardCacheRestoration) -> Float
    = "return #fun(Float::from_js)(#var(self).pageshowEventStart);"

pub ext fun BackForwardCacheRestoration::pageshow_event_end(self: BackForwardCacheRestoration) -> Float
    = "return #fun(Float::from_js)(#var(self).pageshowEventEnd);"

pub ext fun BackForwardCacheRestoration::name(self: BackForwardCacheRestoration) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun BackForwardCacheRestoration::entry_type(self: BackForwardCacheRestoration) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun BackForwardCacheRestoration::start_time(self: BackForwardCacheRestoration) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun BackForwardCacheRestoration::duration(self: BackForwardCacheRestoration) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun BackForwardCacheRestoration::navigation_id(self: BackForwardCacheRestoration) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun BackForwardCacheRestoration::to_json(__self: mut BackForwardCacheRestoration) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun BackForwardCacheRestoration::as_js(self: BackForwardCacheRestoration) -> JsValue = JsValue::unsafe_from[BackForwardCacheRestoration](self)

pub fun BackForwardCacheRestoration::from_js(v: JsValue) -> mut BackForwardCacheRestoration = JsValue::unsafe_as[mut BackForwardCacheRestoration](v)

struct EventCounts()

pub fun EventCounts::as_js(self: EventCounts) -> JsValue = JsValue::unsafe_from[EventCounts](self)

pub fun EventCounts::from_js(v: JsValue) -> mut EventCounts = JsValue::unsafe_as[mut EventCounts](v)

struct InteractionContentfulPaint()

/// Converts a reference to 'InteractionContentfulPaint' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun InteractionContentfulPaint::as_performance_entry(self: InteractionContentfulPaint) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'InteractionContentfulPaint' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun InteractionContentfulPaint::as_mperformance_entry(self: mut InteractionContentfulPaint) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'InteractionContentfulPaint'.
/// The conversion may fail and panic if 'base' is not a reference to 'InteractionContentfulPaint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InteractionContentfulPaint::from_performance_entry(base: PerformanceEntry) -> InteractionContentfulPaint = "
    if(#var(base) instanceof InteractionContentfulPaint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'InteractionContentfulPaint'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'InteractionContentfulPaint'.
/// The conversion may fail and panic if 'base' is not a reference to 'InteractionContentfulPaint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun InteractionContentfulPaint::from_mperformance_entry(base: mut PerformanceEntry) -> mut InteractionContentfulPaint = "
    if(#var(base) instanceof InteractionContentfulPaint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'InteractionContentfulPaint'!\");
"

pub ext fun InteractionContentfulPaint::render_time(self: InteractionContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).renderTime);"

pub ext fun InteractionContentfulPaint::load_time(self: InteractionContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).loadTime);"

pub ext fun InteractionContentfulPaint::size(self: InteractionContentfulPaint) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun InteractionContentfulPaint::id(self: InteractionContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun InteractionContentfulPaint::url(self: InteractionContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun InteractionContentfulPaint::element(self: InteractionContentfulPaint) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).element);"

pub ext fun InteractionContentfulPaint::name(self: InteractionContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun InteractionContentfulPaint::entry_type(self: InteractionContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun InteractionContentfulPaint::start_time(self: InteractionContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun InteractionContentfulPaint::duration(self: InteractionContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun InteractionContentfulPaint::navigation_id(self: InteractionContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun InteractionContentfulPaint::paint_time(self: InteractionContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun InteractionContentfulPaint::presentation_time(self: InteractionContentfulPaint) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun InteractionContentfulPaint::to_json(__self: mut InteractionContentfulPaint) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun InteractionContentfulPaint::as_js(self: InteractionContentfulPaint) -> JsValue = JsValue::unsafe_from[InteractionContentfulPaint](self)

pub fun InteractionContentfulPaint::from_js(v: JsValue) -> mut InteractionContentfulPaint = JsValue::unsafe_as[mut InteractionContentfulPaint](v)

pub ext fun Internals::collect_sample(__self: mut Internals) -> Unit = "
    const r = #var(__self).collectSample();
    return #fun(Unit::from_js)(r);
"

struct LargestContentfulPaint()

/// Converts a reference to 'LargestContentfulPaint' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun LargestContentfulPaint::as_performance_entry(self: LargestContentfulPaint) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'LargestContentfulPaint' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun LargestContentfulPaint::as_mperformance_entry(self: mut LargestContentfulPaint) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'LargestContentfulPaint'.
/// The conversion may fail and panic if 'base' is not a reference to 'LargestContentfulPaint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LargestContentfulPaint::from_performance_entry(base: PerformanceEntry) -> LargestContentfulPaint = "
    if(#var(base) instanceof LargestContentfulPaint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'LargestContentfulPaint'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'LargestContentfulPaint'.
/// The conversion may fail and panic if 'base' is not a reference to 'LargestContentfulPaint' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LargestContentfulPaint::from_mperformance_entry(base: mut PerformanceEntry) -> mut LargestContentfulPaint = "
    if(#var(base) instanceof LargestContentfulPaint) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'LargestContentfulPaint'!\");
"

pub ext fun LargestContentfulPaint::render_time(self: LargestContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).renderTime);"

pub ext fun LargestContentfulPaint::load_time(self: LargestContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).loadTime);"

pub ext fun LargestContentfulPaint::size(self: LargestContentfulPaint) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun LargestContentfulPaint::id(self: LargestContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun LargestContentfulPaint::url(self: LargestContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun LargestContentfulPaint::element(self: LargestContentfulPaint) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).element);"

pub ext fun LargestContentfulPaint::name(self: LargestContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun LargestContentfulPaint::entry_type(self: LargestContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun LargestContentfulPaint::start_time(self: LargestContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun LargestContentfulPaint::duration(self: LargestContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun LargestContentfulPaint::navigation_id(self: LargestContentfulPaint) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun LargestContentfulPaint::paint_time(self: LargestContentfulPaint) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun LargestContentfulPaint::presentation_time(self: LargestContentfulPaint) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun LargestContentfulPaint::to_json(__self: mut LargestContentfulPaint) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun LargestContentfulPaint::as_js(self: LargestContentfulPaint) -> JsValue = JsValue::unsafe_from[LargestContentfulPaint](self)

pub fun LargestContentfulPaint::from_js(v: JsValue) -> mut LargestContentfulPaint = JsValue::unsafe_as[mut LargestContentfulPaint](v)

struct LayoutShift()

/// Converts a reference to 'LayoutShift' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutShift::as_performance_entry(self: LayoutShift) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'LayoutShift' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutShift::as_mperformance_entry(self: mut LayoutShift) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'LayoutShift'.
/// The conversion may fail and panic if 'base' is not a reference to 'LayoutShift' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutShift::from_performance_entry(base: PerformanceEntry) -> LayoutShift = "
    if(#var(base) instanceof LayoutShift) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'LayoutShift'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'LayoutShift'.
/// The conversion may fail and panic if 'base' is not a reference to 'LayoutShift' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun LayoutShift::from_mperformance_entry(base: mut PerformanceEntry) -> mut LayoutShift = "
    if(#var(base) instanceof LayoutShift) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'LayoutShift'!\");
"

pub ext fun LayoutShift::value(self: LayoutShift) -> Float
    = "return #fun(Float::from_js)(#var(self).value);"

pub ext fun LayoutShift::had_recent_input(self: LayoutShift) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hadRecentInput);"

pub ext fun LayoutShift::last_input_time(self: LayoutShift) -> Float
    = "return #fun(Float::from_js)(#var(self).lastInputTime);"

pub ext fun LayoutShift::sources(self: LayoutShift) -> JsValue
    = "return #var(self).sources;"

pub ext fun LayoutShift::name(self: LayoutShift) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun LayoutShift::entry_type(self: LayoutShift) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun LayoutShift::start_time(self: LayoutShift) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun LayoutShift::duration(self: LayoutShift) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun LayoutShift::navigation_id(self: LayoutShift) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun LayoutShift::to_json(__self: mut LayoutShift) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun LayoutShift::as_js(self: LayoutShift) -> JsValue = JsValue::unsafe_from[LayoutShift](self)

pub fun LayoutShift::from_js(v: JsValue) -> mut LayoutShift = JsValue::unsafe_as[mut LayoutShift](v)

struct LayoutShiftAttribution()

pub ext fun LayoutShiftAttribution::node(self: LayoutShiftAttribution) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).node);"

pub ext fun LayoutShiftAttribution::previous_rect(self: LayoutShiftAttribution) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).previousRect);"

pub ext fun LayoutShiftAttribution::current_rect(self: LayoutShiftAttribution) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).currentRect);"

pub ext fun LayoutShiftAttribution::to_json(__self: mut LayoutShiftAttribution) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun LayoutShiftAttribution::as_js(self: LayoutShiftAttribution) -> JsValue = JsValue::unsafe_from[LayoutShiftAttribution](self)

pub fun LayoutShiftAttribution::from_js(v: JsValue) -> mut LayoutShiftAttribution = JsValue::unsafe_as[mut LayoutShiftAttribution](v)

pub struct MemoryAttribution(
    url: String,
    container: Option[mut MemoryAttributionContainer],
    scope: String
)

pub fun MemoryAttribution::default(url: String, scope: String) -> mut MemoryAttribution
    = MemoryAttribution(url, Option::None, scope)

pub ext fun MemoryAttribution::from_js(value: JsValue) -> mut MemoryAttribution = "
    const r = {};
    r.m_url = #fun(String::from_js)(#var(value).url);
    r.m_container = #fun(Option::from_js[mut MemoryAttributionContainer])(#var(value).container);
    r.m_scope = #fun(String::from_js)(#var(value).scope);
    return r;
"

pub ext fun MemoryAttribution::as_js(self: MemoryAttribution) -> JsValue = "
    const r = {};
    r.url = #fun(String::as_js)(#var(self).m_url);
    r.container = #fun(Option::as_js_undef[mut MemoryAttributionContainer])(#var(self).m_container);
    r.scope = #fun(String::as_js)(#var(self).m_scope);
    return r;
"

pub struct MemoryAttributionContainer(
    id: Option[String],
    src: Option[String]
)

pub fun MemoryAttributionContainer::default() -> mut MemoryAttributionContainer
    = MemoryAttributionContainer(Option::None, Option::None)

pub ext fun MemoryAttributionContainer::from_js(value: JsValue) -> mut MemoryAttributionContainer = "
    const r = {};
    r.m_id = #fun(Option::from_js[String])(#var(value).id);
    r.m_src = #fun(Option::from_js[String])(#var(value).src);
    return r;
"

pub ext fun MemoryAttributionContainer::as_js(self: MemoryAttributionContainer) -> JsValue = "
    const r = {};
    r.id = #fun(Option::as_js_undef[String])(#var(self).m_id);
    r.src = #fun(Option::as_js_undef[String])(#var(self).m_src);
    return r;
"

pub struct MemoryBreakdownEntry(
    bytes: Int,
    attribution: List[mut MemoryAttribution],
    types: List[String]
)

pub fun MemoryBreakdownEntry::default(bytes: Int, attribution: List[mut MemoryAttribution], types: List[String]) -> mut MemoryBreakdownEntry
    = MemoryBreakdownEntry(bytes, attribution, types)

pub ext fun MemoryBreakdownEntry::from_js(value: JsValue) -> mut MemoryBreakdownEntry = "
    const r = {};
    r.m_bytes = #fun(Int::from_js)(#var(value).bytes);
    r.m_attribution = #fun(List::from_js[mut MemoryAttribution])(#var(value).attribution);
    r.m_types = #fun(List::from_js[String])(#var(value).types);
    return r;
"

pub ext fun MemoryBreakdownEntry::as_js(self: MemoryBreakdownEntry) -> JsValue = "
    const r = {};
    r.bytes = #fun(Int::as_js)(#var(self).m_bytes);
    r.attribution = #fun(List::as_js[mut MemoryAttribution])(#var(self).m_attribution);
    r.types = #fun(List::as_js[String])(#var(self).m_types);
    return r;
"

pub struct MemoryMeasurement(
    bytes: Int,
    breakdown: List[mut MemoryBreakdownEntry]
)

pub fun MemoryMeasurement::default(bytes: Int, breakdown: List[mut MemoryBreakdownEntry]) -> mut MemoryMeasurement
    = MemoryMeasurement(bytes, breakdown)

pub ext fun MemoryMeasurement::from_js(value: JsValue) -> mut MemoryMeasurement = "
    const r = {};
    r.m_bytes = #fun(Int::from_js)(#var(value).bytes);
    r.m_breakdown = #fun(List::from_js[mut MemoryBreakdownEntry])(#var(value).breakdown);
    return r;
"

pub ext fun MemoryMeasurement::as_js(self: MemoryMeasurement) -> JsValue = "
    const r = {};
    r.bytes = #fun(Int::as_js)(#var(self).m_bytes);
    r.breakdown = #fun(List::as_js[mut MemoryBreakdownEntry])(#var(self).m_breakdown);
    return r;
"

struct MemoryInfo()

pub ext fun MemoryInfo::total_js_heap_size(self: MemoryInfo) -> Int
    = "return #fun(Int::from_js)(#var(self).totalJSHeapSize);"

pub ext fun MemoryInfo::used_js_heap_size(self: MemoryInfo) -> Int
    = "return #fun(Int::from_js)(#var(self).usedJSHeapSize);"

pub ext fun MemoryInfo::js_heap_size_limit(self: MemoryInfo) -> Int
    = "return #fun(Int::from_js)(#var(self).jsHeapSizeLimit);"

pub fun MemoryInfo::as_js(self: MemoryInfo) -> JsValue = JsValue::unsafe_from[MemoryInfo](self)

pub fun MemoryInfo::from_js(v: JsValue) -> mut MemoryInfo = JsValue::unsafe_as[mut MemoryInfo](v)

struct NotRestoredReasonDetails()

pub ext fun NotRestoredReasonDetails::reason(self: NotRestoredReasonDetails) -> String
    = "return #fun(String::from_js)(#var(self).reason);"

pub ext fun NotRestoredReasonDetails::to_json(__self: mut NotRestoredReasonDetails) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun NotRestoredReasonDetails::as_js(self: NotRestoredReasonDetails) -> JsValue = JsValue::unsafe_from[NotRestoredReasonDetails](self)

pub fun NotRestoredReasonDetails::from_js(v: JsValue) -> mut NotRestoredReasonDetails = JsValue::unsafe_as[mut NotRestoredReasonDetails](v)

struct NotRestoredReasons()

pub ext fun NotRestoredReasons::src(self: NotRestoredReasons) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).src);"

pub ext fun NotRestoredReasons::id(self: NotRestoredReasons) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).id);"

pub ext fun NotRestoredReasons::name(self: NotRestoredReasons) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).name);"

pub ext fun NotRestoredReasons::url(self: NotRestoredReasons) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).url);"

pub ext fun NotRestoredReasons::reasons(self: NotRestoredReasons) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).reasons);"

pub ext fun NotRestoredReasons::children(self: NotRestoredReasons) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).children);"

pub ext fun NotRestoredReasons::to_json(__self: mut NotRestoredReasons) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun NotRestoredReasons::as_js(self: NotRestoredReasons) -> JsValue = JsValue::unsafe_from[NotRestoredReasons](self)

pub fun NotRestoredReasons::from_js(v: JsValue) -> mut NotRestoredReasons = JsValue::unsafe_as[mut NotRestoredReasons](v)

struct Performance()

/// Converts a reference to 'Performance' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Performance::as_event_target(self: Performance) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Performance' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Performance::as_mevent_target(self: mut Performance) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Performance'.
/// The conversion may fail and panic if 'base' is not a reference to 'Performance' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Performance::from_event_target(base: EventTarget) -> Performance = "
    if(#var(base) instanceof Performance) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Performance'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Performance'.
/// The conversion may fail and panic if 'base' is not a reference to 'Performance' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Performance::from_mevent_target(base: mut EventTarget) -> mut Performance = "
    if(#var(base) instanceof Performance) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Performance'!\");
"

pub ext fun Performance::time_origin(self: Performance) -> Float
    = "return #fun(Float::from_js)(#var(self).timeOrigin);"

pub ext fun Performance::onresourcetimingbufferfull(self: Performance) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onresourcetimingbufferfull);"

pub ext fun Performance::set_onresourcetimingbufferfull(self: mut Performance, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onresourcetimingbufferfull = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Performance::timing(self: Performance) -> mut PerformanceTiming
    = "return #fun(PerformanceTiming::from_js)(#var(self).timing);"

pub ext fun Performance::navigation(self: Performance) -> mut PerformanceNavigation
    = "return #fun(PerformanceNavigation::from_js)(#var(self).navigation);"

pub ext fun Performance::memory(self: Performance) -> mut MemoryInfo
    = "return #fun(MemoryInfo::from_js)(#var(self).memory);"

pub ext fun Performance::event_counts(self: Performance) -> mut EventCounts
    = "return #fun(EventCounts::from_js)(#var(self).eventCounts);"

pub ext fun Performance::interaction_count(self: Performance) -> Int
    = "return #fun(Int::from_js)(#var(self).interactionCount);"

pub ext fun Performance::now(__self: mut Performance) -> Float = "
    const r = #var(__self).now();
    return #fun(Float::from_js)(r);
"

pub ext fun Performance::get_entries(__self: mut Performance) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntries();
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub ext fun Performance::get_entries_by_type(__self: mut Performance, entry_type: String) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntriesByType(#fun(String::as_js)(#var(entry_type)));
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub ext fun Performance::get_entries_by_name(__self: mut Performance, name: String, entry_type: String) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntriesByName(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(entry_type)));
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub ext fun Performance::clear_resource_timings(__self: mut Performance) -> Unit = "
    const r = #var(__self).clearResourceTimings();
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::set_resource_timing_buffer_size(__self: mut Performance, max_size: Int) -> Unit = "
    const r = #var(__self).setResourceTimingBufferSize(#fun(Int::as_js)(#var(max_size)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::mark(__self: mut Performance, mark_name: String, mark_options: mut PerformanceMarkOptions) -> mut PerformanceMark = "
    const r = #var(__self).mark(#fun(String::as_js)(#var(mark_name)), #fun(PerformanceMarkOptions::as_js)(#var(mark_options)));
    return #fun(PerformanceMark::from_js)(r);
"

pub ext fun Performance::clear_marks(__self: mut Performance, mark_name: String) -> Unit = "
    const r = #var(__self).clearMarks(#fun(String::as_js)(#var(mark_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::measure(__self: mut Performance, measure_name: String, start_or_measure_options: JsValue, end_mark: String) -> mut PerformanceMeasure = "
    const r = #var(__self).measure(#fun(String::as_js)(#var(measure_name)), #var(start_or_measure_options), #fun(String::as_js)(#var(end_mark)));
    return #fun(PerformanceMeasure::from_js)(r);
"

pub ext fun Performance::clear_measures(__self: mut Performance, measure_name: String) -> Unit = "
    const r = #var(__self).clearMeasures(#fun(String::as_js)(#var(measure_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::measure_user_agent_specific_memory(__self: mut Performance) -> Promise[mut MemoryMeasurement] = "
    const r = #var(__self).measureUserAgentSpecificMemory();
    return #fun(Promise::from_js[mut MemoryMeasurement])(r);
"

pub ext fun Performance::bind(__self: mut Performance, inner_function: Fun(JsValue) -> JsValue, this_arg: JsValue, ...args: List[JsValue]) -> Fun(JsValue) -> JsValue = "
    const r = #var(__self).bind(((p0) => { const r = #var(inner_function)(p0); return r; }), #var(this_arg), ...((#var(args)).map(v => v)));
    return ((p0) => { const r = r(p0); return r; });
"

pub ext fun Performance::to_json(__self: mut Performance) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub ext fun Performance::add_event_listener(__self: mut Performance, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::remove_event_listener(__self: mut Performance, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Performance::dispatch_event(__self: mut Performance, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Performance::when(__self: mut Performance, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Performance::as_js(self: Performance) -> JsValue = JsValue::unsafe_from[Performance](self)

pub fun Performance::from_js(v: JsValue) -> mut Performance = JsValue::unsafe_as[mut Performance](v)

struct PerformanceContainerTiming()

/// Converts a reference to 'PerformanceContainerTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceContainerTiming::as_performance_entry(self: PerformanceContainerTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceContainerTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceContainerTiming::as_mperformance_entry(self: mut PerformanceContainerTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceContainerTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceContainerTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceContainerTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceContainerTiming = "
    if(#var(base) instanceof PerformanceContainerTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceContainerTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceContainerTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceContainerTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceContainerTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceContainerTiming = "
    if(#var(base) instanceof PerformanceContainerTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceContainerTiming'!\");
"

pub ext fun PerformanceContainerTiming::intersection_rect(self: PerformanceContainerTiming) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).intersectionRect);"

pub ext fun PerformanceContainerTiming::size(self: PerformanceContainerTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).size);"

pub ext fun PerformanceContainerTiming::identifier(self: PerformanceContainerTiming) -> String
    = "return #fun(String::from_js)(#var(self).identifier);"

pub ext fun PerformanceContainerTiming::last_painted_element(self: PerformanceContainerTiming) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastPaintedElement);"

pub ext fun PerformanceContainerTiming::first_render_time(self: PerformanceContainerTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).firstRenderTime);"

pub ext fun PerformanceContainerTiming::name(self: PerformanceContainerTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceContainerTiming::entry_type(self: PerformanceContainerTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceContainerTiming::start_time(self: PerformanceContainerTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceContainerTiming::duration(self: PerformanceContainerTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceContainerTiming::navigation_id(self: PerformanceContainerTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceContainerTiming::to_json(__self: mut PerformanceContainerTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceContainerTiming::as_js(self: PerformanceContainerTiming) -> JsValue = JsValue::unsafe_from[PerformanceContainerTiming](self)

pub fun PerformanceContainerTiming::from_js(v: JsValue) -> mut PerformanceContainerTiming = JsValue::unsafe_as[mut PerformanceContainerTiming](v)

struct PerformanceElementTiming()

/// Converts a reference to 'PerformanceElementTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceElementTiming::as_performance_entry(self: PerformanceElementTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceElementTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceElementTiming::as_mperformance_entry(self: mut PerformanceElementTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceElementTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceElementTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceElementTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceElementTiming = "
    if(#var(base) instanceof PerformanceElementTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceElementTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceElementTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceElementTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceElementTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceElementTiming = "
    if(#var(base) instanceof PerformanceElementTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceElementTiming'!\");
"

pub ext fun PerformanceElementTiming::render_time(self: PerformanceElementTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).renderTime);"

pub ext fun PerformanceElementTiming::load_time(self: PerformanceElementTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).loadTime);"

pub ext fun PerformanceElementTiming::intersection_rect(self: PerformanceElementTiming) -> mut DOMRectReadOnly
    = "return #fun(DOMRectReadOnly::from_js)(#var(self).intersectionRect);"

pub ext fun PerformanceElementTiming::identifier(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).identifier);"

pub ext fun PerformanceElementTiming::natural_width(self: PerformanceElementTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).naturalWidth);"

pub ext fun PerformanceElementTiming::natural_height(self: PerformanceElementTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).naturalHeight);"

pub ext fun PerformanceElementTiming::id(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun PerformanceElementTiming::element(self: PerformanceElementTiming) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).element);"

pub ext fun PerformanceElementTiming::url(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).url);"

pub ext fun PerformanceElementTiming::name(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceElementTiming::entry_type(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceElementTiming::start_time(self: PerformanceElementTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceElementTiming::duration(self: PerformanceElementTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceElementTiming::navigation_id(self: PerformanceElementTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceElementTiming::paint_time(self: PerformanceElementTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun PerformanceElementTiming::presentation_time(self: PerformanceElementTiming) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun PerformanceElementTiming::to_json(__self: mut PerformanceElementTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceElementTiming::as_js(self: PerformanceElementTiming) -> JsValue = JsValue::unsafe_from[PerformanceElementTiming](self)

pub fun PerformanceElementTiming::from_js(v: JsValue) -> mut PerformanceElementTiming = JsValue::unsafe_as[mut PerformanceElementTiming](v)

struct PerformanceEntry()

pub ext fun PerformanceEntry::name(self: PerformanceEntry) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceEntry::entry_type(self: PerformanceEntry) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceEntry::start_time(self: PerformanceEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceEntry::duration(self: PerformanceEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceEntry::navigation_id(self: PerformanceEntry) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceEntry::to_json(__self: mut PerformanceEntry) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceEntry::as_js(self: PerformanceEntry) -> JsValue = JsValue::unsafe_from[PerformanceEntry](self)

pub fun PerformanceEntry::from_js(v: JsValue) -> mut PerformanceEntry = JsValue::unsafe_as[mut PerformanceEntry](v)

struct PerformanceEventTiming()

/// Converts a reference to 'PerformanceEventTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceEventTiming::as_performance_entry(self: PerformanceEventTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceEventTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceEventTiming::as_mperformance_entry(self: mut PerformanceEventTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceEventTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceEventTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceEventTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceEventTiming = "
    if(#var(base) instanceof PerformanceEventTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceEventTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceEventTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceEventTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceEventTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceEventTiming = "
    if(#var(base) instanceof PerformanceEventTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceEventTiming'!\");
"

pub ext fun PerformanceEventTiming::processing_start(self: PerformanceEventTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).processingStart);"

pub ext fun PerformanceEventTiming::processing_end(self: PerformanceEventTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).processingEnd);"

pub ext fun PerformanceEventTiming::cancelable(self: PerformanceEventTiming) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PerformanceEventTiming::target(self: PerformanceEventTiming) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).target);"

pub ext fun PerformanceEventTiming::interaction_id(self: PerformanceEventTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).interactionId);"

pub ext fun PerformanceEventTiming::name(self: PerformanceEventTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceEventTiming::entry_type(self: PerformanceEventTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceEventTiming::start_time(self: PerformanceEventTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceEventTiming::duration(self: PerformanceEventTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceEventTiming::navigation_id(self: PerformanceEventTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceEventTiming::to_json(__self: mut PerformanceEventTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceEventTiming::as_js(self: PerformanceEventTiming) -> JsValue = JsValue::unsafe_from[PerformanceEventTiming](self)

pub fun PerformanceEventTiming::from_js(v: JsValue) -> mut PerformanceEventTiming = JsValue::unsafe_as[mut PerformanceEventTiming](v)

struct PerformanceLongAnimationFrameTiming()

/// Converts a reference to 'PerformanceLongAnimationFrameTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongAnimationFrameTiming::as_performance_entry(self: PerformanceLongAnimationFrameTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceLongAnimationFrameTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongAnimationFrameTiming::as_mperformance_entry(self: mut PerformanceLongAnimationFrameTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceLongAnimationFrameTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceLongAnimationFrameTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongAnimationFrameTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceLongAnimationFrameTiming = "
    if(#var(base) instanceof PerformanceLongAnimationFrameTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceLongAnimationFrameTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceLongAnimationFrameTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceLongAnimationFrameTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongAnimationFrameTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceLongAnimationFrameTiming = "
    if(#var(base) instanceof PerformanceLongAnimationFrameTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceLongAnimationFrameTiming'!\");
"

pub ext fun PerformanceLongAnimationFrameTiming::render_start(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).renderStart);"

pub ext fun PerformanceLongAnimationFrameTiming::style_and_layout_start(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).styleAndLayoutStart);"

pub ext fun PerformanceLongAnimationFrameTiming::first_ui_event_timestamp(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).firstUIEventTimestamp);"

pub ext fun PerformanceLongAnimationFrameTiming::blocking_duration(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).blockingDuration);"

pub ext fun PerformanceLongAnimationFrameTiming::scripts(self: PerformanceLongAnimationFrameTiming) -> JsValue
    = "return #var(self).scripts;"

pub ext fun PerformanceLongAnimationFrameTiming::name(self: PerformanceLongAnimationFrameTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceLongAnimationFrameTiming::entry_type(self: PerformanceLongAnimationFrameTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceLongAnimationFrameTiming::start_time(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceLongAnimationFrameTiming::duration(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceLongAnimationFrameTiming::navigation_id(self: PerformanceLongAnimationFrameTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceLongAnimationFrameTiming::paint_time(self: PerformanceLongAnimationFrameTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun PerformanceLongAnimationFrameTiming::presentation_time(self: PerformanceLongAnimationFrameTiming) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun PerformanceLongAnimationFrameTiming::to_json(__self: mut PerformanceLongAnimationFrameTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceLongAnimationFrameTiming::as_js(self: PerformanceLongAnimationFrameTiming) -> JsValue = JsValue::unsafe_from[PerformanceLongAnimationFrameTiming](self)

pub fun PerformanceLongAnimationFrameTiming::from_js(v: JsValue) -> mut PerformanceLongAnimationFrameTiming = JsValue::unsafe_as[mut PerformanceLongAnimationFrameTiming](v)

struct PerformanceLongTaskTiming()

/// Converts a reference to 'PerformanceLongTaskTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongTaskTiming::as_performance_entry(self: PerformanceLongTaskTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceLongTaskTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongTaskTiming::as_mperformance_entry(self: mut PerformanceLongTaskTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceLongTaskTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceLongTaskTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongTaskTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceLongTaskTiming = "
    if(#var(base) instanceof PerformanceLongTaskTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceLongTaskTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceLongTaskTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceLongTaskTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceLongTaskTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceLongTaskTiming = "
    if(#var(base) instanceof PerformanceLongTaskTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceLongTaskTiming'!\");
"

pub ext fun PerformanceLongTaskTiming::attribution(self: PerformanceLongTaskTiming) -> JsValue
    = "return #var(self).attribution;"

pub ext fun PerformanceLongTaskTiming::name(self: PerformanceLongTaskTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceLongTaskTiming::entry_type(self: PerformanceLongTaskTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceLongTaskTiming::start_time(self: PerformanceLongTaskTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceLongTaskTiming::duration(self: PerformanceLongTaskTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceLongTaskTiming::navigation_id(self: PerformanceLongTaskTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceLongTaskTiming::to_json(__self: mut PerformanceLongTaskTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceLongTaskTiming::as_js(self: PerformanceLongTaskTiming) -> JsValue = JsValue::unsafe_from[PerformanceLongTaskTiming](self)

pub fun PerformanceLongTaskTiming::from_js(v: JsValue) -> mut PerformanceLongTaskTiming = JsValue::unsafe_as[mut PerformanceLongTaskTiming](v)

struct PerformanceMark()

/// Converts a reference to 'PerformanceMark' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMark::as_performance_entry(self: PerformanceMark) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceMark' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMark::as_mperformance_entry(self: mut PerformanceMark) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceMark'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceMark' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMark::from_performance_entry(base: PerformanceEntry) -> PerformanceMark = "
    if(#var(base) instanceof PerformanceMark) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceMark'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceMark'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceMark' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMark::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceMark = "
    if(#var(base) instanceof PerformanceMark) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceMark'!\");
"

pub ext fun PerformanceMark::from_str_mperformance_mark_options(mark_name: String, mark_options: mut PerformanceMarkOptions) -> mut PerformanceMark
    = "return new PerformanceMark(#fun(String::as_js)(#var(mark_name)), #fun(PerformanceMarkOptions::as_js)(#var(mark_options)));"

pub ext fun PerformanceMark::detail(self: PerformanceMark) -> JsValue
    = "return #var(self).detail;"

pub ext fun PerformanceMark::name(self: PerformanceMark) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceMark::entry_type(self: PerformanceMark) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceMark::start_time(self: PerformanceMark) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceMark::duration(self: PerformanceMark) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceMark::navigation_id(self: PerformanceMark) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceMark::to_json(__self: mut PerformanceMark) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceMark::as_js(self: PerformanceMark) -> JsValue = JsValue::unsafe_from[PerformanceMark](self)

pub fun PerformanceMark::from_js(v: JsValue) -> mut PerformanceMark = JsValue::unsafe_as[mut PerformanceMark](v)

pub struct PerformanceMarkOptions(
    detail: Option[JsValue],
    start_time: Option[Float]
)

pub fun PerformanceMarkOptions::default() -> mut PerformanceMarkOptions
    = PerformanceMarkOptions(Option::None, Option::None)

pub ext fun PerformanceMarkOptions::from_js(value: JsValue) -> mut PerformanceMarkOptions = "
    const r = {};
    r.m_detail = #fun(Option::from_js[JsValue])(#var(value).detail);
    r.m_start_time = #fun(Option::from_js[Float])(#var(value).startTime);
    return r;
"

pub ext fun PerformanceMarkOptions::as_js(self: PerformanceMarkOptions) -> JsValue = "
    const r = {};
    r.detail = #fun(Option::as_js_undef[JsValue])(#var(self).m_detail);
    r.startTime = #fun(Option::as_js_undef[Float])(#var(self).m_start_time);
    return r;
"

struct PerformanceMeasure()

/// Converts a reference to 'PerformanceMeasure' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMeasure::as_performance_entry(self: PerformanceMeasure) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceMeasure' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMeasure::as_mperformance_entry(self: mut PerformanceMeasure) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceMeasure'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceMeasure' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMeasure::from_performance_entry(base: PerformanceEntry) -> PerformanceMeasure = "
    if(#var(base) instanceof PerformanceMeasure) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceMeasure'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceMeasure'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceMeasure' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceMeasure::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceMeasure = "
    if(#var(base) instanceof PerformanceMeasure) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceMeasure'!\");
"

pub ext fun PerformanceMeasure::detail(self: PerformanceMeasure) -> JsValue
    = "return #var(self).detail;"

pub ext fun PerformanceMeasure::name(self: PerformanceMeasure) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceMeasure::entry_type(self: PerformanceMeasure) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceMeasure::start_time(self: PerformanceMeasure) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceMeasure::duration(self: PerformanceMeasure) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceMeasure::navigation_id(self: PerformanceMeasure) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceMeasure::to_json(__self: mut PerformanceMeasure) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceMeasure::as_js(self: PerformanceMeasure) -> JsValue = JsValue::unsafe_from[PerformanceMeasure](self)

pub fun PerformanceMeasure::from_js(v: JsValue) -> mut PerformanceMeasure = JsValue::unsafe_as[mut PerformanceMeasure](v)

pub struct PerformanceMeasureOptions(
    detail: Option[JsValue],
    start: Option[JsValue],
    duration: Option[Float],
    end: Option[JsValue]
)

pub fun PerformanceMeasureOptions::default() -> mut PerformanceMeasureOptions
    = PerformanceMeasureOptions(Option::None, Option::None, Option::None, Option::None)

pub ext fun PerformanceMeasureOptions::from_js(value: JsValue) -> mut PerformanceMeasureOptions = "
    const r = {};
    r.m_detail = #fun(Option::from_js[JsValue])(#var(value).detail);
    r.m_start = #fun(Option::from_js[JsValue])(#var(value).start);
    r.m_duration = #fun(Option::from_js[Float])(#var(value).duration);
    r.m_end = #fun(Option::from_js[JsValue])(#var(value).end);
    return r;
"

pub ext fun PerformanceMeasureOptions::as_js(self: PerformanceMeasureOptions) -> JsValue = "
    const r = {};
    r.detail = #fun(Option::as_js_undef[JsValue])(#var(self).m_detail);
    r.start = #fun(Option::as_js_undef[JsValue])(#var(self).m_start);
    r.duration = #fun(Option::as_js_undef[Float])(#var(self).m_duration);
    r.end = #fun(Option::as_js_undef[JsValue])(#var(self).m_end);
    return r;
"

struct PerformanceNavigation()

pub ext fun PerformanceNavigation::type(self: PerformanceNavigation) -> Int
    = "return #fun(Int::from_js)(#var(self).type);"

pub ext fun PerformanceNavigation::redirect_count(self: PerformanceNavigation) -> Int
    = "return #fun(Int::from_js)(#var(self).redirectCount);"

pub ext fun PerformanceNavigation::to_json(__self: mut PerformanceNavigation) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceNavigation::as_js(self: PerformanceNavigation) -> JsValue = JsValue::unsafe_from[PerformanceNavigation](self)

pub fun PerformanceNavigation::from_js(v: JsValue) -> mut PerformanceNavigation = JsValue::unsafe_as[mut PerformanceNavigation](v)

pub val PerformanceNavigation::type_navigate: Int = 0
pub val PerformanceNavigation::type_reload: Int = 1
pub val PerformanceNavigation::type_back_forward: Int = 2
pub val PerformanceNavigation::type_reserved: Int = 255

pub val NavigationTimingType::Navigate: String = "navigate"
pub val NavigationTimingType::Reload: String = "reload"
pub val NavigationTimingType::BackForward: String = "back_forward"
pub val NavigationTimingType::Prerender: String = "prerender"

pub val NavigationEntropy::High: String = "high"
pub val NavigationEntropy::Normal: String = "normal"

struct PerformanceNavigationTiming()

/// Converts a reference to 'PerformanceNavigationTiming' to a reference to 'PerformanceResourceTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::as_performance_resource_timing(self: PerformanceNavigationTiming) -> PerformanceResourceTiming = "return #var(self);"

/// Converts a mutable reference to 'PerformanceNavigationTiming' to a mutable reference to 'PerformanceResourceTiming'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::as_mperformance_resource_timing(self: mut PerformanceNavigationTiming) -> mut PerformanceResourceTiming = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceResourceTiming' to a reference to 'PerformanceNavigationTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceNavigationTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::from_performance_resource_timing(base: PerformanceResourceTiming) -> PerformanceNavigationTiming = "
    if(#var(base) instanceof PerformanceNavigationTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceResourceTiming' to 'PerformanceNavigationTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceResourceTiming' to a mutable reference to 'PerformanceNavigationTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceNavigationTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::from_mperformance_resource_timing(base: mut PerformanceResourceTiming) -> mut PerformanceNavigationTiming = "
    if(#var(base) instanceof PerformanceNavigationTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceResourceTiming' to 'PerformanceNavigationTiming'!\");
"

/// Converts a reference to 'PerformanceNavigationTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::as_performance_entry(self: PerformanceNavigationTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceNavigationTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::as_mperformance_entry(self: mut PerformanceNavigationTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceNavigationTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceNavigationTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceNavigationTiming = "
    if(#var(base) instanceof PerformanceNavigationTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceNavigationTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceNavigationTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceNavigationTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceNavigationTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceNavigationTiming = "
    if(#var(base) instanceof PerformanceNavigationTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceNavigationTiming'!\");
"

pub ext fun PerformanceNavigationTiming::unload_event_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).unloadEventStart);"

pub ext fun PerformanceNavigationTiming::unload_event_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).unloadEventEnd);"

pub ext fun PerformanceNavigationTiming::dom_interactive(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domInteractive);"

pub ext fun PerformanceNavigationTiming::dom_content_loaded_event_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domContentLoadedEventStart);"

pub ext fun PerformanceNavigationTiming::dom_content_loaded_event_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domContentLoadedEventEnd);"

pub ext fun PerformanceNavigationTiming::dom_complete(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domComplete);"

pub ext fun PerformanceNavigationTiming::load_event_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).loadEventStart);"

pub ext fun PerformanceNavigationTiming::load_event_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).loadEventEnd);"

pub ext fun PerformanceNavigationTiming::type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PerformanceNavigationTiming::redirect_count(self: PerformanceNavigationTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).redirectCount);"

pub ext fun PerformanceNavigationTiming::not_restored_reasons(self: PerformanceNavigationTiming) -> Option[mut NotRestoredReasons]
    = "return #fun(Option::from_js[mut NotRestoredReasons])(#var(self).notRestoredReasons);"

pub ext fun PerformanceNavigationTiming::system_entropy(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).systemEntropy);"

pub ext fun PerformanceNavigationTiming::confidence(self: PerformanceNavigationTiming) -> mut PerformanceTimingConfidence
    = "return #fun(PerformanceTimingConfidence::from_js)(#var(self).confidence);"

pub ext fun PerformanceNavigationTiming::critical_ch_restart(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).criticalCHRestart);"

pub ext fun PerformanceNavigationTiming::initiator_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).initiatorType);"

pub ext fun PerformanceNavigationTiming::next_hop_protocol(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).nextHopProtocol);"

pub ext fun PerformanceNavigationTiming::delivery_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).deliveryType);"

pub ext fun PerformanceNavigationTiming::worker_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerStart);"

pub ext fun PerformanceNavigationTiming::worker_router_evaluation_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerRouterEvaluationStart);"

pub ext fun PerformanceNavigationTiming::worker_cache_lookup_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerCacheLookupStart);"

pub ext fun PerformanceNavigationTiming::worker_matched_source_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).workerMatchedSourceType);"

pub ext fun PerformanceNavigationTiming::worker_final_source_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).workerFinalSourceType);"

pub ext fun PerformanceNavigationTiming::redirect_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).redirectStart);"

pub ext fun PerformanceNavigationTiming::redirect_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).redirectEnd);"

pub ext fun PerformanceNavigationTiming::fetch_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).fetchStart);"

pub ext fun PerformanceNavigationTiming::domain_lookup_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domainLookupStart);"

pub ext fun PerformanceNavigationTiming::domain_lookup_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domainLookupEnd);"

pub ext fun PerformanceNavigationTiming::connect_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).connectStart);"

pub ext fun PerformanceNavigationTiming::connect_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).connectEnd);"

pub ext fun PerformanceNavigationTiming::secure_connection_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).secureConnectionStart);"

pub ext fun PerformanceNavigationTiming::request_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).requestStart);"

pub ext fun PerformanceNavigationTiming::response_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).responseStart);"

pub ext fun PerformanceNavigationTiming::response_end(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).responseEnd);"

pub ext fun PerformanceNavigationTiming::transfer_size(self: PerformanceNavigationTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).transferSize);"

pub ext fun PerformanceNavigationTiming::encoded_body_size(self: PerformanceNavigationTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).encodedBodySize);"

pub ext fun PerformanceNavigationTiming::decoded_body_size(self: PerformanceNavigationTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).decodedBodySize);"

pub ext fun PerformanceNavigationTiming::server_timing(self: PerformanceNavigationTiming) -> JsValue
    = "return #var(self).serverTiming;"

pub ext fun PerformanceNavigationTiming::render_blocking_status(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).renderBlockingStatus);"

pub ext fun PerformanceNavigationTiming::response_status(self: PerformanceNavigationTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).responseStatus);"

pub ext fun PerformanceNavigationTiming::content_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).contentType);"

pub ext fun PerformanceNavigationTiming::content_encoding(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).contentEncoding);"

pub ext fun PerformanceNavigationTiming::final_response_headers_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).finalResponseHeadersStart);"

pub ext fun PerformanceNavigationTiming::first_interim_response_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).firstInterimResponseStart);"

pub ext fun PerformanceNavigationTiming::initiator_url(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).initiatorUrl);"

pub ext fun PerformanceNavigationTiming::name(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceNavigationTiming::entry_type(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceNavigationTiming::start_time(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceNavigationTiming::duration(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceNavigationTiming::navigation_id(self: PerformanceNavigationTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceNavigationTiming::to_json(__self: mut PerformanceNavigationTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceNavigationTiming::as_js(self: PerformanceNavigationTiming) -> JsValue = JsValue::unsafe_from[PerformanceNavigationTiming](self)

pub fun PerformanceNavigationTiming::from_js(v: JsValue) -> mut PerformanceNavigationTiming = JsValue::unsafe_as[mut PerformanceNavigationTiming](v)

pub ext fun PerformanceNavigationTiming::activation_start(self: PerformanceNavigationTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).activationStart);"

struct PerformanceObserver()

pub ext fun PerformanceObserver::from_f_mperformance_observer_entry_list_mperformance_observer_mperformance_observer_callback_options_unit(callback: Fun(mut PerformanceObserverEntryList, mut PerformanceObserver, mut PerformanceObserverCallbackOptions) -> Unit) -> mut PerformanceObserver
    = "return new PerformanceObserver(((p0, p1, p2) => { const r = #var(callback)(#fun(PerformanceObserverEntryList::from_js)(p0), #fun(PerformanceObserver::from_js)(p1), #fun(PerformanceObserverCallbackOptions::from_js)(p2)); return #fun(Unit::as_js)(r); }));"

pub ext fun PerformanceObserver::supported_entry_types() -> JsValue
    = "return PerformanceObserver.supportedEntryTypes;"

pub ext fun PerformanceObserver::observe(__self: mut PerformanceObserver, options: mut PerformanceObserverInit) -> Unit = "
    const r = #var(__self).observe(#fun(PerformanceObserverInit::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun PerformanceObserver::disconnect(__self: mut PerformanceObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun PerformanceObserver::take_records(__self: mut PerformanceObserver) -> List[mut PerformanceEntry] = "
    const r = #var(__self).takeRecords();
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub fun PerformanceObserver::as_js(self: PerformanceObserver) -> JsValue = JsValue::unsafe_from[PerformanceObserver](self)

pub fun PerformanceObserver::from_js(v: JsValue) -> mut PerformanceObserver = JsValue::unsafe_as[mut PerformanceObserver](v)

pub struct PerformanceObserverCallbackOptions(
    dropped_entries_count: Option[Int]
)

pub fun PerformanceObserverCallbackOptions::default() -> mut PerformanceObserverCallbackOptions
    = PerformanceObserverCallbackOptions(Option::None)

pub ext fun PerformanceObserverCallbackOptions::from_js(value: JsValue) -> mut PerformanceObserverCallbackOptions = "
    const r = {};
    r.m_dropped_entries_count = #fun(Option::from_js[Int])(#var(value).droppedEntriesCount);
    return r;
"

pub ext fun PerformanceObserverCallbackOptions::as_js(self: PerformanceObserverCallbackOptions) -> JsValue = "
    const r = {};
    r.droppedEntriesCount = #fun(Option::as_js_undef[Int])(#var(self).m_dropped_entries_count);
    return r;
"

struct PerformanceObserverEntryList()

pub ext fun PerformanceObserverEntryList::get_entries(__self: mut PerformanceObserverEntryList) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntries();
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub ext fun PerformanceObserverEntryList::get_entries_by_type(__self: mut PerformanceObserverEntryList, entry_type: String) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntriesByType(#fun(String::as_js)(#var(entry_type)));
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub ext fun PerformanceObserverEntryList::get_entries_by_name(__self: mut PerformanceObserverEntryList, name: String, entry_type: String) -> List[mut PerformanceEntry] = "
    const r = #var(__self).getEntriesByName(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(entry_type)));
    return #fun(List::from_js[mut PerformanceEntry])(r);
"

pub fun PerformanceObserverEntryList::as_js(self: PerformanceObserverEntryList) -> JsValue = JsValue::unsafe_from[PerformanceObserverEntryList](self)

pub fun PerformanceObserverEntryList::from_js(v: JsValue) -> mut PerformanceObserverEntryList = JsValue::unsafe_as[mut PerformanceObserverEntryList](v)

pub struct PerformanceObserverInit(
    entry_types: Option[List[String]],
    type: Option[String],
    buffered: Option[Bool],
    duration_threshold: Option[Float],
    include_soft_navigation_observations: Option[Bool]
)

pub fun PerformanceObserverInit::default() -> mut PerformanceObserverInit
    = PerformanceObserverInit(Option::None, Option::None, Option::Some(false), Option::None, Option::Some(false))

pub ext fun PerformanceObserverInit::from_js(value: JsValue) -> mut PerformanceObserverInit = "
    const r = {};
    r.m_entry_types = #fun(Option::from_js[List[String]])(#var(value).entryTypes);
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_buffered = #fun(Option::from_js[Bool])(#var(value).buffered);
    r.m_duration_threshold = #fun(Option::from_js[Float])(#var(value).durationThreshold);
    r.m_include_soft_navigation_observations = #fun(Option::from_js[Bool])(#var(value).includeSoftNavigationObservations);
    return r;
"

pub ext fun PerformanceObserverInit::as_js(self: PerformanceObserverInit) -> JsValue = "
    const r = {};
    r.entryTypes = #fun(Option::as_js_undef[List[String]])(#var(self).m_entry_types);
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.buffered = #fun(Option::as_js_undef[Bool])(#var(self).m_buffered);
    r.durationThreshold = #fun(Option::as_js_undef[Float])(#var(self).m_duration_threshold);
    r.includeSoftNavigationObservations = #fun(Option::as_js_undef[Bool])(#var(self).m_include_soft_navigation_observations);
    return r;
"

struct PerformancePaintTiming()

/// Converts a reference to 'PerformancePaintTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformancePaintTiming::as_performance_entry(self: PerformancePaintTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformancePaintTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformancePaintTiming::as_mperformance_entry(self: mut PerformancePaintTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformancePaintTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformancePaintTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformancePaintTiming::from_performance_entry(base: PerformanceEntry) -> PerformancePaintTiming = "
    if(#var(base) instanceof PerformancePaintTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformancePaintTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformancePaintTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformancePaintTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformancePaintTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformancePaintTiming = "
    if(#var(base) instanceof PerformancePaintTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformancePaintTiming'!\");
"

pub ext fun PerformancePaintTiming::name(self: PerformancePaintTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformancePaintTiming::entry_type(self: PerformancePaintTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformancePaintTiming::start_time(self: PerformancePaintTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformancePaintTiming::duration(self: PerformancePaintTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformancePaintTiming::navigation_id(self: PerformancePaintTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformancePaintTiming::paint_time(self: PerformancePaintTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun PerformancePaintTiming::presentation_time(self: PerformancePaintTiming) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun PerformancePaintTiming::to_json(__self: mut PerformancePaintTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformancePaintTiming::as_js(self: PerformancePaintTiming) -> JsValue = JsValue::unsafe_from[PerformancePaintTiming](self)

pub fun PerformancePaintTiming::from_js(v: JsValue) -> mut PerformancePaintTiming = JsValue::unsafe_as[mut PerformancePaintTiming](v)

pub val RenderBlockingStatusType::Blocking: String = "blocking"
pub val RenderBlockingStatusType::NonBlocking: String = "non-blocking"

struct PerformanceResourceTiming()

/// Converts a reference to 'PerformanceResourceTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceResourceTiming::as_performance_entry(self: PerformanceResourceTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceResourceTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceResourceTiming::as_mperformance_entry(self: mut PerformanceResourceTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceResourceTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceResourceTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceResourceTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceResourceTiming = "
    if(#var(base) instanceof PerformanceResourceTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceResourceTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceResourceTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceResourceTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceResourceTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceResourceTiming = "
    if(#var(base) instanceof PerformanceResourceTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceResourceTiming'!\");
"

pub ext fun PerformanceResourceTiming::initiator_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).initiatorType);"

pub ext fun PerformanceResourceTiming::next_hop_protocol(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).nextHopProtocol);"

pub ext fun PerformanceResourceTiming::delivery_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).deliveryType);"

pub ext fun PerformanceResourceTiming::worker_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerStart);"

pub ext fun PerformanceResourceTiming::worker_router_evaluation_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerRouterEvaluationStart);"

pub ext fun PerformanceResourceTiming::worker_cache_lookup_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).workerCacheLookupStart);"

pub ext fun PerformanceResourceTiming::worker_matched_source_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).workerMatchedSourceType);"

pub ext fun PerformanceResourceTiming::worker_final_source_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).workerFinalSourceType);"

pub ext fun PerformanceResourceTiming::redirect_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).redirectStart);"

pub ext fun PerformanceResourceTiming::redirect_end(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).redirectEnd);"

pub ext fun PerformanceResourceTiming::fetch_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).fetchStart);"

pub ext fun PerformanceResourceTiming::domain_lookup_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domainLookupStart);"

pub ext fun PerformanceResourceTiming::domain_lookup_end(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).domainLookupEnd);"

pub ext fun PerformanceResourceTiming::connect_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).connectStart);"

pub ext fun PerformanceResourceTiming::connect_end(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).connectEnd);"

pub ext fun PerformanceResourceTiming::secure_connection_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).secureConnectionStart);"

pub ext fun PerformanceResourceTiming::request_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).requestStart);"

pub ext fun PerformanceResourceTiming::response_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).responseStart);"

pub ext fun PerformanceResourceTiming::response_end(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).responseEnd);"

pub ext fun PerformanceResourceTiming::transfer_size(self: PerformanceResourceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).transferSize);"

pub ext fun PerformanceResourceTiming::encoded_body_size(self: PerformanceResourceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).encodedBodySize);"

pub ext fun PerformanceResourceTiming::decoded_body_size(self: PerformanceResourceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).decodedBodySize);"

pub ext fun PerformanceResourceTiming::server_timing(self: PerformanceResourceTiming) -> JsValue
    = "return #var(self).serverTiming;"

pub ext fun PerformanceResourceTiming::render_blocking_status(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).renderBlockingStatus);"

pub ext fun PerformanceResourceTiming::response_status(self: PerformanceResourceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).responseStatus);"

pub ext fun PerformanceResourceTiming::content_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).contentType);"

pub ext fun PerformanceResourceTiming::content_encoding(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).contentEncoding);"

pub ext fun PerformanceResourceTiming::final_response_headers_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).finalResponseHeadersStart);"

pub ext fun PerformanceResourceTiming::first_interim_response_start(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).firstInterimResponseStart);"

pub ext fun PerformanceResourceTiming::initiator_url(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).initiatorUrl);"

pub ext fun PerformanceResourceTiming::name(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceResourceTiming::entry_type(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceResourceTiming::start_time(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceResourceTiming::duration(self: PerformanceResourceTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceResourceTiming::navigation_id(self: PerformanceResourceTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceResourceTiming::to_json(__self: mut PerformanceResourceTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceResourceTiming::as_js(self: PerformanceResourceTiming) -> JsValue = JsValue::unsafe_from[PerformanceResourceTiming](self)

pub fun PerformanceResourceTiming::from_js(v: JsValue) -> mut PerformanceResourceTiming = JsValue::unsafe_as[mut PerformanceResourceTiming](v)

pub val ScriptInvokerType::ClassicScript: String = "classic-script"
pub val ScriptInvokerType::ModuleScript: String = "module-script"
pub val ScriptInvokerType::EventListener: String = "event-listener"
pub val ScriptInvokerType::UserCallback: String = "user-callback"
pub val ScriptInvokerType::ResolvePromise: String = "resolve-promise"
pub val ScriptInvokerType::RejectPromise: String = "reject-promise"
pub val ScriptInvokerType::UserEntryPoint: String = "user-entry-point"

pub val ScriptWindowAttribution::Self: String = "self"
pub val ScriptWindowAttribution::Descendant: String = "descendant"
pub val ScriptWindowAttribution::Ancestor: String = "ancestor"
pub val ScriptWindowAttribution::SamePage: String = "same-page"
pub val ScriptWindowAttribution::Other: String = "other"

struct PerformanceScriptTiming()

/// Converts a reference to 'PerformanceScriptTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceScriptTiming::as_performance_entry(self: PerformanceScriptTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'PerformanceScriptTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceScriptTiming::as_mperformance_entry(self: mut PerformanceScriptTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'PerformanceScriptTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceScriptTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceScriptTiming::from_performance_entry(base: PerformanceEntry) -> PerformanceScriptTiming = "
    if(#var(base) instanceof PerformanceScriptTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceScriptTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'PerformanceScriptTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'PerformanceScriptTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PerformanceScriptTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut PerformanceScriptTiming = "
    if(#var(base) instanceof PerformanceScriptTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'PerformanceScriptTiming'!\");
"

pub ext fun PerformanceScriptTiming::invoker_type(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).invokerType);"

pub ext fun PerformanceScriptTiming::invoker(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).invoker);"

pub ext fun PerformanceScriptTiming::window_attribution(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).windowAttribution);"

pub ext fun PerformanceScriptTiming::execution_start(self: PerformanceScriptTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).executionStart);"

pub ext fun PerformanceScriptTiming::forced_style_and_layout_duration(self: PerformanceScriptTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).forcedStyleAndLayoutDuration);"

pub ext fun PerformanceScriptTiming::pause_duration(self: PerformanceScriptTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).pauseDuration);"

pub ext fun PerformanceScriptTiming::window(self: PerformanceScriptTiming) -> Option[mut Window]
    = "return #fun(Option::from_js[mut Window])(#var(self).window);"

pub ext fun PerformanceScriptTiming::source_url(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).sourceURL);"

pub ext fun PerformanceScriptTiming::source_function_name(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).sourceFunctionName);"

pub ext fun PerformanceScriptTiming::source_char_position(self: PerformanceScriptTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).sourceCharPosition);"

pub ext fun PerformanceScriptTiming::source_line(self: PerformanceScriptTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).sourceLine);"

pub ext fun PerformanceScriptTiming::source_column(self: PerformanceScriptTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).sourceColumn);"

pub ext fun PerformanceScriptTiming::name(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceScriptTiming::entry_type(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun PerformanceScriptTiming::start_time(self: PerformanceScriptTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun PerformanceScriptTiming::duration(self: PerformanceScriptTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceScriptTiming::navigation_id(self: PerformanceScriptTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun PerformanceScriptTiming::to_json(__self: mut PerformanceScriptTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceScriptTiming::as_js(self: PerformanceScriptTiming) -> JsValue = JsValue::unsafe_from[PerformanceScriptTiming](self)

pub fun PerformanceScriptTiming::from_js(v: JsValue) -> mut PerformanceScriptTiming = JsValue::unsafe_as[mut PerformanceScriptTiming](v)

struct PerformanceServerTiming()

pub ext fun PerformanceServerTiming::name(self: PerformanceServerTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun PerformanceServerTiming::duration(self: PerformanceServerTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun PerformanceServerTiming::description(self: PerformanceServerTiming) -> String
    = "return #fun(String::from_js)(#var(self).description);"

pub ext fun PerformanceServerTiming::to_json(__self: mut PerformanceServerTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceServerTiming::as_js(self: PerformanceServerTiming) -> JsValue = JsValue::unsafe_from[PerformanceServerTiming](self)

pub fun PerformanceServerTiming::from_js(v: JsValue) -> mut PerformanceServerTiming = JsValue::unsafe_as[mut PerformanceServerTiming](v)

struct PerformanceTiming()

pub ext fun PerformanceTiming::navigation_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).navigationStart);"

pub ext fun PerformanceTiming::unload_event_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).unloadEventStart);"

pub ext fun PerformanceTiming::unload_event_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).unloadEventEnd);"

pub ext fun PerformanceTiming::redirect_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).redirectStart);"

pub ext fun PerformanceTiming::redirect_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).redirectEnd);"

pub ext fun PerformanceTiming::fetch_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).fetchStart);"

pub ext fun PerformanceTiming::domain_lookup_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domainLookupStart);"

pub ext fun PerformanceTiming::domain_lookup_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domainLookupEnd);"

pub ext fun PerformanceTiming::connect_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).connectStart);"

pub ext fun PerformanceTiming::connect_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).connectEnd);"

pub ext fun PerformanceTiming::secure_connection_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).secureConnectionStart);"

pub ext fun PerformanceTiming::request_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).requestStart);"

pub ext fun PerformanceTiming::response_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).responseStart);"

pub ext fun PerformanceTiming::response_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).responseEnd);"

pub ext fun PerformanceTiming::dom_loading(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domLoading);"

pub ext fun PerformanceTiming::dom_interactive(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domInteractive);"

pub ext fun PerformanceTiming::dom_content_loaded_event_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domContentLoadedEventStart);"

pub ext fun PerformanceTiming::dom_content_loaded_event_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domContentLoadedEventEnd);"

pub ext fun PerformanceTiming::dom_complete(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).domComplete);"

pub ext fun PerformanceTiming::load_event_start(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).loadEventStart);"

pub ext fun PerformanceTiming::load_event_end(self: PerformanceTiming) -> Int
    = "return #fun(Int::from_js)(#var(self).loadEventEnd);"

pub ext fun PerformanceTiming::to_json(__self: mut PerformanceTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceTiming::as_js(self: PerformanceTiming) -> JsValue = JsValue::unsafe_from[PerformanceTiming](self)

pub fun PerformanceTiming::from_js(v: JsValue) -> mut PerformanceTiming = JsValue::unsafe_as[mut PerformanceTiming](v)

pub val PerformanceTimingConfidenceValue::High: String = "high"
pub val PerformanceTimingConfidenceValue::Low: String = "low"

struct PerformanceTimingConfidence()

pub ext fun PerformanceTimingConfidence::randomized_trigger_rate(self: PerformanceTimingConfidence) -> Float
    = "return #fun(Float::from_js)(#var(self).randomizedTriggerRate);"

pub ext fun PerformanceTimingConfidence::value(self: PerformanceTimingConfidence) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun PerformanceTimingConfidence::to_json(__self: mut PerformanceTimingConfidence) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun PerformanceTimingConfidence::as_js(self: PerformanceTimingConfidence) -> JsValue = JsValue::unsafe_from[PerformanceTimingConfidence](self)

pub fun PerformanceTimingConfidence::from_js(v: JsValue) -> mut PerformanceTimingConfidence = JsValue::unsafe_as[mut PerformanceTimingConfidence](v)

struct Profiler()

/// Converts a reference to 'Profiler' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Profiler::as_event_target(self: Profiler) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Profiler' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Profiler::as_mevent_target(self: mut Profiler) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Profiler'.
/// The conversion may fail and panic if 'base' is not a reference to 'Profiler' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Profiler::from_event_target(base: EventTarget) -> Profiler = "
    if(#var(base) instanceof Profiler) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Profiler'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Profiler'.
/// The conversion may fail and panic if 'base' is not a reference to 'Profiler' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Profiler::from_mevent_target(base: mut EventTarget) -> mut Profiler = "
    if(#var(base) instanceof Profiler) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Profiler'!\");
"

pub ext fun Profiler::from_mprofiler_init_options(options: mut ProfilerInitOptions) -> mut Profiler
    = "return new Profiler(#fun(ProfilerInitOptions::as_js)(#var(options)));"

pub ext fun Profiler::sample_interval(self: Profiler) -> Float
    = "return #fun(Float::from_js)(#var(self).sampleInterval);"

pub ext fun Profiler::stopped(self: Profiler) -> Bool
    = "return #fun(Bool::from_js)(#var(self).stopped);"

pub ext fun Profiler::stop(__self: mut Profiler) -> Promise[mut ProfilerTrace] = "
    const r = #var(__self).stop();
    return #fun(Promise::from_js[mut ProfilerTrace])(r);
"

pub ext fun Profiler::add_event_listener(__self: mut Profiler, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Profiler::remove_event_listener(__self: mut Profiler, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Profiler::dispatch_event(__self: mut Profiler, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Profiler::when(__self: mut Profiler, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Profiler::as_js(self: Profiler) -> JsValue = JsValue::unsafe_from[Profiler](self)

pub fun Profiler::from_js(v: JsValue) -> mut Profiler = JsValue::unsafe_as[mut Profiler](v)

pub struct ProfilerFrame(
    name: String,
    resource_id: Option[Int],
    line: Option[Int],
    column: Option[Int]
)

pub fun ProfilerFrame::default(name: String) -> mut ProfilerFrame
    = ProfilerFrame(name, Option::None, Option::None, Option::None)

pub ext fun ProfilerFrame::from_js(value: JsValue) -> mut ProfilerFrame = "
    const r = {};
    r.m_name = #fun(String::from_js)(#var(value).name);
    r.m_resource_id = #fun(Option::from_js[Int])(#var(value).resourceId);
    r.m_line = #fun(Option::from_js[Int])(#var(value).line);
    r.m_column = #fun(Option::from_js[Int])(#var(value).column);
    return r;
"

pub ext fun ProfilerFrame::as_js(self: ProfilerFrame) -> JsValue = "
    const r = {};
    r.name = #fun(String::as_js)(#var(self).m_name);
    r.resourceId = #fun(Option::as_js_undef[Int])(#var(self).m_resource_id);
    r.line = #fun(Option::as_js_undef[Int])(#var(self).m_line);
    r.column = #fun(Option::as_js_undef[Int])(#var(self).m_column);
    return r;
"

pub struct ProfilerInitOptions(
    sample_interval: Float,
    max_buffer_size: Int
)

pub fun ProfilerInitOptions::default(sample_interval: Float, max_buffer_size: Int) -> mut ProfilerInitOptions
    = ProfilerInitOptions(sample_interval, max_buffer_size)

pub ext fun ProfilerInitOptions::from_js(value: JsValue) -> mut ProfilerInitOptions = "
    const r = {};
    r.m_sample_interval = #fun(Float::from_js)(#var(value).sampleInterval);
    r.m_max_buffer_size = #fun(Int::from_js)(#var(value).maxBufferSize);
    return r;
"

pub ext fun ProfilerInitOptions::as_js(self: ProfilerInitOptions) -> JsValue = "
    const r = {};
    r.sampleInterval = #fun(Float::as_js)(#var(self).m_sample_interval);
    r.maxBufferSize = #fun(Int::as_js)(#var(self).m_max_buffer_size);
    return r;
"

pub val ProfilerMarker::Gc: String = "gc"
pub val ProfilerMarker::Layout: String = "layout"
pub val ProfilerMarker::Paint: String = "paint"
pub val ProfilerMarker::Script: String = "script"
pub val ProfilerMarker::Style: String = "style"

pub struct ProfilerSample(
    timestamp: Float,
    stack_id: Option[Int],
    marker: Option[String]
)

pub fun ProfilerSample::default(timestamp: Float) -> mut ProfilerSample
    = ProfilerSample(timestamp, Option::None, Option::None)

pub ext fun ProfilerSample::from_js(value: JsValue) -> mut ProfilerSample = "
    const r = {};
    r.m_timestamp = #fun(Float::from_js)(#var(value).timestamp);
    r.m_stack_id = #fun(Option::from_js[Int])(#var(value).stackId);
    r.m_marker = #fun(Option::from_js[String])(#var(value).marker);
    return r;
"

pub ext fun ProfilerSample::as_js(self: ProfilerSample) -> JsValue = "
    const r = {};
    r.timestamp = #fun(Float::as_js)(#var(self).m_timestamp);
    r.stackId = #fun(Option::as_js_undef[Int])(#var(self).m_stack_id);
    r.marker = #fun(Option::as_js_undef[String])(#var(self).m_marker);
    return r;
"

pub struct ProfilerStack(
    parent_id: Option[Int],
    frame_id: Int
)

pub fun ProfilerStack::default(frame_id: Int) -> mut ProfilerStack
    = ProfilerStack(Option::None, frame_id)

pub ext fun ProfilerStack::from_js(value: JsValue) -> mut ProfilerStack = "
    const r = {};
    r.m_parent_id = #fun(Option::from_js[Int])(#var(value).parentId);
    r.m_frame_id = #fun(Int::from_js)(#var(value).frameId);
    return r;
"

pub ext fun ProfilerStack::as_js(self: ProfilerStack) -> JsValue = "
    const r = {};
    r.parentId = #fun(Option::as_js_undef[Int])(#var(self).m_parent_id);
    r.frameId = #fun(Int::as_js)(#var(self).m_frame_id);
    return r;
"

pub struct ProfilerTrace(
    resources: List[String],
    frames: List[mut ProfilerFrame],
    stacks: List[mut ProfilerStack],
    samples: List[mut ProfilerSample]
)

pub fun ProfilerTrace::default(resources: List[String], frames: List[mut ProfilerFrame], stacks: List[mut ProfilerStack], samples: List[mut ProfilerSample]) -> mut ProfilerTrace
    = ProfilerTrace(resources, frames, stacks, samples)

pub ext fun ProfilerTrace::from_js(value: JsValue) -> mut ProfilerTrace = "
    const r = {};
    r.m_resources = #fun(List::from_js[String])(#var(value).resources);
    r.m_frames = #fun(List::from_js[mut ProfilerFrame])(#var(value).frames);
    r.m_stacks = #fun(List::from_js[mut ProfilerStack])(#var(value).stacks);
    r.m_samples = #fun(List::from_js[mut ProfilerSample])(#var(value).samples);
    return r;
"

pub ext fun ProfilerTrace::as_js(self: ProfilerTrace) -> JsValue = "
    const r = {};
    r.resources = #fun(List::as_js[String])(#var(self).m_resources);
    r.frames = #fun(List::as_js[mut ProfilerFrame])(#var(self).m_frames);
    r.stacks = #fun(List::as_js[mut ProfilerStack])(#var(self).m_stacks);
    r.samples = #fun(List::as_js[mut ProfilerSample])(#var(self).m_samples);
    return r;
"

struct SoftNavigationEntry()

/// Converts a reference to 'SoftNavigationEntry' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun SoftNavigationEntry::as_performance_entry(self: SoftNavigationEntry) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'SoftNavigationEntry' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun SoftNavigationEntry::as_mperformance_entry(self: mut SoftNavigationEntry) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'SoftNavigationEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'SoftNavigationEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SoftNavigationEntry::from_performance_entry(base: PerformanceEntry) -> SoftNavigationEntry = "
    if(#var(base) instanceof SoftNavigationEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'SoftNavigationEntry'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'SoftNavigationEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'SoftNavigationEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SoftNavigationEntry::from_mperformance_entry(base: mut PerformanceEntry) -> mut SoftNavigationEntry = "
    if(#var(base) instanceof SoftNavigationEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'SoftNavigationEntry'!\");
"

pub ext fun SoftNavigationEntry::name(self: SoftNavigationEntry) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun SoftNavigationEntry::entry_type(self: SoftNavigationEntry) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun SoftNavigationEntry::start_time(self: SoftNavigationEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun SoftNavigationEntry::duration(self: SoftNavigationEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun SoftNavigationEntry::navigation_id(self: SoftNavigationEntry) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun SoftNavigationEntry::paint_time(self: SoftNavigationEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).paintTime);"

pub ext fun SoftNavigationEntry::presentation_time(self: SoftNavigationEntry) -> Option[Float]
    = "return #fun(Option::from_js[Float])(#var(self).presentationTime);"

pub ext fun SoftNavigationEntry::to_json(__self: mut SoftNavigationEntry) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun SoftNavigationEntry::as_js(self: SoftNavigationEntry) -> JsValue = JsValue::unsafe_from[SoftNavigationEntry](self)

pub fun SoftNavigationEntry::from_js(v: JsValue) -> mut SoftNavigationEntry = JsValue::unsafe_as[mut SoftNavigationEntry](v)

struct TaskAttributionTiming()

/// Converts a reference to 'TaskAttributionTiming' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskAttributionTiming::as_performance_entry(self: TaskAttributionTiming) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'TaskAttributionTiming' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun TaskAttributionTiming::as_mperformance_entry(self: mut TaskAttributionTiming) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'TaskAttributionTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskAttributionTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskAttributionTiming::from_performance_entry(base: PerformanceEntry) -> TaskAttributionTiming = "
    if(#var(base) instanceof TaskAttributionTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'TaskAttributionTiming'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'TaskAttributionTiming'.
/// The conversion may fail and panic if 'base' is not a reference to 'TaskAttributionTiming' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TaskAttributionTiming::from_mperformance_entry(base: mut PerformanceEntry) -> mut TaskAttributionTiming = "
    if(#var(base) instanceof TaskAttributionTiming) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'TaskAttributionTiming'!\");
"

pub ext fun TaskAttributionTiming::container_type(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).containerType);"

pub ext fun TaskAttributionTiming::container_src(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).containerSrc);"

pub ext fun TaskAttributionTiming::container_id(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).containerId);"

pub ext fun TaskAttributionTiming::container_name(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).containerName);"

pub ext fun TaskAttributionTiming::name(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun TaskAttributionTiming::entry_type(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun TaskAttributionTiming::start_time(self: TaskAttributionTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun TaskAttributionTiming::duration(self: TaskAttributionTiming) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun TaskAttributionTiming::navigation_id(self: TaskAttributionTiming) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun TaskAttributionTiming::to_json(__self: mut TaskAttributionTiming) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun TaskAttributionTiming::as_js(self: TaskAttributionTiming) -> JsValue = JsValue::unsafe_from[TaskAttributionTiming](self)

pub fun TaskAttributionTiming::from_js(v: JsValue) -> mut TaskAttributionTiming = JsValue::unsafe_as[mut TaskAttributionTiming](v)

struct VisibilityStateEntry()

/// Converts a reference to 'VisibilityStateEntry' to a reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun VisibilityStateEntry::as_performance_entry(self: VisibilityStateEntry) -> PerformanceEntry = "return #var(self);"

/// Converts a mutable reference to 'VisibilityStateEntry' to a mutable reference to 'PerformanceEntry'.
/// This does not involve manipulating the object or reference.
pub ext fun VisibilityStateEntry::as_mperformance_entry(self: mut VisibilityStateEntry) -> mut PerformanceEntry = "return #var(self);"

/// Attempts to convert a reference to 'PerformanceEntry' to a reference to 'VisibilityStateEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'VisibilityStateEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VisibilityStateEntry::from_performance_entry(base: PerformanceEntry) -> VisibilityStateEntry = "
    if(#var(base) instanceof VisibilityStateEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'VisibilityStateEntry'!\");
"

/// Attempts to convert a mutable reference to 'PerformanceEntry' to a mutable reference to 'VisibilityStateEntry'.
/// The conversion may fail and panic if 'base' is not a reference to 'VisibilityStateEntry' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun VisibilityStateEntry::from_mperformance_entry(base: mut PerformanceEntry) -> mut VisibilityStateEntry = "
    if(#var(base) instanceof VisibilityStateEntry) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'PerformanceEntry' to 'VisibilityStateEntry'!\");
"

pub ext fun VisibilityStateEntry::name(self: VisibilityStateEntry) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun VisibilityStateEntry::entry_type(self: VisibilityStateEntry) -> String
    = "return #fun(String::from_js)(#var(self).entryType);"

pub ext fun VisibilityStateEntry::start_time(self: VisibilityStateEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).startTime);"

pub ext fun VisibilityStateEntry::duration(self: VisibilityStateEntry) -> Float
    = "return #fun(Float::from_js)(#var(self).duration);"

pub ext fun VisibilityStateEntry::navigation_id(self: VisibilityStateEntry) -> String
    = "return #fun(String::from_js)(#var(self).navigationId);"

pub ext fun VisibilityStateEntry::to_json(__self: mut VisibilityStateEntry) -> JsObject = "
    const r = #var(__self).toJSON();
    return r;
"

pub fun VisibilityStateEntry::as_js(self: VisibilityStateEntry) -> JsValue = JsValue::unsafe_from[VisibilityStateEntry](self)

pub fun VisibilityStateEntry::from_js(v: JsValue) -> mut VisibilityStateEntry = JsValue::unsafe_as[mut VisibilityStateEntry](v)

pub ext fun Window::performance(self: Window) -> mut Performance
    = "return #fun(Performance::from_js)(#var(self).performance);"

pub ext fun WorkerGlobalScope::performance(self: WorkerGlobalScope) -> mut Performance
    = "return #fun(Performance::from_js)(#var(self).performance);"

struct TrustedHTML()

pub ext fun TrustedHTML::as_string(__self: mut TrustedHTML) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun TrustedHTML::to_json(__self: mut TrustedHTML) -> String = "
    const r = #var(__self).toJSON();
    return #fun(String::from_js)(r);
"

pub ext fun TrustedHTML::from_literal(template_literal: JsValue) -> mut TrustedHTML = "
    const r = TrustedHTML.fromLiteral(#var(template_literal));
    return #fun(TrustedHTML::from_js)(r);
"

pub fun TrustedHTML::as_js(self: TrustedHTML) -> JsValue = JsValue::unsafe_from[TrustedHTML](self)

pub fun TrustedHTML::from_js(v: JsValue) -> mut TrustedHTML = JsValue::unsafe_as[mut TrustedHTML](v)

struct TrustedScript()

pub ext fun TrustedScript::as_string(__self: mut TrustedScript) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun TrustedScript::to_json(__self: mut TrustedScript) -> String = "
    const r = #var(__self).toJSON();
    return #fun(String::from_js)(r);
"

pub ext fun TrustedScript::from_literal(template_literal: JsValue) -> mut TrustedScript = "
    const r = TrustedScript.fromLiteral(#var(template_literal));
    return #fun(TrustedScript::from_js)(r);
"

pub fun TrustedScript::as_js(self: TrustedScript) -> JsValue = JsValue::unsafe_from[TrustedScript](self)

pub fun TrustedScript::from_js(v: JsValue) -> mut TrustedScript = JsValue::unsafe_as[mut TrustedScript](v)

struct TrustedScriptURL()

pub ext fun TrustedScriptURL::as_string(__self: mut TrustedScriptURL) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub ext fun TrustedScriptURL::to_json(__self: mut TrustedScriptURL) -> String = "
    const r = #var(__self).toJSON();
    return #fun(String::from_js)(r);
"

pub ext fun TrustedScriptURL::from_literal(template_literal: JsValue) -> mut TrustedScriptURL = "
    const r = TrustedScriptURL.fromLiteral(#var(template_literal));
    return #fun(TrustedScriptURL::from_js)(r);
"

pub fun TrustedScriptURL::as_js(self: TrustedScriptURL) -> JsValue = JsValue::unsafe_from[TrustedScriptURL](self)

pub fun TrustedScriptURL::from_js(v: JsValue) -> mut TrustedScriptURL = JsValue::unsafe_as[mut TrustedScriptURL](v)

struct TrustedTypePolicy()

pub ext fun TrustedTypePolicy::name(self: TrustedTypePolicy) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun TrustedTypePolicy::create_html(__self: mut TrustedTypePolicy, input: String, ...args: List[JsValue]) -> mut TrustedHTML = "
    const r = #var(__self).createHTML(#fun(String::as_js)(#var(input)), ...((#var(args)).map(v => v)));
    return #fun(TrustedHTML::from_js)(r);
"

pub ext fun TrustedTypePolicy::create_script(__self: mut TrustedTypePolicy, input: String, ...args: List[JsValue]) -> mut TrustedScript = "
    const r = #var(__self).createScript(#fun(String::as_js)(#var(input)), ...((#var(args)).map(v => v)));
    return #fun(TrustedScript::from_js)(r);
"

pub ext fun TrustedTypePolicy::create_script_url(__self: mut TrustedTypePolicy, input: String, ...args: List[JsValue]) -> mut TrustedScriptURL = "
    const r = #var(__self).createScriptURL(#fun(String::as_js)(#var(input)), ...((#var(args)).map(v => v)));
    return #fun(TrustedScriptURL::from_js)(r);
"

pub fun TrustedTypePolicy::as_js(self: TrustedTypePolicy) -> JsValue = JsValue::unsafe_from[TrustedTypePolicy](self)

pub fun TrustedTypePolicy::from_js(v: JsValue) -> mut TrustedTypePolicy = JsValue::unsafe_as[mut TrustedTypePolicy](v)

struct TrustedTypePolicyFactory()

/// Converts a reference to 'TrustedTypePolicyFactory' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TrustedTypePolicyFactory::as_event_target(self: TrustedTypePolicyFactory) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'TrustedTypePolicyFactory' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun TrustedTypePolicyFactory::as_mevent_target(self: mut TrustedTypePolicyFactory) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'TrustedTypePolicyFactory'.
/// The conversion may fail and panic if 'base' is not a reference to 'TrustedTypePolicyFactory' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TrustedTypePolicyFactory::from_event_target(base: EventTarget) -> TrustedTypePolicyFactory = "
    if(#var(base) instanceof TrustedTypePolicyFactory) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TrustedTypePolicyFactory'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'TrustedTypePolicyFactory'.
/// The conversion may fail and panic if 'base' is not a reference to 'TrustedTypePolicyFactory' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun TrustedTypePolicyFactory::from_mevent_target(base: mut EventTarget) -> mut TrustedTypePolicyFactory = "
    if(#var(base) instanceof TrustedTypePolicyFactory) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'TrustedTypePolicyFactory'!\");
"

pub ext fun TrustedTypePolicyFactory::empty_html(self: TrustedTypePolicyFactory) -> mut TrustedHTML
    = "return #fun(TrustedHTML::from_js)(#var(self).emptyHTML);"

pub ext fun TrustedTypePolicyFactory::empty_script(self: TrustedTypePolicyFactory) -> mut TrustedScript
    = "return #fun(TrustedScript::from_js)(#var(self).emptyScript);"

pub ext fun TrustedTypePolicyFactory::default_policy(self: TrustedTypePolicyFactory) -> mut TrustedTypePolicy
    = "return #fun(TrustedTypePolicy::from_js)(#var(self).defaultPolicy);"

pub ext fun TrustedTypePolicyFactory::onbeforecreatepolicy(self: TrustedTypePolicyFactory) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onbeforecreatepolicy);"

pub ext fun TrustedTypePolicyFactory::set_onbeforecreatepolicy(self: mut TrustedTypePolicyFactory, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onbeforecreatepolicy = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun TrustedTypePolicyFactory::create_policy(__self: mut TrustedTypePolicyFactory, policy_name: String, policy_options: mut TrustedTypePolicyOptions) -> mut TrustedTypePolicy = "
    const r = #var(__self).createPolicy(#fun(String::as_js)(#var(policy_name)), #fun(TrustedTypePolicyOptions::as_js)(#var(policy_options)));
    return #fun(TrustedTypePolicy::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::is_html(__self: mut TrustedTypePolicyFactory, checked_object: JsValue) -> Bool = "
    const r = #var(__self).isHTML(#var(checked_object));
    return #fun(Bool::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::is_script(__self: mut TrustedTypePolicyFactory, checked_object: JsValue) -> Bool = "
    const r = #var(__self).isScript(#var(checked_object));
    return #fun(Bool::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::is_script_url(__self: mut TrustedTypePolicyFactory, checked_object: JsValue) -> Bool = "
    const r = #var(__self).isScriptURL(#var(checked_object));
    return #fun(Bool::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::get_attribute_type(__self: mut TrustedTypePolicyFactory, tag_name: String, attribute: String, element_ns: Option[String], attr_ns: Option[String]) -> Option[String] = "
    const r = #var(__self).getAttributeType(#fun(String::as_js)(#var(tag_name)), #fun(String::as_js)(#var(attribute)), #fun(Option::as_js[String])(#var(element_ns)), #fun(Option::as_js[String])(#var(attr_ns)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun TrustedTypePolicyFactory::get_property_type(__self: mut TrustedTypePolicyFactory, tag_name: String, property: String, element_ns: Option[String]) -> Option[String] = "
    const r = #var(__self).getPropertyType(#fun(String::as_js)(#var(tag_name)), #fun(String::as_js)(#var(property)), #fun(Option::as_js[String])(#var(element_ns)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun TrustedTypePolicyFactory::get_type_mapping(__self: mut TrustedTypePolicyFactory, ns: String) -> Option[JsObject] = "
    const r = #var(__self).getTypeMapping(#fun(String::as_js)(#var(ns)));
    return #fun(Option::from_js[JsObject])(r);
"

pub ext fun TrustedTypePolicyFactory::add_event_listener(__self: mut TrustedTypePolicyFactory, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::remove_event_listener(__self: mut TrustedTypePolicyFactory, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::dispatch_event(__self: mut TrustedTypePolicyFactory, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun TrustedTypePolicyFactory::when(__self: mut TrustedTypePolicyFactory, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun TrustedTypePolicyFactory::as_js(self: TrustedTypePolicyFactory) -> JsValue = JsValue::unsafe_from[TrustedTypePolicyFactory](self)

pub fun TrustedTypePolicyFactory::from_js(v: JsValue) -> mut TrustedTypePolicyFactory = JsValue::unsafe_as[mut TrustedTypePolicyFactory](v)

pub struct TrustedTypePolicyOptions(
    create_html: Option[Fun(String, JsValue) -> Option[String]],
    create_script: Option[Fun(String, JsValue) -> Option[String]],
    create_script_url: Option[Fun(String, JsValue) -> Option[String]]
)

pub fun TrustedTypePolicyOptions::default() -> mut TrustedTypePolicyOptions
    = TrustedTypePolicyOptions(Option::None, Option::None, Option::None)

pub ext fun TrustedTypePolicyOptions::from_js(value: JsValue) -> mut TrustedTypePolicyOptions = "
    const r = {};
    r.m_create_html = #fun(Option::from_js[Fun(String, JsValue) -> Option[String]])(#var(value).createHTML);
    r.m_create_script = #fun(Option::from_js[Fun(String, JsValue) -> Option[String]])(#var(value).createScript);
    r.m_create_script_url = #fun(Option::from_js[Fun(String, JsValue) -> Option[String]])(#var(value).createScriptURL);
    return r;
"

pub ext fun TrustedTypePolicyOptions::as_js(self: TrustedTypePolicyOptions) -> JsValue = "
    const r = {};
    r.createHTML = #fun(Option::as_js_undef[Fun(String, JsValue) -> Option[String]])(#var(self).m_create_html);
    r.createScript = #fun(Option::as_js_undef[Fun(String, JsValue) -> Option[String]])(#var(self).m_create_script);
    r.createScriptURL = #fun(Option::as_js_undef[Fun(String, JsValue) -> Option[String]])(#var(self).m_create_script_url);
    return r;
"

pub ext fun URL::from_str_str(url: String, base: String) -> mut URL
    = "return new URL(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(base)));"

pub ext fun URL::href(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun URL::set_href(self: mut URL, value: String)
    = "#var(self).href = #fun(String::as_js)(#var(value));"

pub ext fun URL::origin(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun URL::protocol(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun URL::set_protocol(self: mut URL, value: String)
    = "#var(self).protocol = #fun(String::as_js)(#var(value));"

pub ext fun URL::username(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).username);"

pub ext fun URL::set_username(self: mut URL, value: String)
    = "#var(self).username = #fun(String::as_js)(#var(value));"

pub ext fun URL::password(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).password);"

pub ext fun URL::set_password(self: mut URL, value: String)
    = "#var(self).password = #fun(String::as_js)(#var(value));"

pub ext fun URL::host(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).host);"

pub ext fun URL::set_host(self: mut URL, value: String)
    = "#var(self).host = #fun(String::as_js)(#var(value));"

pub ext fun URL::hostname(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun URL::set_hostname(self: mut URL, value: String)
    = "#var(self).hostname = #fun(String::as_js)(#var(value));"

pub ext fun URL::port(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun URL::set_port(self: mut URL, value: String)
    = "#var(self).port = #fun(String::as_js)(#var(value));"

pub ext fun URL::pathname(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun URL::set_pathname(self: mut URL, value: String)
    = "#var(self).pathname = #fun(String::as_js)(#var(value));"

pub ext fun URL::search(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun URL::set_search(self: mut URL, value: String)
    = "#var(self).search = #fun(String::as_js)(#var(value));"

pub ext fun URL::search_params(self: URL) -> mut URLSearchParams
    = "return #fun(URLSearchParams::from_js)(#var(self).searchParams);"

pub ext fun URL::hash(self: URL) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub ext fun URL::set_hash(self: mut URL, value: String)
    = "#var(self).hash = #fun(String::as_js)(#var(value));"

pub ext fun URL::parse(url: String, base: String) -> Option[mut URL] = "
    const r = URL.parse(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(base)));
    return #fun(Option::from_js[mut URL])(r);
"

pub ext fun URL::can_parse(url: String, base: String) -> Bool = "
    const r = URL.canParse(#fun(String::as_js)(#var(url)), #fun(String::as_js)(#var(base)));
    return #fun(Bool::from_js)(r);
"

pub ext fun URL::to_json(__self: mut URL) -> String = "
    const r = #var(__self).toJSON();
    return #fun(String::from_js)(r);
"

struct URLSearchParams()

pub ext fun URLSearchParams::from_any(init: JsValue) -> mut URLSearchParams
    = "return new URLSearchParams(#var(init));"

pub ext fun URLSearchParams::size(self: URLSearchParams) -> Int
    = "return #fun(Int::from_js)(#var(self).size);"

pub ext fun URLSearchParams::append(__self: mut URLSearchParams, name: String, value: String) -> Unit = "
    const r = #var(__self).append(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun URLSearchParams::delete(__self: mut URLSearchParams, name: String, value: String) -> Unit = "
    const r = #var(__self).delete(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun URLSearchParams::get(__self: mut URLSearchParams, name: String) -> Option[String] = "
    const r = #var(__self).get(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun URLSearchParams::get_all(__self: mut URLSearchParams, name: String) -> List[String] = "
    const r = #var(__self).getAll(#fun(String::as_js)(#var(name)));
    return #fun(List::from_js[String])(r);
"

pub ext fun URLSearchParams::has(__self: mut URLSearchParams, name: String, value: String) -> Bool = "
    const r = #var(__self).has(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Bool::from_js)(r);
"

pub ext fun URLSearchParams::set(__self: mut URLSearchParams, name: String, value: String) -> Unit = "
    const r = #var(__self).set(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun URLSearchParams::sort(__self: mut URLSearchParams) -> Unit = "
    const r = #var(__self).sort();
    return #fun(Unit::from_js)(r);
"

pub ext fun URLSearchParams::as_string(__self: mut URLSearchParams) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub fun URLSearchParams::as_js(self: URLSearchParams) -> JsValue = JsValue::unsafe_from[URLSearchParams](self)

pub fun URLSearchParams::from_js(v: JsValue) -> mut URLSearchParams = JsValue::unsafe_as[mut URLSearchParams](v)

pub val URLPatternComponent::Protocol: String = "protocol"
pub val URLPatternComponent::Username: String = "username"
pub val URLPatternComponent::Password: String = "password"
pub val URLPatternComponent::Hostname: String = "hostname"
pub val URLPatternComponent::Port: String = "port"
pub val URLPatternComponent::Pathname: String = "pathname"
pub val URLPatternComponent::Search: String = "search"
pub val URLPatternComponent::Hash: String = "hash"

struct URLPattern()

pub ext fun URLPattern::from_any_str_murl_pattern_options(input: JsValue, base_url: String, options: mut URLPatternOptions) -> mut URLPattern
    = "return new URLPattern(#var(input), #fun(String::as_js)(#var(base_url)), #fun(URLPatternOptions::as_js)(#var(options)));"

pub ext fun URLPattern::from_any_murl_pattern_options(input: JsValue, options: mut URLPatternOptions) -> mut URLPattern
    = "return new URLPattern(#var(input), #fun(URLPatternOptions::as_js)(#var(options)));"

pub ext fun URLPattern::protocol(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun URLPattern::username(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).username);"

pub ext fun URLPattern::password(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).password);"

pub ext fun URLPattern::hostname(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun URLPattern::port(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun URLPattern::pathname(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun URLPattern::search(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun URLPattern::hash(self: URLPattern) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub ext fun URLPattern::has_reg_exp_groups(self: URLPattern) -> Bool
    = "return #fun(Bool::from_js)(#var(self).hasRegExpGroups);"

pub ext fun URLPattern::test(__self: mut URLPattern, input: JsValue, base_url: String) -> Bool = "
    const r = #var(__self).test(#var(input), #fun(String::as_js)(#var(base_url)));
    return #fun(Bool::from_js)(r);
"

pub ext fun URLPattern::exec(__self: mut URLPattern, input: JsValue, base_url: String) -> Option[mut URLPatternResult] = "
    const r = #var(__self).exec(#var(input), #fun(String::as_js)(#var(base_url)));
    return #fun(Option::from_js[mut URLPatternResult])(r);
"

pub ext fun URLPattern::generate(__self: mut URLPattern, component: String, groups: Record[String]) -> String = "
    const r = #var(__self).generate(#var(component), #fun(Record::as_js[String])(#var(groups)));
    return #fun(String::from_js)(r);
"

pub ext fun URLPattern::compare_component(component: String, left: mut URLPattern, right: mut URLPattern) -> Int = "
    const r = URLPattern.compareComponent(#var(component), #fun(URLPattern::as_js)(#var(left)), #fun(URLPattern::as_js)(#var(right)));
    return #fun(Int::from_js)(r);
"

pub fun URLPattern::as_js(self: URLPattern) -> JsValue = JsValue::unsafe_from[URLPattern](self)

pub fun URLPattern::from_js(v: JsValue) -> mut URLPattern = JsValue::unsafe_as[mut URLPattern](v)

pub struct URLPatternComponentResult(
    input: Option[String],
    groups: Option[Record[JsValue]]
)

pub fun URLPatternComponentResult::default() -> mut URLPatternComponentResult
    = URLPatternComponentResult(Option::None, Option::None)

pub ext fun URLPatternComponentResult::from_js(value: JsValue) -> mut URLPatternComponentResult = "
    const r = {};
    r.m_input = #fun(Option::from_js[String])(#var(value).input);
    r.m_groups = #fun(Option::from_js[Record[JsValue]])(#var(value).groups);
    return r;
"

pub ext fun URLPatternComponentResult::as_js(self: URLPatternComponentResult) -> JsValue = "
    const r = {};
    r.input = #fun(Option::as_js_undef[String])(#var(self).m_input);
    r.groups = #fun(Option::as_js_undef[Record[JsValue]])(#var(self).m_groups);
    return r;
"

pub struct URLPatternInit(
    protocol: Option[String],
    username: Option[String],
    password: Option[String],
    hostname: Option[String],
    port: Option[String],
    pathname: Option[String],
    search: Option[String],
    hash: Option[String],
    base_url: Option[String]
)

pub fun URLPatternInit::default() -> mut URLPatternInit
    = URLPatternInit(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun URLPatternInit::from_js(value: JsValue) -> mut URLPatternInit = "
    const r = {};
    r.m_protocol = #fun(Option::from_js[String])(#var(value).protocol);
    r.m_username = #fun(Option::from_js[String])(#var(value).username);
    r.m_password = #fun(Option::from_js[String])(#var(value).password);
    r.m_hostname = #fun(Option::from_js[String])(#var(value).hostname);
    r.m_port = #fun(Option::from_js[String])(#var(value).port);
    r.m_pathname = #fun(Option::from_js[String])(#var(value).pathname);
    r.m_search = #fun(Option::from_js[String])(#var(value).search);
    r.m_hash = #fun(Option::from_js[String])(#var(value).hash);
    r.m_base_url = #fun(Option::from_js[String])(#var(value).baseURL);
    return r;
"

pub ext fun URLPatternInit::as_js(self: URLPatternInit) -> JsValue = "
    const r = {};
    r.protocol = #fun(Option::as_js_undef[String])(#var(self).m_protocol);
    r.username = #fun(Option::as_js_undef[String])(#var(self).m_username);
    r.password = #fun(Option::as_js_undef[String])(#var(self).m_password);
    r.hostname = #fun(Option::as_js_undef[String])(#var(self).m_hostname);
    r.port = #fun(Option::as_js_undef[String])(#var(self).m_port);
    r.pathname = #fun(Option::as_js_undef[String])(#var(self).m_pathname);
    r.search = #fun(Option::as_js_undef[String])(#var(self).m_search);
    r.hash = #fun(Option::as_js_undef[String])(#var(self).m_hash);
    r.baseURL = #fun(Option::as_js_undef[String])(#var(self).m_base_url);
    return r;
"

pub struct URLPatternOptions(
    ignore_case: Option[Bool]
)

pub fun URLPatternOptions::default() -> mut URLPatternOptions
    = URLPatternOptions(Option::Some(false))

pub ext fun URLPatternOptions::from_js(value: JsValue) -> mut URLPatternOptions = "
    const r = {};
    r.m_ignore_case = #fun(Option::from_js[Bool])(#var(value).ignoreCase);
    return r;
"

pub ext fun URLPatternOptions::as_js(self: URLPatternOptions) -> JsValue = "
    const r = {};
    r.ignoreCase = #fun(Option::as_js_undef[Bool])(#var(self).m_ignore_case);
    return r;
"

pub struct URLPatternResult(
    inputs: Option[List[JsValue]],
    protocol: Option[mut URLPatternComponentResult],
    username: Option[mut URLPatternComponentResult],
    password: Option[mut URLPatternComponentResult],
    hostname: Option[mut URLPatternComponentResult],
    port: Option[mut URLPatternComponentResult],
    pathname: Option[mut URLPatternComponentResult],
    search: Option[mut URLPatternComponentResult],
    hash: Option[mut URLPatternComponentResult]
)

pub fun URLPatternResult::default() -> mut URLPatternResult
    = URLPatternResult(Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None, Option::None)

pub ext fun URLPatternResult::from_js(value: JsValue) -> mut URLPatternResult = "
    const r = {};
    r.m_inputs = #fun(Option::from_js[List[JsValue]])(#var(value).inputs);
    r.m_protocol = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).protocol);
    r.m_username = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).username);
    r.m_password = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).password);
    r.m_hostname = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).hostname);
    r.m_port = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).port);
    r.m_pathname = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).pathname);
    r.m_search = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).search);
    r.m_hash = #fun(Option::from_js[mut URLPatternComponentResult])(#var(value).hash);
    return r;
"

pub ext fun URLPatternResult::as_js(self: URLPatternResult) -> JsValue = "
    const r = {};
    r.inputs = #fun(Option::as_js_undef[List[JsValue]])(#var(self).m_inputs);
    r.protocol = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_protocol);
    r.username = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_username);
    r.password = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_password);
    r.hostname = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_hostname);
    r.port = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_port);
    r.pathname = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_pathname);
    r.search = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_search);
    r.hash = #fun(Option::as_js_undef[mut URLPatternComponentResult])(#var(self).m_hash);
    return r;
"

struct PageRevealEvent()

/// Converts a reference to 'PageRevealEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEvent::as_event(self: PageRevealEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PageRevealEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEvent::as_mevent(self: mut PageRevealEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PageRevealEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageRevealEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEvent::from_event(base: Event) -> PageRevealEvent = "
    if(#var(base) instanceof PageRevealEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageRevealEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PageRevealEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageRevealEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEvent::from_mevent(base: mut Event) -> mut PageRevealEvent = "
    if(#var(base) instanceof PageRevealEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageRevealEvent'!\");
"

pub ext fun PageRevealEvent::from_str_mpage_reveal_event_init(type: String, event_init_dict: mut PageRevealEventInit) -> mut PageRevealEvent
    = "return new PageRevealEvent(#fun(String::as_js)(#var(type)), #fun(PageRevealEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PageRevealEvent::view_transition(self: PageRevealEvent) -> Option[mut ViewTransition]
    = "return #fun(Option::from_js[mut ViewTransition])(#var(self).viewTransition);"

pub ext fun PageRevealEvent::type(self: PageRevealEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PageRevealEvent::target(self: PageRevealEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PageRevealEvent::current_target(self: PageRevealEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PageRevealEvent::event_phase(self: PageRevealEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PageRevealEvent::bubbles(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PageRevealEvent::cancelable(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PageRevealEvent::default_prevented(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PageRevealEvent::composed(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PageRevealEvent::is_trusted(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PageRevealEvent::time_stamp(self: PageRevealEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PageRevealEvent::src_element(self: PageRevealEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PageRevealEvent::return_value(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PageRevealEvent::set_return_value(self: mut PageRevealEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PageRevealEvent::cancel_bubble(self: PageRevealEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PageRevealEvent::set_cancel_bubble(self: mut PageRevealEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PageRevealEvent::composed_path(__self: mut PageRevealEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PageRevealEvent::stop_propagation(__self: mut PageRevealEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageRevealEvent::stop_immediate_propagation(__self: mut PageRevealEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageRevealEvent::prevent_default(__self: mut PageRevealEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageRevealEvent::init_event(__self: mut PageRevealEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PageRevealEvent::as_js(self: PageRevealEvent) -> JsValue = JsValue::unsafe_from[PageRevealEvent](self)

pub fun PageRevealEvent::from_js(v: JsValue) -> mut PageRevealEvent = JsValue::unsafe_as[mut PageRevealEvent](v)

pub val PageRevealEvent::none: Int = 0
pub val PageRevealEvent::capturing_phase: Int = 1
pub val PageRevealEvent::at_target: Int = 2
pub val PageRevealEvent::bubbling_phase: Int = 3

pub struct PageRevealEventInit(
    view_transition: Option[mut ViewTransition],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PageRevealEventInit::default() -> mut PageRevealEventInit
    = PageRevealEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PageRevealEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEventInit::as_event_init(self: PageRevealEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'PageRevealEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEventInit::as_mevent_init(self: mut PageRevealEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'PageRevealEventInit'.
/// A 'base' that is not a reference to 'PageRevealEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEventInit::from_event_init_unchecked(base: EventInit) -> PageRevealEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'PageRevealEventInit'.
/// A 'base' that is not a reference to 'PageRevealEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageRevealEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut PageRevealEventInit = "return #var(base);"

pub ext fun PageRevealEventInit::from_js(value: JsValue) -> mut PageRevealEventInit = "
    const r = {};
    r.m_view_transition = #fun(Option::from_js[mut ViewTransition])(#var(value).viewTransition);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PageRevealEventInit::as_js(self: PageRevealEventInit) -> JsValue = "
    const r = {};
    r.viewTransition = #fun(Option::as_js_undef[mut ViewTransition])(#var(self).m_view_transition);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

struct PageSwapEvent()

/// Converts a reference to 'PageSwapEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEvent::as_event(self: PageSwapEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'PageSwapEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEvent::as_mevent(self: mut PageSwapEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'PageSwapEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageSwapEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEvent::from_event(base: Event) -> PageSwapEvent = "
    if(#var(base) instanceof PageSwapEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageSwapEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'PageSwapEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'PageSwapEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEvent::from_mevent(base: mut Event) -> mut PageSwapEvent = "
    if(#var(base) instanceof PageSwapEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'PageSwapEvent'!\");
"

pub ext fun PageSwapEvent::from_str_mpage_swap_event_init(type: String, event_init_dict: mut PageSwapEventInit) -> mut PageSwapEvent
    = "return new PageSwapEvent(#fun(String::as_js)(#var(type)), #fun(PageSwapEventInit::as_js)(#var(event_init_dict)));"

pub ext fun PageSwapEvent::view_transition(self: PageSwapEvent) -> Option[mut ViewTransition]
    = "return #fun(Option::from_js[mut ViewTransition])(#var(self).viewTransition);"

pub ext fun PageSwapEvent::activation(self: PageSwapEvent) -> Option[mut NavigationActivation]
    = "return #fun(Option::from_js[mut NavigationActivation])(#var(self).activation);"

pub ext fun PageSwapEvent::type(self: PageSwapEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun PageSwapEvent::target(self: PageSwapEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun PageSwapEvent::current_target(self: PageSwapEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun PageSwapEvent::event_phase(self: PageSwapEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun PageSwapEvent::bubbles(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun PageSwapEvent::cancelable(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun PageSwapEvent::default_prevented(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun PageSwapEvent::composed(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun PageSwapEvent::is_trusted(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun PageSwapEvent::time_stamp(self: PageSwapEvent) -> Float
    = "return #fun(Float::from_js)(#var(self).timeStamp);"

pub ext fun PageSwapEvent::src_element(self: PageSwapEvent) -> mut EventTarget
    = "return #fun(EventTarget::from_js)(#var(self).srcElement);"

pub ext fun PageSwapEvent::return_value(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun PageSwapEvent::set_return_value(self: mut PageSwapEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun PageSwapEvent::cancel_bubble(self: PageSwapEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun PageSwapEvent::set_cancel_bubble(self: mut PageSwapEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun PageSwapEvent::composed_path(__self: mut PageSwapEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun PageSwapEvent::stop_propagation(__self: mut PageSwapEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageSwapEvent::stop_immediate_propagation(__self: mut PageSwapEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageSwapEvent::prevent_default(__self: mut PageSwapEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun PageSwapEvent::init_event(__self: mut PageSwapEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun PageSwapEvent::as_js(self: PageSwapEvent) -> JsValue = JsValue::unsafe_from[PageSwapEvent](self)

pub fun PageSwapEvent::from_js(v: JsValue) -> mut PageSwapEvent = JsValue::unsafe_as[mut PageSwapEvent](v)

pub val PageSwapEvent::none: Int = 0
pub val PageSwapEvent::capturing_phase: Int = 1
pub val PageSwapEvent::at_target: Int = 2
pub val PageSwapEvent::bubbling_phase: Int = 3

pub struct PageSwapEventInit(
    activation: Option[mut NavigationActivation],
    view_transition: Option[mut ViewTransition],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun PageSwapEventInit::default() -> mut PageSwapEventInit
    = PageSwapEventInit(Option::None, Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'PageSwapEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEventInit::as_event_init(self: PageSwapEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'PageSwapEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEventInit::as_mevent_init(self: mut PageSwapEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'PageSwapEventInit'.
/// A 'base' that is not a reference to 'PageSwapEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEventInit::from_event_init_unchecked(base: EventInit) -> PageSwapEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'PageSwapEventInit'.
/// A 'base' that is not a reference to 'PageSwapEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun PageSwapEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut PageSwapEventInit = "return #var(base);"

pub ext fun PageSwapEventInit::from_js(value: JsValue) -> mut PageSwapEventInit = "
    const r = {};
    r.m_activation = #fun(Option::from_js[mut NavigationActivation])(#var(value).activation);
    r.m_view_transition = #fun(Option::from_js[mut ViewTransition])(#var(value).viewTransition);
    r.m_bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.m_cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.m_composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun PageSwapEventInit::as_js(self: PageSwapEventInit) -> JsValue = "
    const r = {};
    r.activation = #fun(Option::as_js_undef[mut NavigationActivation])(#var(self).m_activation);
    r.viewTransition = #fun(Option::as_js_undef[mut ViewTransition])(#var(self).m_view_transition);
    r.bubbles = #fun(Option::as_js_undef[Bool])(#var(self).m_bubbles);
    r.cancelable = #fun(Option::as_js_undef[Bool])(#var(self).m_cancelable);
    r.composed = #fun(Option::as_js_undef[Bool])(#var(self).m_composed);
    return r;
"

pub ext fun Element::start_view_transition(__self: mut Element) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun Element::start_view_transition_f_prom_unit(__self: mut Element, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun Element::start_view_transition_mview_transition_options(__self: mut Element, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

struct ViewTransition()

pub ext fun ViewTransition::finished(self: ViewTransition) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).finished);"

pub ext fun ViewTransition::ready(self: ViewTransition) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).ready);"

pub ext fun ViewTransition::update_callback_done(self: ViewTransition) -> Promise[Unit]
    = "return #fun(Promise::from_js[Unit])(#var(self).updateCallbackDone);"

pub ext fun ViewTransition::types(self: ViewTransition) -> mut ViewTransitionTypeSet
    = "return #fun(ViewTransitionTypeSet::from_js)(#var(self).types);"

pub ext fun ViewTransition::transition_root(self: ViewTransition) -> mut Element
    = "return #fun(Element::from_js)(#var(self).transitionRoot);"

pub ext fun ViewTransition::skip_transition(__self: mut ViewTransition) -> Unit = "
    const r = #var(__self).skipTransition();
    return #fun(Unit::from_js)(r);
"

pub fun ViewTransition::as_js(self: ViewTransition) -> JsValue = JsValue::unsafe_from[ViewTransition](self)

pub fun ViewTransition::from_js(v: JsValue) -> mut ViewTransition = JsValue::unsafe_as[mut ViewTransition](v)

pub struct ViewTransitionOptions(
    update: Option[Fun() -> Promise[Unit]],
    types: Option[List[String]]
)

pub fun ViewTransitionOptions::default() -> mut ViewTransitionOptions
    = ViewTransitionOptions(Option::None, Option::None)

pub ext fun ViewTransitionOptions::from_js(value: JsValue) -> mut ViewTransitionOptions = "
    const r = {};
    r.m_update = #fun(Option::from_js[Fun() -> Promise[Unit]])(#var(value).update);
    r.m_types = #fun(Option::from_js[List[String]])(#var(value).types);
    return r;
"

pub ext fun ViewTransitionOptions::as_js(self: ViewTransitionOptions) -> JsValue = "
    const r = {};
    r.update = #fun(Option::as_js_undef[Fun() -> Promise[Unit]])(#var(self).m_update);
    r.types = #fun(Option::as_js_undef[List[String]])(#var(self).m_types);
    return r;
"

pub ext fun Document::start_view_transition(__self: mut Document) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition();
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun Document::start_view_transition_f_prom_unit(__self: mut Document, update: Fun() -> Promise[Unit]) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition((() => { const r = #var(update)(); return #fun(Promise::as_js[Unit])(r); }));
    return #fun(ViewTransition::from_js)(r);
"

pub ext fun Document::start_view_transition_mview_transition_options(__self: mut Document, opts: mut ViewTransitionOptions) -> mut ViewTransition = "
    const r = #var(__self).startViewTransition(#fun(ViewTransitionOptions::as_js)(#var(opts)));
    return #fun(ViewTransition::from_js)(r);
"

struct ViewTransitionTypeSet()

pub ext fun ViewTransitionTypeSet::add(__self: mut ViewTransitionTypeSet, key: String) -> Unit = "
    const r = #var(__self).add(#fun(String::as_js)(#var(key)));
    return #fun(Unit::from_js)(r);
"

pub fun ViewTransitionTypeSet::as_js(self: ViewTransitionTypeSet) -> JsValue = JsValue::unsafe_from[ViewTransitionTypeSet](self)

pub fun ViewTransitionTypeSet::from_js(v: JsValue) -> mut ViewTransitionTypeSet = JsValue::unsafe_as[mut ViewTransitionTypeSet](v)

struct DedicatedWorkerGlobalScope()

/// Converts a reference to 'DedicatedWorkerGlobalScope' to a reference to 'WorkerGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::as_worker_global_scope(self: DedicatedWorkerGlobalScope) -> WorkerGlobalScope = "return #var(self);"

/// Converts a mutable reference to 'DedicatedWorkerGlobalScope' to a mutable reference to 'WorkerGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::as_mworker_global_scope(self: mut DedicatedWorkerGlobalScope) -> mut WorkerGlobalScope = "return #var(self);"

/// Attempts to convert a reference to 'WorkerGlobalScope' to a reference to 'DedicatedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'DedicatedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::from_worker_global_scope(base: WorkerGlobalScope) -> DedicatedWorkerGlobalScope = "
    if(#var(base) instanceof DedicatedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkerGlobalScope' to 'DedicatedWorkerGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'WorkerGlobalScope' to a mutable reference to 'DedicatedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'DedicatedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::from_mworker_global_scope(base: mut WorkerGlobalScope) -> mut DedicatedWorkerGlobalScope = "
    if(#var(base) instanceof DedicatedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkerGlobalScope' to 'DedicatedWorkerGlobalScope'!\");
"

/// Converts a reference to 'DedicatedWorkerGlobalScope' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::as_event_target(self: DedicatedWorkerGlobalScope) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'DedicatedWorkerGlobalScope' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::as_mevent_target(self: mut DedicatedWorkerGlobalScope) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'DedicatedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'DedicatedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::from_event_target(base: EventTarget) -> DedicatedWorkerGlobalScope = "
    if(#var(base) instanceof DedicatedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DedicatedWorkerGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'DedicatedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'DedicatedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DedicatedWorkerGlobalScope::from_mevent_target(base: mut EventTarget) -> mut DedicatedWorkerGlobalScope = "
    if(#var(base) instanceof DedicatedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DedicatedWorkerGlobalScope'!\");
"

pub ext fun DedicatedWorkerGlobalScope::name(self: DedicatedWorkerGlobalScope) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun DedicatedWorkerGlobalScope::onmessage(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun DedicatedWorkerGlobalScope::set_onmessage(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::onmessageerror(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessageerror);"

pub ext fun DedicatedWorkerGlobalScope::set_onmessageerror(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessageerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::self(self: DedicatedWorkerGlobalScope) -> mut WorkerGlobalScope
    = "return #fun(WorkerGlobalScope::from_js)(#var(self).self);"

pub ext fun DedicatedWorkerGlobalScope::location(self: DedicatedWorkerGlobalScope) -> mut WorkerLocation
    = "return #fun(WorkerLocation::from_js)(#var(self).location);"

pub ext fun DedicatedWorkerGlobalScope::onerror(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun DedicatedWorkerGlobalScope::set_onerror(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::onlanguagechange(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun DedicatedWorkerGlobalScope::set_onlanguagechange(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::ontimezonechange(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun DedicatedWorkerGlobalScope::set_ontimezonechange(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::navigator(self: DedicatedWorkerGlobalScope) -> mut WorkerNavigator
    = "return #fun(WorkerNavigator::from_js)(#var(self).navigator);"

pub ext fun DedicatedWorkerGlobalScope::onrejectionhandled(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun DedicatedWorkerGlobalScope::set_onrejectionhandled(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::onunhandledrejection(self: DedicatedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun DedicatedWorkerGlobalScope::set_onunhandledrejection(self: mut DedicatedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun DedicatedWorkerGlobalScope::origin(self: DedicatedWorkerGlobalScope) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun DedicatedWorkerGlobalScope::trusted_types(self: DedicatedWorkerGlobalScope) -> mut TrustedTypePolicyFactory
    = "return #fun(TrustedTypePolicyFactory::from_js)(#var(self).trustedTypes);"

pub ext fun DedicatedWorkerGlobalScope::post_message_any_list_obj(__self: mut DedicatedWorkerGlobalScope, message: JsValue, transfer: List[JsObject]) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(List::as_js[JsObject])(#var(transfer)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::post_message_any_mpost_message_options(__self: mut DedicatedWorkerGlobalScope, message: JsValue, options: mut PostMessageOptions) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(PostMessageOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::close(__self: mut DedicatedWorkerGlobalScope) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::request_animation_frame(__self: mut DedicatedWorkerGlobalScope, callback: Fun(Float) -> Unit) -> Int = "
    const r = #var(__self).requestAnimationFrame(((p0) => { const r = #var(callback)(#fun(Float::from_js)(p0)); return #fun(Unit::as_js)(r); }));
    return #fun(Int::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::cancel_animation_frame(__self: mut DedicatedWorkerGlobalScope, handle: Int) -> Unit = "
    const r = #var(__self).cancelAnimationFrame(#fun(Int::as_js)(#var(handle)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::import_scripts(__self: mut DedicatedWorkerGlobalScope, ...urls: List[JsValue]) -> Unit = "
    const r = #var(__self).importScripts(...((#var(urls)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::add_event_listener(__self: mut DedicatedWorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::remove_event_listener(__self: mut DedicatedWorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::dispatch_event(__self: mut DedicatedWorkerGlobalScope, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DedicatedWorkerGlobalScope::when(__self: mut DedicatedWorkerGlobalScope, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun DedicatedWorkerGlobalScope::as_js(self: DedicatedWorkerGlobalScope) -> JsValue = JsValue::unsafe_from[DedicatedWorkerGlobalScope](self)

pub fun DedicatedWorkerGlobalScope::from_js(v: JsValue) -> mut DedicatedWorkerGlobalScope = JsValue::unsafe_as[mut DedicatedWorkerGlobalScope](v)

pub struct SharedWorkerOptions(
    same_site_cookies: Option[String],
    extended_lifetime: Option[Bool],
    type: Option[String],
    credentials: Option[String],
    name: Option[String]
)

pub fun SharedWorkerOptions::default() -> mut SharedWorkerOptions
    = SharedWorkerOptions(Option::None, Option::None, Option::Some("classic"), Option::Some("same-origin"), Option::Some(""))

/// Converts a reference to 'SharedWorkerOptions' to a reference to 'WorkerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerOptions::as_worker_options(self: SharedWorkerOptions) -> WorkerOptions = "return #var(self);"

/// Converts a mutable reference to 'SharedWorkerOptions' to a mutable reference to 'WorkerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerOptions::as_mworker_options(self: mut SharedWorkerOptions) -> mut WorkerOptions = "return #var(self);"

/// Attempts to convert a reference to 'WorkerOptions' to a reference to 'SharedWorkerOptions'.
/// A 'base' that is not a reference to 'SharedWorkerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerOptions::from_worker_options_unchecked(base: WorkerOptions) -> SharedWorkerOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'WorkerOptions' to a mutable reference to 'SharedWorkerOptions'.
/// A 'base' that is not a reference to 'SharedWorkerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerOptions::from_mworker_options_unchecked(base: mut WorkerOptions) -> mut SharedWorkerOptions = "return #var(base);"

pub ext fun SharedWorkerOptions::from_js(value: JsValue) -> mut SharedWorkerOptions = "
    const r = {};
    r.m_same_site_cookies = #fun(Option::from_js[String])(#var(value).sameSiteCookies);
    r.m_extended_lifetime = #fun(Option::from_js[Bool])(#var(value).extendedLifetime);
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_credentials = #fun(Option::from_js[String])(#var(value).credentials);
    r.m_name = #fun(Option::from_js[String])(#var(value).name);
    return r;
"

pub ext fun SharedWorkerOptions::as_js(self: SharedWorkerOptions) -> JsValue = "
    const r = {};
    r.sameSiteCookies = #fun(Option::as_js_undef[String])(#var(self).m_same_site_cookies);
    r.extendedLifetime = #fun(Option::as_js_undef[Bool])(#var(self).m_extended_lifetime);
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.credentials = #fun(Option::as_js_undef[String])(#var(self).m_credentials);
    r.name = #fun(Option::as_js_undef[String])(#var(self).m_name);
    return r;
"

pub val SharedWorkerSameSiteCookies::All: String = "all"
pub val SharedWorkerSameSiteCookies::None: String = "none"

struct SharedWorker()

/// Converts a reference to 'SharedWorker' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorker::as_event_target(self: SharedWorker) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'SharedWorker' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorker::as_mevent_target(self: mut SharedWorker) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'SharedWorker'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorker' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorker::from_event_target(base: EventTarget) -> SharedWorker = "
    if(#var(base) instanceof SharedWorker) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'SharedWorker'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'SharedWorker'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorker' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorker::from_mevent_target(base: mut EventTarget) -> mut SharedWorker = "
    if(#var(base) instanceof SharedWorker) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'SharedWorker'!\");
"

pub ext fun SharedWorker::from_str_any(script_url: String, options: JsValue) -> mut SharedWorker
    = "return new SharedWorker(#fun(String::as_js)(#var(script_url)), #var(options));"

pub ext fun SharedWorker::port(self: SharedWorker) -> mut MessagePort
    = "return #fun(MessagePort::from_js)(#var(self).port);"

pub ext fun SharedWorker::onerror(self: SharedWorker) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun SharedWorker::set_onerror(self: mut SharedWorker, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorker::add_event_listener(__self: mut SharedWorker, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorker::remove_event_listener(__self: mut SharedWorker, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorker::dispatch_event(__self: mut SharedWorker, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SharedWorker::when(__self: mut SharedWorker, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun SharedWorker::as_js(self: SharedWorker) -> JsValue = JsValue::unsafe_from[SharedWorker](self)

pub fun SharedWorker::from_js(v: JsValue) -> mut SharedWorker = JsValue::unsafe_as[mut SharedWorker](v)

struct SharedWorkerGlobalScope()

/// Converts a reference to 'SharedWorkerGlobalScope' to a reference to 'WorkerGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::as_worker_global_scope(self: SharedWorkerGlobalScope) -> WorkerGlobalScope = "return #var(self);"

/// Converts a mutable reference to 'SharedWorkerGlobalScope' to a mutable reference to 'WorkerGlobalScope'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::as_mworker_global_scope(self: mut SharedWorkerGlobalScope) -> mut WorkerGlobalScope = "return #var(self);"

/// Attempts to convert a reference to 'WorkerGlobalScope' to a reference to 'SharedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::from_worker_global_scope(base: WorkerGlobalScope) -> SharedWorkerGlobalScope = "
    if(#var(base) instanceof SharedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkerGlobalScope' to 'SharedWorkerGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'WorkerGlobalScope' to a mutable reference to 'SharedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::from_mworker_global_scope(base: mut WorkerGlobalScope) -> mut SharedWorkerGlobalScope = "
    if(#var(base) instanceof SharedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'WorkerGlobalScope' to 'SharedWorkerGlobalScope'!\");
"

/// Converts a reference to 'SharedWorkerGlobalScope' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::as_event_target(self: SharedWorkerGlobalScope) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'SharedWorkerGlobalScope' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::as_mevent_target(self: mut SharedWorkerGlobalScope) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'SharedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::from_event_target(base: EventTarget) -> SharedWorkerGlobalScope = "
    if(#var(base) instanceof SharedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'SharedWorkerGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'SharedWorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'SharedWorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun SharedWorkerGlobalScope::from_mevent_target(base: mut EventTarget) -> mut SharedWorkerGlobalScope = "
    if(#var(base) instanceof SharedWorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'SharedWorkerGlobalScope'!\");
"

pub ext fun SharedWorkerGlobalScope::name(self: SharedWorkerGlobalScope) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun SharedWorkerGlobalScope::onconnect(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onconnect);"

pub ext fun SharedWorkerGlobalScope::set_onconnect(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onconnect = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::self(self: SharedWorkerGlobalScope) -> mut WorkerGlobalScope
    = "return #fun(WorkerGlobalScope::from_js)(#var(self).self);"

pub ext fun SharedWorkerGlobalScope::location(self: SharedWorkerGlobalScope) -> mut WorkerLocation
    = "return #fun(WorkerLocation::from_js)(#var(self).location);"

pub ext fun SharedWorkerGlobalScope::onerror(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun SharedWorkerGlobalScope::set_onerror(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::onlanguagechange(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun SharedWorkerGlobalScope::set_onlanguagechange(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::ontimezonechange(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun SharedWorkerGlobalScope::set_ontimezonechange(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::navigator(self: SharedWorkerGlobalScope) -> mut WorkerNavigator
    = "return #fun(WorkerNavigator::from_js)(#var(self).navigator);"

pub ext fun SharedWorkerGlobalScope::onrejectionhandled(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun SharedWorkerGlobalScope::set_onrejectionhandled(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::onunhandledrejection(self: SharedWorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun SharedWorkerGlobalScope::set_onunhandledrejection(self: mut SharedWorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun SharedWorkerGlobalScope::origin(self: SharedWorkerGlobalScope) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun SharedWorkerGlobalScope::trusted_types(self: SharedWorkerGlobalScope) -> mut TrustedTypePolicyFactory
    = "return #fun(TrustedTypePolicyFactory::from_js)(#var(self).trustedTypes);"

pub ext fun SharedWorkerGlobalScope::close(__self: mut SharedWorkerGlobalScope) -> Unit = "
    const r = #var(__self).close();
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorkerGlobalScope::import_scripts(__self: mut SharedWorkerGlobalScope, ...urls: List[JsValue]) -> Unit = "
    const r = #var(__self).importScripts(...((#var(urls)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorkerGlobalScope::add_event_listener(__self: mut SharedWorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorkerGlobalScope::remove_event_listener(__self: mut SharedWorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun SharedWorkerGlobalScope::dispatch_event(__self: mut SharedWorkerGlobalScope, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun SharedWorkerGlobalScope::when(__self: mut SharedWorkerGlobalScope, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun SharedWorkerGlobalScope::as_js(self: SharedWorkerGlobalScope) -> JsValue = JsValue::unsafe_from[SharedWorkerGlobalScope](self)

pub fun SharedWorkerGlobalScope::from_js(v: JsValue) -> mut SharedWorkerGlobalScope = JsValue::unsafe_as[mut SharedWorkerGlobalScope](v)

struct Worker()

/// Converts a reference to 'Worker' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Worker::as_event_target(self: Worker) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Worker' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Worker::as_mevent_target(self: mut Worker) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Worker'.
/// The conversion may fail and panic if 'base' is not a reference to 'Worker' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Worker::from_event_target(base: EventTarget) -> Worker = "
    if(#var(base) instanceof Worker) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Worker'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Worker'.
/// The conversion may fail and panic if 'base' is not a reference to 'Worker' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Worker::from_mevent_target(base: mut EventTarget) -> mut Worker = "
    if(#var(base) instanceof Worker) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Worker'!\");
"

pub ext fun Worker::from_str_mworker_options(script_url: String, options: mut WorkerOptions) -> mut Worker
    = "return new Worker(#fun(String::as_js)(#var(script_url)), #fun(WorkerOptions::as_js)(#var(options)));"

pub ext fun Worker::onmessage(self: Worker) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onmessage);"

pub ext fun Worker::set_onmessage(self: mut Worker, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onmessage = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Worker::onerror(self: Worker) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun Worker::set_onerror(self: mut Worker, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun Worker::terminate(__self: mut Worker) -> Unit = "
    const r = #var(__self).terminate();
    return #fun(Unit::from_js)(r);
"

pub ext fun Worker::post_message_any_list_obj(__self: mut Worker, message: JsValue, transfer: List[JsObject]) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(List::as_js[JsObject])(#var(transfer)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Worker::post_message_any_mpost_message_options(__self: mut Worker, message: JsValue, options: mut PostMessageOptions) -> Unit = "
    const r = #var(__self).postMessage(#var(message), #fun(PostMessageOptions::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Worker::add_event_listener(__self: mut Worker, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Worker::remove_event_listener(__self: mut Worker, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Worker::dispatch_event(__self: mut Worker, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Worker::when(__self: mut Worker, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun Worker::as_js(self: Worker) -> JsValue = JsValue::unsafe_from[Worker](self)

pub fun Worker::from_js(v: JsValue) -> mut Worker = JsValue::unsafe_as[mut Worker](v)

/// Converts a reference to 'WorkerGlobalScope' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun WorkerGlobalScope::as_event_target(self: WorkerGlobalScope) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'WorkerGlobalScope' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun WorkerGlobalScope::as_mevent_target(self: mut WorkerGlobalScope) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'WorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'WorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WorkerGlobalScope::from_event_target(base: EventTarget) -> WorkerGlobalScope = "
    if(#var(base) instanceof WorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'WorkerGlobalScope'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'WorkerGlobalScope'.
/// The conversion may fail and panic if 'base' is not a reference to 'WorkerGlobalScope' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun WorkerGlobalScope::from_mevent_target(base: mut EventTarget) -> mut WorkerGlobalScope = "
    if(#var(base) instanceof WorkerGlobalScope) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'WorkerGlobalScope'!\");
"

pub ext fun WorkerGlobalScope::self(self: WorkerGlobalScope) -> mut WorkerGlobalScope
    = "return #fun(WorkerGlobalScope::from_js)(#var(self).self);"

pub ext fun WorkerGlobalScope::location(self: WorkerGlobalScope) -> mut WorkerLocation
    = "return #fun(WorkerLocation::from_js)(#var(self).location);"

pub ext fun WorkerGlobalScope::onerror(self: WorkerGlobalScope) -> Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun WorkerGlobalScope::set_onerror(self: mut WorkerGlobalScope, value: Option[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue, String, Int, Int, JsValue) -> JsValue])(#var(value));"

pub ext fun WorkerGlobalScope::onlanguagechange(self: WorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onlanguagechange);"

pub ext fun WorkerGlobalScope::set_onlanguagechange(self: mut WorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onlanguagechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun WorkerGlobalScope::ontimezonechange(self: WorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimezonechange);"

pub ext fun WorkerGlobalScope::set_ontimezonechange(self: mut WorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimezonechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun WorkerGlobalScope::navigator(self: WorkerGlobalScope) -> mut WorkerNavigator
    = "return #fun(WorkerNavigator::from_js)(#var(self).navigator);"

pub ext fun WorkerGlobalScope::onrejectionhandled(self: WorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onrejectionhandled);"

pub ext fun WorkerGlobalScope::set_onrejectionhandled(self: mut WorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onrejectionhandled = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun WorkerGlobalScope::onunhandledrejection(self: WorkerGlobalScope) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onunhandledrejection);"

pub ext fun WorkerGlobalScope::set_onunhandledrejection(self: mut WorkerGlobalScope, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onunhandledrejection = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun WorkerGlobalScope::origin(self: WorkerGlobalScope) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun WorkerGlobalScope::trusted_types(self: WorkerGlobalScope) -> mut TrustedTypePolicyFactory
    = "return #fun(TrustedTypePolicyFactory::from_js)(#var(self).trustedTypes);"

pub ext fun WorkerGlobalScope::import_scripts(__self: mut WorkerGlobalScope, ...urls: List[JsValue]) -> Unit = "
    const r = #var(__self).importScripts(...((#var(urls)).map(v => v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerGlobalScope::add_event_listener(__self: mut WorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerGlobalScope::remove_event_listener(__self: mut WorkerGlobalScope, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun WorkerGlobalScope::dispatch_event(__self: mut WorkerGlobalScope, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun WorkerGlobalScope::when(__self: mut WorkerGlobalScope, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

struct WorkerLocation()

pub ext fun WorkerLocation::href(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).href);"

pub ext fun WorkerLocation::origin(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).origin);"

pub ext fun WorkerLocation::protocol(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).protocol);"

pub ext fun WorkerLocation::host(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).host);"

pub ext fun WorkerLocation::hostname(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).hostname);"

pub ext fun WorkerLocation::port(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).port);"

pub ext fun WorkerLocation::pathname(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).pathname);"

pub ext fun WorkerLocation::search(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).search);"

pub ext fun WorkerLocation::hash(self: WorkerLocation) -> String
    = "return #fun(String::from_js)(#var(self).hash);"

pub fun WorkerLocation::as_js(self: WorkerLocation) -> JsValue = JsValue::unsafe_from[WorkerLocation](self)

pub fun WorkerLocation::from_js(v: JsValue) -> mut WorkerLocation = JsValue::unsafe_as[mut WorkerLocation](v)

struct WorkerNavigator()

pub ext fun WorkerNavigator::hardware_concurrency(self: WorkerNavigator) -> Int
    = "return #fun(Int::from_js)(#var(self).hardwareConcurrency);"

pub ext fun WorkerNavigator::device_memory(self: WorkerNavigator) -> Float
    = "return #fun(Float::from_js)(#var(self).deviceMemory);"

pub ext fun WorkerNavigator::app_code_name(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).appCodeName);"

pub ext fun WorkerNavigator::app_name(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).appName);"

pub ext fun WorkerNavigator::app_version(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).appVersion);"

pub ext fun WorkerNavigator::platform(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).platform);"

pub ext fun WorkerNavigator::product(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).product);"

pub ext fun WorkerNavigator::user_agent(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).userAgent);"

pub ext fun WorkerNavigator::language(self: WorkerNavigator) -> String
    = "return #fun(String::from_js)(#var(self).language);"

pub ext fun WorkerNavigator::languages(self: WorkerNavigator) -> JsValue
    = "return #var(self).languages;"

pub ext fun WorkerNavigator::on_line(self: WorkerNavigator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).onLine);"

pub ext fun WorkerNavigator::user_agent_data(self: WorkerNavigator) -> mut NavigatorUAData
    = "return #fun(NavigatorUAData::from_js)(#var(self).userAgentData);"

pub fun WorkerNavigator::as_js(self: WorkerNavigator) -> JsValue = JsValue::unsafe_from[WorkerNavigator](self)

pub fun WorkerNavigator::from_js(v: JsValue) -> mut WorkerNavigator = JsValue::unsafe_as[mut WorkerNavigator](v)

pub struct WorkerOptions(
    type: Option[String],
    credentials: Option[String],
    name: Option[String]
)

pub fun WorkerOptions::default() -> mut WorkerOptions
    = WorkerOptions(Option::Some("classic"), Option::Some("same-origin"), Option::Some(""))

pub ext fun WorkerOptions::from_js(value: JsValue) -> mut WorkerOptions = "
    const r = {};
    r.m_type = #fun(Option::from_js[String])(#var(value).type);
    r.m_credentials = #fun(Option::from_js[String])(#var(value).credentials);
    r.m_name = #fun(Option::from_js[String])(#var(value).name);
    return r;
"

pub ext fun WorkerOptions::as_js(self: WorkerOptions) -> JsValue = "
    const r = {};
    r.type = #fun(Option::as_js_undef[String])(#var(self).m_type);
    r.credentials = #fun(Option::as_js_undef[String])(#var(self).m_credentials);
    r.name = #fun(Option::as_js_undef[String])(#var(self).m_name);
    return r;
"

pub val WorkerType::Classic: String = "classic"
pub val WorkerType::Module: String = "module"

struct Worklet()

pub ext fun Worklet::add_module(__self: mut Worklet, module_url: String, options: mut WorkletOptions) -> Promise[Unit] = "
    const r = #var(__self).addModule(#fun(String::as_js)(#var(module_url)), #fun(WorkletOptions::as_js)(#var(options)));
    return #fun(Promise::from_js[Unit])(r);
"

pub fun Worklet::as_js(self: Worklet) -> JsValue = JsValue::unsafe_from[Worklet](self)

pub fun Worklet::from_js(v: JsValue) -> mut Worklet = JsValue::unsafe_as[mut Worklet](v)

struct WorkletGlobalScope()

pub fun WorkletGlobalScope::as_js(self: WorkletGlobalScope) -> JsValue = JsValue::unsafe_from[WorkletGlobalScope](self)

pub fun WorkletGlobalScope::from_js(v: JsValue) -> mut WorkletGlobalScope = JsValue::unsafe_as[mut WorkletGlobalScope](v)

pub struct WorkletOptions(
    credentials: Option[String]
)

pub fun WorkletOptions::default() -> mut WorkletOptions
    = WorkletOptions(Option::Some("same-origin"))

pub ext fun WorkletOptions::from_js(value: JsValue) -> mut WorkletOptions = "
    const r = {};
    r.m_credentials = #fun(Option::from_js[String])(#var(value).credentials);
    return r;
"

pub ext fun WorkletOptions::as_js(self: WorkletOptions) -> JsValue = "
    const r = {};
    r.credentials = #fun(Option::as_js_undef[String])(#var(self).m_credentials);
    return r;
"

pub ext fun Document::create_expression(__self: mut Document, expression: String, resolver: Option[Fun(String) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun Document::create_ns_resolver(__self: mut Document, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::evaluate(__self: mut Document, expression: String, context_node: mut Node, resolver: Option[Fun(String) -> Option[String]], type: Int, in_result: Option[JsObject]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[JsObject])(#var(in_result)));
    return #fun(XPathResult::from_js)(r);
"

pub val SupportedType::TextHtml: String = "text/html"
pub val SupportedType::TextXml: String = "text/xml"
pub val SupportedType::ApplicationXml: String = "application/xml"
pub val SupportedType::ApplicationXhtmlXml: String = "application/xhtml+xml"
pub val SupportedType::ImageSvgXml: String = "image/svg+xml"

struct DOMParser()

pub ext fun DOMParser::new() -> mut DOMParser
    = "return new DOMParser();"

pub ext fun DOMParser::parse_from_string(__self: mut DOMParser, str: String, type: String) -> mut Document = "
    const r = #var(__self).parseFromString(#fun(String::as_js)(#var(str)), #var(type));
    return #fun(Document::from_js)(r);
"

pub fun DOMParser::as_js(self: DOMParser) -> JsValue = JsValue::unsafe_from[DOMParser](self)

pub fun DOMParser::from_js(v: JsValue) -> mut DOMParser = JsValue::unsafe_as[mut DOMParser](v)

struct XMLSerializer()

pub ext fun XMLSerializer::new() -> mut XMLSerializer
    = "return new XMLSerializer();"

pub ext fun XMLSerializer::serialize_to_string(__self: mut XMLSerializer, root: mut Node) -> String = "
    const r = #var(__self).serializeToString(#fun(Node::as_js)(#var(root)));
    return #fun(String::from_js)(r);
"

pub fun XMLSerializer::as_js(self: XMLSerializer) -> JsValue = JsValue::unsafe_from[XMLSerializer](self)

pub fun XMLSerializer::from_js(v: JsValue) -> mut XMLSerializer = JsValue::unsafe_as[mut XMLSerializer](v)

struct XPathEvaluator()

pub ext fun XPathEvaluator::new() -> mut XPathEvaluator
    = "return new XPathEvaluator();"

pub ext fun XPathEvaluator::create_expression(__self: mut XPathEvaluator, expression: String, resolver: Option[Fun(String) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun XPathEvaluator::create_ns_resolver(__self: mut XPathEvaluator, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun XPathEvaluator::evaluate(__self: mut XPathEvaluator, expression: String, context_node: mut Node, resolver: Option[Fun(String) -> Option[String]], type: Int, in_result: Option[JsObject]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(String) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[JsObject])(#var(in_result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun XPathEvaluator::as_js(self: XPathEvaluator) -> JsValue = JsValue::unsafe_from[XPathEvaluator](self)

pub fun XPathEvaluator::from_js(v: JsValue) -> mut XPathEvaluator = JsValue::unsafe_as[mut XPathEvaluator](v)

struct XPathExpression()

pub ext fun XPathExpression::evaluate(__self: mut XPathExpression, context_node: mut Node, type: Int, in_result: Option[JsObject]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(Node::as_js)(#var(context_node)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[JsObject])(#var(in_result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun XPathExpression::as_js(self: XPathExpression) -> JsValue = JsValue::unsafe_from[XPathExpression](self)

pub fun XPathExpression::from_js(v: JsValue) -> mut XPathExpression = JsValue::unsafe_as[mut XPathExpression](v)

struct XPathResult()

pub ext fun XPathResult::result_type(self: XPathResult) -> Int
    = "return #fun(Int::from_js)(#var(self).resultType);"

pub ext fun XPathResult::number_value(self: XPathResult) -> Float
    = "return #fun(Float::from_js)(#var(self).numberValue);"

pub ext fun XPathResult::string_value(self: XPathResult) -> String
    = "return #fun(String::from_js)(#var(self).stringValue);"

pub ext fun XPathResult::boolean_value(self: XPathResult) -> Bool
    = "return #fun(Bool::from_js)(#var(self).booleanValue);"

pub ext fun XPathResult::single_node_value(self: XPathResult) -> mut Node
    = "return #fun(Node::from_js)(#var(self).singleNodeValue);"

pub ext fun XPathResult::invalid_iterator_state(self: XPathResult) -> Bool
    = "return #fun(Bool::from_js)(#var(self).invalidIteratorState);"

pub ext fun XPathResult::snapshot_length(self: XPathResult) -> Int
    = "return #fun(Int::from_js)(#var(self).snapshotLength);"

pub ext fun XPathResult::iterate_next(__self: mut XPathResult) -> Option[mut Node] = "
    const r = #var(__self).iterateNext();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun XPathResult::snapshot_item(__self: mut XPathResult, index: Int) -> Option[mut Node] = "
    const r = #var(__self).snapshotItem(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Node])(r);
"

pub fun XPathResult::as_js(self: XPathResult) -> JsValue = JsValue::unsafe_from[XPathResult](self)

pub fun XPathResult::from_js(v: JsValue) -> mut XPathResult = JsValue::unsafe_as[mut XPathResult](v)

pub val XPathResult::any_type: Int = 0
pub val XPathResult::number_type: Int = 1
pub val XPathResult::string_type: Int = 2
pub val XPathResult::boolean_type: Int = 3
pub val XPathResult::unordered_node_iterator_type: Int = 4
pub val XPathResult::ordered_node_iterator_type: Int = 5
pub val XPathResult::unordered_node_snapshot_type: Int = 6
pub val XPathResult::ordered_node_snapshot_type: Int = 7
pub val XPathResult::any_unordered_node_type: Int = 8
pub val XPathResult::first_ordered_node_type: Int = 9

struct XSLTProcessor()

pub ext fun XSLTProcessor::new() -> mut XSLTProcessor
    = "return new XSLTProcessor();"

pub ext fun XSLTProcessor::import_stylesheet(__self: mut XSLTProcessor, style: mut Node) -> Unit = "
    const r = #var(__self).importStylesheet(#fun(Node::as_js)(#var(style)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::transform_to_fragment(__self: mut XSLTProcessor, source: mut Node, output: mut Document) -> Option[mut DocumentFragment] = "
    const r = #var(__self).transformToFragment(#fun(Node::as_js)(#var(source)), #fun(Document::as_js)(#var(output)));
    return #fun(Option::from_js[mut DocumentFragment])(r);
"

pub ext fun XSLTProcessor::transform_to_document(__self: mut XSLTProcessor, source: mut Node) -> Option[mut Document] = "
    const r = #var(__self).transformToDocument(#fun(Node::as_js)(#var(source)));
    return #fun(Option::from_js[mut Document])(r);
"

pub ext fun XSLTProcessor::set_parameter(__self: mut XSLTProcessor, namespace_uri: Option[String], local_name: String, value: String) -> Unit = "
    const r = #var(__self).setParameter(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::get_parameter(__self: mut XSLTProcessor, namespace_uri: Option[String], local_name: String) -> Option[String] = "
    const r = #var(__self).getParameter(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun XSLTProcessor::remove_parameter(__self: mut XSLTProcessor, namespace_uri: Option[String], local_name: String) -> Unit = "
    const r = #var(__self).removeParameter(#fun(Option::as_js[String])(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::clear_parameters(__self: mut XSLTProcessor) -> Unit = "
    const r = #var(__self).clearParameters();
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::reset(__self: mut XSLTProcessor) -> Unit = "
    const r = #var(__self).reset();
    return #fun(Unit::from_js)(r);
"

pub fun XSLTProcessor::as_js(self: XSLTProcessor) -> JsValue = JsValue::unsafe_from[XSLTProcessor](self)

pub fun XSLTProcessor::from_js(v: JsValue) -> mut XSLTProcessor = JsValue::unsafe_as[mut XSLTProcessor](v)

pub val XMLHttpRequestResponseType::Arraybuffer: String = "arraybuffer"
pub val XMLHttpRequestResponseType::Blob: String = "blob"
pub val XMLHttpRequestResponseType::Document: String = "document"
pub val XMLHttpRequestResponseType::Json: String = "json"
pub val XMLHttpRequestResponseType::Text: String = "text"

struct XMLHttpRequest()

/// Converts a reference to 'XMLHttpRequest' to a reference to 'XMLHttpRequestEventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::as_xml_http_request_event_target(self: XMLHttpRequest) -> XMLHttpRequestEventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLHttpRequest' to a mutable reference to 'XMLHttpRequestEventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::as_mxml_http_request_event_target(self: mut XMLHttpRequest) -> mut XMLHttpRequestEventTarget = "return #var(self);"

/// Attempts to convert a reference to 'XMLHttpRequestEventTarget' to a reference to 'XMLHttpRequest'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequest' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::from_xml_http_request_event_target(base: XMLHttpRequestEventTarget) -> XMLHttpRequest = "
    if(#var(base) instanceof XMLHttpRequest) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'XMLHttpRequestEventTarget' to 'XMLHttpRequest'!\");
"

/// Attempts to convert a mutable reference to 'XMLHttpRequestEventTarget' to a mutable reference to 'XMLHttpRequest'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequest' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::from_mxml_http_request_event_target(base: mut XMLHttpRequestEventTarget) -> mut XMLHttpRequest = "
    if(#var(base) instanceof XMLHttpRequest) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'XMLHttpRequestEventTarget' to 'XMLHttpRequest'!\");
"

/// Converts a reference to 'XMLHttpRequest' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::as_event_target(self: XMLHttpRequest) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLHttpRequest' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::as_mevent_target(self: mut XMLHttpRequest) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'XMLHttpRequest'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequest' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::from_event_target(base: EventTarget) -> XMLHttpRequest = "
    if(#var(base) instanceof XMLHttpRequest) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequest'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'XMLHttpRequest'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequest' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequest::from_mevent_target(base: mut EventTarget) -> mut XMLHttpRequest = "
    if(#var(base) instanceof XMLHttpRequest) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequest'!\");
"

pub ext fun XMLHttpRequest::new() -> mut XMLHttpRequest
    = "return new XMLHttpRequest();"

pub ext fun XMLHttpRequest::onreadystatechange(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onreadystatechange);"

pub ext fun XMLHttpRequest::set_onreadystatechange(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onreadystatechange = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::ready_state(self: XMLHttpRequest) -> Int
    = "return #fun(Int::from_js)(#var(self).readyState);"

pub ext fun XMLHttpRequest::timeout(self: XMLHttpRequest) -> Int
    = "return #fun(Int::from_js)(#var(self).timeout);"

pub ext fun XMLHttpRequest::set_timeout(self: mut XMLHttpRequest, value: Int)
    = "#var(self).timeout = #fun(Int::as_js)(#var(value));"

pub ext fun XMLHttpRequest::with_credentials(self: XMLHttpRequest) -> Bool
    = "return #fun(Bool::from_js)(#var(self).withCredentials);"

pub ext fun XMLHttpRequest::set_with_credentials(self: mut XMLHttpRequest, value: Bool)
    = "#var(self).withCredentials = #fun(Bool::as_js)(#var(value));"

pub ext fun XMLHttpRequest::upload(self: XMLHttpRequest) -> mut XMLHttpRequestUpload
    = "return #fun(XMLHttpRequestUpload::from_js)(#var(self).upload);"

pub ext fun XMLHttpRequest::response_url(self: XMLHttpRequest) -> String
    = "return #fun(String::from_js)(#var(self).responseURL);"

pub ext fun XMLHttpRequest::status(self: XMLHttpRequest) -> Int
    = "return #fun(Int::from_js)(#var(self).status);"

pub ext fun XMLHttpRequest::status_text(self: XMLHttpRequest) -> String
    = "return #fun(String::from_js)(#var(self).statusText);"

pub ext fun XMLHttpRequest::response_type(self: XMLHttpRequest) -> String
    = "return #fun(String::from_js)(#var(self).responseType);"

pub ext fun XMLHttpRequest::set_response_type(self: mut XMLHttpRequest, value: String)
    = "#var(self).responseType = #var(value);"

pub ext fun XMLHttpRequest::response(self: XMLHttpRequest) -> JsValue
    = "return #var(self).response;"

pub ext fun XMLHttpRequest::response_text(self: XMLHttpRequest) -> String
    = "return #fun(String::from_js)(#var(self).responseText);"

pub ext fun XMLHttpRequest::response_xml(self: XMLHttpRequest) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).responseXML);"

pub ext fun XMLHttpRequest::onloadstart(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun XMLHttpRequest::set_onloadstart(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::onprogress(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun XMLHttpRequest::set_onprogress(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::onabort(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun XMLHttpRequest::set_onabort(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::onerror(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun XMLHttpRequest::set_onerror(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::onload(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun XMLHttpRequest::set_onload(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::ontimeout(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeout);"

pub ext fun XMLHttpRequest::set_ontimeout(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::onloadend(self: XMLHttpRequest) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadend);"

pub ext fun XMLHttpRequest::set_onloadend(self: mut XMLHttpRequest, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequest::open_str_str(__self: mut XMLHttpRequest, method: String, url: String) -> Unit = "
    const r = #var(__self).open(#fun(String::as_js)(#var(method)), #fun(String::as_js)(#var(url)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::open_str_str_bool_ostr_ostr(__self: mut XMLHttpRequest, method: String, url: String, async: Bool, username: Option[String], password: Option[String]) -> Unit = "
    const r = #var(__self).open(#fun(String::as_js)(#var(method)), #fun(String::as_js)(#var(url)), #fun(Bool::as_js)(#var(async)), #fun(Option::as_js[String])(#var(username)), #fun(Option::as_js[String])(#var(password)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::set_request_header(__self: mut XMLHttpRequest, name: String, value: String) -> Unit = "
    const r = #var(__self).setRequestHeader(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::set_private_token(__self: mut XMLHttpRequest, private_token: mut PrivateToken) -> Unit = "
    const r = #var(__self).setPrivateToken(#fun(PrivateToken::as_js)(#var(private_token)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::set_attribution_reporting(__self: mut XMLHttpRequest, attribution_reporting: mut AttributionReportingRequestOptions) -> Unit = "
    const r = #var(__self).setAttributionReporting(#fun(AttributionReportingRequestOptions::as_js)(#var(attribution_reporting)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::send(__self: mut XMLHttpRequest, body: Option[JsValue]) -> Unit = "
    const r = #var(__self).send(#fun(Option::as_js[JsValue])(#var(body)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::abort(__self: mut XMLHttpRequest) -> Unit = "
    const r = #var(__self).abort();
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::get_response_header(__self: mut XMLHttpRequest, name: String) -> Option[String] = "
    const r = #var(__self).getResponseHeader(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun XMLHttpRequest::get_all_response_headers(__self: mut XMLHttpRequest) -> String = "
    const r = #var(__self).getAllResponseHeaders();
    return #fun(String::from_js)(r);
"

pub ext fun XMLHttpRequest::override_mime_type(__self: mut XMLHttpRequest, mime: String) -> Unit = "
    const r = #var(__self).overrideMimeType(#fun(String::as_js)(#var(mime)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::add_event_listener(__self: mut XMLHttpRequest, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::remove_event_listener(__self: mut XMLHttpRequest, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequest::dispatch_event(__self: mut XMLHttpRequest, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLHttpRequest::when(__self: mut XMLHttpRequest, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun XMLHttpRequest::as_js(self: XMLHttpRequest) -> JsValue = JsValue::unsafe_from[XMLHttpRequest](self)

pub fun XMLHttpRequest::from_js(v: JsValue) -> mut XMLHttpRequest = JsValue::unsafe_as[mut XMLHttpRequest](v)

pub val XMLHttpRequest::unsent: Int = 0
pub val XMLHttpRequest::opened: Int = 1
pub val XMLHttpRequest::headers_received: Int = 2
pub val XMLHttpRequest::loading: Int = 3
pub val XMLHttpRequest::done: Int = 4

struct XMLHttpRequestEventTarget()

/// Converts a reference to 'XMLHttpRequestEventTarget' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestEventTarget::as_event_target(self: XMLHttpRequestEventTarget) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLHttpRequestEventTarget' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestEventTarget::as_mevent_target(self: mut XMLHttpRequestEventTarget) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'XMLHttpRequestEventTarget'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestEventTarget' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestEventTarget::from_event_target(base: EventTarget) -> XMLHttpRequestEventTarget = "
    if(#var(base) instanceof XMLHttpRequestEventTarget) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequestEventTarget'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'XMLHttpRequestEventTarget'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestEventTarget' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestEventTarget::from_mevent_target(base: mut EventTarget) -> mut XMLHttpRequestEventTarget = "
    if(#var(base) instanceof XMLHttpRequestEventTarget) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequestEventTarget'!\");
"

pub ext fun XMLHttpRequestEventTarget::onloadstart(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun XMLHttpRequestEventTarget::set_onloadstart(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::onprogress(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun XMLHttpRequestEventTarget::set_onprogress(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::onabort(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun XMLHttpRequestEventTarget::set_onabort(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::onerror(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun XMLHttpRequestEventTarget::set_onerror(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::onload(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun XMLHttpRequestEventTarget::set_onload(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::ontimeout(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeout);"

pub ext fun XMLHttpRequestEventTarget::set_ontimeout(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::onloadend(self: XMLHttpRequestEventTarget) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadend);"

pub ext fun XMLHttpRequestEventTarget::set_onloadend(self: mut XMLHttpRequestEventTarget, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestEventTarget::add_event_listener(__self: mut XMLHttpRequestEventTarget, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequestEventTarget::remove_event_listener(__self: mut XMLHttpRequestEventTarget, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequestEventTarget::dispatch_event(__self: mut XMLHttpRequestEventTarget, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLHttpRequestEventTarget::when(__self: mut XMLHttpRequestEventTarget, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun XMLHttpRequestEventTarget::as_js(self: XMLHttpRequestEventTarget) -> JsValue = JsValue::unsafe_from[XMLHttpRequestEventTarget](self)

pub fun XMLHttpRequestEventTarget::from_js(v: JsValue) -> mut XMLHttpRequestEventTarget = JsValue::unsafe_as[mut XMLHttpRequestEventTarget](v)

struct XMLHttpRequestUpload()

/// Converts a reference to 'XMLHttpRequestUpload' to a reference to 'XMLHttpRequestEventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::as_xml_http_request_event_target(self: XMLHttpRequestUpload) -> XMLHttpRequestEventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLHttpRequestUpload' to a mutable reference to 'XMLHttpRequestEventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::as_mxml_http_request_event_target(self: mut XMLHttpRequestUpload) -> mut XMLHttpRequestEventTarget = "return #var(self);"

/// Attempts to convert a reference to 'XMLHttpRequestEventTarget' to a reference to 'XMLHttpRequestUpload'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestUpload' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::from_xml_http_request_event_target(base: XMLHttpRequestEventTarget) -> XMLHttpRequestUpload = "
    if(#var(base) instanceof XMLHttpRequestUpload) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'XMLHttpRequestEventTarget' to 'XMLHttpRequestUpload'!\");
"

/// Attempts to convert a mutable reference to 'XMLHttpRequestEventTarget' to a mutable reference to 'XMLHttpRequestUpload'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestUpload' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::from_mxml_http_request_event_target(base: mut XMLHttpRequestEventTarget) -> mut XMLHttpRequestUpload = "
    if(#var(base) instanceof XMLHttpRequestUpload) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'XMLHttpRequestEventTarget' to 'XMLHttpRequestUpload'!\");
"

/// Converts a reference to 'XMLHttpRequestUpload' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::as_event_target(self: XMLHttpRequestUpload) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLHttpRequestUpload' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::as_mevent_target(self: mut XMLHttpRequestUpload) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'XMLHttpRequestUpload'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestUpload' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::from_event_target(base: EventTarget) -> XMLHttpRequestUpload = "
    if(#var(base) instanceof XMLHttpRequestUpload) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequestUpload'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'XMLHttpRequestUpload'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLHttpRequestUpload' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLHttpRequestUpload::from_mevent_target(base: mut EventTarget) -> mut XMLHttpRequestUpload = "
    if(#var(base) instanceof XMLHttpRequestUpload) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLHttpRequestUpload'!\");
"

pub ext fun XMLHttpRequestUpload::onloadstart(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadstart);"

pub ext fun XMLHttpRequestUpload::set_onloadstart(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadstart = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::onprogress(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onprogress);"

pub ext fun XMLHttpRequestUpload::set_onprogress(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onprogress = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::onabort(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onabort);"

pub ext fun XMLHttpRequestUpload::set_onabort(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onabort = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::onerror(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onerror);"

pub ext fun XMLHttpRequestUpload::set_onerror(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onerror = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::onload(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onload);"

pub ext fun XMLHttpRequestUpload::set_onload(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onload = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::ontimeout(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).ontimeout);"

pub ext fun XMLHttpRequestUpload::set_ontimeout(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).ontimeout = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::onloadend(self: XMLHttpRequestUpload) -> Option[Fun(JsValue) -> JsValue]
    = "return #fun(Option::from_js[Fun(JsValue) -> JsValue])(#var(self).onloadend);"

pub ext fun XMLHttpRequestUpload::set_onloadend(self: mut XMLHttpRequestUpload, value: Option[Fun(JsValue) -> JsValue])
    = "#var(self).onloadend = #fun(Option::as_js[Fun(JsValue) -> JsValue])(#var(value));"

pub ext fun XMLHttpRequestUpload::add_event_listener(__self: mut XMLHttpRequestUpload, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequestUpload::remove_event_listener(__self: mut XMLHttpRequestUpload, type: String, listener: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(listener)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLHttpRequestUpload::dispatch_event(__self: mut XMLHttpRequestUpload, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLHttpRequestUpload::when(__self: mut XMLHttpRequestUpload, type: String, options: mut ObservableEventListenerOptions) -> mut Observable = "
    const r = #var(__self).when(#fun(String::as_js)(#var(type)), #fun(ObservableEventListenerOptions::as_js)(#var(options)));
    return #fun(Observable::from_js)(r);
"

pub fun XMLHttpRequestUpload::as_js(self: XMLHttpRequestUpload) -> JsValue = JsValue::unsafe_from[XMLHttpRequestUpload](self)

pub fun XMLHttpRequestUpload::from_js(v: JsValue) -> mut XMLHttpRequestUpload = JsValue::unsafe_as[mut XMLHttpRequestUpload](v)

